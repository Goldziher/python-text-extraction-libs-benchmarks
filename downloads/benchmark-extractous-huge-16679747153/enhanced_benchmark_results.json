[{"file_path":"test_documents/pdfs/Proof of Concept or GTFO - v13 (October 18th, 2016).pdf","file_size":62061798,"file_type":"pdf","category":"huge","framework":"extractous","iteration":0,"extraction_time":21.392807245254517,"startup_time":null,"peak_memory_mb":483.8046875,"avg_memory_mb":439.43125,"peak_cpu_percent":55.8,"avg_cpu_percent":11.16,"total_io_mb":null,"status":"success","character_count":249077,"word_count":49251,"error_type":null,"error_message":null,"quality_metrics":{"char_count":249077,"word_count":49251,"sentence_count":2476,"paragraph_count":3887,"avg_word_length":3.931026781182108,"avg_sentence_length":20.149434571890147,"extraction_completeness":1.0,"text_coherence":0.65130336229694,"noise_ratio":0.4415935634362065,"gibberish_ratio":0.0,"flesch_reading_ease":63.174401982914816,"gunning_fog_index":14.645896292590756,"has_proper_formatting":true,"maintains_line_breaks":true,"preserves_whitespace":true,"table_structure_preserved":true,"format_specific_score":0.8,"expected_content_preserved":false,"has_encoding_issues":false,"has_ocr_artifacts":true,"preserves_pdf_formatting":true},"overall_quality_score":0.6344930384824043,"extracted_text":"\nPoC||GTFOPoC||GTFOP\nr\no\no\nf\n\nCo\nncep\nt\n\nGe\nt\n\nT\nh\ne\n\nF\nu\nc\nk\n\nO\nu\nt\n\no r\n\nfo\n\nPASTOR LAPHROAIG’S MERCY SHIPPASTOR LAPHROAIG’S MERCY SHIP\nHOLDS STONES FROM THE IVORY TOWER,HOLDS STONES FROM THE IVORY TOWER,\n\nBUT ONLY AS BALLAST!BUT ONLY AS BALLAST!\n\ne0, $0 USD, 10s 6d GBP, 0 RSD, 0 SEK, $50 CAD, 6× 1029 Pengő (3× 108 Adópengő).\nÜres hasnak elég a szép szó; это самиздат. pocorgtfo13.pdf. October 18, 2016.\n\n13:213:2 Atari Star RaidersAtari Star Raiders\n\n13:313:3 Slowing Down a Race ConditionSlowing Down a Race Condition\n\n13:413:4 Glitching Attacks over USB; or,Glitching Attacks over USB; or,\n\nA Wacom Tablet Reads RFIDsA Wacom Tablet Reads RFIDs\n\n13:513:5 Running AMBE Firmware in LinuxRunning AMBE Firmware in Linux\n\n13:613:6 A Rogue Strategy for SpinlocksA Rogue Strategy for Spinlocks\n\n13:713:7 Reverse Engineering LoRa’s PHYReverse Engineering LoRa’s PHY\n\n13:813:8 Concerning Plumbers and PopperConcerning Plumbers and Popper\n\n13:913:9 Where is ShimDBC.exe?Where is ShimDBC.exe?\n\n13:1013:10 Postscript for Schizophrenic GhostsPostscript for Schizophrenic Ghosts\n\n\n\nLegal Note: In solidarity with , the Author Formerly Known as Homer Hickam, we place no restrictions\nof any kind upon our authors. They are quite welcome to do whatever the hell they like with their own\nwork, in any medium they like, including but not limited to endeavors of theater and interpretive dance.\n\nReprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please\nmirror—don’t merely link!—pocorgtfo13.pdf and our other issues far and wide, so our articles can help fight\nthe coming flame deluge. We like the following mirrors.\nhttps://unpack.debug.su/pocorgtfo/\nhttps://pocorgtfo.hacke.rs/\nhttps://www.alchemistowl.org/pocorgtfo/\nhttp://www.sultanik.com/pocorgtfo/\n\nTechnical Note: As described in PoC‖GTFO 13:10, pocorgtfo13.pdf is a polyglot that may be inter-\npreted as both a PDF and a PostScript file. As a PDF, this file is mostly harmless, but we warn you that\nthe Postscript will render differently each time, including both a randomly generated maze and—if Tavis\nOrmandy hasn’t killed such a lovely bug yet—a copy of your /etc/passwd file.\n\nCover Art: The cover artwork from this issue is by Harry Clarke, first used to illustrate the poem Sea\nFever by John Masefield in the collection The Year’s at the Spring, 1920.\n\nPrinting Instructions: Pirate print runs of this journal are most welcome! PoC‖GTFO is to be printed\nduplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper in\nSamland, then fold to get a booklet in A4 or Letter size. Secret volcano labs in Canada may use P3 (280 mm\nx 430 mm) if they like, folded to make P4. The outermost sheet should be on thicker paper to form a cover.\n\n# This is how to convert an issue for duplex printing.\nsudo apt-get install pdfjam\npdfbook --short-edge --vanilla --paper a3paper pocorgtfo13.pdf -o pocorgtfo13-book.pdf\n\nMan of The Book Manul Laphroaig\nEditor of Last Resort Melilot\nTEXnician Evan Sultanik\nEditorial Whipping Boy Jacob Torrey\nFunky File Supervisor Ange Albertini\nAssistant Scenic Designer Philippe Teuwen\n\nand sundry others\n\n2\n\n\n\n1 Read me if you want to live!\n\nNeighbors, please join me in reading this four-\nteenth release of the International Journal of Proof\nof Concept or Get the Fuck Out, a friendly little\ncollection of articles for ladies and gentlemen of dis-\ntinguished ability and taste in the field of reverse en-\ngineering and worshippers of weird machines. This\nfourteenth release is given on paper to the fine neigh-\nbors of São Paulo, San Diego, and Budapest.\n\nIf you are missing the first thirteen issues, we the\neditors suggest pirating them from the usual loca-\ntions, or on paper from a neighbor who picked up a\ncopy of the first in Vegas, the second in São Paulo,\nthe third in Hamburg, the fourth in Heidelberg, the\nfifth in Montréal, the sixth in Las Vegas, the seventh\nfrom his parents’ inkjet printer during the Thanks-\ngiving holiday, the eighth in Heidelberg, the ninth in\nMontréal, the tenth in Novi Sad or Stockholm, the\neleventh in Washington D.C., the twelfth in Heidel-\nberg, or the thirteenth in Montréal.\n\nAfter our paper release, and only when qual-\nity control has been passed, we will make an elec-\ntronic release named pocorgtfo13.pdf. It is valid\nas PDF, ZIP, and PostScript; please read it with\nAdobe Reader, unzip, and gv.\n\nWe begin on page 5 with the story of how STAR\nRAIDERS by Doug Neubauer for the Atari 400 was\ntaken apart by Lorenz Weist, from a mere ROM car-\ntridge dump to annotated and literate 6502 disas-\nsembly. By a stroke of luck, Lorenz was able to read\nDoug’s original source code for the game after com-\n\npleting his reverse engineering project, giving him\nthe rare opportunity to confirm his understanding\nof the game’s design and behavior.\n\nOn page 24, James Forshaw introduces us to a\nnifty little trick for simplifying reliable exploitation\nof race condition vulnerabilities. Rather than spin\nup a dozen attempts to improve racetrack odds, he\ninstead induces situations with pathological perfor-\nmance penalties to Windows NT system calls, stun-\nning the threads of execution that might interfere\nwith his exploit for twenty minutes or more!\n\nMicah Elizabeth Scott continues to send us bril-\nliant articles that refuse to be described by a single\nabstract, so let’s just say that on page 30 she ex-\nplains a USB magic trick in which her FaceWhis-\nperer board—combining the Facedancer and the\nChip Whisperer—is able to reliably glitch the USB\nstack of an embedded device to dump its firmware.\nOr, we could say that on page 30 she explains how\nto use undocumented commands from that firmware\ndump to program the Harvard device by ROP. Or,\nwe could say that on page 30 she shows you to read\nRFID tags with a Wacom tablet. These tricks are\nall the same article, and you’d be a fool not to read\nit.\n\n3\n\n\n\nIn PoC‖GTFO 10:8, Travis Goodspeed jailbroke\nthe Tytera MD380 radio to allow for firmware ex-\ntraction and patching. Since then, a lively open\nsource project has sprung up, with fancy new fea-\ntures and fixes to old bugs. On page 38, he describes\nhow to rip the AMBE audio codec out of the radio\nfirmware, transforming it into a command line audio\nprocessing tool that runs on any Linux workstation.\nSimilar tricks can be used to quickly toss together\nemulators for many ARM and PowerPC embedded\nsystems, re-using their library functions, or fuzzing\ntheir parsers in the familiar environment of an ev-\neryday laptop.\n\nEvan Sultanik is back with a safe cracking adven-\nture that could only be expressed as a play in three\nacts, narrated by our own Pastor Manul Laphroaig.\nSpeaking parts are available for Alice Feynman, Bob\nSchrute, Havva al-Kindi, and the ghost of Paul\nErdős. You’ll find Evan’s script on page 43.\n\nMatt Knight has been reverse engineering the\nPHY of LoRa, a low-power protocol for sub-GHz\nwireless networking over long distances. On page 48\nyou will find not just the protocol details that al-\nlowed him to write an open source receiver, but, far\nmore importantly, you will also find the methods by\nwhich he reverse engineered this information from\ncaptured packets, vague application notes, and the\noutright lies of the patent application.\n\nPastor Manul Laphroaig, your friendly neighbor-\nhood evangelist of the gospel of the weird machines,\n\nhas a sermon for you on page 60. He reminds us\nthat science takes place neither on stage in front of\na live studio audience nor in committees and gov-\nernment offices, but over a glass of fine scotch that’s\naccompanied by finer conversation of practitioners.\nIn the same way that we oughtn’t put Tim the “Tool\nMan” Taylor in charge of vocational education, we\nought to leave the teaching of science to those who\ndo it, not those who talk about it on TV.\n\nGeoff Chappell is an old-school reverse engineer,\nan x86 archaeologist who has spent the past twenty-\nfour years reading Windows binaries to identify all\nthe forgotten features and corner cases that the rest\nof us might take for granted.1 On page 63, he\nintroduces us to the mystery of Microsoft’s Shim\nDatabase Compiler, an unpublished tool for compil-\ning driver shims that doesn’t seem to be available\nto the outside world. Geoff shows us that, in fact,\nthe tool is available, wrapped up inside of a GUI\nas QFixApp.exe or CompatAdmin.exe. By patch-\ning the program to expose its intact winmain(), he\ncan recover the long-lost ShimDBC.exe for compiling\nWindows driver compatibility shims from XML!\n\nEvan Sultanik and Philippe Teuwen have teamed\nup on page 71, to explain the inner workings of\npocorgtfo13.pdf, which you can rename to read\nas pocorgtfo13.zip or pocorgtfo13.ps.\n\nOn page 72, the last page, we pass around the\ncollection plate. Our church has no interest in cash\nor cheques, but we’d love your donation of a nifty\nreverse engineering story. Please send one our way.\n\n1Geoff was the first to discover Aaron R. Reynolds’ “AARD” code from the beta release of Windows 3.1 that intentionally\nbroke compatibility with DR-DOS. He also has a delightful article on exactly how AOL exploited a buffer overflow in their own\nAOL Instant Messenger client to distinguish it from Microsoft’s clone, MSN Messenger.\n\n4\n\n\n\n2 Reverse Engineering Star Raiders\nby Lorenz Wiest\n\n2.1 Introduction\n\nSTAR RAIDERS is a seminal computer game pub-\nlished by Atari Inc. in 1979 as one of the first titles\nfor the original Atari 8-bit Home Computer System\n(Atari 400 and Atari 800). It was written by Atari\nengineer Doug Neubauer, who also created the sys-\ntem’s POKEY sound chip. STAR RAIDERS is consid-\n\nered to be one of the ten most important computer\ngames of all time.2.\n\nCONTROLLER JACKS\n\nSYSTEM\nRESET\n\nOPTION\n\nSELECT\n\nSTART\n\n21 3 4\n\nPLYR 1 PLYR 2 PLYR 3 PLYR 4\n\nThe game is a 3D space combat flight simulation\nwhere you fly your starship through space, shooting\nat attacking Zylon spaceships.The game’s universe\nis made up of a 16 × 8 grid of sectors Some of\nthem contain enemy Zylon units some a friendly\nstarbase The Zylon units converge toward the star-\nbases and try to destroy them. The starbases serve\nas repair and refueling points for your starship. You\nmove your starship between sectors with your hyper-\nwarp drive The game is over if you have destroyed\nall Zylon ships, have ran out of energy, or if the\nZylons have destroyed all starbases.\n\nAt a time when home computer games were\npretty static – think SPACE INVADERS (1978) and\nPAC MAN (1980) – STAR RAIDERS was a huge hit\nbecause the game play centered on the very dynamic\n3D first-person view out of your starship’s cockpit\nwindow.\n\nThe original Atari 8-bit Home Computer System\n2“Is That Just Some Game? No, It’s a Cultural Artifact.” Heather Chaplin, The New York Times, March 12, 2007.\n\n5\n\n\n\nhas up to 48 KB RAM and uses a Motorola 6502\nCPU. The same CPU is also used in the Apple II,\nthe Commodore C64 (a 6502 variant), and the T-\n800 Terminator 3 Several proprietary Atari custom\nchips provide additional capabilities to the system.\nSTAR RAIDERS shows off many of them: 5 Play-\ners (sprites), mixed text and pixel graphics modes,\ndynamic Display Lists, a custom character set, 4-\nchannel sound, Vertical Blank Interrupt and Dis-\nplay List Interrupt code – even the BCD mode of\nthe 6502 CPU is used C\n\nCONTROLLER JACKS21 3 4\n\nPULL     OPEN SYSTEMRESETOPTIONSELECTSTART\n\n@angealbertini 2016\n\nlig\nht\n\n p\nen\n\nso\nun\n\nd\n\nse\nri\n\nal\nbu\n\ns\n\npi\nct\n\nur\ne\n\nco\nns\n\nol\ne \n\nsw\nit\nch\n\nes\n\njo\nys\n\nti\nck\n\n t\nri\n\ngg\ner\n\ns\n\nke\nyb\n\noa\nrd\n\nkeyboard\nspeaker\n\npa\ndd\n\nle\ns\n\nke\nyb\n\noa\nrd\n\nco\nnt\n\nro\nlle\n\nrs\n\njo\nys\n\nti\nck\n\npa\ndd\n\nle\ntr\n\nig\nge\n\nrs\n\nMOS\n6502\n\nRAM left\ncartridge\n\nright\ncartridge OS\n\nROM\ndisk\n\ndrives\n\nother\nperiph.\n\nPOtentiometer\nKEYboard\nintegrated circuit\n\nPeripheral\nInterface\nAdaptor\n\nColor/Graphics\nTelevision\n\nInterface Adaptor16KB - 48KB\n\n1.77-1,79Mhz\n\n16bit freq counter mode\nkeyboard/paddle scanning\nIRQ generator\n\nAlpha-Numeric\nTelevision\nInterface\nControllerSALLY\n\nSprites: player/missile\n\ndisplay lists\n\nprocessor busprocessor bus\n\nI have been always wondering what made STAR\nRAIDERS tick. I was especially curious how that\n3D first-person view star field worked, in particu-\nlar the rotations of the stars when you fly a turn.\nSo I decided to reverse engineer the game, aiming\nat a complete, fully documented assembly language\nsource code of STAR RAIDERS.\n\n;*********************************************************************\n;*                                                                  *\n;*                      S T A R   R A I D E R S                     *\n;*                                                                  *\n;*             for the Atari 8-bit Home Computer System             *\n;*                                                                  *\n;*  Reverse-engineered and documented assembly language source code  *\n;*                                                                  *\n;*                                by                                *\n;*                                                                  *\n;*                           Lorenz Wiest                           *\n;*                                                                  *\n;*                       (lo.wiest(at)web.de)                       *\n;*                                                                  *\n;*                           First Release                          *\n;*                            22-SEP-2015                           *\n;*                                                                  *\n;*                            Last Update                           *\n;*                            10-AUG-2016                           *\n;*                                                                  *\n;*           STAR RAIDERS was created by Douglas Neubauer           *\n;*             STAR RAIDERS was published by Atari Inc.             *\n;*                                                                  *\n;*********************************************************************\n\nIn the following sections I’ll show you how I ap-\nproached the reverse engineering effort, introduce\nmy favorite piece of code in STAR RAIDERS, talk\nabout how the tight memory limits influenced the\nimplementation, reveal some bugs, point at some\nmysterious code, and explain how I got a grip on\ndocumenting STAR RAIDERS. From time to time, to\nprovide some context to you, I will reference memory\nlocations of the game, which you can look up in the\nreverse engineered, complete, and fully documented\nassembly language source code of STAR RAIDERS\navailable on GitHub.4\n\n2.2 Getting Started\n\nSTAR RAIDERS is distributed as an 8 KB ROM car-\ntridge, occupying memory locations $A000 to $BFFF.\n\nThe obvious first step was to prod a ROM dump\nwith a disassembler and to apply Atari’s published\nhardware and OS symbols to the disassembly. To\nmy surprise this soon revealed that code and data\nwere clearly separated into three parts:\n$A000 – $A149 Data (Part 1 of 2)\n$A14A – $B8DE Code (6502 instructions)\n$B8DF – $BFFF Data (Part 2 of 2)\nThis clear separation helped me instantly to get\n\nan overview of the code part, as I could create a\ndisassembly of the code in one go and not having to\nsift slowly through the bytes of the ROM, deciding\nwhich ones are instructions and which ones are data.\n\nCloser inspection of the code part revealed that it\nwas composed of neatly separated subroutines. Each\nsubroutine handles a specific task. The largest sub-\nroutine is the main game loop GAMELOOP ($A1F3),\nshown in Figure 1. What I expected to be spaghetti\ncode – given the development tools of 1979 and the\nsubstantial amount of game features crammed into\nthe 8K ROM – turned out to be surprisingly struc-\ntured code. Table 1 lists all subroutines of STAR\nRAIDERS, as their function emerged during the re-\nverse engineering effort, giving a good overview how\nthe STAR RAIDERS code is organized.\n\nFigure 2 shows the “genome sequence” of the\nSTAR RAIDERS 8 KB ROM: The 8192 bytes of the\ngame are stacked vertically, with each byte repre-\nsented by a tiny, solid horizontal line of 8 pixels.\nThis stack is split into strips of 192 bytes, arranged\nside-by-side. Alternating light and dark blue areas\nrepresent bytes of distinct subroutines. Alternat-\ning light and dark green and purple areas repre-\nsent bytes of distinct sections of data (lookup tables,\ngraphical shapes, etc.). When data bytes represent\ngraphical shapes, the solid line of a byte is replaced\nby its actual bit pattern (in purple color).\n\nThere are a couple of interesting things to see:\n\n• The figure reflects the ROM’s separation into\na data part (green and purple), a code part\n(blue), and one more data part (green and pur-\nple).\n\n• The first data part contains mostly the custom\n3In the movie TERMINATOR (1984) there are scenes showing the Terminator’s point of view in shades of red. In these\n\nscenes lines of source code are listed onscreen. Close inspection of still frames of the movie reveal this to be 6502 assembly\nlanguage source code.\n\n4git clone https://github.com/lwiest/StarRaiders or unzip pocorgtfo13.pdf StarRaiders.zip\n\n6\n\n\n\nGAMELOOP\n$A1F3\n\nUPDATTCOMP Update Attack Computer Display\n$A7BF\n\nHYPERWARP Handle hyperwarp\n$A89B\n\nMANEUVER Maneuver our starship's and Zylon\nphoton torpedoes and Zylon ships$AA79\n\nINITEXPL Initialize explosion\n$AC6B\n\nDOCKING Handle docking at starbase,\nlaunch and return of transfer vessel$ACE6\n\nMODDLST Modify Display List\n$ADF1\n\nCLRPLAYFIELD Clear PLAYFIELD memory\n$AE0D\n\nTRIGGER Handle joystick trigger\n$AE29\n\nNOISE Copy noise sound pattern\n$AEA8\n\nDAMAGE Damage or destroy one of our starship's subsystems\n$AEE1\n\nCOLLISION Detect a collision of our starship's photon torpedoes\n$AF3D\n\nGAMEOVER Handle Game Over\n$B10A\n\nFLUSHGAMELOOP Handle remaining tasks at the end\nof a game loop iteration$B4E4\n\nDRAWLINES Draw horizontal and vertical lines\n$A76F\n\nPROJECTION Calculate pixel column (or row) number\nfrom position vector$AA21\n\nKEYBOARD Handle Keyboard Input\n$AFFE\n\nSETVIEW Set Front view\n$B045\n\nSELECTWARP Select hyperwarp arrival location\non Galactic Chart$B162\n\nROTATE Rotate position vector component\n(coordinate) by fixed angle$B69B\n\nSCREENCOLUMN Calculate pixel column number\nfrom centered pixel column number$B6FB\n\nSCREENROW Calculate pixel row number\nfrom centered pixel row number$B71E\n\nINITPOSVEC Initialize position vector of a space object\n$B764\n\nUPDPANEL Update Control Panel Display\n$B804\n\nDECENERGYDecrease energy\n$B86F\n\nInitialize program (cold start)\n$A14A\nINITCOLD\n\nEntry point when SELECT function key was pressed\n$A15A\nINITSELECT\n\nEntry point when program switches into demo mode\n$A15C\nINITDEMO\n\nEntry point when START function key was pressed\n$A15E\nINITSTART\n\nUPDTITLE Update title line\n$B216\n\nA B A is followed by B in memory A B A calls B (and returns)\n\nA B A jumps to B (no return)\n\n$A6D0\n\nFigure 1. Simplified Call Graph of Start Up and Game Loop\n\n7\n\n\n\n1 $A14A INITCOLD I n i t i a l i z e program (Cold s t a r t )\n$A15A INITSELECT Entry po int when SELECT func t i on key was pre s sed\n\n3 $A15C INITDEMO Entry po int when program swi t che s in to demo mode\n$A15E INITSTART Entry po int when START func t i on key was pre s sed\n\n5 $A1F3 GAMELOOP Game loop\n$A6D1 VBIHNDLR Ve r t i c a l Blank In t e r rup t Handler\n\n7 $A718 DLSTHNDLR Display L i s t In t e r rup t Handler\n$A751 IRQHNDLR Int e r rup t Request (IRQ) Handler\n\n9 $A76F DRAWLINES Draw ho r i z on t a l and v e r t i c a l l i n e s\n$A782 DRAWLINE Draw a s i n g l e ho r i z on t a l or v e r t i c a l l i n e\n\n11 $A784 DRAWLINE2 Draw b l i p in Attack Computer\n$A7BF UPDATTCOMP Update Attack Computer Display\n\n13 $A89B HYPERWARP Handle hyperwarp\n$A980 ABORTWARP Abort hyperwarp\n\n15 $A987 ENDWARP End hyperwarp\n$A98D CLEANUPWARP Clean up hyperwarp v a r i a b l e s\n\n17 $A9B4 INITTRAIL I n i t i a l i z e s t a r t r a i l dur ing STAR TRAIL PHASE of hyperwarp\n$AA21 PROJECTION Calcu la te p i x e l column ( or row ) number from po s i t i o n vec to r\n\n19 $AA79 MANEUVER Maneuver our s t a r s h i p ’ s and Zylon photon torpedoes and Zylon sh ip s\n$AC6B INITEXPL I n i t i a l i z e exp l o s i on\n\n21 $ACAF COPYPOSVEC Copy a po s i t i o n vec to r\n$ACC1 COPYPOSXY Copy x and y components ( coo rd ina t e s ) o f p o s i t i o n vec to r\n\n23 $ACE6 DOCKING Handle docking at s tarbase , launch and return o f t r a n s f e r v e s s e l\n$ADF1 MODDLST Modify Display L i s t\n\n25 $AE0D CLRPLAYFIELD Clear PLAYFIELD memory\n$AE0F CLRMEM Clear memory\n\n27 $AE29 TRIGGER Handle j o y s t i c k t r i g g e r\n$AEA8 NOISE Copy no i s e sound pattern\n\n29 $AECA HOMINGVEL Calcu la te homing v e l o c i t y o f our s t a r s h i p ’ s photon torpedo 0 or 1\n$AEE1 DAMAGE Damage or des t roy one o f our s t a r s h i p ’ s subsystems\n\n31 $AF3D COLLISION Detect a c o l l i s i o n o f our s t a r s h i p ’ s photon torpedoes\n$AFFE KEYBOARD Handle Keyboard Input\n\n33 $B045 SETVIEW Set Front view\n$B07B UPDSCREEN Clear PLAYFIELD, draw Attack\n\n35 $B10A GAMEOVER Handle game over\n$B121 GAMEOVER2 Game over ( Miss ion s u c c e s s f u l )\n\n37 $B162 SELECTWARP Se l e c t hyperwarp a r r i v a l l o c a t i o n on Ga lac t i c Chart\n$B1A7 CALCWARP Calcu la te and d i sp l ay hyperwarp energy\n\n39 $B216 UPDTITLE Update t i t l e l i n e\n$B223 SETTITLE Set t i t l e phrase in t i t l e l i n e\n\n41 $B2AB SOUND Handle sound e f f e c t s\n$B3A6 BEEP Copy beeper sound pattern\n\n43 $B3BA INITIALIZE More game i n i t i a l i z a t i o n\n$B4B9 DRAWGC Draw Galac t i c Chart\n\n45 $B4E4 FLUSHGAMELOOP Handle remaining ta sk s at the end o f a game loop i t e r a t i o n\n$B69B ROTATE Rotate p o s i t i o n vec to r component ( coord inate ) by f i x ed ang le\n\n47 $B6FB SCREENCOLUMN Calcu la te p i x e l column number from cente red p i x e l column number\n$B71E SCREENROW Calcu la te p i x e l row number from cente red p i x e l row number\n\n49 $B764 INITPOSVEC I n i t i a l i z e p o s i t i o n vec to r o f a space ob j e c t\n$B7BE RNDINVXY Randomly i nv e r t the x and y components o f a po s i t i o n vec to r\n\n51 $B7F1 ISSURROUNDED Check i f a s e c t o r i s surrounded by Zylon un i t s\n$B804 UPDPANEL Control Panel Display\n\n53 $B86F DECENERGY Decrease energy\n$B8A7 SHOWCOORD Display a po s i t i o n vec to r component ( coord inate ) in\n\n55 Control Panel Display\n$B8CD SHOWDIGITS Display a value by a readout o f the Control Panel Display\n\nTable 1. Star Raiders Subroutines\n\n8\n\n\n\nCODE DATABITMAP\n\n+00\n\n+08\n\n+10\n\n+18\n\n+20\n\n+28\n\n+30\n\n+38\n\n+40\n\n+48\n\n+50\n\n+58\n\n+60\n\n+68\n\n+70\n\n+78\n\n+80\n\n+88\n\n+90\n\n+98\n\n+A0\n\n+A8\n\n+B0\n\n+B8\n\n+C0\n\nGA\nME\nLO\nOP\n\n## 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43\n\nA000    A180    A300    A480    A600    A780    A900    AA80    AC00    AD80    AF00    B080    B200    B380    B500    B680    B800    B980    BB00    BC80    BE00    BF80\n    A0C0    A240    A3C0    A540    A6C0    A840    A9C0    AB40    ACC0    AE40    AFC0    B140    B2C0    B440    B5C0    B740    B8C0    BA40    BBC0    BD40    BEC0\n\nW\nO\nR\nD\nT\nA\nB\n\nW\nO\nR\nD\nT\nA\nB\n\nMA\nNE\nUV\nER\n\nMA\nNE\nUV\nER\n\nF\nL\nU\nS\nH\nG\nA\nM\nE\nL\nO\nO\nP\n\nFigure 2. Genome Sequence of the STAR RAIDERS ROM\n\nfont (in strips 1-2).\n\n• The largest contiguous (dark) blue chunk rep-\nresents the 1246 bytes of the main game loop\nGAMELOOP ($A1F3) (in strips 3-10).\n\n• At the beginning of the second data part are\nthe shapes for the Players (sprites) (in strips\n34-36).\n\n• The largest contiguous (light) green chunk rep-\nresents the 503 bytes of the game’s word table\nWORDTAB ($BC2B) (in strips 38-41).\n\nA good reverse engineering strategy was to start\nworking from code locations that used Atari’s pub-\nlished symbols, the equivalent of piecing together\nthe border of a jigsaw puzzle first before starting to\ntackle the puzzle’s center. Then, however, came the\ninevitable and very long stretch of reconstructing\nthe game’s logic and variables with a combination\nof educated guesses, trial-and-error, and lots of pa-\ntience. At this stage, the tools I used mostly were\nnothing but a text editor (Notepad) and a word pro-\ncessor (Microsoft Word) to fill the gaps in the doc-\numentation of the code and the data. I also created\n\na memory map text file to list the used memory lo-\ncations and their purpose. These entries were con-\ntinually updated – and more than often discarded\nafter it turned out that I had taken a wrong turn.\n\n2.3 A Programming Gem: Rotating\n3D Vectors\n\nWhat is the most interesting, fascinating, and un-\nexpected piece of code in STAR RAIDERS? My pick\nwould be the very code that started me to reverse\nengineer STAR RAIDERS in the first place: subrou-\ntine ROTATE ($B69B), which rotates objects in the\ngame’s 3D coordinate space (shown in Figure 3).\nAnd here is why: Rotation calculations usually in-\nvolve trigonometry, matrices, and so on – at least\nsome multiplications. But the 6502 CPU has only\n8-bit addition and subtraction operations. It does\nnot provide either a multiplication or a division op-\neration – and certainly no trig operation! So how do\nthe rotation calculations work, then?\n\nLet’s start with the basics: The game uses a 3D\ncoordinate system with the position of our starship\nat the center of the coordinate system. The loca-\ntions of all space objects (Zylon ships, meteors, pho-\n\n9\n\n\n\nton torpedoes, starbase, transfer vessel, Hyperwarp\nTarget Marker, stars, and explosion fragments) are\ndescribed by a position vector relative to our star-\nship.\n\nA position vector is composed of an x, y, and z\ncomponent, whose values I call the x, y, and z coor-\ndinates with the arbitrary unit <KM>. The range\nof a coordinate is −65536 to +65535 <KM>.\n\nEach coordinate is a signed 17-bit integer num-\nber, which fits into three bytes. Bit 16 contains\nthe sign bit, which is 1 for positive and 0 for nega-\ntive sign. Bits 15 to 0 are the mantissa as a two’s-\ncomplement integer.\n\nSign Mantissa\n2 B16 B15 . . . B8 B7 . . . . B0\n\n| | | | |\n4 0000000∗ ∗∗∗∗∗∗∗∗ ∗∗∗∗∗∗∗∗\n\nSome example bit patterns for coordinates:\n\n00000001 11111111 11111111 = +65535 <KM>\n2 00000001 00000001 00000000 = +256 <KM>\n\n00000001 00000000 11111111 = +255 <KM>\n4 00000001 00000000 00000001 = +1 <KM>\n\n00000001 00000000 00000000 = +0 <KM>\n6 00000000 11111111 11111111 = −1 <KM>\n\n00000000 11111111 11111110 = −2 <KM>\n8 00000000 11111111 00000001 = −255 <KM>\n\n00000000 11111111 00000000 = −256 <KM>\n10 00000000 00000000 00000000 = −65536 <KM>\n\nThe position vector for each space object is\nstored in nine tables (3 coordinates × 3 bytes for\neach coordinate). There are up to 49 space objects\nused in the game simultaneously, so each table is 49\nbytes long:\n\nXPOSSIGN XPOSHI XPOSLO\n($09DE..$0A0E) ($0A71..$0AA1) ($0B04..$0B34)\n\nYPOSSIGN YPOSHI YPOSLO\n($0A0F..$0A3F) ($0AA2..$0AD2) ($0B35..$0B65)\n\nZPOSSIGN ZPOSHI ZPOSLO\n($09AD..$09DD) ($0A40..$0A70) ($0AD3..$0B03)\n\nWith that explained, let’s have a look at sub-\nroutine ROTATE ($B69B). This subroutine rotates a\nposition vector component (coordinate) of a space\nobject by a fixed angle around the center of the\n3D coordinate system, the location of our starship.\nThis operation is used in 3 out of 4 of the game’s\nview modes (Front view, Aft view, Long-Range Scan\nview) to rotate space objects in and out of the view.\n\n2.3.1 Rotation Mathematics\n\nThe game uses a left-handed 3D coordinate system\nwith the positive x-axis pointing to the right, the\npositive y-axis pointing up, and the positive z-axis\npointing into flight direction.\n\nry\n\nz-axis\n\nx-axis\nx x’\n\nz\n\nz’\n\ny--axis\n\nx-axis\n\nz-axis\n\nA rotation in this coordinate system around the\ny-axis (horizontal rotation) can be expressed as\n\nx′ = cos(ry)x+ sin(ry)z (1)\nz′ = − sin(ry)x+ cos(ry)z\n\nwhere ry is the clockwise rotation angle around the\ny-axis, x and z are the coordinates before this ro-\ntation, and the primed coordinates x′ and z′ the\ncoordinates after this rotation. The y-coordinate is\nnot changed by this rotation.\n\nrx\n\ny-axis\n\nz-axis\nz z’\n\ny\n\ny’\n\ny-axis\n\nx-axis\n\nz-axis\n\nA rotation in this coordinate system around the\nx-axis (vertical rotation) can be expressed as\n\nz′ = cos(rx)z + sin(rx)y (2)\ny′ = − sin(rx)z + cos(rx)y\n\nwhere rx is the clockwise rotation angle around the\nx-axis, z and y are the coordinates before this ro-\ntation, and the primed coordinates z′ and y′ the\ncoordinates after this rotation. The x-coordinate is\nnot changed by this rotation.\n\n2.3.2 Subroutine Implementation Overview\n\nA single call of subroutine ROTATE ($B69B) is able\nto compute one of the four expressions in Equa-\ntions 1 and 2. To compute all four expressions to\n\n10\n\n\n\nget the new set of coordinates, this subroutine has\nto be called four times. This is done twice in pairs\nin GAMELOOP ($A1F3) at $A391 and $A398, and at\n$A3AE and $A3B5, respectively.\n\nThe first pair of calls calculates the new x and\nz coordinates of a space object due to a horizon-\ntal (left/right) rotation of our starship around the\ny-axis following the expressions of Equation 1.\n\nThe second pair of calls calculates the new y and\nz coordinates of the same space object due to a ver-\ntical (up/down) rotation of our starship around the\nx-axis following the expressions of Equation 2.\n\nIf you look at the code of ROTATE ($B69B), you\nmay be wondering how this calculation is actually\nexecuted, as there is neither a sine nor cosine func-\ntion call. What you’ll actually find implemented,\nhowever, are the following calculations:\n\nJoystick Left\n\nx := x+ z/64 (3)\nz := −x/64 + z\n\nJoystick Right\n\nx := x− z/64 (4)\nz := x/64 + z\n\nJoystick Down\n\ny := y + z/64 (5)\nz := −y/64 + z\n\nJoystick Up\n\ny := y − z/64 (6)\nz := y/64 + z\n\n2.3.3 CORDIC Algorithm\n\nWhen you compare the expressions of Equations 1–2\nwith expressions of Equations 3–6, notice the simi-\nlarity between the expressions if you substitute5\n\nsin(ry)→ 1/64\n\ncos(ry)→ 1\n\nsin(rx)→ 1/64\n\ncos(rx)→ 1\n\nFrom sin(ry) = 1/64 and sin(rx) = 1/64 you can\nderive that the rotation angles ry and rx by which\nthe space object is rotated (per game loop iteration)\nhave a constant value of 0.89◦, as arcsin(1/64) =\n0.89◦.\n\nWhat about cos(ry) and cos(rx)? The substi-\ntution does not match our derived angle exactly,\nbecause cos(0.89◦) = 0.99988 and is not exactly\n1. However, this value is so close that substitut-\ning cos(0.89◦) with 1 is a very good approximation,\nsimplifying calculations significantly.\n\nAnother significant simplification results from\nthe division by 64, as the actual division operation\ncan be replaced with a much faster bit shift opera-\ntion.\n\nThis calculation-friendly way of computing rota-\ntions is also known as the “CORDIC (COordinate\nRotation DIgital Computer)” algorithm.\n\n2.3.4 Minsky Rotation\n\nThere is one more interesting mathematical sub-\ntlety: Did you notice that expressions of Equa-\ntions 1 and 2 use a new (primed) pair of variables\nto store the resulting coordinates, whereas in the\nimplemented Equations 3–6, the value of the first\ncoordinate of a coordinate pair is overwritten with\nits new value and this value is used in the subsequent\ncalculation of the second coordinate? For example,\nwhen the joystick is pushed left, the first call of this\nsubroutine calculates the new value of x according\nto first expression of Equation 3, overwriting the old\nvalue of x. During the second call to calculate z ac-\ncording to the second expression of Equation 3, the\nnew value of x is used instead of the old one. Is this\nto save the memory needed to temporarily store the\nold value of x? Is this a bug? If so, why does the\nrotation calculation actually work?\n\nHave a look at the expressions of Equation 3 (the\nother Equations 4–6 work in a similar fashion):\n\nx := x+ z/64\n\nz := −x/64 + z\n\nIf we substitute 1/64 with e, we get\n\nx := x+ ez\n\nz := −ex+ z\n\n5This substitution gave a friendly mathematician who happened to see it a nasty shock. She yelled at us that cos2x+sin2x = 1\nfor all real x and forever, and therefore this could not possibly be a rotation; it’s a rotation with a stretch! We reminded her\nof the old joke that in wartime the value of the cosine has been known to reach 4. —PML\n\n11\n\n\n\nNote that x is calculated first and then used in\nthe second expression. When using primed coordi-\nnates for the resulting coordinates after calculating\nthe two expressions we get\n\nx′ := x+ ez\n\nz′ :=− ex′ + z\n\n=− e(x+ ez) + z\n\n=− ex+ (1− e2)z\n\nor in matrix form(\nx′\n\nz′\n\n)\n=\n\n(\n1 e\n−e 1− e2\n\n)(\nx\nz\n\n)\nSurprisingly, this turns out to be a rotation ma-\n\ntrix, because its determinant is (1× (1−e2)− (−e×\ne)) = 1. (Incidentally, the column vectors of this\nmatrix do not form an orthogonal basis, as their\nscalar product is 1 × e + (−e × (1 − e2)) = −e2.\nOrthogonality holds for e = 0 only.)\n\nThis kind of rotation calculation is described\nby Marvin Minsky in AIM 239 HAKMEM6 and is\ncalled “Minsky Rotation.”\n\n2.3.5 Subroutine Implementation Details\n\nTo better understand how the implementation of\nthis subroutine works, we must again look at Equa-\ntions 3–6. If you rearrange the expressions a little,\ntheir structure is always of the form:\n\nTERM1 := TERM1 SIGN TERM2/64\n\nor shorter\n\nTERM1 := TERM1 SIGN TERM3\n\nwhere TERM3 := TERM2/64 and SIGN := + or − and\nwhere TERM1 and TERM2 are coordinates. In fact, this\nis all this subroutine actually does: It simply adds\nTERM2 divided by 64 to TERM1 or subtracts TERM2\ndivided by 64 from TERM1.\n\nWhen calling this subroutine the correct table\nindices for the appropriate coordinates TERM1 and\nTERM2 are passed in the CPU’s Y and X registers,\nrespectively.\n\nWhat about SIGN between TERM1 and TERM3?\nAgain, have a look at Equations 3–6. To compute\n\nthe two new coordinates after a rotation, the SIGN\ntoggles from plus to minus and vice versa. The SIGN\nis initialized with the value of JOYSTICKDELTA ($6D)\nbefore calling subroutine ROTATE ($B69B, Figure 3)\nand is toggled in every call of this subroutine. The\ninitial value of SIGN should be positive (+, byte\nvalue $01) if the rotation is clockwise (the joystick is\npushed right or up) and negative (−, byte value $FF)\nif the rotation is counter-clockwise (the joystick is\npushed left or down), respectively. Because SIGN is\nalways toggled in ROTATE ($B69B) before the adding\nor subtraction operation of TERM1 and TERM3 takes\nplace, you have to pass the already toggled value\nwith the first call.\n\nUnclear still are three instructions starting at ad-\ndress $B6AD. They seem to set the two least signifi-\ncant bits of TERM3 in a random fashion. Could this\nbe some quick hack to avoid messing with exact but\npotentially lengthy two’s-complement arithmetic?\n\nCX40\n\n2.4 Dodging Memory Limitations\n\nIt is impressing how much functionality was\nsqueezed into STAR RAIDERS. Not surprisingly, the\nbytes of the 8 KB ROM are used up almost com-\npletely. Only a single byte is left unused at the very\nend of the code. When counting four more bytes\nfrom three orphaned entries in the game’s lookup\ntables, only five bytes in total out of 8,192 bytes are\nactually not used. ROMmemory was extremely pre-\ncious. Here are some techniques that demonstrate\n\n6unzip pocorgtfo13.pdf AIM-239.pdf #Item 149, page 73.\n\n12\n\nNote that x is calculated first and then used in\nthe second expression. When using primed coordi-\nnates for the resulting coordinates after calculating\nthe two expressions we get\n\ny\n\nv= “4+ ez\n\ng:=—ea' +2\n=—e(atez) +z\n=—exr+(1—e?)z\n\nor in matrix form\n\n(2 )-(20 122 )G)\n\nSurprisingly, this turns out to be a rotation ma-\ntrix, because its determinant is (1 x (1 —e?) — (—e x\ne)) = 1. (Incidentally, the column vectors of this\nmatrix do not form an orthogonal basis, as their\nscalar product is 1 x e + (—e x (1 — e?)) = —e?.\nOrthogonality holds for e = 0 only.)\n\nThis kind of rotation calculation is described\nby Marvin Minsky in AIM 239 HAKMEM® and is\n\ncalled “Minsky Rotation.”\n\n2.3.5 Subroutine Implementation Details\n\nTo better understand how the implementation of\nthis subroutine works, we must again look at Equa-\ntions 3-6. If you rearrange the expressions a little,\ntheir structure is always of the form:\n\nTERM1 := TERM1 SIGN TERM2/64\n\nor shorter\n\nTERM1 := TERM1 SIGN TERM3\n\nwhere TERM3 := TERM2/64 and SIGN := + or — and\nwhere TERM1 and TERM2 are coordinates. In fact, this\nis all this subroutine actually does: It simply adds\nTERM2 divided by 64 to TERM1 or subtracts TERM2\ndivided by 64 from TERM1.\n\nWhen calling this subroutine the correct table\nindices for the appropriate coordinates TERM1 and\nTERM2 are passed in the CPU’s Y and X registers,\nrespectively.\n\nWhat about SIGN between TERM1 and TERM3?\nAgain, have a look at Equations 3-6. To compute\n\nSunzip pocorgtfo13.pdf AIM-239.pdf #Item 149, page 73.\n\n12\n\nthe two new coordinates after a rotation, the SIGN\ntoggles from plus to minus and vice versa. The SIGN\nis initialized with the value of JOYSTICKDELTA ($6D)\nbefore calling subroutine ROTATE ($B69B, Figure 3)\nand is toggled in every call of this subroutine. The\ninitial value of SIGN should be positive (+, byte\nvalue $01) if the rotation is clockwise (the joystick is\npushed right or up) and negative (—, byte value $FF)\nif the rotation is counter-clockwise (the joystick is\npushed left or down), respectively. Because SIGN is\nalways toggled in ROTATE ($B69B) before the adding\nor subtraction operation of TERM1 and TERM3 takes\nplace, you have to pass the already toggled value\nwith the first call.\n\nUnclear still are three instructions starting at ad-\ndress $B6AD. They seem to set the two least signifi-\ncant bits of TERM3 in a random fashion. Could this\nbe some quick hack to avoid messing with exact but\npotentially lengthy two’s-complement arithmetic?\n\n2.4 Dodging Memory Limitations\n\nIt is impressing how much functionality was\nsqueezed into STAR RAIDERS. Not surprisingly, the\nbytes of the 8 KB ROM are used up almost com-\npletely. Only a single byte is left unused at the very\nend of the code. When counting four more bytes\nfrom three orphaned entries in the game’s lookup\ntables, only five bytes in total out of 8,192 bytes are\nactually not used. ROM memory was extremely pre-\ncious. Here are some techniques that demonstrate\n\n\n\n\n; INPUT\n2 ;\n\n; X = Pos i t i on vector component index o f TERM2. Used va lues are :\n4 ; $00 . . $30 −> z−component ( z−coord inate ) o f po s i t i on vector 0 . . 4 8\n\n; $31 . . $61 −> x−component (x−coord inate ) o f po s i t i on vector 0 . . 4 8\n6 ; $62 . . $92 −> y−component (y−coord inate ) o f po s i t i on vector 0 . . 4 8\n\n;\n8 ; Y = Pos i t i on vector component index o f TERM1. Used va lues are :\n\n; $00 . . $30 −> z−component ( z−coord inate ) o f po s i t i on vector 0 . . 4 8\n10 ; $31 . . $61 −> x−component (x−coord inate ) o f po s i t i on vector 0 . . 4 8\n\n; $62 . . $92 −> y−component (y−coord inate ) o f po s i t i on vector 0 . . 4 8\n12 ;\n\n; JOYSTICKDELTA ($6D) = I n i t i a l value o f SIGN . Used va lues are :\n14 ; $01 −> (= Pos i t i v e ) Rotate r i gh t or up\n\n; $FF −> (= Negative ) Rotate l e f t or down\n16\n\n; TERM3 i s a 24−b i t value , r epre sented by 3 bytes as\n18 ; $ ( s i gn ) ( high byte ) ( low byte )\n\n=006A L .TERM3LO = $6A ; TERM3 ( high byte ) , where TERM3 := TERM2 / 64\n20 =006B L .TERM3HI = $6B ; TERM3 ( low byte ) , where TERM3 := TERM2 / 64\n\n=006C L .TERM3SIGN = $6C ; TERM3 ( s ign ) , where TERM3 := TERM2 / 64\n22\n\nB69B BDAD09 ROTATE LDA ZPOSSIGN,X ;\n24 B69E 4901 EOR #$01 ;\n\nB6A0 F002 BEQ SKIP224 ; Skip i f s i gn o f TERM2 i s p o s i t i v e\n26 B6A2 A9FF LDA #$FF ;\n\n28 B6A4 856B SKIP224 STA L .TERM3HI ; I f TERM2 pos . −> TERM3 := $0000xx (= TERM2 / 256)\nB6A6 856C STA L .TERM3SIGN ; I f TERM2 neg . −> TERM3 := $FFFFxx (= TERM2 / 256)\n\n30 B6A8 BD400A LDA ZPOSHI ,X ; where xx := TERM2 ( high byte )\nB6AB 856A STA L .TERM3LO ;\n\n32\nB6AD AD0AD2 LDA RANDOM ; (? ) Hack to avoid messing with two−complement ’ s\n\n34 B6B0 09BF ORA #$BF ; (? ) a r i thmet i c ? Provides two l e a s t s i g n i f i c a n t\nB6B2 5DD30A EOR ZPOSLO,X ; (? ) b i t s B1 . . 0 in TERM3.\n\n36\nB6B5 0A ASL A ; TERM3 := TERM3 ∗ 4 (= TERM2 / 256 ∗ 4 = TERM2 / 64)\n\n38 B6B6 266A ROL L .TERM3LO ;\nB6B8 266B ROL L .TERM3HI ;\n\n40 B6BA 0A ASL A ;\nB6BB 266A ROL L .TERM3LO ;\n\n42 B6BD 266B ROL L .TERM3HI ;\n\n44 B6BF A56D LDA JOYSTICKDELTA ; Toggle SIGN fo r next c a l l o f ROTATE\nB6C1 49FF EOR #$FF ;\n\n46 B6C3 856D STA JOYSTICKDELTA ;\nB6C5 301A BMI SKIP225 ; I f SIGN negat ive then subtract , e l s e add TERM3\n\n48\n;∗∗∗ Addition ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗\n\n50 B6C7 18 CLC ; TERM1 := TERM1 + TERM3\nB6C8 B9D30A LDA ZPOSLO,Y ; (24− b i t add i t i on )\n\n52 B6CB 656A ADC L .TERM3LO ;\nB6CD 99D30A STA ZPOSLO,Y ;\n\n54\nB6D0 B9400A LDA ZPOSHI ,Y ;\n\n56 B6D3 656B ADC L .TERM3HI ;\nB6D5 99400A STA ZPOSHI ,Y ;\n\n58\nB6D8 B9AD09 LDA ZPOSSIGN,Y ;\n\n60 B6DB 656C ADC L .TERM3SIGN ;\nB6DD 99AD09 STA ZPOSSIGN,Y ;\n\n62 B6E0 60 RTS ;\n\n64 ;∗∗∗ Subtract ion ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗\nB6E1 38 SKIP225 SEC ; TERM1 := TERM1 − TERM3\n\n66 B6E2 B9D30A LDA ZPOSLO,Y ; (24− b i t subt rac t i on )\nB6E5 E56A SBC L .TERM3LO ;\n\n68 B6E7 99D30A STA ZPOSLO,Y ;\n\n70 B6EA B9400A LDA ZPOSHI ,Y ;\nB6ED E56B SBC L .TERM3HI ;\n\n72 B6EF 99400A STA ZPOSHI ,Y ;\n\n74 B6F2 B9AD09 LDA ZPOSSIGN,Y ;\nB6F5 E56C SBC L .TERM3SIGN ;\n\n76 B6F7 99AD09 STA ZPOSSIGN,Y ;\nB6FA 60 RTS ;\n\nFigure 3. ROTATE Subroutine at $B69B\n\n13\n\n\n\nthe fierce fight for each spare ROM byte.\n\n2.4.1 Loop Jamming\n\nLoop jamming is the technique of combining two\nloops into one, reusing the loop index and option-\nally skipping operations of one loop when the loop\nindex overshoots.\n\nHow much bytes are saved by loop jamming? As\nan example, Figure 4 shows an original 19-byte frag-\nment of subroutine INITIALIZE ($B3BA) using loop\njamming. The same fragment without loop jam-\nming, shown in Figure 5, is 20 bytes long. So loop\njamming saved one single byte.\n\nAnother example is the loop that is set up at\n$A165 in INITCOLD ($A14A). A third example is the\nloop set up at $B413 in INITIALIZE ($B3BA). This\nloop does not explicitly skip loop indices, thus sav-\ning four more bytes (the CMP and BCS instructions)\non top of the one byte saved by regular loop jam-\nming. Thus, seven bytes are saved in total by loop\njamming.\n\n2.4.2 Sharing Blank Characters\n\nOne more technique to save bytes is to let strings\nshare their leading and trailing blank characters. In\nthe game there is a header text line of twenty char-\nacters that displays one of the strings “LONG RANGE\nSCAN,” “AFT VIEW,” or “GALACTIC CHART.” The dis-\nplay hardware directly points to their location in the\nROM. They are enclosed in blank characters (bytes\nof value $00) so that they appear horizontally cen-\ntered.\n\nA naive implementation would use 3 × 20 = 60\nbytes to store these strings in ROM. In the actual\nimplementation, however, the trailing blanks of one\nheader string are reused as leading blanks of the\nfollowing header, as shown in Figure 6. By shar-\ning blank characters the required memory is reduced\nfrom 60 bytes to 54 bytes, saving six bytes.\n\n2.4.3 Reusing Interrupt Exit Code\n\nYet another, rather traditional technique is to reuse\ncode, of course. Figure 7 shows the exit code of the\nVertical Blank Interrupt handler VBIHNDLR ($A6D1)\nat $A715, which jumps into the exit code of the Dis-\nplay List Interrupt handler DLSTHNDLR ($A718) at\n$A74B, reusing the code that restores the registers\nthat were put on the CPU stack before entering the\nVertical Blank Interrupt handler.\n\nThis saves another six bytes (PLA, TAY, PLA, TAX,\nPLA, RTI), but spends three bytes (JMP JUMP004), in\ntotal saving three bytes.\n\n2.5 Bugs\nThere are a few bugs, or let’s call them glitches, in\nSTAR RAIDERS. This is quite astonishing, given the\ncomplex game and the development tools of 1979,\nand is a testament to thorough play testing. The\ninteresting thing is that the often intense game play\ndistracts the players’ attention from noticing these\nglitches, just like what a skilled parlor magician\nwould do.\n\n2.5.1 A Starbase Without Wings\n\nWhen a starbase reaches the lower edge of the graph-\nics screen and overlaps with the Control Panel Dis-\nplay below (Figure 8 (left), screenshot) and you\nnudge the starbase a little bit more downward, its\nwings suddenly vanish (Figure 8 (right), screenshot).\n\nThe reason is shown in the insert on the right\nside of the figure: The starbase is a composite of\nthree Players (sprites). Their bounding boxes are\nindicated by three white rectangles. If the verti-\ncal position of the top border of a Player is larger\nthan a vertical position limit, indicated by the tip\nof the white arrow, the Player is not displayed. The\nrelevant location of the comparison is at $A534 in\nGAMELOOP ($A1F3). While the Player of the central\npart of the starbase does not exceed this vertical\nlimit, the Players that form the starbase’s wings do\nso, and are thus not rendered.\n\nThis glitch is rarely noticed because players do\ntheir best to keep the starbase centered on the\nscreen, a prerequisite for a successful docking.\n\n2.5.2 Shuffling Priorities\n\nThere are two glitches that are almost impossible to\nnotice (and I admit some twisted kind of pleasure to\nexpose them, ;-):\n\n• During regular gameplay, the Zylon ships and\nthe photon torpedoes appear in front of the\ncross hairs (Figure 9 (left)), as if the cross hairs\nwere light years away.\n\n• During docking, the starbase not only appears\nbehind the stars (Figure 9 (right)) as if the\nstarbase is light years away, but the transfer\nvessel moves in front of the cross hairs!\n\n14\n\n\n\n1 B3BA A259 INITIALIZE LDX #89 ; Set 89(+1) GRAPHICS7 rows from DSPLST+5 on\nB3BC A90D LOOP060 LDA #$0D ; Prep DL in s t r u c t i o n $0D ( one row of GRAPHICS7)\n\n3 B3BE 9D8502 STA DSPLST+5,X ; DSPLST+5,X := one row of GRAPHICS7\nB3C1 E00A CPX #10 ;\n\n5 B3C3 B005 BCS SKIP195 ;\nB3C5 BDA9BF LDA PFCOLORTAB,X ; Copy PLAYFIELD co l o r tab l e to zero−page tab l e\n\n7 B3C8 95F2 STA PF0COLOR,X ; ( loop jamming )\nB3CA CA SKIP195 DEX ;\n\n9 B3CB 10EF BPL LOOP060 ;\n\nFigure 4. INITIALIZE Subroutine at $B3BA (Excerpt)\n\n1 B3BA A259 INITIALIZE LDX #89 ; Set 89(+1) GRAPHICS7 rows from DSPLST+5 on\nB3BC A90D LOOP060 LDA #$0D ; Prep DL in s t r u c t i o n $0D ( one row of GRAPHICS7)\n\n3 B3BE 9D8502 STA DSPLST+5,X ; DSPLST+5,X := one row of GRAPHICS7\nB3C1 CA DEX ;\n\n5 B3C2 10F8 BPL LOOP060 ;\nB3C4 A209 LDX #9 ;\n\n7 B3C6 BDAABF LOOP060B LDA PFCOLORTAB,X ; Copy PLAYFIELD co l o r tab l e to zero−page tab l e\nB3C9 95F2 STA PF0COLOR,X ;\n\n9 B3CB CA DEX ;\nB3CC 10F8 BPL LOOP060B ;\n\nFigure 5. INITIALIZE Subroutine Without Loop Jamming (Excerpt)\n\nThe reason is the drawing order or “graphics pri-\nority” of the bit-mapped graphics and the Players\n(sprites). It is controlled by the PRIOR ($D01B) hard-\nware register.\n\nDuring regular flight, see Figure 9 (left), PRIOR\n($D01B) has a value of $11. This arranges the dis-\nplayed elements in the following order, from front to\nback:\n\n• Players 0-4 (photon torpedoes, Zylon ships,\n. . . )\n\n• Bit-mapped graphics (stars, cross hairs)\n\n• Background.\n\nThis arrangement is fine for the stars as they are\nbit-mapped graphics and need to appear behind the\nphoton torpedoes and the Zylon ships, but this ar-\nrangement applies also to the cross hairs – causing\nthe glitch.\n\nDuring docking, see Figure 9 (right), PRIOR\n($D01B) has a value of $14. This arranges the dis-\nplayed elements the following order, from front to\nback:\n\n• Player 4 (transfer vessel)\n\n• Bit-mapped graphics (stars, cross hairs)\n\n• Players 0-3 (starbase, . . . )\n\n• Background.\n\nThis time the arrangement is fine for the cross\nhairs as they are bit-mapped graphics and need to\nappear in front of the starbase, but this arrangement\nalso applies to the stars. In addition, the Player of\nthe white transfer vessel correctly appears in front\nof the bit-mapped stars, but also in front of the bit-\nmapped cross hairs.\n\nFixing these glitches is hardly possible, as the\ndisplay hardware does not allow for a finer control\nof graphics priorities for individual Players.\n\n2.6 A Mysterious Finding\nA simple instruction at location $A175 contained\nthe most mysterious finding in the game’s code.\nThe disassembler reported the following instruction,\nwhich is equivalent to STA $0067,X. (ISVBISYNC has\na value of $67.)\nA175 9D6700 STA ISVBISYNC,X\n\nThe object code assembled from this instruction\nis unusual as its address operand was assembled\nas a 16-bit address and not as an 8-bit zero-page\naddress. Standard 6502 assemblers would always\ngenerate shorter object code, producing 9567 (STA\n$67,X) instead of 9D6700 and saving a byte.\n\nIn my reverse engineered source code, the only\nway to reproduce the original object code was the\nfollowing:\n\n15\n\n\n\n;∗∗∗ Header text o f Long−Range Scan view ( share s spaces with f o l l ow ing header ) ∗\n2 A0F8 00006C6F LRSHEADER .BYTE $00 , $00 , $6C , $6F , $6E , $67 , $00 , $72 ; ‘ ‘ LONG RANGE SCAN’ ’\n\nA0FC 6E670072\n4 A100 616E6765 .BYTE $61 , $6E , $67 , $65 , $00 , $73 , $63 , $61\n\nA104 00736361\n6 A108 6E .BYTE $6E\n\n8 ;∗∗∗ Header text o f Aft view ( share s spaces with f o l l ow ing header ) ∗∗∗∗∗∗∗∗∗∗∗∗∗\nA109 00000000 AFTHEADER .BYTE $00 , $00 , $00 , $00 , $00 , $00 , $61 , $66 ; ‘ ‘ AFT VIEW ‘ ‘\n\n10 A10D 00006166\nA111 74007669 .BYTE $74 , $00 , $76 , $69 , $65 , $77 , $00 , $00\n\n12 A115 65770000\nA119 00 .BYTE $00\n\n14\n;∗∗∗ Header text o f Ga lac t i c Chart view ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗\n\n16 A11A 00000067 GCHEADER .BYTE $00 , $00 , $00 , $67 , $61 , $6C , $61 , $63 ; ‘ ‘ GALACTIC CHART ‘ ‘\nA11E 616C6163\n\n18 A122 74696300 .BYTE $74 , $69 , $63 , $00 , $63 , $68 , $61 , $72\nA126 63686172\n\n20 A12A 74000000 .BYTE $74 , $00 , $00 , $00\n\nFigure 6. Header Texts at $A0F8\n\nA6D1 A9FF VBIHNDLR LDA #$FF ; Star t o f Ve r t i c a l Blank In t e r rupt handler\n2 . . .\n\nA715 4C4BA7 SKIP046 JMP JUMP004 ; End of Ve r t i c a l Blank In t e r rupt handler\n4 . . .\n\nA718 48 DLSTHNDLR PHA ; Star t o f Display L i s t In t e r rupt handler\n6 . . .\n\nA74B 68 JUMP004 PLA ; Restore r e g i s t e r s\n8 A74C A8 TAY ;\n\nA74D 68 PLA ;\n10 A74E AA TAX ;\n\nA74F 68 PLA ;\n12 A750 40 RTI ; End of Display L i s t In t e r rupt Handler\n\nFigure 7. VBIHNDLR and DLSTHNDLR Handlers Share Exit Code\n\n1 ; HACK: Fake STA ISVBISYNC,X with 16b addr\nA175 9D .BYTE $9D\n\n3 A176 6700 .WORD ISVBISYNC\n\nI speculated for a long time whether this strange\nassembler output indicated that the object code of\nthe original ROM cartridge was produced with a\nnon-standard 6502 assembler. I have heard that\nAtari’s in-house development systems ran on PDP-\n11 hardware. Luckily, the month after I finished\nmy reverse engineering effort, the original STAR\nRAIDERS source code re-surfaced.7 To my aston-\nishment it uses exactly the same “hack” to repro-\nduce the three-byte form of the STA ISVBISYNC,X\ninstruction:\n\n1 A175 9D .BYTE $9D ; STA ABS,X\nA176 67 00 .WORD PAGE0 ; STA PAGE0,X (ABSOLUTE)\n\nUnfortunately the comments do not give a clue\nwhy this pattern was chosen. After quite some time\n\nit made click: The instruction STA ISVBISYNC,X is\nused in a loop which iterates the CPU’s X register\nfrom 0 to 255 to clear memory. By using this instruc-\ntion with a 16-bit address (“indexed” mode operand)\nmemory from $0067 to $0166 is cleared. Had the\ncode been using the same operation with an 8-bit ad-\ndress (“indexed, zero-page” mode operand), memory\nfrom $0067 to $00FF would have been cleared, then\nthe indexed address would have wrapped back to\n$0000 clearing memory $0000 to $0066, effectively\noverwriting already initialized memory locations.\n\n2.7 Documenting Star Raiders\n\nRight from the start of reverse engineering STAR\nRAIDERS I not only wanted to understand how the\ngame worked, but I also wanted to document the re-\nsult of my effort. But what would be an appropriate\nform?\n\nFirst, I combined the emerging memory map file\nwith the fledgling assembly language source code in\n\n7https://archive.org/details/AtariStarRaidersSourceCode\nunzip pocorgtfo13.pdf StarRaidersOrig.pdf\n\n16\n\n\n\nFigure 8. A Starbase’s Wings Vanish\n\nFigure 9. Photon torpedo in front of cross hairs and a starbase behind the stars!\n\norder to work with just one file. Then, I switched\nthe source code format to that of MAC/65, a well-\nknown and powerful macro assembler for the Atari\n8-bit Home Computer System. I also planned, at\nsome then distant point in the future, to assemble\nthe finished source code with this assembler on an\n8-bit Atari.\n\nAnother major influence on the emerging docu-\nmentation was the Atari BASIC Source Book, which\nI came across by accident8. It reproduced the com-\nplete, commented assembly language source code of\nthe 8 KB Atari BASIC interpreter cartridge, a truly\nnon-trivial piece of software. But what was more:\nThe source code was accompanied by several chap-\nters of text that explained in increasing detail its\nconcepts and architecture, that is, how Atari BASIC\nactually worked. Deeply impressed, I decided on\nthe spot that my reverse engineered STAR RAIDERS\nsource code should be documented at the same level\nof detail.\n\nThe overall documentation structure for the\nsource code, which I ended up with was fourfold: On\nthe lowest level, end-of-line comments documented\nthe functionality of individual instructions. On the\nnext level, line comments explained groups of in-\nstructions. One level higher still, comments com-\n\nposed of several paragraphs introduced each sub-\nroutine. These paragraphs provided a summary of\nthe subroutine’s implementation and a description\nof all input and output parameters, including the\nvalid value ranges, if possible. On the highest level,\nI added the memory map to the source code as a\nhandy reference. I also planned to add some chap-\nters on the game’s general concepts and overall ar-\nchitecture, just like the Atari BASIC Source Book\nhad done. Unfortunately, I had to drop that idea\ndue to lack of time. I also felt that the detailed sub-\nroutine documentation was quite sufficient. How-\never, I did add sections on the 3D coordinate system\nand the position and velocity vectors to the source\ncode as a tip of the hat to the Atari BASIC Source\nBook.\n\nAfter I was well into reverse engineering STAR\nRAIDERS, slowly adding bits and pieces of informa-\ntion to the raw disassembly of the STAR RAIDERS\nROM and fleshing out the ever growing documen-\ntation, I started to struggle with establishing a con-\nsistent and uniform terminology for the documenta-\ntion (Is it “asteroid,” “meteorite,” or “meteor”? “Ex-\nplosion bits,” “explosion debris,” or “explosion frag-\nments”? “Gun sights” or “cross hairs”?) A look into\nthe STAR RAIDERS instruction manual clarified only\n\n8The Atari BASIC Source Book by Wilkinson, O’Brien, and Laughton. A COMPUTE! publication.\n\n17\n\n\n\na painfully small amount of cases. Incidentally, it\nalso contradicted itself as it called the enemies “Cy-\nlons” while the game called them “Zylons,” such as\nin the message “SHIP DESTROYED BY ZYLON FIRE.”\n\nBut I was not only after uniform documenta-\ntion, I also wanted to unify the symbol names of\nthe source code. For example, I had created a\nhodge-podge of color-related symbol names, which\ncontained fragments such as “COL,” “CLR,” “COLR,”\nand “COLOR.” To make matters worse, color-related\nsymbol names containing “COL” could be confused\nwith symbol names related to (pixel) columns. The\nsame occurred with symbol names related to Players\n(sprites), which contained fragments such as “PL,”\n“PLY,” “PLYR,” “PLAY,” and “PLAYER,” or with sym-\nbol names of lookup tables, which ended in “TB,”\n“TBL,” “TAB,” and “TABLE,” and so on. In addition\nto inventing uniform symbol names I also did not\nwant to exceed a self-imposed symbol name limit of\n15 characters. So I refactored the source code with\nthe search-and-replace functionality of the text edi-\ntor over and over again.\n\n18\n\n\n\nI noticed that I spent more and more time\non refactoring the documentation and the symbol\nnames and less time on adding actual content. In\naddition, the actual formatting of the emerging doc-\numented source code had to be re-adjusted after ev-\nery refactoring step. Handling the source code be-\ncame very unwieldy. And worst of all: How could\nI be sure that the source code still represented the\nexact binary image of the ROM cartridge?\n\nThe solution I found to this problem eventually\nwas to create an automated build pipeline, which\ndealt with the monotonous chores of formatting and\nassembling the source code, as well as comparing the\nproduced ROM cartridge image with a reference im-\nage. This freed time for me to concentrate on the\nactual source code content. Yet another incarnation\nof “separation of form and content,” the automated\nbuild pipeline was always a pleasure to watch work-\ning its magic. (Mental note: I should have created\nthis pipeline much earlier in the reverse engineering\neffort.) These are the steps of the automated build\npipeline:\n\n1. The pipeline starts with a raw, documented as-\nsembly language source code file. It is already\nroughly formatted and uses a little propri-\netary markup, just enough to mark up sections\nof meta-comments that are to be removed in\nthe output as well as subroutine documen-\ntation containing multiple paragraphs, num-\nbered, and unnumbered lists. This source code\nfile is fed to a pre-formatter program, which\nI implemented in Java. The pre-formatter re-\nmoves the meta-comments. It also formats the\nentries of the memory map and the subroutine\n\ndocumentation by wrapping multi-line text at\na preset right margin, out- and indenting list\nitems, numbering lists, and vertically aligning\nparameter descriptions. It also corrects the\nnumber of trailing asterisks in line comments,\nand adjusts the number of asterisks of the box\nheaders that introduce subroutine comments,\ncentering their text content inside the asterisk\nboxes.\n\n2. The output of the pre-formatter from step 1 is\nfed into an Atari 6502 assembler, which I also\nwrote in Java. It is available as open-source\non GitHub.9 Why write an Atari 6502 assem-\nbler? There are other 6502 assemblers readily\navailable, but not all produce object code for\nthe Atari 8-bit Home Computer System, not\nall use the MAC/65 source code format, and\nnot all of them can be easily tweaked when\nnecessary. The output of this step is both an\nassembler output listing and an object file.\n\n3. The assembler output listing from step 2 is the\nfinished, formatted, reverse engineered STAR\nRAIDERS source code, containing the docu-\nmentation, the source code, and the object\ncode listing.\n\n4. The assembler output listing from step 2 is fed\ninto a symbol checker program, which I again\nwrote in Java. It searches the documenta-\ntion parts of the assembler output listing and\nchecks if every symbol, such as “GAMELOOP,” is\nfollowed by its correct hex value, “($A1F3).” It\nreports any symbol with missing or incorrect\nhex values. This ensures further consistency\nof the documentation.\n\n5. The object file of step 2 is converted by yet an-\nother program I wrote in Java from the Atari\nexecutable format into the final Atari ROM\ncartridge format.\n\n6. The output from step 5 is compared with a\nreference binary image of the original STAR\nRAIDERS 8 KB ROM cartridge. If both im-\nages are the same, then the entire build was\nsuccessful: The raw assembly language source\ncode really represents the exact image of the\nSTAR RAIDERS 8 KB ROM cartridge\n\n9git clone https://github.com/lwiest/Atari6502Assembler\nunzip pocorgtfo13.pdf Atari6502Assembler.zip\n\n19\n\n\n\nTypical build times on my not-so-recent Win-\ndows XP box (512 MB) were 15 seconds.\n\nFor some finishing touches, I ran a spell-checker\nover the documented assembly language source code\nfile from time to time, which also helped to improve\ndocumentation quality.\n\n2.8 Conclusion\nAfter quite some time, I achieved my goal to create a\nreverse engineered, complete, and fully documented\nassembly language source code of STAR RAIDERS.\nFor final verification, I successfully assembled it with\nMAC/65 on an Atari 800 XL with 64 KB RAM (em-\nulated with Atari800Win Plus). MAC/65 is able to\nassemble source code larger than the available RAM\nby reading the source code as several chained files.\nSo I split the source code (560 KB) into chunks of 32\nKB and simply had the emulator point to a hard disk\nfolder containing these files. The resulting assembler\noutput listing and the object file were written back\nto the same hard disk folder. The object file, after\nbeing transformed into the Atari cartridge format,\nexactly reproduced the original STAR RAIDERS 8 KB\nROM cartridge.\n\n2.9 Postscript\nI finished my reverse engineering effort in Septem-\nber 2015. I was absolutely thrilled to learn that in\nOctober 2015 scans of the original STAR RAIDERS\nsource code re-surfaced. To my delight, inspection\nof the original source code confirmed the findings of\nmy reverse engineered version and caused only a few\ntrivial corrections. Even more, the documentation\nof my reverse engineered version added a substan-\ntial amount of information – from overall theory of\noperation down to some tricky details – to the un-\nderstanding of the often sparsely commented origi-\nnal (quite expected for source code never meant for\npublication).\n\n20\n\n\n\n21\n\n00 7f 47 47 47 47 47 7f 00 30 10 10 10 38 38 38 00 78 08 08 78 40 40 78 00 78 08 08 7c 0c 0c 7c 00 60 60 60 6c 7c 0c 0c 00 78 40 40 78\n08 08 78 00 78 48 40 40 7e 42 7e 00 7c 44 04 1c 10 10 10 00 38 28 28 7c 6c 6c 7c 00 7c 44 44 7c 0c 0c 0c 00 00 00 00 00 00 00 00 38 38\n38 00 00 38 38 38 80 80 80 80 80 80 80 ff 00 3c 20 20 78 60 60 7c 00 66 99 99 99 66 00 00 00 00 00 7e 00 00 00 00 00 18 18 18 7e 18 18\n18 00 18 7e db 99 db 7e 18 66 66 66 66 66 2c 38 30 00 7c 44 44 7c 68 6c 6c 00 1c 3e 63 5d 63 3e 1c 00 46 46 44 7c 64 66 66 fe 92 10 18\n18 18 18 18 fc 8c 8c 80 80 80 84 fc 00 00 00 00 00 00 00 ff 80 80 80 80 80 80 80 80 00 00 00 00 00 00 00 80 80 aa 9c be 9c aa 80 ff 80\n98 80 b6 80 8c 80 ff 80 8e 80 b8 80 9c 80 ff 80 b0 98 be 98 b0 80 ff 00 00 6c 6f 6e 67 00 72 61 6e 67 65 00 73 63 61 6e 00 00 00 00 00\n00 61 66 74 00 76 69 65 77 00 00 00 00 00 00 67 61 6c 61 63 74 69 63 00 63 68 61 72 74 00 00 00 60 46 1a a1 f0 47 35 0d 07 07 07 07 07\n07 07 07 80 46 1f 0d 46 71 09 06 06 41 80 02 a9 00 8d 0f d2 85 66 85 62 85 63 a9 03 8d 0f d2 a0 2f a9 ff 84 65 85 64 a9 00 aa 9d 00 d0\n9d 00 d4 e0 0f b0 03 9d 00 d2 9d 00 d3 9d 67 00 e8 d0 ea ca 9a d8 a9 02 20 0f ae a9 51 8d 16 02 a9 a7 8d 17 02 a9 d1 8d 22 02 a9 18 8d\n00 02 a9 a6 8d 23 02 a9 a7 8d 01 02 a9 04 8d 02 d3 a9 11 8d 1b d0 a9 03 8d 1d d0 20 ba b3 a2 0a 20 45 b0 a5 64 29 80 a8 a2 5f a9 08 20\nf1 ad a9 20 85 71 a9 80 8d 02 d4 a9 02 8d 03 d4 a9 3e 8d 00 d4 a9 00 8d 07 d4 a9 10 85 79 a6 62 bc 0c bf 20 23 b2 a9 40 8d 0e d2 58 a9\nc0 8d 0e d4 a5 67 f0 fc a9 00 85 67 a5 7a f0 20 a2 04 e8 bc 5b 0c b9 00 08 85 68 b9 64 08 85 69 bc 8c 0c bd bd 0c 91 68 e4 7a 90 e6 a9\n00 85 7a a5 c0 30 2d a6 79 86 7a bd f9 0b 9d 5b 0c a8 b9 00 08 85 68 b9 64 08 85 69 bd 2a 0c 4a 4a 9d 8c 0c a8 b1 68 9d bd 0c 1d ee 0c\n91 68 ca e0 04 d0 d7 a5 66 10 0e a9 00 8d e3 17 8d e4 17 8d bc 17 8d bb 17 a9 00 ac 5f 0c ae c1 0c 99 00 03 c8 ca 10 f9 ac 5e 0c ae c0\n0c 99 00 07 c8 ca 10 f9 ac 5d 0c ae bf 0c 99 00 06 c8 ca 10 f9 ac 5c 0c ae be 0c 99 00 05 c8 ca 10 f9 ac 5b 0c ae bd 0c 99 00 04 c8 ca\n10 f9 ad 90 0c c9 01 a4 e8 ae fd 0b 8e 5f 0c ad f2 0c 85 6a 8d c1 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 03 c8 e8 c6 6a 10 ef ad 8f 0c c9 01\na4 e7 ae fc 0b 8e 5e 0c ad f1 0c 85 6a 8d c0 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 07 e8 c8 c6 6a 10 ef ad 8e 0c c9 01 a4 e6 ae fb 0b 8e 5d\n0c ad f0 0c 85 6a 8d bf 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 06 e8 c8 c6 6a 10 ef a4 e5 ae fa 0b 8e 5c 0c ad ef 0c 85 6a 8d be 0c b9 b1 b9\n9d 00 05 e8 c8 c6 6a 10 f4 a4 e4 ae f9 0b 8e 5b 0c ad ee 0c 85 6a 8d bd 0c b9 b1 b9 9d 00 04 e8 c8 c6 6a 10 f4 ad 2a 0c 8d 00 d0 ad 2b\n0c 8d 01 d0 ad 2c 0c 8d 02 d0 ad 2d 0c 8d 03 d0 ad 2e 0c 8d 07 d0 18 69 02 8d 06 d0 69 02 8d 05 d0 69 02 8d 04 d0 24 d0 30 3a a5 c8 f0\n19 85 6d a4 79 84 6e 18 98 aa 69 31 a8 20 9b b6 98 aa a4 6e 20 9b b6 88 10 eb a5 c9 f0 19 85 6d a4 79 84 6e 18 98 aa 69 62 a8 20 9b b6\n98 aa a4 6e 20 9b b6 88 10 eb a6 79 e0 05 b0 05 bd 8c 0c f0 19 38 bd d3 0a e5 70 9d d3 0a bd 40 0a e5 c1 9d 40 0a bd ad 09 e9 00 9d ad\n09 ca 10 db a6 79 e0 10 d0 02 a2 04 8a a8 a9 00 85 6b b9 66 0b 10 09 49 7f 18 69 01 b0 02 c6 6b 18 79 d3 0a 99 d3 0a b9 40 0a 65 6b 99\n40 0a b9 ad 09 65 6b 99 ad 09 98 18 69 31 c9 90 90 ce ca 10 c4 a0 04 98 aa a9 02 85 6a bd ad 09 c9 02 90 10 0a a9 00 9d ad 09 b0 05 fe\nad 09 49 ff 9d 40 0a 8a 18 69 31 aa c6 6a 10 e0 88 10 d7 a5 d0 c9 02 b0 5c a6 79 a9 ff bc ad 09 c4 d0 f0 4b bd 0f 0a d0 12 38 a9 00 fd\n35 0b 85 6a a9 00 fd a2 0a 85 6b 4c 7d a4 bd 35 0b 85 6a bd a2 0a 85 6b 20 21 aa 20 1e b7 bd de 09 d0 12 38 a9 00 fd 04 0b 85 6a a9 00\nfd 71 0a 85 6b 4c a4 a4 bd 04 0b 85 6a bd 71 0a 85 6b 20 21 aa 20 fb b6 ca 10 a6 20 62 b1 24 d0 50 31 a2 31 20 6f a7 2c 96 09 70 27 a6\n79 bd 40 0a bc ad 09 d0 02 49 ff a8 b9 e9 0d 20 1e b7 bd 71 0a bc de 09 d0 02 49 ff a8 b9 e9 0d 20 fb b6 ca 10 db a2 05 ca 10 03 4c 79\na5 a9 00 95 e4 9d ee 0c 24 d0 10 0b e0 03 90 eb ad 0a d2 a0 f2 30 2b d5 e9 f0 e0 70 f3 bc 40 0a 24 7b 50 1e e0 02 b0 16 ad 2c 0c 18 7d\ndb be 9d 2a 0c ad fb 0b 18 69 04 9d f9 0b ac 42 0a a5 76 29 0f 85 6b 98 bc f9 0b c0 cc b0 af a4 d0 f0 02 49 ff c9 20 b0 a5 c9 10 90 02\na9 0f 85 6a 1d 8c 0c 4a a8 b9 2f be 95 e4 b9 7f be 9d ee 0c 98 4a 4a 4a a8 b9 d1 bf c0 08 d0 03 4d 0a d2 a4 6a 59 db bf 45 6b bc df b8\n99 ee 00 4c e7 a4 a0 af a6 81 a5 8b f0 0c c6 8b a0 4f 29 20 f0 04 a2 42 a0 60 84 f4 86 f6 a6 79 bd 40 0a a4 d0 c0 01 d0 09 c9 f0 b0 03\n20 64 b7 49 ff c9 10 90 02 a9 0f 0a 29 1c 05 72 a8 b9 90 ba 85 6a bd 2a 0c 29 03 a8 b9 b0 ba 25 6a 9d ee 0c ca e0 05 b0 ca 24 64 50 03\n4c 9b a6 20 fe af ad 00 d3 a8 29 03 aa bd f5 ba 85 c9 98 4a 4a 29 03 aa bd f5 ba 85 c8 20 3d af 20 29 ae 2c 95 09 70 40 a5 7e f0 3c a5\nd0 d0 03 20 bf a7 ae 5c 09 a5 bf 30 05 aa 09 80 85 bf b5 e9 d0 0b 8a 49 01 aa b5 e9 d0 03 ae 5c 09 8e 5c 09 a5 7c f0 13 a5 d0 c9 02 b0\n0d 49 01 dd ad 09 f0 06 aa bd cf be 85 ca 20 e6 ac 20 79 aa a5 7b d0 5c a5 eb f0 58 ac 42 0a c8 c0 02 b0 50 ac 73 0a c8 c0 02 b0 48 ac\na4 0a c8 c0 02 b0 40 20 e1 ae a0 02 20 6b ac a2 7f a5 81 d0 1e a2 0a 20 45 b0 a0 23 a2 08 20 0a b1 a2 5f a0 80 a9 08 20 f1 ad 20 0d ae\na2 40 86 e3 a2 ff 86 8a a9 00 85 eb a9 02 85 be a2 01 20 6f b8 a2 0a 20 a8 ae a4 63 ad 1f d0 49 ff 29 03 85 63 f0 1a 88 10 17 85 66 c9\n02 b0 06 a9 00 a8 4c 5e a1 e6 62 a5 62 29 03 85 62 4c 5a a1 20 04 b8 20 9b a8 20 16 b2 20 e4 b4 4c f3 a1 a9 ff 85 67 a9 e0 8d 09 d4 a6\nf6 ad 0a d2 24 8a 50 07 30 04 29 72 09 40 aa a5 d0 c9 03 90 02 a2 a0 86 f6 a2 08 b5 ee 9d 12 d0 ca 10 f8 8d 1e d0 20 ab b2 e6 77 d0 0d\na5 66 30 09 e6 66 10 05 a0 00 4c 5c a1 4c 4b a7 48 8a 48 98 48 a9 e0 ac 0b d4 c0 60 f0 02 a9 a0 8d 09 d4 a2 04 8d 0a d4 b5 f7 9d 16 d0\nca 10 f8 ad 08 d0 0d 09 d0 0d 0a d0 0d 0b d0 85 83 ad 0f d0 85 82 68 a8 68 aa 68 40 48 a9 00 8d 0e d2 a9 40 8d 0e d2 ad 09 d2 09 c0 85\nca 68 40 99 a4 00 e8 88 10 0e 20 82 a7 a9 05 85 a2 2c 95 09 70 09 a0 02 bd f9 ba c9 fe d0 e4 60 a9 55 85 6b a5 a4 85 6e 29 7f 85 a4 a4\na5 b9 00 08 85 68 b9 64 08 85 69 a5 a6 4a 4a 85 6a a5 a6 29 03 a8 b9 b0 ba 25 6b a4 6a 11 68 91 68 24 6e 10 04 e6 a5 d0 02 e6 a6 c6 a4\nd0 d0 60 ae 5c 09 a4 a2 c0 05 b0 24 a5 a0 85 a6 b9 6e bf 0a 85 6c 90 0d a9 81 85 a4 a5 a1 85 a5 a9 aa 20 84 a7 e6 a6 a5 6c d0 e8 e6 a1\ne6 a2 60 c0 0a 90 f9 b5 e9 f0 3c bd 71 0a bc de 09 f0 08 c9 0c 90 0a a9 0b 10 06 c9 f5 b0 02 a9 f5 18 69 83 85 a0 bd a2 0a 49 ff bc 0f\n0a d0 08 c9 05 90 0a a9 04 10 06 c9 fa b0 02 a9 fa 18 69 4d 85 a1 a9 00 85 a2 a9 36 85 68 a9 1b 85 69 a2 0e a0 06 b1 68 29 55 91 68 88\n10 f7 18 a5 68 69 28 85 68 90 02 e6 69 ca 10 e7 ae 5c 09 c8 a5 88 f0 04 c6 88 d0 39 a5 a0 c9 81 90 33 c9 85 b0 2f a9 aa 8d fe 1b 8d 04\n1c a5 a1 c9 4b 90 21 c9 4f b0 1d a9 aa 8d 9e 1c 8d a4 1c bd 40 0a c9 0c b0 0e a0 a0 8c 40 1d 8c 68 1d 8c 42 1d 8c 6a 1d 84 a3 60 a4 c0\nf0 61 a5 70 c9 fe b0 5c c9 80 90 03 20 b4 a9 a9 03 8d 5c 09 a9 90 8d 8f 0c 85 ec a9 1f 8d 43 0a 38 ad fc 0b e9 77 18 65 c5 29 7f 85 8e\n38 ad 2d 0c e9 7d 18 65 c4 29 7f 85 8f a5 62 f0 11 ad 0a d2 a4 d0 f0 06 8d 2d 0c 8d fc 0b c9 10 b0 14 ad 0a d2 09 10 25 c6 8d 9a 0b ad\n0a d2 09 10 25 c6 8d cb 0b 60 98 30 11 a9 ff 85 c0 a2 00 20 a6 b3 20 a7 b1 a0 1b 4c 8d a9 c6 91 f0 05 a2 02 4c 6f b8 a0 19 20 87 a9 a5\n8f 85 8d a5 8e 85 8c 4a 29 07 aa bd b3 bf 85 c7 a4 92 84 90 a9 00 85 7b be c9 08 10 2e a9 ff 85 7b a0 00 a9 00 99 68 0b a9 01 99 af 09\nad 0a d2 25 c7 99 42 0a 98 18 69 31 a8 c9 93 90 e5 ad 42 0a 09 71 8d 42 0a a2 02 4c be b7 f0 0e a9 ff 85 8b a2 06 20 a6 b3 a0 75 20 23\nb2 60 a2 01 20 6f b8 a0 17 a9 00 85 71 85 c0 a9 10 85 79 a9 00 85 c1 85 73 85 8a 8d 8f 0c 85 80 c0 17 f0 04 85 e9 85 ea 85 eb 85 ec 85\ned 85 75 8d 5c 09 4c 23 b2 c6 c2 10 68 a9 01 85 c1 a9 30 85 79 a9 03 85 c2 a6 c3 a9 12 85 69 ad 0a d2 29 03 a8 b9 3a bb 9d 71 0a b9 3e\nbb 9d a2 0a 20 be b7 8a a8 a9 05 85 6e 18 a5 68 69 50 85 68 9d d3 0a a5 69 69 00 85 69 9d 40 0a a9 00 9d 66 0b 9d 97 0b 9d c8 0b a9 01\n9d ad 09 a9 63 9d f9 0b 9d 2a 0c 20 c1 ac ca e0 11 b0 02 a2 30 c6 6e 10 c7 86 c3 60 a9 00 85 6d a9 07 85 6e 46 6b 66 6a a5 d0 d0 0f bd\n40 0a 4a 85 69 bd d3 0a 6a 85 68 4c 52 aa 38 a9 00 fd d3 0a 85 68 a9 00 fd 40 0a 4a 85 69 66 68 06 6d 38 a5 6a e5 68 a8 a5 6b e5 69 90\n06 85 6b 84 6a e6 6d 06 6a 26 6b 90 03 a9 ff 60 c6 6e 10 df a4 6d b9 e9 0d 60 a5 c0 05 7b d0 f9 a5 86 f0 30 a6 89 38 bd f9 0b ed fc 0b\n90 02 a9 00 20 ca ae 8d cb 0b 8d cc 0b 38 ad 2d 0c fd 2a 0c 20 ca ae 8d 9a 0b 38 ad 2e 0c fd 2a 0c 20 ca ae 8d 9b 0b a2 03 d6 ba 10 27\n8a 4a a8 b9 c8 00 a4 d0 f0 05 49 ff 18 69 01 18 75 b4 10 02 a9 00 c9 10 90 02 a9 0f 95 b4 c9 08 90 02 49 0f 0a 95 ba ca 10 d2 ad 8e 0c\nd0 1b a4 62 b9 85 bf ae a4 0a 10 02 29 7f 8d ca 0b 09 80 ae 73 0a 10 02 29 7f 8d 99 0b a5 76 29 03 f0 2e a5 e6 f0 04 a5 eb d0 25 ad 0a\nd2 c9 04 b0 1e a9 60 8d 8e 0c a2 02 20 64 b7 a9 3c 85 eb a9 88 8d 68 0b a9 00 8d 2c 0c 8d 99 0b 8d ca 0b 60 a5 a7 49 01 85 a7 aa b5 e9\nd0 42 a5 e9 05 ea 29 01 a4 90 d9 c9 08 b0 ba a9 ff 95 e9 ad 0a d2 29 07 a8 b9 89 bf 9d 8c 0c a5 62 f0 03 b9 91 bf 95 a8 a9 01 95 aa 9d\nad 09 ad 0a d2 25 c7 9d a2 0a 69 13 9d 71 0a 09 71 9d 40 0a 20 be b7 bd 40 0a c9 20 b0 11 bd ad 09 f0 08 b5 e4 f0 08 c9 29 f0 04 a9 00\n95 a8 d6 aa 10 24 a9 78 95 aa a5 62 ac 0a d2 c0 30 90 01 4a 4a 95 b8 b5 a8 2c 0a d2 10 02 49 0f 95 ac e8 e8 e0 06 90 f1 a6 a7 b5 a8 d0\n32 a4 a7 c0 31 b0 13 b9 b8 00 4a b9 40 0a b0 06 c9 0a 90 0e b0 04 c9 f5 b0 04 b9 ad 09 4a a9 0f b0 02 a9 00 95 ac 18 98 69 31 a8 e8 e8\ne0 06 90 d2 a6 a7 a4 a7 b5 b2 d5 ac f0 08 b0 04 f6 b2 90 02 d6 b2 86 6a aa bd 99 bf a6 6a 99 66 0b 98 18 69 31 a8 e8 e8 e0 06 90 dc a6\na7 ad 8e 0c d0 0b a5 eb d0 06 a5 be f0 03 c6 be 60 18 bd a2 0a 69 02 c9 05 b0 f5 a0 d0 bd ad 09 4a bd 40 0a b0 08 49 ff a4 62 f0 e4 a0\n50 c9 20 b0 de 8c 68 0b a9 00 8d 8e 0c 8d 2c 0c a9 3e 85 eb a2 02 a4 a7 84 bf 4c af ac a9 80 85 73 a2 30 86 79 ad 0a d2 29 0f 79 2a 0c\ne9 30 9d 2a 0c ad 0a d2 29 0f 79 f9 0b 4a e9 10 9d f9 0b 20 af ac ad 0a d2 29 87 9d 66 0b ad 0a d2 29 87 9d 97 0b ad 0a d2 29 87 9d c8\n0b ca e0 10 d0 c5 60 b9 ad 09 9d ad 09 b9 40 0a 9d 40 0a b9 d3 0a 9d d3 0a b9 de 09 9d de 09 b9 71 0a 9d 71 0a b9 0f 0a 9d 0f 0a b9 a2\n0a 9d a2 0a b9 04 0b 9d 04 0b b9 35 0b 9d 35 0b 60 a5 7b f0 fb a5 d0 d0 05 a9 14 8d 1b d0 a9 02 8d 5c 09 a9 30 8d 8e 0c a9 20 8d 8d 0c\na9 40 8d 8c 0c a9 ff a6 90 bc c9 08 30 02 a9 00 85 e9 85 ea 85 eb 85 7b 30 0a a0 02 20 6b ac a2 0a 4c a8 ae ad 42 0a d0 0a ad d5 0a c9\n20 b0 03 ee d5 0a ad 2c 0c 38 e9 78 c9 10 b0 22 ad fb 0b 38 e9 68 c9 10 b0 18 ad 42 0a c9 02 b0 11 ad af 09 2d 11 0a 49 01 05 70 0d a4\n0a 05 71 f0 10 a5 75 c9 02 90 05 a0 1f 20 23 b2 a9 00 85 75 60 24 75 70 0d 30 42 a5 75 d0 f5 c6 75 a0 1c 4c 23 b2 a2 00 86 65 a4 d1 d0\ne6 a9 50 8d 90 0c a9 01 8d b1 09 8d e2 09 8d 13 0a 8d a6 0a 8d 9b 0b a9 10 8d 44 0a a9 00 8d 75 0a a9 87 8d 6a 0b a9 81 85 75 8d cc 0b\n85 ed 60 ad b1 09 d0 fa a2 0c 20 a6 b3 a0 21 20 23 b2 a2 05 bd 8b bb 9d 92 09 ca 10 f7 a9 89 a2 03 9d 55 09 ca 10 fa a9 07 8d 6a 0b a9\n81 8d 9b 0b a9 01 8d cc 0b 85 75 4c 7b b0 78 85 6a ad 0b d4 c9 7c 90 f9 b9 62 ba c8 10 02 a9 0d 9d 80 02 e8 c6 6a d0 f0 58 60 a9 10 85\n69 a9 00 a8 85 68 85 a3 85 7a 91 68 c8 d0 fb e6 69 a4 69 c0 20 a8 90 f2 60 a5 84 ac 10 d0 84 84 d0 0e 84 66 a6 c0 d0 08 a6 87 c9 01 f0\n03 b0 18 60 b5 ec c9 e8 b0 f9 ac 5c 09 84 89 a9 0c a4 a3 84 86 f0 02 a9 00 85 88 84 84 2c 92 09 70 e1 30 05 8a 49 01 85 87 8a 9d e1 09\nbd 73 bf 9d 74 0a a9 ff 95 ec 9d a5 0a a9 00 9d 8f 0c 9d 43 0a 9d 07 0b 9d 12 0a 9d 38 0b a9 01 9d b0 09 9d d6 0a a5 d0 4a 6a 09 66 9d\n69 0b a9 00 9d 9a 0b 9d cb 0b a2 02 20 6f b8 a2 00 8a d0 06 a5 e1 c9 18 b0 18 a0 07 bd 20 bf 99 da 00 e8 88 10 f6 bd 20 bf 8d 08 d2 bd\n21 bf 8d 04 d2 60 a0 80 b0 04 49 ff a0 00 84 6a c9 08 90 02 a9 07 a8 a5 6a 19 c9 bf 60 24 64 30 57 a6 62 ad 0a d2 dd 10 bf b0 4d 29 07\nc9 06 b0 47 aa bd 92 09 0a 30 eb a5 eb c9 1e a9 80 bc 14 bf 90 17 e0 03 d0 05 2c 96 09 70 0e e0 04 d0 05 2c 95 09 70 05 a9 c0 bc 1a bf\n1d 92 09 9d 92 09 84 65 2c 95 09 50 07 a9 00 85 7e 20 0d ae a0 52 20 23 b2 a2 12 20 a6 b3 60 a2 02 ca 10 01 60 bd 8f 0c d0 f7 b5 ec f0\nf3 b5 82 29 07 f0 ed 4a c9 03 d0 01 4a a8 b9 e9 00 f0 e1 a5 d0 f0 02 a9 ff 85 6c 59 40 0a c9 10 90 02 a9 0f 4a 84 6b a8 a5 6c 5d 43 0a\nd9 75 bf b0 c2 d9 7d bf 90 bd a4 6b 38 a9 ff f5 ec 85 e2 c9 0f 90 05 b9 8c 0c c9 80 a9 00 85 88 95 ec b0 4b 99 e9 00 b9 8c 0c f0 43 c9\n60 f0 3f a9 00 85 86 a6 90 de c9 08 10 13 a9 00 9d c9 08 38 a5 cb e9 03 85 cb a5 cc e9 00 85 cc 60 18 a5 cb 69 06 85 cb a5 cc 69 00 85\n\n00 7f 47 47 47 47 47 7f 00 30 10 10 10 38 38 38 00 78 08 08 78 40 40 78 00 78 08 08 7c 0c 0c 7c 00 60 60 60 6c 7c 0c 0c 00 78 40 40 78\n08 08 78 00 78 48 40 40 7e 42 7e 00 7c 44 04 1c 10 10 10 00 38 28 28 7c 6c 6c 7c 00 7c 44 44 7c 0c 0c 0c 00 00 00 00 00 00 00 00 38 38\n38 00 00 38 38 38 80 80 80 80 80 80 80 ff 00 3c 20 20 78 60 60 7c 00 66 99 99 99 66 00 00 00 00 00 7e 00 00 00 00 00 18 18 18 7e 18 18\n18 00 18 7e db 99 db 7e 18 66 66 66 66 66 2c 38 30 00 7c 44 44 7c 68 6c 6c 00 1c 3e 63 5d 63 3e 1c 00 46 46 44 7c 64 66 66 fe 92 10 18\n18 18 18 18 fc 8c 8c 80 80 80 84 fc 00 00 00 00 00 00 00 ff 80 80 80 80 80 80 80 80 00 00 00 00 00 00 00 80 80 aa 9c be 9c aa 80 ff 80\n98 80 b6 80 8c 80 ff 80 8e 80 b8 80 9c 80 ff 80 b0 98 be 98 b0 80 ff 00 00 6c 6f 6e 67 00 72 61 6e 67 65 00 73 63 61 6e 00 00 00 00 00\n00 61 66 74 00 76 69 65 77 00 00 00 00 00 00 67 61 6c 61 63 74 69 63 00 63 68 61 72 74 00 00 00 60 46 1a a1 f0 47 35 0d 07 07 07 07 07\n07 07 07 80 46 1f 0d 46 71 09 06 06 41 80 02 a9 00 8d 0f d2 85 66 85 62 85 63 a9 03 8d 0f d2 a0 2f a9 ff 84 65 85 64 a9 00 aa 9d 00 d0\n9d 00 d4 e0 0f b0 03 9d 00 d2 9d 00 d3 9d 67 00 e8 d0 ea ca 9a d8 a9 02 20 0f ae a9 51 8d 16 02 a9 a7 8d 17 02 a9 d1 8d 22 02 a9 18 8d\n00 02 a9 a6 8d 23 02 a9 a7 8d 01 02 a9 04 8d 02 d3 a9 11 8d 1b d0 a9 03 8d 1d d0 20 ba b3 a2 0a 20 45 b0 a5 64 29 80 a8 a2 5f a9 08 20\nf1 ad a9 20 85 71 a9 80 8d 02 d4 a9 02 8d 03 d4 a9 3e 8d 00 d4 a9 00 8d 07 d4 a9 10 85 79 a6 62 bc 0c bf 20 23 b2 a9 40 8d 0e d2 58 a9\nc0 8d 0e d4 a5 67 f0 fc a9 00 85 67 a5 7a f0 20 a2 04 e8 bc 5b 0c b9 00 08 85 68 b9 64 08 85 69 bc 8c 0c bd bd 0c 91 68 e4 7a 90 e6 a9\n00 85 7a a5 c0 30 2d a6 79 86 7a bd f9 0b 9d 5b 0c a8 b9 00 08 85 68 b9 64 08 85 69 bd 2a 0c 4a 4a 9d 8c 0c a8 b1 68 9d bd 0c 1d ee 0c\n91 68 ca e0 04 d0 d7 a5 66 10 0e a9 00 8d e3 17 8d e4 17 8d bc 17 8d bb 17 a9 00 ac 5f 0c ae c1 0c 99 00 03 c8 ca 10 f9 ac 5e 0c ae c0\n0c 99 00 07 c8 ca 10 f9 ac 5d 0c ae bf 0c 99 00 06 c8 ca 10 f9 ac 5c 0c ae be 0c 99 00 05 c8 ca 10 f9 ac 5b 0c ae bd 0c 99 00 04 c8 ca\n10 f9 ad 90 0c c9 01 a4 e8 ae fd 0b 8e 5f 0c ad f2 0c 85 6a 8d c1 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 03 c8 e8 c6 6a 10 ef ad 8f 0c c9 01\na4 e7 ae fc 0b 8e 5e 0c ad f1 0c 85 6a 8d c0 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 07 e8 c8 c6 6a 10 ef ad 8e 0c c9 01 a4 e6 ae fb 0b 8e 5d\n0c ad f0 0c 85 6a 8d bf 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 06 e8 c8 c6 6a 10 ef a4 e5 ae fa 0b 8e 5c 0c ad ef 0c 85 6a 8d be 0c b9 b1 b9\n9d 00 05 e8 c8 c6 6a 10 f4 a4 e4 ae f9 0b 8e 5b 0c ad ee 0c 85 6a 8d bd 0c b9 b1 b9 9d 00 04 e8 c8 c6 6a 10 f4 ad 2a 0c 8d 00 d0 ad 2b\n0c 8d 01 d0 ad 2c 0c 8d 02 d0 ad 2d 0c 8d 03 d0 ad 2e 0c 8d 07 d0 18 69 02 8d 06 d0 69 02 8d 05 d0 69 02 8d 04 d0 24 d0 30 3a a5 c8 f0\n19 85 6d a4 79 84 6e 18 98 aa 69 31 a8 20 9b b6 98 aa a4 6e 20 9b b6 88 10 eb a5 c9 f0 19 85 6d a4 79 84 6e 18 98 aa 69 62 a8 20 9b b6\n98 aa a4 6e 20 9b b6 88 10 eb a6 79 e0 05 b0 05 bd 8c 0c f0 19 38 bd d3 0a e5 70 9d d3 0a bd 40 0a e5 c1 9d 40 0a bd ad 09 e9 00 9d ad\n09 ca 10 db a6 79 e0 10 d0 02 a2 04 8a a8 a9 00 85 6b b9 66 0b 10 09 49 7f 18 69 01 b0 02 c6 6b 18 79 d3 0a 99 d3 0a b9 40 0a 65 6b 99\n40 0a b9 ad 09 65 6b 99 ad 09 98 18 69 31 c9 90 90 ce ca 10 c4 a0 04 98 aa a9 02 85 6a bd ad 09 c9 02 90 10 0a a9 00 9d ad 09 b0 05 fe\nad 09 49 ff 9d 40 0a 8a 18 69 31 aa c6 6a 10 e0 88 10 d7 a5 d0 c9 02 b0 5c a6 79 a9 ff bc ad 09 c4 d0 f0 4b bd 0f 0a d0 12 38 a9 00 fd\n35 0b 85 6a a9 00 fd a2 0a 85 6b 4c 7d a4 bd 35 0b 85 6a bd a2 0a 85 6b 20 21 aa 20 1e b7 bd de 09 d0 12 38 a9 00 fd 04 0b 85 6a a9 00\nfd 71 0a 85 6b 4c a4 a4 bd 04 0b 85 6a bd 71 0a 85 6b 20 21 aa 20 fb b6 ca 10 a6 20 62 b1 24 d0 50 31 a2 31 20 6f a7 2c 96 09 70 27 a6\n79 bd 40 0a bc ad 09 d0 02 49 ff a8 b9 e9 0d 20 1e b7 bd 71 0a bc de 09 d0 02 49 ff a8 b9 e9 0d 20 fb b6 ca 10 db a2 05 ca 10 03 4c 79\na5 a9 00 95 e4 9d ee 0c 24 d0 10 0b e0 03 90 eb ad 0a d2 a0 f2 30 2b d5 e9 f0 e0 70 f3 bc 40 0a 24 7b 50 1e e0 02 b0 16 ad 2c 0c 18 7d\ndb be 9d 2a 0c ad fb 0b 18 69 04 9d f9 0b ac 42 0a a5 76 29 0f 85 6b 98 bc f9 0b c0 cc b0 af a4 d0 f0 02 49 ff c9 20 b0 a5 c9 10 90 02\na9 0f 85 6a 1d 8c 0c 4a a8 b9 2f be 95 e4 b9 7f be 9d ee 0c 98 4a 4a 4a a8 b9 d1 bf c0 08 d0 03 4d 0a d2 a4 6a 59 db bf 45 6b bc df b8\n99 ee 00 4c e7 a4 a0 af a6 81 a5 8b f0 0c c6 8b a0 4f 29 20 f0 04 a2 42 a0 60 84 f4 86 f6 a6 79 bd 40 0a a4 d0 c0 01 d0 09 c9 f0 b0 03\n20 64 b7 49 ff c9 10 90 02 a9 0f 0a 29 1c 05 72 a8 b9 90 ba 85 6a bd 2a 0c 29 03 a8 b9 b0 ba 25 6a 9d ee 0c ca e0 05 b0 ca 24 64 50 03\n4c 9b a6 20 fe af ad 00 d3 a8 29 03 aa bd f5 ba 85 c9 98 4a 4a 29 03 aa bd f5 ba 85 c8 20 3d af 20 29 ae 2c 95 09 70 40 a5 7e f0 3c a5\nd0 d0 03 20 bf a7 ae 5c 09 a5 bf 30 05 aa 09 80 85 bf b5 e9 d0 0b 8a 49 01 aa b5 e9 d0 03 ae 5c 09 8e 5c 09 a5 7c f0 13 a5 d0 c9 02 b0\n0d 49 01 dd ad 09 f0 06 aa bd cf be 85 ca 20 e6 ac 20 79 aa a5 7b d0 5c a5 eb f0 58 ac 42 0a c8 c0 02 b0 50 ac 73 0a c8 c0 02 b0 48 ac\na4 0a c8 c0 02 b0 40 20 e1 ae a0 02 20 6b ac a2 7f a5 81 d0 1e a2 0a 20 45 b0 a0 23 a2 08 20 0a b1 a2 5f a0 80 a9 08 20 f1 ad 20 0d ae\na2 40 86 e3 a2 ff 86 8a a9 00 85 eb a9 02 85 be a2 01 20 6f b8 a2 0a 20 a8 ae a4 63 ad 1f d0 49 ff 29 03 85 63 f0 1a 88 10 17 85 66 c9\n02 b0 06 a9 00 a8 4c 5e a1 e6 62 a5 62 29 03 85 62 4c 5a a1 20 04 b8 20 9b a8 20 16 b2 20 e4 b4 4c f3 a1 a9 ff 85 67 a9 e0 8d 09 d4 a6\nf6 ad 0a d2 24 8a 50 07 30 04 29 72 09 40 aa a5 d0 c9 03 90 02 a2 a0 86 f6 a2 08 b5 ee 9d 12 d0 ca 10 f8 8d 1e d0 20 ab b2 e6 77 d0 0d\na5 66 30 09 e6 66 10 05 a0 00 4c 5c a1 4c 4b a7 48 8a 48 98 48 a9 e0 ac 0b d4 c0 60 f0 02 a9 a0 8d 09 d4 a2 04 8d 0a d4 b5 f7 9d 16 d0\nca 10 f8 ad 08 d0 0d 09 d0 0d 0a d0 0d 0b d0 85 83 ad 0f d0 85 82 68 a8 68 aa 68 40 48 a9 00 8d 0e d2 a9 40 8d 0e d2 ad 09 d2 09 c0 85\nca 68 40 99 a4 00 e8 88 10 0e 20 82 a7 a9 05 85 a2 2c 95 09 70 09 a0 02 bd f9 ba c9 fe d0 e4 60 a9 55 85 6b a5 a4 85 6e 29 7f 85 a4 a4\na5 b9 00 08 85 68 b9 64 08 85 69 a5 a6 4a 4a 85 6a a5 a6 29 03 a8 b9 b0 ba 25 6b a4 6a 11 68 91 68 24 6e 10 04 e6 a5 d0 02 e6 a6 c6 a4\nd0 d0 60 ae 5c 09 a4 a2 c0 05 b0 24 a5 a0 85 a6 b9 6e bf 0a 85 6c 90 0d a9 81 85 a4 a5 a1 85 a5 a9 aa 20 84 a7 e6 a6 a5 6c d0 e8 e6 a1\ne6 a2 60 c0 0a 90 f9 b5 e9 f0 3c bd 71 0a bc de 09 f0 08 c9 0c 90 0a a9 0b 10 06 c9 f5 b0 02 a9 f5 18 69 83 85 a0 bd a2 0a 49 ff bc 0f\n0a d0 08 c9 05 90 0a a9 04 10 06 c9 fa b0 02 a9 fa 18 69 4d 85 a1 a9 00 85 a2 a9 36 85 68 a9 1b 85 69 a2 0e a0 06 b1 68 29 55 91 68 88\n10 f7 18 a5 68 69 28 85 68 90 02 e6 69 ca 10 e7 ae 5c 09 c8 a5 88 f0 04 c6 88 d0 39 a5 a0 c9 81 90 33 c9 85 b0 2f a9 aa 8d fe 1b 8d 04\n1c a5 a1 c9 4b 90 21 c9 4f b0 1d a9 aa 8d 9e 1c 8d a4 1c bd 40 0a c9 0c b0 0e a0 a0 8c 40 1d 8c 68 1d 8c 42 1d 8c 6a 1d 84 a3 60 a4 c0\nf0 61 a5 70 c9 fe b0 5c c9 80 90 03 20 b4 a9 a9 03 8d 5c 09 a9 90 8d 8f 0c 85 ec a9 1f 8d 43 0a 38 ad fc 0b e9 77 18 65 c5 29 7f 85 8e\n38 ad 2d 0c e9 7d 18 65 c4 29 7f 85 8f a5 62 f0 11 ad 0a d2 a4 d0 f0 06 8d 2d 0c 8d fc 0b c9 10 b0 14 ad 0a d2 09 10 25 c6 8d 9a 0b ad\n0a d2 09 10 25 c6 8d cb 0b 60 98 30 11 a9 ff 85 c0 a2 00 20 a6 b3 20 a7 b1 a0 1b 4c 8d a9 c6 91 f0 05 a2 02 4c 6f b8 a0 19 20 87 a9 a5\n8f 85 8d a5 8e 85 8c 4a 29 07 aa bd b3 bf 85 c7 a4 92 84 90 a9 00 85 7b be c9 08 10 2e a9 ff 85 7b a0 00 a9 00 99 68 0b a9 01 99 af 09\nad 0a d2 25 c7 99 42 0a 98 18 69 31 a8 c9 93 90 e5 ad 42 0a 09 71 8d 42 0a a2 02 4c be b7 f0 0e a9 ff 85 8b a2 06 20 a6 b3 a0 75 20 23\nb2 60 a2 01 20 6f b8 a0 17 a9 00 85 71 85 c0 a9 10 85 79 a9 00 85 c1 85 73 85 8a 8d 8f 0c 85 80 c0 17 f0 04 85 e9 85 ea 85 eb 85 ec 85\ned 85 75 8d 5c 09 4c 23 b2 c6 c2 10 68 a9 01 85 c1 a9 30 85 79 a9 03 85 c2 a6 c3 a9 12 85 69 ad 0a d2 29 03 a8 b9 3a bb 9d 71 0a b9 3e\nbb 9d a2 0a 20 be b7 8a a8 a9 05 85 6e 18 a5 68 69 50 85 68 9d d3 0a a5 69 69 00 85 69 9d 40 0a a9 00 9d 66 0b 9d 97 0b 9d c8 0b a9 01\n9d ad 09 a9 63 9d f9 0b 9d 2a 0c 20 c1 ac ca e0 11 b0 02 a2 30 c6 6e 10 c7 86 c3 60 a9 00 85 6d a9 07 85 6e 46 6b 66 6a a5 d0 d0 0f bd\n40 0a 4a 85 69 bd d3 0a 6a 85 68 4c 52 aa 38 a9 00 fd d3 0a 85 68 a9 00 fd 40 0a 4a 85 69 66 68 06 6d 38 a5 6a e5 68 a8 a5 6b e5 69 90\n06 85 6b 84 6a e6 6d 06 6a 26 6b 90 03 a9 ff 60 c6 6e 10 df a4 6d b9 e9 0d 60 a5 c0 05 7b d0 f9 a5 86 f0 30 a6 89 38 bd f9 0b ed fc 0b\n90 02 a9 00 20 ca ae 8d cb 0b 8d cc 0b 38 ad 2d 0c fd 2a 0c 20 ca ae 8d 9a 0b 38 ad 2e 0c fd 2a 0c 20 ca ae 8d 9b 0b a2 03 d6 ba 10 27\n8a 4a a8 b9 c8 00 a4 d0 f0 05 49 ff 18 69 01 18 75 b4 10 02 a9 00 c9 10 90 02 a9 0f 95 b4 c9 08 90 02 49 0f 0a 95 ba ca 10 d2 ad 8e 0c\nd0 1b a4 62 b9 85 bf ae a4 0a 10 02 29 7f 8d ca 0b 09 80 ae 73 0a 10 02 29 7f 8d 99 0b a5 76 29 03 f0 2e a5 e6 f0 04 a5 eb d0 25 ad 0a\nd2 c9 04 b0 1e a9 60 8d 8e 0c a2 02 20 64 b7 a9 3c 85 eb a9 88 8d 68 0b a9 00 8d 2c 0c 8d 99 0b 8d ca 0b 60 a5 a7 49 01 85 a7 aa b5 e9\nd0 42 a5 e9 05 ea 29 01 a4 90 d9 c9 08 b0 ba a9 ff 95 e9 ad 0a d2 29 07 a8 b9 89 bf 9d 8c 0c a5 62 f0 03 b9 91 bf 95 a8 a9 01 95 aa 9d\nad 09 ad 0a d2 25 c7 9d a2 0a 69 13 9d 71 0a 09 71 9d 40 0a 20 be b7 bd 40 0a c9 20 b0 11 bd ad 09 f0 08 b5 e4 f0 08 c9 29 f0 04 a9 00\n95 a8 d6 aa 10 24 a9 78 95 aa a5 62 ac 0a d2 c0 30 90 01 4a 4a 95 b8 b5 a8 2c 0a d2 10 02 49 0f 95 ac e8 e8 e0 06 90 f1 a6 a7 b5 a8 d0\n32 a4 a7 c0 31 b0 13 b9 b8 00 4a b9 40 0a b0 06 c9 0a 90 0e b0 04 c9 f5 b0 04 b9 ad 09 4a a9 0f b0 02 a9 00 95 ac 18 98 69 31 a8 e8 e8\ne0 06 90 d2 a6 a7 a4 a7 b5 b2 d5 ac f0 08 b0 04 f6 b2 90 02 d6 b2 86 6a aa bd 99 bf a6 6a 99 66 0b 98 18 69 31 a8 e8 e8 e0 06 90 dc a6\na7 ad 8e 0c d0 0b a5 eb d0 06 a5 be f0 03 c6 be 60 18 bd a2 0a 69 02 c9 05 b0 f5 a0 d0 bd ad 09 4a bd 40 0a b0 08 49 ff a4 62 f0 e4 a0\n50 c9 20 b0 de 8c 68 0b a9 00 8d 8e 0c 8d 2c 0c a9 3e 85 eb a2 02 a4 a7 84 bf 4c af ac a9 80 85 73 a2 30 86 79 ad 0a d2 29 0f 79 2a 0c\ne9 30 9d 2a 0c ad 0a d2 29 0f 79 f9 0b 4a e9 10 9d f9 0b 20 af ac ad 0a d2 29 87 9d 66 0b ad 0a d2 29 87 9d 97 0b ad 0a d2 29 87 9d c8\n0b ca e0 10 d0 c5 60 b9 ad 09 9d ad 09 b9 40 0a 9d 40 0a b9 d3 0a 9d d3 0a b9 de 09 9d de 09 b9 71 0a 9d 71 0a b9 0f 0a 9d 0f 0a b9 a2\n0a 9d a2 0a b9 04 0b 9d 04 0b b9 35 0b 9d 35 0b 60 a5 7b f0 fb a5 d0 d0 05 a9 14 8d 1b d0 a9 02 8d 5c 09 a9 30 8d 8e 0c a9 20 8d 8d 0c\na9 40 8d 8c 0c a9 ff a6 90 bc c9 08 30 02 a9 00 85 e9 85 ea 85 eb 85 7b 30 0a a0 02 20 6b ac a2 0a 4c a8 ae ad 42 0a d0 0a ad d5 0a c9\n20 b0 03 ee d5 0a ad 2c 0c 38 e9 78 c9 10 b0 22 ad fb 0b 38 e9 68 c9 10 b0 18 ad 42 0a c9 02 b0 11 ad af 09 2d 11 0a 49 01 05 70 0d a4\n0a 05 71 f0 10 a5 75 c9 02 90 05 a0 1f 20 23 b2 a9 00 85 75 60 24 75 70 0d 30 42 a5 75 d0 f5 c6 75 a0 1c 4c 23 b2 a2 00 86 65 a4 d1 d0\ne6 a9 50 8d 90 0c a9 01 8d b1 09 8d e2 09 8d 13 0a 8d a6 0a 8d 9b 0b a9 10 8d 44 0a a9 00 8d 75 0a a9 87 8d 6a 0b a9 81 85 75 8d cc 0b\n85 ed 60 ad b1 09 d0 fa a2 0c 20 a6 b3 a0 21 20 23 b2 a2 05 bd 8b bb 9d 92 09 ca 10 f7 a9 89 a2 03 9d 55 09 ca 10 fa a9 07 8d 6a 0b a9\n81 8d 9b 0b a9 01 8d cc 0b 85 75 4c 7b b0 78 85 6a ad 0b d4 c9 7c 90 f9 b9 62 ba c8 10 02 a9 0d 9d 80 02 e8 c6 6a d0 f0 58 60 a9 10 85\n69 a9 00 a8 85 68 85 a3 85 7a 91 68 c8 d0 fb e6 69 a4 69 c0 20 a8 90 f2 60 a5 84 ac 10 d0 84 84 d0 0e 84 66 a6 c0 d0 08 a6 87 c9 01 f0\n03 b0 18 60 b5 ec c9 e8 b0 f9 ac 5c 09 84 89 a9 0c a4 a3 84 86 f0 02 a9 00 85 88 84 84 2c 92 09 70 e1 30 05 8a 49 01 85 87 8a 9d e1 09\nbd 73 bf 9d 74 0a a9 ff 95 ec 9d a5 0a a9 00 9d 8f 0c 9d 43 0a 9d 07 0b 9d 12 0a 9d 38 0b a9 01 9d b0 09 9d d6 0a a5 d0 4a 6a 09 66 9d\n69 0b a9 00 9d 9a 0b 9d cb 0b a2 02 20 6f b8 a2 00 8a d0 06 a5 e1 c9 18 b0 18 a0 07 bd 20 bf 99 da 00 e8 88 10 f6 bd 20 bf 8d 08 d2 bd\n21 bf 8d 04 d2 60 a0 80 b0 04 49 ff a0 00 84 6a c9 08 90 02 a9 07 a8 a5 6a 19 c9 bf 60 24 64 30 57 a6 62 ad 0a d2 dd 10 bf b0 4d 29 07\nc9 06 b0 47 aa bd 92 09 0a 30 eb a5 eb c9 1e a9 80 bc 14 bf 90 17 e0 03 d0 05 2c 96 09 70 0e e0 04 d0 05 2c 95 09 70 05 a9 c0 bc 1a bf\n1d 92 09 9d 92 09 84 65 2c 95 09 50 07 a9 00 85 7e 20 0d ae a0 52 20 23 b2 a2 12 20 a6 b3 60 a2 02 ca 10 01 60 bd 8f 0c d0 f7 b5 ec f0\nf3 b5 82 29 07 f0 ed 4a c9 03 d0 01 4a a8 b9 e9 00 f0 e1 a5 d0 f0 02 a9 ff 85 6c 59 40 0a c9 10 90 02 a9 0f 4a 84 6b a8 a5 6c 5d 43 0a\nd9 75 bf b0 c2 d9 7d bf 90 bd a4 6b 38 a9 ff f5 ec 85 e2 c9 0f 90 05 b9 8c 0c c9 80 a9 00 85 88 95 ec b0 4b 99 e9 00 b9 8c 0c f0 43 c9\n60 f0 3f a9 00 85 86 a6 90 de c9 08 10 13 a9 00 9d c9 08 38 a5 cb e9 03 85 cb a5 cc e9 00 85 cc 60 18 a5 cb 69 06 85 cb a5 cc 69 00 85\n\n3\n\nPoC GTFO\n\nСамиздат\n\na b\n\nc\n\n# #\nCut Here if Printing on A4 Cut Here if Printing on A4\n\n\n\n9 6\n\ncc\na2\n\n01\nfe\n\n50\n09\n\nbd\n50\n\n09\nc9\n\n4a\n90\n\n08\na9\n\n40\n9d\n\n50\n09\n\nca\n10\n\nee\n20\n\n6b\nac\n\na2\n7f\n\nbd\nc9\n\n08\n30\n\n02\nd0\n\n0a\nca\n\n10\nf6\n\na0\n3f\n\na2\n00\n\n20\n21\n\nb1\n60\n\na5\nca\n\nf0\n3e\n\na2\n14\n\n85\n6a\n\na9\n00\n\n85\n66\n\n85\nca\n\na9\n11\n\n8d\n1b\n\nd0\nbd\n\nbe\nba\n\nc5\n6a\n\nf0\n08\n\nca\n10\n\nf6\na0\n\n10\n4c\n\n23\nb2\n\ne0\n0a\n\nb0\n1d\n\na5\nc0\n\nf0\n03\n\n4c\n80\n\na9\n2c\n\n93\n09\n\n50\n06\n\ne0\n06\n\n90\n02\n\na2\n05\n\nbd\nd3\n\nba\n85\n\n80\nbd\n\nb4\nba\n\n85\n71\n\n60\ne0\n\n0e\nb0\n\n1b\nbd\n\n18\nbe\n\n85\nd0\n\nbc\n82\n\nba\na2\n\n02\na9\n\n08\n20\n\nf1\nad\n\na2\n10\n\n20\n64\n\nb7\nca\n\ne0\n05\n\nb0\nf8\n\n90\n1b\n\ne0\n11\n\nb0\n35\n\nbc\n18\n\nbe\nb5\n\n6e\n5d\n\n1b\nbe\n\n95\n6e\n\nf0\n03\n\nbc\n1e\n\nbe\n20\n\n23\nb2\n\na2\n0c\n\n20\na6\n\nb3\na2\n\n16\na4\n\n7c\nf0\n\n01\ne8\n\n8e\n5a\n\n09\n20\n\n0d\nae\n\na5\n7e\n\nf0\nb4\n\na6\nd0\n\nf0\n06\n\ne0\n01\n\nd0\nac\n\na2\n2a\n\n4c\n6f\n\na7\ne0\n\n11\nd0\n\n50\na5\n\nc0\nd0\n\n5a\na9\n\n7f\n85\n\nc0\na9\n\nff\n85\n\n71\na9\n\n1e\n85\n\n80\na9\n\n30\n85\n\nc3\na9\n\n00\n85\n\nc2\n8d\n\n74\n0a\n\n8d\n07\n\n0b\n8d\n\n38\n0b\n\n8d\n69\n\n0b\na9\n\n01\n8d\n\nb0\n09\n\n8d\ne1\n\n09\n8d\n\n12\n0a\n\n8d\na5\n\n0a\na5\n\n8f\n85\n\nc4\na5\n\n8e\n85\n\nc5\na5\n\n62\nf0\n\n0b\na5\n\n91\n2a\n\n2a\n2a\n\n29\n03\n\na8\nb9\n\nd7\nbe\n\n85\nc6\n\na0\n11\n\n4c\n23\n\nb2\ne0\n\n13\nb0\n\n0b\nad\n\n5c\n09\n\n49\n01\n\n29\n01\n\n8d\n5c\n\n09\n60\n\nd0\n08\n\nad\n00\n\nd3\nc9\n\nff\nf0\n\nf7\n60\n\na0\n76\n\na2\n04\n\na9\n00\n\n85\nec\n\n85\nd6\n\n85\nd1\n\n85\n8b\n\n8d\n07\n\nd2\n85\n\n71\n85\n\n81\n85\n\n7d\n85\n\nc0\n85\n\nc1\na9\n\nff\n85\n\n64\n84\n\n65\n8a\n\n05\n62\n\naa\nbd\n\ndd\nbe\n\n18\n65\n\ncb\naa\n\na9\n00\n\n85\nc9\n\n85\nc8\n\n65\ncc\n\n30\n25\n\n4a\n8a\n\n6a\n4a\n\n4a\n4a\n\nc9\n13\n\n90\n04\n\na9\n12\n\na2\n0f\n\n85\ncd\n\na8\n8a\n\nc0\n00\n\nf0\n0b\n\nc0\n0b\n\n90\n04\n\nc0\n0f\n\n90\n03\n\n4a\n49\n\n08\n29\n\n0f\n85\n\nce\n60\n\na5\nc0\n\nd0\n04\n\na5\nd0\n\n30\n01\n\n60\n2c\n\n97\n09\n\n30\n03\n\n20\nb9\n\nb4\na5\n\n72\n29\n\n01\nd0\n\n2e\n18\n\na5\n8f\n\n65\nc8\n\n29\n7f\n\n85\n8f\n\n18\n69\n\n3d\n8d\n\n2e\n0c\n\n18\na5\n\n8e\n65\n\nc9\n29\n\n7f\n85\n\n8e\n18\n\n69\n3f\n\n8d\nfd\n\n0b\na5\n\n8c\n18\n\n69\n3f\n\n8d\nfc\n\n0b\na5\n\n8d\n18\n\n69\n3d\n\n8d\n2d\n\n0c\na5\n\n8f\n4a\n\n4a\n4a\n\n85\n6a\n\na5\n8e\n\n29\n70\n\n05\n6a\n\n85\n92\n\naa\nbd\n\nc9\n08\n\n10\n02\n\na9\n00\n\n09\n90\n\n2c\n97\n\n09\n70\n\n03\n8d\n\n8d\n09\n\n38\na5\n\n8f\ne5\n\n8d\nb0\n\n04\n49\n\nff\n69\n\n01\n85\n\n6a\n38\n\na5\n8e\n\ne5\n8c\n\nb0\n04\n\n49\nff\n\n69\n01\n\n4a\n18\n\n65\n6a\n\na8\n4a\n\n4a\n4a\n\naa\n98\n\n29\n03\n\n18\n7d\n\ndd\nba\n\n85\n91\n\na8\na9\n\n10\n8d\n\n7d\n09\n\n8d\n7e\n\n09\n8d\n\n7f\n09\n\na2\n02\n\nfe\n7d\n\n09\nbd\n\n7d\n09\n\nc9\n1a\n\n90\n08\n\na9\n10\n\n9d\n7d\n\n09\nca\n\n10\nee\n\n88\nd0\n\ne9\n60\n\na5\nd1\n\nf0\n05\n\nc6\ncf\n\nf0\n10\n\n60\na4\n\n65\nf0\n\nfb\n84\n\nd1\na0\n\n23\na2\n\n0f\na9\n\n07\n20\n\nf1\nad\n\na2\n13\n\na9\n00\n\n85\n6b\n\n9d\n1f\n\n0d\nca\n\n10\nfa\n\na6\nd1\n\ne6\nd1\n\nd0\n09\n\na2\n0f\n\na0\n80\n\na9\n07\n\n4c\nf1\n\nad\nbd\n\naa\nbb\n\nc9\nfc\n\nd0\n0f\n\na4\nce\n\nb9\nfc\n\nbe\na6\n\n6b\n9d\n\n1f\n0d\n\na9\n3c\n\n85\ncf\n\n60\nc9\n\nfd\nd0\n\n05\na4\n\ncd\nb9\n\ne9\nbe\n\n85\n6c\n\n29\n3f\n\n85\n6a\n\na9\n2a\n\n85\n68\n\na9\nbc\n\n85\n69\n\ne6\n68\n\nd0\n02\n\ne6\n69\n\na0\n00\n\nb1\n68\n\n10\nf4\n\nc6\n6a\n\nd0\nf0\n\n29\n3f\n\n49\na0\n\na6\n6b\n\ne6\n6b\n\n9d\n1f\n\n0d\nc8\n\nb1\n68\n\n10\nf0\n\ne6\n6b\n\na9\n3c\n\n24\n6c\n\n10\n04\n\n50\n08\n\na9\nfe\n\n50\n96\n\na0\nff\n\n84\nd1\n\n85\ncf\n\n60\na5\n\nd6\nf0\n\n37\nc6\n\nd8\n10\n\n33\na5\n\nd9\nf0\n\n0a\na5\n\nd5\n30\n\n06\n85\n\nd8\na0\n\n00\nf0\n\n20\na5\n\nd4\n85\n\nd8\na6\n\nd2\ne6\n\nd2\nbd\n\n5c\nbf\n\n8d\n06\n\nd2\na0\n\na8\nc9\n\nff\nd0\n\n0c\na5\n\nd7\n85\n\nd2\nc6\n\nd3\n10\n\ne4\na0\n\n00\n84\n\nd6\n8c\n\n07\nd2\n\n84\nd9\n\na5\ne2\n\nf0\n09\n\nc6\ne2\n\nd0\n05\n\na2\n14\n\n20\na8\n\nae\na6\n\n70\n8a\n\n4a\n4a\n\n4a\n4a\n\n4a\nc5\n\ne1\n90\n\n2c\na9\n\n00\n85\n\ne1\ne8\n\n8a\n49\n\nff\n8d\n\n04\nd2\n\naa\n0a\n\n0a\n0a\n\n0a\n0a\n\n8d\n00\n\nd2\n8a\n\n4a\n4a\n\n4a\n8d\n\n02\nd2\n\n4a\n49\n\n8f\n8d\n\n03\nd2\n\n29\n87\n\n8d\n05\n\nd2\na9\n\n70\n8d\n\n08\nd2\n\n60\na5\n\ndb\nf0\n\n08\nc6\n\ndb\nd0\n\n04\na9\n\n8f\n85\n\ndc\na6\n\nda\nf0\n\n1c\nc6\n\nda\nd0\n\n0a\na9\n\naf\n85\n\ndc\na9\n\n02\n85\n\nde\n85\n\ndf\nbd\n\nea\nbf\n\n85\ndd\n\nbd\nf2\n\nbf\n8d\n\n04\nd2\n\n8d\n09\n\nd2\na5\n\ne3\nf0\n\n0e\nc6\n\ne3\nad\n\n0a\nd2\n\n8d\n04\n\nd2\n29\n\n20\n45\n\ndd\n85\n\ndd\n18\n\na5\nde\n\n65\ne0\n\n85\nde\n\n8d\n00\n\nd2\na5\n\ndf\n69\n\n00\n85\n\ndf\n8d\n\n02\nd2\n\na6\ndc\n\na4\ndd\n\na5\n72\n\n4a\n90\n\n1a\na5\n\ne1\nf0\n\n16\nc6\n\ne1\nc9\n\n11\nb0\n\n10\n8a\n\n29\n0f\n\nf0\n03\n\nca\n86\n\ndc\n98\n\n29\n0f\n\nf0\n03\n\n88\n84\n\ndd\n8e\n\n03\nd2\n\n8c\n05\n\nd2\n60\n\nbd\n3e\n\nbf\nc5\n\nd6\n90\n\n0c\na0\n\n05\nbd\n\n3e\nbf\n\n99\nd2\n\n00\ne8\n\n88\n10\n\nf6\n60\n\na2\n59\n\na9\n0d\n\n9d\n85\n\n02\ne0\n\n0a\nb0\n\n05\nbd\n\na9\nbf\n\n95\nf2\n\nca\n10\n\nef\na9\n\n70\n8d\n\n80\n02\n\n8d\n81\n\n02\na9\n\n41\n8d\n\ne7\n02\n\na9\n80\n\n8d\ne8\n\n02\na9\n\n02\n8d\n\ne9\n02\n\na2\n00\n\n86\n68\n\n86\n69\n\n86\n6a\n\n86\n6b\n\n18\na5\n\n68\n69\n\n51\n85\n\n68\na5\n\n69\n9d\n\ne9\n0d\n\n69\n00\n\n85\n69\n\n18\na5\n\n6a\n69\n\n64\n85\n\n6a\na5\n\n6b\n9d\n\ne9\n0e\n\nf8\n69\n\n00\nd8\n\n85\n6b\n\ne8\nd0\n\ndb\na2\n\n00\n86\n\n68\na9\n\n10\n85\n\n69\n18\n\na5\n68\n\n9d\n00\n\n08\n69\n\n28\n85\n\n68\na5\n\n69\n9d\n\n64\n08\n\n69\n00\n\n85\n69\n\nbd\n42\n\nbb\n9d\n\n49\n09\n\ne8\ne0\n\n64\n90\n\ne2\nca\n\n86\n78\n\na2\n03\n\n8e\n11\n\n09\nbd\n\na6\nbb\n\n85\n6a\n\na4\n62\n\nc8\nc8\n\n84\n6b\n\nad\n0a\n\nd2\n29\n\n7f\na8\n\nb9\nc9\n\n08\nd0\n\nf5\na5\n\n6a\n10\n\n21\nc0\n\n10\n90\n\ned\nc0\n\n70\nb0\n\ne9\n98\n\n29\n0f\n\nf0\ne4\n\nc9\n0f\n\nf0\ne0\n\nb9\nc8\n\n08\n19\n\nca\n08\n\n19\nd9\n\n08\n19\n\nb9\n08\n\nd0\nd2\n\na5\n6a\n\n99\nc9\n\n08\nc6\n\n6b\n10\n\nc9\nca\n\n10\nbb\n\na2\nb4\n\na9\n0a\n\n9d\n34\n\n0d\nca\n\nd0\nf8\n\na2\n0f\n\na9\n18\n\n9d\n37\n\n0d\nca\n\n10\nf8\n\na9\n1a\n\n8d\n47\n\n0d\na9\n\n00\n8d\n\n11\n09\n\na9\n48\n\n85\n90\n\na9\n43\n\n85\n8d\n\n85\n8f\n\na9\n47\n\n85\n8e\n\n85\n8c\n\na9\nea\n\n8d\ne8\n\n0f\na0\n\n00\n84\n\n6a\na6\n\n6a\nbd\n\nc9\n08\n\n10\n02\n\na9\n05\n\naa\nbd\n\nd1\nbe\n\n99\n4b\n\n0d\nc8\n\ne6\n6a\n\na5\n6a\n\n29\n0f\n\nd0\ne7\n\na9\n19\n\n99\n4b\n\n0d\nc8\n\nc8\nc8\n\nc8\nc0\n\na0\n90\n\nda\n60\n\ne6\n76\n\na2\n90\n\na5\n76\n\n10\n09\n\nac\n55\n\n09\nc0\n\n80\nd0\n\n02\na2\n\n44\n29\n\n03\n85\n\n72\nd0\n\n1f\na4\n\n7d\nf0\n\n17\na0\n\na0\n2c\n\n94\n09\n\n10\n0b\n\n70\n07\n\nad\n0a\n\nd2\nc9\n\nc8\n90\n\n07\na0\n\n00\n98\n\nd0\n02\n\na2\n26\n\n84\n81\n\n86\nfb\n\na2\n02\n\nbd\n8e\n\n0c\nd0\n\n06\nb5\n\neb\nf0\n\n02\nd6\n\neb\nca\n\n10\nf2\n\na5\n73\n\nf0\n16\n\nc6\n73\n\nd0\n04\n\na2\n11\n\n86\n79\n\nc9\n70\n\nb0\n04\n\na2\n00\n\n86\n8a\n\nc9\n18\n\nb0\n02\n\nc6\n79\n\nc6\n74\n\n10\n21\n\na9\n28\n\n85\n74\n\na2\n04\n\nfe\na3\n\n09\nbd\n\na3\n09\n\nc9\nda\n\n90\n0d\n\na9\nd0\n\n9d\na3\n\n09\ne0\n\n03\nd0\n\n01\nca\n\nca\n10\n\ne9\nc6\n\n78\n30\n\n01\n60\n\na9\n31\n\n85\n78\n\na5\ncb\n\nd0\n02\n\nc6\ncc\n\nc6\ncb\n\na6\n64\n\nd0\nef\n\n86\n6a\n\nbd\nc9\n\n08\n10\n\n19\n20\n\nf1\nb7\n\nf0\n14\n\na9\n02\n\n9d\nc9\n\n08\n85\n\n6a\n38\n\na5\ncb\n\ne9\n12\n\n85\ncb\n\na5\ncc\n\ne9\n00\n\n85\ncc\n\ne8\n10\n\ndf\na5\n\n6a\nf0\n\n0f\n2c\n\n97\n09\n\n70\n0a\n\na0\n15\n\n20\n23\n\nb2\na2\n\n18\n20\n\na6\nb3\n\nc6\n9f\n\n30\n07\n\na6\n93\n\nbd\nc9\n\n08\n30\n\n1f\na9\n\n07\n85\n\n9f\na0\n\n7f\nad\n\n0a\nd2\n\n29\n7f\n\naa\nbd\n\nc9\n08\n\n30\n0e\n\n88\n10\n\nf2\na2\n\n7f\nbd\n\nc9\n08\n\n30\n04\n\nca\n10\n\nf8\n60\n\n86\n93\n\n8a\n29\n\n0f\n85\n\n94\n8a\n\n4a\n4a\n\n4a\n4a\n\n85\n95\n\na2\nff\n\ne8\n10\n\n30\na2\n\n00\nbd\n\nc9\n08\n\n29\ndf\n\n9d\nc9\n\n08\ne8\n\n10\nf5\n\n2c\n97\n\n09\n70\n\n1d\na2\n\n00\nbd\n\nc9\n08\n\n10\n13\n\n20\nf1\n\nb7\nf0\n\n0e\na9\n\n63\n85\n\n78\na0\n\n13\n20\n\n23\nb2\n\na2\n18\n\n4c\na6\n\nb3\ne8\n\n10\ne5\n\n60\nbc\n\nc9\n08\n\nc0\n0a\n\nb0\nc6\n\nad\n0a\n\nd2\nd9\n\nbb\nbf\n\nb0\nbe\n\ne4\n90\n\nf0\nba\n\na0\n08\n\n18\n8a\n\n79\nc0\n\nbf\n85\n\n6a\n29\n\n0f\n38\n\ne5\n94\n\nb0\n04\n\n49\nff\n\n69\n01\n\n85\n6b\n\na5\n6a\n\n4a\n4a\n\n4a\n4a\n\n38\ne5\n\n95\nb0\n\n04\n49\n\nff\n69\n\n01\n18\n\n65\n6b\n\n99\n96\n\n00\n88\n\n10\nd4\n\na9\n01\n\n85\n6b\n\na0\n07\n\nb9\n96\n\n00\nc5\n\n9e\nb0\n\n24\n18\n\n8a\n79\n\nc0\nbf\n\n30\n1d\n\n84\n6a\n\na8\nb9\n\nc9\n08\n\nd0\n13\n\nbd\nc9\n\n08\nc4\n\n90\nf0\n\n0c\n09\n\n20\n99\n\nc9\n08\n\na9\n00\n\n9d\nc9\n\n08\nf0\n\n0b\na4\n\n6a\n88\n\n10\nd2\n\ne6\n9e\n\nc6\n6b\n\n10\nca\n\n4c\nea\n\nb5\nbd\n\nad\n09\n\n49\n01\n\nf0\n02\n\na9\nff\n\n85\n6b\n\n85\n6c\n\nbd\n40\n\n0a\n85\n\n6a\nad\n\n0a\nd2\n\n09\nbf\n\n5d\nd3\n\n0a\n0a\n\n26\n6a\n\n26\n6b\n\n0a\n26\n\n6a\n26\n\n6b\na5\n\n6d\n49\n\nff\n85\n\n6d\n30\n\n1a\n18\n\nb9\nd3\n\n0a\n65\n\n6a\n99\n\nd3\n0a\n\nb9\n40\n\n0a\n65\n\n6b\n99\n\n40\n0a\n\nb9\nad\n\n09\n65\n\n6c\n99\n\nad\n09\n\n60\n38\n\nb9\nd3\n\n0a\ne5\n\n6a\n99\n\nd3\n0a\n\nb9\n40\n\n0a\ne5\n\n6b\n99\n\n40\n0a\n\nb9\nad\n\n09\ne5\n\n6c\n99\n\nad\n09\n\n60\nc9\n\n50\nb0\n\n5b\n85\n\n6d\na9\n\n50\ne0\n\n05\nb0\n\n02\na9\n\n7d\nbc\n\nde\n09\n\nd0\n09\n\n38\ne6\n\n6d\ne5\n\n6d\n9d\n\n2a\n0c\n\n60\n18\n\n65\n6d\n\n9d\n2a\n\n0c\n60\n\nc9\n32\n\nb0\n38\n\n85\n6d\n\na9\n32\n\ne0\n05\n\nb0\n04\n\n06\n6d\n\na9\n7a\n\n24\nd0\n\n50\n13\n\n2c\n96\n\n09\n10\n\n07\n2c\n\n0a\nd2\n\n50\n0e\n\n70\n15\n\nbc\nad\n\n09\nd0\n\n07\nf0\n\n0e\nbc\n\n0f\n0a\n\nf0\n09\n\n38\ne6\n\n6d\ne5\n\n6d\n9d\n\nf9\n0b\n\n60\n18\n\n65\n6d\n\n9d\nf9\n\n0b\n60\n\ne0\n05\n\nb0\n06\n\na9\nfb\n\n9d\nf9\n\n0b\n60\n\na9\n63\n\n9d\nf9\n\n0b\n9d\n\n2a\n0c\n\ne0\n11\n\nb0\nf3\n\nad\n0a\n\nd2\n29\n\n0f\n85\n\n6a\n9d\n\na2\n0a\n\nad\n0a\n\nd2\n29\n\n0f\nc5\n\n6a\n90\n\n02\n85\n\n6a\n9d\n\n71\n0a\n\na9\n0f\n\n9d\n40\n\n0a\na5\n\nd0\n49\n\n01\n29\n\n01\n9d\n\nad\n09\n\nd0\n11\n\n9d\n04\n\n0b\n9d\n\n35\n0b\n\n38\ne5\n\n6a\n9d\n\n40\n0a\n\na9\n80\n\n9d\nd3\n\n0a\n24\n\nd0\n50\n\n11\nad\n\n0a\nd2\n\n9d\n71\n\n0a\nad\n\n0a\nd2\n\n9d\n40\n\n0a\n29\n\n01\n9d\n\nad\n09\n\nad\n0a\n\nd2\n29\n\n01\n9d\n\n0f\n0a\n\nd0\n0f\n\n38\nfd\n\n35\n0b\n\n9d\n35\n\n0b\na9\n\n00\nfd\n\na2\n0a\n\n9d\na2\n\n0a\nad\n\n0a\nd2\n\n29\n01\n\n9d\nde\n\n09\nd0\n\n0f\n38\n\nfd\n04\n\n0b\n9d\n\n04\n0b\n\na9\n00\n\nfd\n71\n\n0a\n9d\n\n71\n0a\n\n60\nbd\n\nc8\n08\n\nf0\n0d\n\nbd\n\nca\n08\n\nf0\n08\n\nbd\nb9\n\n08\nf0\n\n03\nbd\n\nd9\n08\n\n60\na6\n\n70\ne4\n\n71\nf0\n\n08\n90\n\n04\nc6\n\n70\nb0\n\n12\ne6\n\n70\na5\n\nc0\nd0\n\n0c\n2c\n\n93\n09\n\n10\n07\n\na5\n71\n\n2d\n0a\n\nd2\n85\n\n70\na0\n\n01\n20\n\ncd\nb8\n\n2c\n95\n\n09\n30\n\n30\na9\n\n31\na0\n\n17\n20\n\na7\nb8\n\na9\n62\n\na0\n1d\n\n20\na7\n\nb8\na9\n\n00\na0\n\n23\n20\n\na7\nb8\n\nad\n6e\n\n09\n8d\n\n6f\n09\n\nc9\n0a\n\nb0\n11\n\nae\n5c\n\n09\nbd\n\nd3\n0a\n\n4a\n4a\n\n4a\n4a\n\naa\nbd\n\ne9\n0e\n\n8d\n6f\n\n09\n18\n\na5\n7f\n\n65\n7d\n\n65\n80\n\n65\n7e\n\n69\n01\n\nc5\n7f\n\n85\n7f\n\nb0\n39\n\na2\n03\n\n24\n64\n\n70\n33\n\nde\n55\n\n09\nbd\n\n55\n09\n\nc9\n80\n\nb0\n29\n\na9\n89\n\n9d\n55\n\n09\ne0\n\n02\nd0\n\n08\na5\n\ncb\nd0\n\n02\nc6\n\ncc\nc6\n\ncb\nca\n\n10\nde\n\na2\n0a\n\n8a\na0\n\n03\n99\n\n55\n09\n\n88\n10\n\nfa\n20\n\n45\nb0\n\na0\n31\n\na2\n04\n\n20\n0a\n\nb1\n60\n\n18\n6d\n\n5c\n09\n\naa\na9\n\n10\n85\n\n6a\nbd\n\nad\n09\n\n4a\nbd\n\n40\n0a\n\nb0\n04\n\n49\nff\n\nc6\n6a\n\naa\na5\n\n6a\n99\n\n49\n09\n\n98\n29\n\n10\nf0\n\n05\ne0\n\nff\nd0\n\n01\nca\n\nbd\ne9\n\n0e\naa\n\n29\n0f\n\n99\n4b\n\n09\n8a\n\n4a\n4a\n\n4a\n4a\n\n99\n4a\n\n09\n60\n\n00\n01\n\n02\n03\n\n07\n00\n\n18\n3c\n\n7e\n7e\n\n76\nf7\n\ndf\ndf\n\nff\nff\n\nf7\n76\n\n7e\n7e\n\n3c\n18\n\n10\n38\n\n7c\n7c\n\nfe\nde\n\nda\nfa\n\nee\nee\n\n7c\n7c\n\n38\n10\n\n18\n3c\n\n3c\n7e\n\n6e\n7a\n\n7e\n76\n\n7e\n3c\n\n3c\n18\n\n10\n38\n\n38\n7c\n\n74\n7c\n\n6c\n38\n\n38\n10\n\n10\n18\n\n3c\n2c\n\n3c\n3c\n\n18\n08\n\n10\n38\n\n38\n28\n\n38\n10\n\n3c\n3c\n\n24\n3c\n\n7e\n7e\n\n7e\n5a\n\nff\nff\n\n42\n42\n\n42\n42\n\n42\n42\n\n1c\n1c\n\n14\n3e\n\n3e\n3e\n\n2a\n7f\n\n7f\n22\n\n22\n22\n\n22\n22\n\n18\n18\n\n3c\n3c\n\n3c\n3c\n\n7e\n24\n\n24\n24\n\n24\n10\n\n10\n38\n\n38\n38\n\n7c\n28\n\n28\n28\n\n18\n18\n\n3c\n18\n\n18\n10\n\n10\n38\n\n10\n18\n\n7e\nff\n\nff\nff\n\nff\nff\n\ne7\ne7\n\nff\nff\n\nff\nff\n\nff\n7e\n\n7e\n00\n\n18\n3c\n\n7e\nff\n\nff\nff\n\ne7\n66\n\nff\nff\n\nff\nff\n\n7e\n7e\n\n00\n18\n\n3c\n7e\n\nff\nff\n\ne7\n66\n\nff\nff\n\nff\nff\n\n3c\n18\n\n3c\nff\n\nff\ne7\n\n66\nff\n\nff\n7e\n\n3c\n00\n\n18\n3c\n\nff\nff\n\nff\n3c\n\n18\n18\n\n3c\nff\n\n3c\n18\n\n28\n28\n\n28\n28\n\nee\n00\n\n00\nee\n\n28\n28\n\n28\n28\n\n00\n81\n\n81\n81\n\n81\nbd\n\nff\nff\n\nbd\n81\n\n81\n81\n\n81\n82\n\n82\nba\n\nfe\nfe\n\nba\n82\n\n82\n42\n\n5a\n7e\n\n7e\n5a\n\n42\n44\n\n54\n7c\n\n7c\n54\n\n44\n24\n\n3c\n3c\n\n24\n28\n\n38\n38\n\n28\n18\n\n18\n10\n\n10\ne0\n\nf8\nf8\n\nfe\n57\n\nfe\nf8\n\nf8\nc0\n\nc0\nf0\n\nc0\nf0\n\nf0\nfc\n\nbe\nfc\n\nf0\n80\n\n80\nc0\n\nc0\nf0\n\nbc\nf0\n\nc0\n07\n\n1f\n1f\n\n7f\nea\n\n7f\n1f\n\n1f\n03\n\n03\n0f\n\n03\n0f\n\n0f\n3f\n\n7d\n3f\n\n0f\n01\n\n01\n03\n\n03\n0f\n\n3d\n0f\n\n03\n18\n\n3c\n7e\n\n7e\ndb\n\nc3\n81\n\n81\n81\n\n10\n38\n\n7c\n7c\n\nd6\nc6\n\n82\n82\n\n18\n3c\n\n3c\n66\n\n66\n42\n\n42\n10\n\n38\n38\n\n6c\n44\n\n44\n18\n\n3c\n24\n\n24\n10\n\n38\n28\n\n18\n3c\n\n7e\nff\n\n18\n18\n\nff\n7e\n\n3c\n18\n\n10\n38\n\n7c\nfe\n\n38\n38\n\nfe\n7c\n\n38\n10\n\n18\n3c\n\n7e\n18\n\n7e\n3c\n\n18\n10\n\n38\n7c\n\n10\n7c\n\n38\n10\n\n18\n3c\n\n18\n3c\n\n18\n10\n\n38\n38\n\n10\n8d\n\n00\n46\n\n49\n09\n\n20\n06\n\n00\n01\n\n2e\na1\n\n00\n00\n\n46\nf8\n\na0\n4d\n\nc8\n10\n\n00\n00\n\n46\n09\n\na1\n4d\n\nc8\n10\n\n4d\n00\n\n10\n0d\n\n0d\n0d\n\n0d\n0d\n\n30\n46\n\n1f\n0d\n\n4d\na8\n\n12\n1b\n\n13\n0b\n\n08\nff\n\nff\nff\n\nff\naa\n\nff\naa\n\nff\naa\n\naa\naa\n\nff\naa\n\naa\naa\n\naa\naa\n\naa\naa\n\n55\n55\n\naa\n55\n\naa\n55\n\n55\n55\n\naa\n55\n\n55\n55\n\n55\nc0\n\n30\n0c\n\n03\n00\n\n01\n02\n\n04\n08\n\n10\n20\n\n40\n60\n\n70\nf2\n\ndf\nde\n\nda\nd8\n\ndd\ndb\n\nf3\nf5\n\nf0\nf8\n\nff\nc0\n\nfd\ned\n\nfe\nd2\n\nf9\ne5\n\nca\ne7\n\n00\n04\n\n06\n08\n\n0a\n0c\n\n0e\n1e\n\n2d\n3c\n\n0a\n0d\n\n10\n14\n\n17\n32\n\n46\n50\n\n5a\n78\n\n7d\n82\n\n87\n8c\n\n9b\naa\n\nb8\nc8\n\nd0\nd8\n\ndf\ne8\n\nf1\nfa\n\n00\n01\n\nff\n00\n\n50\n28\n\n87\n50\n\n36\n87\n\n77\n46\n\n1e\n77\n\n56\n1e\n\n77\n46\n\n91\n94\n\n46\n91\n\n78\n4e\n\n06\n7e\n\n4b\n0f\n\n7e\n51\n\n0f\n8d\n\n4e\n07\n\n85\n47\n\n84\n7e\n\n4c\n85\n\n8c\n4c\n\n85\n85\n\n52\n84\n\n3e\n32\n\n0f\n54\n\n32\n0f\n\nfe\n4e\n\n35\n82\n\n4f\n34\n\n82\n50\n\n32\n85\n\n51\n34\n\n82\n52\n\n35\n82\n\nfe\n04\n\n04\n03\n\n02\n02\n\n03\n04\n\n04\n12\n\n0b\n00\n\n00\n0a\n\n55\n4b\n\n40\n40\n\n0a\n8d\n\n8b\n89\n\n89\n89\n\n89\n0a\n\n16\n0b\n\n00\n0a\n\n14\n0b\n\n0f\n00\n\n00\n0a\n\n51\n4b\n\n0f\n00\n\n00\n0a\n\n93\n8b\n\n0f\n00\n\n00\n00\n\n0a\n37\n\n21\n32\n\n30\n00\n\n25\n2e\n\n25\n32\n\n27\n39\n\n1a\n00\n\n00\n00\n\n10\n00\n\n00\n00\n\n00\nb4\n\na1\nb2\n\na7\na5\n\nb4\nb3\n\n9a\n00\n\n00\n24\n\n23\n1a\n\n30\n25\n\n33\n23\n\n2c\n32\n\n00\nf3\n\nf4\ne1\n\nf2\n00\n\ne4\ne1\n\nf4\ne5\n\nda\nd0\n\nd0\nce\n\nd0\nd0\n\n00\n00\n\n00\n00\n\n00\ncf\n\n04\n03\n\n02\n00\n\n05\n06\n\n42\n05\n\n06\n43\n\n04\n42\n\n04\n43\n\n06\n07\n\n42\n07\n\n43\n48\n\n09\n4a\n\n0b\ncd\n\n0b\ncc\n\n09\n4e\n\n09\n4f\n\nd0\n11\n\n92\n56\n\n13\n4e\n\n15\n4f\n\nb8\n97\n\n99\n98\n\n8c\n9d\n\n1e\n9f\n\nfd\n25\n\nfc\n78\n\n9b\n60\n\nb8\n97\n\n98\n1a\n\n8e\n1c\n\n94\n24\n\n9f\nfd\n\n25\nfc\n\na7\n68\n\nb8\n97\n\n98\n1a\n\n8f\n24\n\n9f\nfd\n\n25\nfc\n\n66\n2c\n\n5a\n2e\n\n5a\n31\n\n5a\n33\n\n5a\nb8\n\n34\n76\n\n37\nb5\n\n78\n37\n\n8c\n78\n\n23\nb5\n\n78\n23\n\n8c\n78\n\n04\nb5\n\n78\n04\n\n8c\n78\n\n06\nb5\n\n78\n06\n\n8c\n78\n\na2\n75\n\na2\n4c\n\na1\n75\n\na1\n4c\n\nc1\nb8\n\n97\n98\n\n1a\n8e\n\n24\n9f\n\nfd\n25\n\nfc\n66\n\na0\n20\n\n20\n20\n\n20\n52\n\n45\n44\n\n20\n41\n\n4c\n45\n\n52\n54\n\ncf\n4e\n\ncf\n46\n\n46\nd3\n\n48\n49\n\n45\n4c\n\n44\n53\n\nc1\n54\n\n54\n41\n\n43\n4b\n\nc3\n4f\n\n4d\n50\n\n55\n54\n\n45\n52\n\nd4\n52\n\n41\n43\n\n4b\n49\n\n4e\n47\n\nd7\n48\n\n41\n54\n\n53\n20\n\n57\n52\n\n4f\n4e\n\n47\n3f\n\nc8\n59\n\n50\n45\n\n52\n57\n\n41\n52\n\n50\nc5\n\n4e\n47\n\n41\n47\n\n45\n44\n\nd3\n54\n\n41\n52\n\n42\n41\n\n53\n45\n\nc4\n45\n\n53\n54\n\n52\n4f\n\n59\n45\n\n44\nd3\n\n55\n52\n\n52\n4f\n\n55\n4e\n\n44\n45\n\n44\nc1\n\n42\n4f\n\n52\n54\n\n45\n44\n\nc3\n4f\n\n4d\n50\n\n4c\n45\n\n54\n45\n\nc8\n59\n\n50\n45\n\n52\n53\n\n50\n41\n\n43\n45\n\ncf\n52\n\n42\n49\n\n54\nc5\n\n53\n54\n\n41\n42\n\n4c\n49\n\n53\n48\n\n45\n44\n\nc4\n4f\n\n43\n4b\n\n49\n4e\n\n47\nc5\n\n4e\n45\n\n52\n47\n\n59\nd4\n\n52\n41\n\n4e\n53\n\n46\n45\n\n52\nd3\n\n54\n41\n\n4e\n44\n\n42\n59\n\nd3\n54\n\n41\n52\n\n20\n46\n\n4c\n45\n\n45\n54\n\n20\n54\n\n4f\nd3\n\n54\n41\n\n52\n20\n\n43\n52\n\n55\n49\n\n53\n45\n\n52\n20\n\n37\nc1\n\n4c\n4c\n\n20\n55\n\n4e\n49\n\n54\n53\n\ncd\n49\n\n53\n53\n\n49\n4f\n\n4e\na0\n\n20\n20\n\n20\n53\n\n54\n41\n\n52\n20\n\n52\n41\n\n49\n44\n\n45\n52\n\n53\nda\n\n45\n52\n\n4f\nc2\n\n59\n20\n\n5a\n59\n\n4c\n4f\n\n4e\n20\n\n46\n49\n\n52\n45\n\nd0\n4f\n\n53\n54\n\n48\n55\n\n4d\n4f\n\n55\n53\n\nd2\n41\n\n4e\n4b\n\n20\n49\n\n53\n3a\n\nc3\n4f\n\n50\n59\n\n52\n49\n\n47\n48\n\n54\n20\n\n41\n54\n\n41\n52\n\n49\n20\n\n31\n39\n\n37\n39\n\nd3\n55\n\n42\n2d\n\n53\n50\n\n41\n43\n\n45\n20\n\n52\n41\n\n44\n49\n\n4f\nd3\n\n45\n43\n\n54\n4f\n\n52\n20\n\n53\n43\n\n41\n4e\n\nc5\n4e\n\n47\n49\n\n4e\n45\n\n53\nce\n\n45\n57\n\nc3\n4c\n\n41\n53\n\n53\nc3\n\n4f\n4e\n\n47\n52\n\n41\n54\n\n55\n4c\n\n41\n54\n\n49\n4f\n\n4e\n53\n\nd2\n45\n\n50\n4f\n\n52\n54\n\n20\n54\n\n4f\n20\n\n42\n41\n\n53\n45\n\nc6\n4f\n\n52\n20\n\n54\n52\n\n41\n49\n\n4e\n49\n\n4e\n47\n\nc7\n41\n\n4c\n41\n\n43\n54\n\n49\n43\n\n20\n43\n\n4f\n4f\n\n4b\nc7\n\n41\n52\n\n42\n41\n\n47\n45\n\n20\n53\n\n43\n4f\n\n57\n20\n\n43\n41\n\n50\n54\n\n41\n49\n\n4e\nd2\n\n4f\n4f\n\n4b\n49\n\n45\nce\n\n4f\n56\n\n49\n43\n\n45\nc5\n\n4e\n53\n\n49\n47\n\n4e\nd0\n\n49\n4c\n\n4f\n54\n\nc1\n43\n\n45\ncc\n\n49\n45\n\n55\n54\n\n45\n4e\n\n41\n4e\n\n54\nd7\n\n41\n52\n\n52\n49\n\n4f\n52\n\nc3\n41\n\n50\n54\n\n41\n49\n\n4e\nc3\n\n4f\n4d\n\n4d\n41\n\n4e\n44\n\n45\n52\n\nc4\n41\n\n4d\n41\n\n47\n45\n\nc4\n41\n\n4d\n41\n\n47\n45\n\n44\nc3\n\n4f\n4e\n\n54\n52\n\n4f\n4c\n\nd0\n48\n\n4f\n54\n\n4f\n4e\n\n53\na0\n\nd3\n54\n\n41\n52\n\n20\n43\n\n4f\n4d\n\n4d\n41\n\n4e\n44\n\n45\n52\n\n80\n00\n\n01\n40\n\n80\n0e\n\n09\n04\n\nff\n08\n\n02\n0b\n\n07\n01\n\n01\n11\n\n1f\n2b\n\n35\n3d\n\n75\n7a\n\n01\n0d\n\n15\n1b\n\n21\n25\n\n29\n2b\n\n2d\n38\n\n41\n36\n\n36\n00\n\n00\n00\n\n7e\n8e\n\n9d\naa\n\nb4\nbc\n\n7b\n7a\n\n47\n52\n\n5b\n50\n\n50\n00\n\n00\n00\n\n43\n53\n\n61\n6c\n\n75\n7a\n\n75\n7a\n\n01\n11\n\n1f\n2b\n\n35\n3d\n\n75\n7a\n\n61\n6a\n\n72\n79\n\n7f\n83\n\n29\n2b\n\n86\n90\n\n9a\na1\n\na8\nad\n\n29\n2b\n\nc1\nc1\n\nc1\nc1\n\nc1\nc1\n\n75\nc1\n\n0f\n0d\n\n0b\n09\n\n07\n05\n\n01\n01\n\n0b\n07\n\n05\n05\n\n03\n03\n\n01\n01\n\n09\n08\n\n05\n02\n\n00\n00\n\n00\n00\n\n0f\n0e\n\n0c\n09\n\n07\n04\n\n02\n01\n\n09\n08\n\n05\n02\n\n00\n00\n\n00\n00\n\n0f\n0d\n\n0a\n08\n\n04\n03\n\n01\n01\n\n0f\n0d\n\n0b\n09\n\n07\n05\n\n01\n01\n\n08\n07\n\n06\n05\n\n03\n02\n\n01\n01\n\n09\n09\n\n06\n06\n\n04\n03\n\n01\n01\n\n0b\n0b\n\n0b\n0b\n\n0b\n0b\n\n01\n0b\n\nf8\nff\n\n0c\n1e\n\n1e\n1d\n\n1c\n1b\n\n9f\nbf\n\ndf\nff\n\nf8\n08\n\n50\n4c\n\n3c\n6f\n\n3c\n3c\n\n32\n64\n\n28\n32\n\n28\n5a\n\na9\naa\n\naa\nab\n\nab\nac\n\nac\nad\n\nad\nae\n\nae\naf\n\nb0\nb1\n\nb2\nb3\n\nb3\nb9\n\nb9\n95\n\n95\n95\n\n94\n94\n\n94\n94\n\n93\n93\n\n93\n92\n\n92\n92\n\n91\n91\n\n91\n4a\n\n4c\n4e\n\n50\n00\n\n50\nb4\n\nfe\n55\n\n5b\n61\n\n67\n6d\n\n71\n58\n\n5e\n64\n\n6a\n6f\n\n73\n18\n\nff\n02\n\n00\n8a\n\na0\n00\n\n08\n50\n\n00\n40\n\n40\n01\n\n03\n88\n\naf\n08\n\n00\n50\n\n04\n30\n\n40\n01\n\n03\n84\n\na8\n04\n\n00\n50\n\n04\n02\n\n02\n02\n\n03\n0c\n\n02\n04\n\n03\nff\n\n10\n07\n\n04\n07\n\n04\n02\n\n02\n00\n\n07\n0b\n\n05\nff\n\n20\n02\n\n0b\n0e\n\n06\n08\n\n20\n00\n\n0e\n10\n\nff\n18\n\nff\n40\n\n60\nff\n\n10\n10\n\n10\nff\n\n40\n20\n\nff\n48\n\n40\n51\n\nff\n84\n\nb4\nfc\n\nb4\n84\n\nff\n01\n\n0c\n0c\n\n0c\n0c\n\n0e\n0e\n\n0e\n20\n\n00\n00\n\n00\n02\n\n04\n06\n\n08\n0c\n\n81\n84\n\n88\n94\n\n80\n10\n\n10\n10\n\n70\n70\n\n70\n10\n\n04\n04\n\n00\n00\n\n00\n01\n\n00\n00\n\n3e\n1e\n\n10\n08\n\n04\n02\n\n01\n00\n\n00\n81\n\n82\n84\n\n88\n90\n\n9e\nbe\n\na6\naa\n\naf\n00\n\n00\nb8\n\n5a\nfc\n\n5e\n90\n\nff\nff\n\n3f\n0f\n\n3f\n7f\n\nff\nff\n\n00\nff\n\nff\nc0\n\n20\nf0\n\nef\nff\n\n0f\n10\n\n11\n01\n\nf1\n00\n\n00\n08\n\n10\n18\n\n28\n30\n\n38\n40\n\n50\n00\n\n20\n20\n\n20\n00\n\na0\n00\n\n00\n9f\n\n0e\n0e\n\n0e\n0c\n\n0c\n0c\n\n0a\n0a\n\n0a\n08\n\n08\n08\n\n06\n06\n\n04\n04\n\n8a\n8f\n\n8d\n8b\n\n89\n87\n\n85\n83\n\n00\n04\n\n01\n04\n\n01\n04\n\n01\n04\n\n07\n00\n\n80\n4a\n\na1\n\n!7 # 8\n\nGTFO\n\n!\n\n5\n\n#\n\n4PoC\n\n\n\n23\n\nManhattan Punch Line Theatre\n\nSteve Kaplan Mitch McGuire Richard Erickson Jerry Heymann\nProducing Directors\npresents\n\na new play\nby\nMike Eisenberg\n\nHACKERS\n\nDirected by Jerry Heymann\n\n} The Story of\na Boy\n\nand\nhis Machine\n\nManhattan Punch Line\nat the Lion Theatre\nYce West Yend Street\non theatre Row\n\n23\n\n\n\n\n3 How Slow Can You Go?\nby James Forshaw\n\nWhile doing my research into Windows, I tend to\nfind quite a few race condition vulnerabilities. Al-\nthough these vulnerabilities can be exploited, you\ntypically only get a tiny window of time in which\nto do it. A fairly typical sequence of actions looks\nsomething like this:\n\n1. Do some security check.\n\n2. Access some resource.\n\n3. Perform secure action.\n\nIn this case the race condition is between the\nsecurity check and the action. If we can modify\nthe state of the system in between those actions,\nit might be possible to elevate privileges or do un-\nexpected things. The time window is typically very\nsmall, but if the code is accessing some controllable\nresource in between the check and the action, we\nmight still be able to create a very reliable exploit.\n\nI wanted to find a way of increasing the time win-\ndow to win the race in cases where the code accesses\na resource we control. The following is an overview\nof the thought process I went through to come up\nwith a working solution.\n\n3.1 Investigating Object Manager\nLookup Performance\n\nHidden under the hood of Windows NT is the Ob-\nject Manager Namespace (OMN). You wouldn’t typ-\nically interact with it directly as the Win32 API for\nthe most part hides it away. The NT kernel defines a\nset of objects, such as Files, Events, Registry Keys,\nthat can all have a name associated with them. The\nOMN provides the means to lookup these named\nobjects. It acts like a file system; for example, you\ncan specify a path to an NT system call such as\n\\BaseNamedObjects\\MyEvent, and an event can be\nthus looked up.\n\nThere are two special object types for use in the\nOMN: Object Directories and Symbolic Links. Ob-\nject Directories act as named containers for other\nobjects, whereas Symbolic Links allow a name to be\nredirected to another OMN path. Symbolic Links\nare used quite a lot; for example, the Windows drive\nletters are really symbolic links to the real storage\ndevice. When we call an NT system call, the kernel\nmust lookup the entire path, following any symbolic\nlinks until it either reaches the named object or fails\nto find a match.\n\nIn this exploit we want to make the process of\nlooking up a resource we control as slow as possible.\nFor example, if we could make it take 1 or 2 seconds,\nthen we’ve got a massive window of opportunity to\nwin the race condition. Therefore I want to find\na way of manipulating the Object Manager lookup\nprocess in such a way that we achieve this goal. I\nam going to present my approach to achieving the\nrequired result.\n\nA note about my setup: for my testing I am go-\ning to open a named Event object. All testing is\ndone on my 2.8GHz Xeon Workstation. Although it\nhas 20 physical cores, the lookup process won’t be\nparallelized, and therefore that shouldn’t be an is-\nsue. Xeons tend to have more L2/L3 cache than con-\nsumer processors, but if anything this should only\nmake our timings faster. If I can get a long lookup\ntime on my Workstation, it should be possible on\npretty much anything else running Windows. Fi-\nnally, this is all tested on an up-to-date Windows 10;\nhowever, not much has changed since Windows 7\nthat might affect the results.\n\nFirst let’s just measure the time it takes to do\n\n24\n\n\n\na normal lookup. We’ll repeat the lookup a 1, 000\ntimes and take the average. The results are prob-\nably what we’d expect: the lookup process for a\nsimple named Event is roughly 3µs. That includes\nthe system call transition, lookup process, and the\naccess check on the Event object. Although in the-\nory you could win a race, it seems pretty unlikely,\neven on a multi-core processor. So let’s think about\na way of improving the lookup time (and when I say\n“improve”, I mean making the lookup time slower).\n\nAn Object Manager path is limited to the\nmaximum string size afforded by the UNI-\nCODE_STRING structure.\n\nstruct UNICODE_STRING {\n2 USHORT Length ;\n\nUSHORT MaximumLength ;\n4 PWSTR Buf f e r ;\n\n}\n\nWe can see that the Length member is an un-\nsigned 16 bit integer, limiting the maximum length\nto 216 − 1. This, however, is a byte count, so in\nfact this limits us to 215 − 1 or 32767 characters.\nFrom this result, there are two obvious possible ap-\nproaches we can take:\n\n1. Make a path that contains one very long name.\nThe lookup process would have to compare the\nentire name using a typical string comparison\noperation to verify it’s accessing the correct\nobject. This should take linear time relative\nto the length of the string.\n\n2. Make multiple small named directories and re-\npeat. E.g., \\A\\A\\A\\A\\...\\EventName. The\nassumption here is that each lookup takes a\nfixed amount of time to complete. The oper-\nation will again be linear time relative to the\ndepth of recursion of the directories.\n\nNow it would seem likely that the cost of the en-\ntire operation of a single lookup will be worse than\na string comparison, a primitive that is typically op-\ntimized quite heavily. At this point we have not had\nto look at any actual kernel code, and we won’t start\nquite yet, so instead empirical testing seems the way\nto go.\n\nLet’s start with the first approach, making a\nlong string and performing a lookup on it. Our\nname limit is around 32767, although we’ll need\nto be able to make the object in a writable direc-\ntory such as \\BaseNamedObject, which reduces the\n\nlength slightly, but not enough to make significant\nimpact. Therefore, we’ll perform the Event opening\non names between 1 character and 32,000 characters\nin length. The results are shown below:\n\n0 8000 16000 24000 32000\n0\n\n0.025\n\n0.05\n\n0.075\n\n0.1\n\nName Length in Characters\n\nL\noo\n\nku\np \n\nT\nim\n\ne \nA\nve\n\nra\nge\n\n (\nm\n\ns)\n\nAlthough this is a little noisy, our assumption\nof a linear lookup time seems correct. The longer\nthe string, the longer it takes to look it up. For a\n32,000 character long string, this seems to top out\nat roughly 90µs – still not enough in my opinion for\na useful primitive, but certainly a start.\n\nNow let’s instead look at the recursive directory\napproach. In this case the upper bound is around\n16,000 directories. This is because each path compo-\nnent must contain a backslash and a single charac-\nter name (i.e. \\A\\A\\A...). Therefore our maximum\npath limit is halved. Of course we’d make the as-\nsumption that the time to go through the lookup\nprocess is going to be greater than the time it takes\nto compare 4 Unicode characters, but let’s test to\nmake sure. The results are shown below:\n\n0 4000 8000 12000 16000\n0\n\n1\n\n2\n\n3\n\n4\n\nDirectory Count\n\nL\noo\n\nku\np \n\nT\nim\n\ne \nA\nve\n\nra\nge\n\n (\nm\n\ns)\n\nWell, I think that’s unequivocal. For 16,000 re-\ncursive depth, the average lookup time is around\n3700µs, or around 40 times larger than the long path\nname lookup result. Now, of course, this comes with\ndownsides. For a start, you need to create 16,000 or\nso directory objects in the kernel. At least on a mod-\n\n25\n\n\n\nern 64 bit Windows this isn’t likely to be too taxing,\nhowever it’s still worth bearing in mind. Also the\nprocess must maintain a handle to each of those di-\nrectories, because otherwise they’d be deleted (as a\nnormal user cannot make kernel objects permanent).\nFortunately our handle limit for a single process is\nof the order of 16 million, so we’re a couple of orders\nof magnitude below the limit of that.\n\nNow, is 3700µs going to be enough for us?\nMaybe, it’s certainly orders of magnitude greater\nthan 3µs. But can we do better? We’ve now run\nout of path space, we’ve filled the absolute maxi-\nmum allowed string length with recursive directory\nnames. What we could do with is a method of mul-\ntiplying that effect without requiring a longer path.\nWe can do this by using Object Manager symbolic\nlinks. By placing the symbolic link as the last com-\nponent of the long path we can force the kernel to\nreparse, and start the lookup all over again. On the\nfinal lookup we’ll just point the symbolic link to the\ntarget.\n\nUltimately though we can only do this 64 times.\nWhy, can’t we do this indefinitely? Well, no—for\na fairly obvious reason: each time a symbolic link\nis encountered the kernel restarts the parsing pro-\ncesses; if you pointed a symbolic link at itself, you’d\nend up in an infinite loop. The reparse limit of 64\nprevents that from becoming a problem. The re-\nsults are as we expected, the time taken to lookup\nour event is proportional to both the number of sym-\nbolic links and the number of recursive directories.\nFor 64 symbolic links and 16,000 directories it takes\napproximately 200ms (note I’ve had to change the\norder of the result now to milliseconds). At around\n1\n5 of a second that should be enough, right? Sure,\nbut I’m greedy; I want more. How can we make the\nlookup time even worse?\n\nAt this point it’s time to break out the disassem-\nbler and see how the lookup process works under the\nhood in the kernel. First off, let’s see what an object\ndirectory structure looks like. We can dump it from\na kernel debugging session using WinDBG with the\n\n26\n\n\n\ncommand dt nt!_OBJECT_DIRECTORY. Converted\nback to a C-style structure, it looks something like\nthe following:\n\n1 struct OBJECT_DIRECTORY\n{\n\n3 POBJECT_DIRECTORY_ENTRY HashBuckets [ 3 7 ] ;\nEX_PUSH_LOCK Lock ;\n\n5 PDEVICE_MAP DeviceMap ;\nULONG Ses s i on Id ;\n\n7 PVOID NamespaceEntry ;\nULONG Flags ;\n\n9 POBJECT_DIRECTORY ShadowDirectory ;\n}\n\nBased on the presence of the HashBucket field,\nit’s safe to assume that the kernel is using a hash\ntable to store directory entries. This makes some\nsense, because if the kernel just maintained a list\nof directory entries, this would be pretty poor for\nperformance. With a hash table the lookup time\nis much reduced as long as the hashing algorithm\ndoes a good job of reducing collisions. This is only\nthe case though if the algorithm isn’t being actively\nexploited. As we’re trying to increase the cost of\nlookups, we can intentionally add entries with col-\nlisions to make the lookup process take the worst\ncase time, which is linear relative to the number of\nentries in a directory. This again provides us with\nanother scaling factor, and in this case the number\nof entries is only going to be limited by available\nmemory, as we are never going to need to put the\nname into the path.\n\nSo what’s the algorithm for the hash? The\nmain function of interest is ObpLookupObject-\nName, which is referenced by functions such as Ob-\nReferenceObjectByName. The directory entry logic\nis buried somewhere in this large function; however,\nfortunately there’s a helper function ObpLookup-\nDirectoryEntryEx, which has the same logic (it\nisn’t actually called by ObpLookupObjectName, but\nit doesn’t matter) that is smaller and easier to re-\nverse (Figure 10).\n\nSo the hashing algorithm is pretty simple; it re-\npeatedly mixes the bits of the current hash value\nand then adds the uppercase Unicode character to\nthe hash. We could work out a clever way of getting\nhash collisions from this, but actually it’s pretty sim-\nple. The object manager allows us to specify names\ncontaining NULL characters, therefore if we take our\ntarget name, say ‘A’, and prefix it with increasing\nlength strings containing only NULL, we get both\nHash and Bucket collisions. This does limit us to\n\ncreating only 32,000 or so colliding entries before we\nrun out of strings to create them, but, as we’ll see\nin a minute, that’s not a problem. Let’s look at the\nresults of doing this for a single directory:\n\n0 4000 8000 12000 16000\n0\n\n0.15\n\n0.3\n\n0.45\n\n0.6\n\nCollisions\n\nL\noo\n\nku\np \n\nT\nim\n\ne \nA\nve\n\nra\nge\n\n (\nm\n\ns)\n\nYet again, a nice linear graph. For a given col-\nlision count it’s nowhere near as good as the recur-\nsive directory approach, but it is a multiplicative\nfactor in the lookup time, which we can abuse. So\nyou’d think we can now easily apply this to all our\n16,000 recursive directories, add in symbolic links,\nand probably get an insane lookup time. Yes, we\nwould, however there’s a problem, insertion time.\nEvery time we add a new entry to a directory, the\nkernel must do a lookup to check that the entry\ndoesn’t already exist. This means that, for every\nentry we add, we must do (n − 1)2 checks in the\nhash bucket just to find that we don’t have the en-\ntry before we insert it. This means that the time\nto add a new entry is approximately proportional to\nthe square of the number of entries. Sure it’s not\na cubic or exponential increase, but that’s hardly a\nconsolation. To prove that this is the case we can\njust measure the insertion time:\n\n0 4000 8000 12000 16000\n0\n\n1500\n\n3000\n\n4500\n\n6000\n\nDirectory Count\n\nIn\nse\n\nrt\nio\n\nn \nT\n\nim\ne \n\n(m\ns)\n\nThat graph shows a pretty clear n2 trend for the\ninsertion time. If, say, we wanted to create a direc-\ntory entry with 16,000 collisions, it takes close to 5.5\nseconds. If we wanted to then do that for all 16,000\n\n27\n\n\n\nPOBJECT_DIRECTORY ObpLookupDirectoryEntryEx (POBJECT_DIRECTORY Directory ,\n2 PUNICODE_STRING Name,\n\nULONG Attr ibuteF lags ) {\n4 BOOLEAN Case InSens i t i v e = ( Att r ibuteF lags & OBJ_CASE_INSENSITIVE) != 0 ;\n\nSIZE_T CharCount = Name−>Length / s izeof (WCHAR) ;\n6 WCHAR∗ Buf f e r = Name−>Buf f e r ;\n\nULONG Hash = 0 ;\n8 while (CharCount ) {\n\nHash = (Hash / 2) + 3 ∗ Hash ;\n10 Hash += RtlUpcaseUnicodeChar (∗ Buf f e r ) ;\n\nBu f f e r++;\n12 CharCount−−;\n\n}\n14\n\nOBJECT_DIRECTORY_ENTRY∗ Entry = Directory−>HashBuckets [ Hash % 3 7 ] ;\n16 while ( Entry ) {\n\ni f ( Entry−>HashValue == Hash ) {\n18 i f ( RtlEqualUnicodeStr ing (Name,\n\nObpGetObjectName (Entry−>Object ) , Case InSens i t i v e ) ) {\n20 ObReferenceObject ( Entry−>Object ) ;\n\nreturn Entry−>Object ;\n22 }\n\n}\n24 Entry = Entry−>ChainLink ;\n\n}\n26\n\nreturn NULL;\n28 }\n\nFigure 10. ObpLookupDirectoryEntryEx()\n\n28\n\n\n\nrecursive directory entries, it would take around 24\nhours! Now, I think we’re going a bit over the top\nhere, and by fiddling with the values we can get\nsomething that doesn’t take too long to set up and\ngives us a long lookup time. But I’m still greedy; I\nwant to see how far I can push the lookup time. Is\nthere any way we can get the best of all worlds?\n\nThe final piece of the puzzle is to bring in Shadow\ndirectories, which allow the Object Manager a fall-\nback path if it can’t find an entry in a directory.\nYou can use almost any other Object Manager direc-\ntory as a shadow, which will allow us to control the\nlookup behavior. A Shadow Directory has a crucial\ndifference from symbolic links, as it doesn’t cause a\nreparse to occur in the lookup process. This means\nthey’re not restricted to the 64 reparse limit. As\neach lookup consumes a path component, eventually\nthere will be no more paths to lookup. If we put to-\ngether two directories in the following arrangement,\nwe can pass a similar path to our recursive directory\nlookup, without actually creating all the directories.\n\nShadow Directory\nLookup\n\nPath: \\A\\A\\A\\A\\A ...\n\nLookup\n\nAA\n\nSo how does this actually work? If we open a\npath of the form \\A\\A\\A\\A\\A..., the kernel will first\nlookup the initial ‘A’ directory. This is the directory\non the left of the diagram. It will then try to open\nthe next ‘A’ directory, which is on the right, which\nagain it will find. Next the kernel again looks up\n‘A’, but in this case it doesn’t exist. As the direc-\ntory has a shadow link to its parent, it looks there\ninstead, finds the same ‘A’ directory, and repeats\nthe process. This will continue until we run out of\npath elements to lookup.\n\nSo let’s determine the performance of this ap-\nproach. We’d perhaps expect it to be less perfor-\n\nmant relative to actually creating all those directo-\nries if only because of the cache effects of the pro-\ncessor. But hopefully it won’t be too far behind.\n\n0 4000 8000 12000 160000\n\n1\n\n2\n\n3\n\n4\n\nDirectory Count\n\nL\noo\n\nku\np \n\nT\nim\n\ne \nA\nve\n\nra\nge\n\n (\nm\n\ns) Linear Sub\nDirectory\n\nLinear\nShadow\nDirectory\n\nLooks good. Yes, the performance is lower than\nactually creating the directories, but once we bring\ncollisions into the mix, that’s not really going to\nmatter much. So the final result is that instead of\ncreating 16,000 directories with 16,000 collisions we\ncan do it with just 2 directories, which is far more\nmanageable and only takes around 11 seconds on\nmy workstation. So, to sign off, let’s combine every-\nthing together.\n\n1. 16,000 path components using 2 object direc-\ntories in a shadow configuration\n\n2. 16,000 collisions per directory\n\n3. 64 symbolic link reparses\n\nAnd the resulting time for a single lookup on\nmy workstation is *drum roll please* 19 minutes! I\nthink we might just be able to win the race condition\nwith that.\n\nCode examples can be found attached to this\ndocument.10\n\n3.2 Conclusion\n\nSo after all that effort we can make the kernel take\naround 19 minutes to lookup a single controlled re-\nsource path. That’s pretty impressive. We have\nmany options to get the kernel to start the lookup\nprocess, allowing us to use not just files and registry\nkeys but almost any named event. It’s a typical tale\nof unexpected behavior when facing pathological in-\nput, and it’s not really surprising Microsoft wouldn’t\noptimize for this use case.\n\n10unzip pocorgtfo13.pdf object_manager_lookup_poc.cs\n\n29\n\n\n\n4 The FaceWhisperer for USB Glitching; or,\nReading RFID with ROP and a Wacom Tablet\n\nby Micah Elizabeth Scott\n\nGreetings, neighbors!\nToday, like most days, I would like to celebrate\n\nthe diversity of tiny machines around us. This time\nI’ve prepared a USB magic trick of sorts, incorpo-\nrating techniques from the analog and the digital\ndomains.\n\nRegular readers will be well aware that computer\nperipherals are typically general-purpose computers\nthemselves, and the operating system often trusts\nthem a little too much. Devices attached to Thun-\nderbolt (PCI Express) are trusted as much as the\nCPU. Devices attached to USB, at best, are as privi-\nleged as the user, who can typically do anything they\nwant albeit slowly and using interfaces designed for\nmeat.11 If that USB device can exploit a bug in lit-\nerally any available driver, the device could achieve\neven more direct levels of control.\n\nNot only are these peripherals small computers\nwith storage and vulnerabilities and secrets, they\ntypically have very direct access to their own hard-\nware. It’s often firmware’s responsibility to set up\nclocks, program power converters, and process ana-\nlog signals. Projects like BadUSB have focused on\nreprogramming a USB device to attack the com-\nputer they’re attached to. What about using the\navailable low-level peripherals in ways they weren’t\nintended?\n\nI recently made a video, a “Graphics Tablet\nPrimer for Hackers,” going into some detail on how a\npen tablet input device actually works. I compared\nthe electromagnetic power and data transfer to the\nlow-frequency RFID cards still used by many door\naccess control systems. At the time this was just a\nconvenient didactic tool, but it did start me won-\ndering just how hard it would be to use a graphics\ntablet to read 125 kHz RFID cards.\n\nI had somewhat arbitrarily chosen a Wacom\nCTE-450 (Bamboo Fun) tablet for this experiment.\nI had one handy, and I’d already done a little pre-\nliminary reversing on its protocol and circuit design.\nIt’s old enough that it didn’t seem to use any cus-\ntom Wacom silicon, recent enough to be both cheap\nand plentiful on the second-hand market.\n\n4.1 A Very Descriptive Descriptor\n\nTypically you need firmware to analyze a device.\nDocumented interfaces are the tip of the iceberg. To\nreally see what a device is capable of, you need to\nsee everything the firmware knows how to do. Some-\ntimes this is easy to get. Back in PoC‖GTFO 7:3\nwhen I was reversing an optical drive, the firmware\nwas plainly available from the manufacturer’s web\nsite. Usually you won’t be so lucky. Manufactur-\ners often encrypt firmware to hide their crimes or\nslow down clones, and some devices don’t appear to\nsupport firmware updates at all.\n\nThis device seemed to be the latter kind. No\nfirmware updates online. No hints of a firmware up-\ndating process hidden in their drivers. The CPU\nwas something I didn’t recognize at first. I posted\n\n11unzip pocorgtfo13.pdf meat.txt\n\n30\n\n\n\nXM\nEG\n\nA1\n28\n\nD\n4\n\nM\nAX\n\n34\n21\n\nES\nM\n\nD\n\nC\nLK\n\n1\n\nC\nLK\n\n2\n\nN\nC\n\n7W\nZ1\n\n4\nN\n\nC\n7W\n\nZ1\n4\n\n.1\nuF\n\n49\n\nVU\nSB\n\n IN\n\nG\nN\n\nD\n\nG\nN\n\nD\n\nC\nLK\n\n3\n\n3.\n3V\n\n3.\n3V\n\n3.\n3V\n\nR\nES\n\nET\n\nG\nN\n\nD\n\nG\nN\n\nD\n\nG\nN\n\nD\n\n10\n0n\n\n10\n0n\n\n10\n0n\n\n10\n0n\n\n1u\n\nG\nN\n\nD\nG\n\nN\nD\n\n3.\n3V\n\n3.\n3V\n\n10\n010\nk\n\n3.\n3V\n\nR\nes\n\net\n\n1k\n\n10\n0\n\nG\nN\n\nD\n\n3.\n3V\n\nG\nN\n\nD\n\nPo\nw\n\ner\nGND\n\n1k\n\n3.3V\n\nVBUS\n1k\n\n33 33\n\nPA\n5\n\nPA\n6\n\n1k 1k\n\n3.\n3V\n\nPT\nC\n\n 2\nA\n\nG\nN\n\nD\n\nG\nN\n\nD\n\nSY\nN\n\nC\nIN\n\nG\nN\n\nD\n\nIC\n1 PE\n\n0\n28\n\nPE\n1\n\n29\nPE\n\n2\n32\n\nPE\n3\n\n33\n\nPD\n7\n\n27\nPD\n\n6\n26\n\nPD\n5\n\n25\nPD\n\n4\n24\n\nPD\n3\n\n23\nPD\n\n2\n22\n\nPD\n1\n\n21\nPD\n\n0\n20\n\nPC\n7\n\n17\nPC\n\n6\n16\n\nPC\n5\n\n15\nPC\n\n4\n14\n\nPC\n3\n\n13\nPC\n\n2\n12\n\nPC\n1\n\n11\nPC\n\n0\n10\n\nPB\n3\n\n7\nPB\n\n2\n6\n\nPB\n1\n\n5\nPB\n\n0\n4\n\nPA\n6\n\n2\nPA\n\n7\n3\n\nPA\n5\n\n1\nPA\n\n4\n44\n\nPA\n3\n\n43\nPA\n\n2\n42\n\nPA\n1\n\n41\nPA\n\n0\n40\n\nAV\nC\n\nC\n39 3831\n\nPR\n0(\n\nXT\n2)\n\n36\n\nPR\n1(\n\nXT\n1)\n\n3719\nVC\n\nC\n9 18\n\nG\nN\n\nD\n8\n\nPD\nI_\n\nD\nAT\n\nA\n34 30\n\nR\nES\n\nET\n/P\n\nD\nI_\n\nC\nLK\n\n35\n\nU\n1 VC\n\nC\n23\n\nVL\n2\n\nD\n+\n\n21\nD\n\n-\n20\n\nVB\nC\n\nO\nM\n\nP\n22\n\nX0\n25\n\nX1\n24\n\nIN\nT\n\n18\nR\n\nES\n12\n\nG\nPX\n\n17\nM\n\nO\nSI\n\n16\nM\n\nIS\nO\n\n15\nSC\n\nK\n13\n\nSS\n14\n\nG\nN\n\nD\n3\n\nG\nN\n\nD\n19\n\nG\nO\n\nU\nT7\n\n11\nG\n\nO\nU\n\nT6\n10\n\nG\nO\n\nU\nT5\n\n9\nG\n\nO\nU\n\nT4\n8\n\nG\nO\n\nU\nT3\n\n7\nG\n\nO\nU\n\nT2\n6\n\nG\nO\n\nU\nT1\n\n5\nG\n\nO\nU\n\nT0\n4\n\nG\nPI\n\nN\n7\n\n1\nG\n\nPI\nN\n\n6\n32\n\nG\nPI\n\nN\n5\n\n31\nG\n\nPI\nN\n\n4\n30\n\nG\nPI\n\nN\n3\n\n29\nG\n\nPI\nN\n\n2\n28\n\nG\nPI\n\nN\n1\n\n27\nG\n\nPI\nN\n\n0\n26\n\nX1X2\n\nD\n+ D\n-\n\nVB\nU\n\nS\nG\n\nN\nD\n\nGND@1\nGND@2\n\nQ\n1\n\nU\n2A\n\n1\n6\n\nU\n2B\n\n3\n4\n\nC\n1\n\nR\n1\n\nU\n2P GNDVCC\n\n25\n\nJ2\n\nJ5\n\n123\n\nPR\nST\n\n5\n3V\n\n3\n3\n\n3V\n3\n\n18\n\n5V\n1\n\n5V\n20\n\nFH\nS1\n\n4\nFH\n\nS2\n6\n\nFI\nO\n\n1\n10\n\nFI\nO\n\n2\n12\n\nFI\nO\n\n3\n14\n\nFI\nO\n\n4\n16\n\nG\nN\n\nD\n17\n\nG\nN\n\nD\n19\n\nG\nN\n\nD\n2\n\nPD\nIC\n\n13\nPD\n\nID\n15\n\nPM\nIS\n\nO\n7\n\nPM\nO\n\nSI\n9\n\nPS\nC\n\nK\n11\n\nVR\nEF\n\n8\n\nJ4\n\n1 2 3 4\n\nJ6\n\n123\n\nC\n2\n\nC\n3\n\nC\n4\n\nC\n5\n\nC\n6\n\nR\n2R\n\n3\n\nLE\nD\n\n2\n\nR4\n\nR\n5\n\nLE\nD\n\n1\n\nR\n6\n\nLED3\n\nR7\n\nR\n8\n\nR\n9\n\nLE\nD\n\n4\n\nLE\nD\n\n5\n\nR\n10 R\n11\n\nF1\n\nJ7\n\n123\n\nD\n+\n\nD\n+\n\nD\n-\n\nD\n-\n\nC\nLK\n\n12\n\nC\nLK\n\n12\n\nC\nLK\n\n12\n\nC\nLK\n\n12\n\nR\nES\n\nET\n_G\n\nAT\nE\n\nR\nES\n\nET\n_G\n\nAT\nE\n\nTI\nO\n\n1\n\nTI\nO\n\n1\n\nTI\nO\n\n2\n\nTI\nO\n\n2\n\nTI\nO\n\n3\n\nTI\nO\n\n3\n\nTI\nO\n\n4\n\nTI\nO\n\n4\n\nPD\nI_\n\nC\nLK\n\nPD\nI_\n\nC\nLK\n\nPD\nI_\n\nD\nAT\n\nA\nPD\n\nI_\nD\n\nAT\nA\n\nU\nSB\n\n_I\nR\n\nQ\n\nU\nSB\n\n_I\nR\n\nQ\n\nU\nSB\n\n_R\nES\n\nET\n\nU\nSB\n\n_R\nES\n\nET\n\nU\nSB\n\n_G\nPX\n\nU\nSB\n\n_G\nPX\n\nU\nSB\n\n_M\nO\n\nSI\nU\n\nSB\n_M\n\nO\nSI\n\nU\nSB\n\n_M\nIS\n\nO\n\nU\nSB\n\n_M\nIS\n\nO\n\nU\nSB\n\n_S\nC\n\nK\n\nU\nSB\n\n_S\nC\n\nK\n\nU\nSB\n\n_S\nS\n\nU\nSB\n\n_S\nSSY\n\nN\nC\n\n_I\nN\n\nSY\nN\n\nC\n_I\n\nN\n\ns\nc\na\nn\nl\ni\nm\ne\n\ng\ni\nt\n\nUSB\n\nD\n\nG\n\nS\n\nR\nel\n\nea\nse\n\nd \nun\n\nde\nr t\n\nhe\n C\n\nre\nat\n\niv\ne \n\nC\nom\n\nm\non\n\ns\nAt\n\ntri\nbu\n\ntio\nn \n\nSh\nar\n\ne-\nAl\n\nik\ne \n\n4.\n0 \n\nLi\nce\n\nns\ne\n\n h\nttp\n\ns:\n//c\n\nre\nat\n\niv\nec\n\nom\nm\n\non\ns.\n\nor\ng/\n\nlic\nen\n\nse\ns/\n\nby\n-s\n\na/\n4.\n\n0/\n\nD\nes\n\nig\nn \n\nby\n:\n\n31\n\n\n\nthe photo to Twitter, and Ladyada recognized it as\na Sanyo/ONsemi LC87, an 8-bit micro that seems\nto be mostly used in Japanese consumer electron-\nics. It comes in both flash and ROM versions, both\nof which I would later find in these tablets. Test\npoints were available for an on-chip debugger, but I\ncouldn’t find the debug adapter for sale anywhere\nnor could I find any documentation for the pro-\ntocol. I even found the firmware for this myste-\nrious TCB87-TypeC debug adapter, and a way to\ndisassemble it, but the actual debug port was im-\nplemented by a custom peripheral on the adapter’s\nCPU. I tried various bit twiddling and pulse pushing\nin hopes of getting a response from the debug port,\nbut my best guess is that it’s been disabled.\n\nAt this point, the remaining options are more di-\nrect. A sufficiently funded and motivated researcher\ncould certainly break out the micropositioners and\nacid, reading the data directly from on-chip busses.\nBut this is needlessly complex and expensive. This\nis a USB device after all, and we have a perfectly\ngood off-chip bus that can already do many things.\nIn fact, when you attach a USB device to your PC,\nit typically hands very small pieces of its firmware\nback to the PC in order to identify itself. We think of\nthese USB Descriptors as data tables, not part of the\nfirmware at all, but where else would they be stored?\nOn an embedded device where RAM is so precious,\nthe descriptor chunks will be copied directly from\nFlash or Mask ROM into the USB endpoint buffer.\nIt’s a tiny engine designed to read parts of firmware\nout over USB, and nearly every USB device has code\nlike this.\n\nIf this code is functioning properly, it will read\nback only the USB descriptor tables, and nothing\nelse. If there’s a bug in the size calculation, you\nmay be able to request more data. If there isn’t\nalready a bug, you can introduce one via clock or\npower glitching.\n\nIntroducing a bug at just the right time can be\ntricky, so this is where it helped to build a new tool.\nWell, a tiny add-on for a masterful existing tool:\nthe ChipWhisperer-Lite by Colin O’Flynn. The\nChipWhisperer is an open source platform for side-\nchannel power analysis and glitching. The joy of\nhaving both power analysis and glitching in the same\nplatform is that they can be on the same reference\nclock. With one oscillator, you can deterministically\nstep your target device through its paces, measure\nits activity via the power consumption waveform,\nand deliver glitches to specific clock cycles. By re-\n\nmoving as many sources of jitter as possible, glitches\ncan be delivered more reliably to the intended oper-\nation within the target’s firmware.\n\nMy humble addon is the FaceWhisperer, a\nUSB host controller based on the MAX3421E\nchip, inspired of course by Travis Goodspeed’s\nFacedancer21 tool. Whereas the USB host controller\nin your PC will be subject to many influences far\noutside your control, the USB host in the FaceWhis-\nperer can be precisely synchronized with both the\ntarget device and the ChipWhisperer itself.\n\nPutting everything on the same clock is neces-\nsary but not sufficient for cycle-accurate timing re-\npeatability. The LC87, like many microcontrollers,\nwill boot from a free-running RC oscillator before\nswitching to the external clock under software con-\ntrol. This means it’s necessary to synchronize with\nthe running firmware somehow before starting up\nthe USB host. In this case, I’m using a comparator\ninput on the FaceWhisperer to precisely wait on a\ndebug signal that indicates the beginning of a tablet\nscanning cycle.\n\nThe GET_DESCRIPTOR request we’re interested in\ncomes in several parts: a SETUP token that describes\nwhat descriptor we’d like to read, some IN tokens\nthat each ask the device to send back one more\npacket, and finally an OUT for acknowledgment.\nThese phases each drive a forgetful state machine\nthat wakes up on each interrupt and leaves notes to\nitself for what needs to be done to the next packet.\nUnlike antique asynchronous serial ports, USB de-\nvices can never speak to the host unless they’re of-\nfered a timeslot with an IN token, so no matter how\nbadly we glitch the firmware we do need to follow\nthis flow in order to read back data from the device.\n\nThis firmware extraction glitch works by disrupt-\ning the calculation and/or storage of the descriptor\nlength, between that SETUP and the first IN. To ex-\ntract as much data as possible, the SETUP can have\na length limit of 0xFFFF and the FaceWhisperer can\ncontinue spamming IN tokens until something fails.\nWith this infrastructure in place, the ChipWhis-\nperer’s Glitch Explorer can hone in on timing off-\nsets and glitch parameters that give us longer than\nusual descriptor responses. By briefly interrupting\npower at slightly different timing offsets after the\nSETUP packet, a variety of glitched behavior can be\nobserved.\n\nThe descriptor we’ll be reading is the USB Con-\nfiguration Descriptor, typically one of the longest\ndescriptors a device will provide. This device has a\n\n32\n\n\n\n33\n\nCEEEEE CocceEe CEEEEE COEECECE CEOCECE COEEEe COCECE COOLED CLOEECE CoCCEe CoLECEE CoKGEE\n\ne°coe\n\naues +8 9.\nGOaarars ¢\n><)\n20x( ‘ 5\n\nBSu[seb,o\n0\n\n© cccoo o\n\n2\nLunes\n\necoce © cocee\n\n© eccce 0\n\neoccee cfoccce\n\n¢\necococe ccecce ceocece cococee cocece ccecoe CeCCoee CoCece Ceoecee cacceo cocecc occoo\n\n33\n\n\n\n\n34-byte descriptor that we’ll be trying to glitch into\nsomething much longer. Usually the whole thing\ncomes back in one packet:\n\nIN\n2 09022200010100801 E0904000001030102000921\n\n0001000122920007058103090004\n4 rcode 5 t o t a l 34\n\nSometimes our glitches occur while copying the\nIN data itself. These aren’t useful on their own, but\nthey can give some feedback on how well the glitch\nis working:\n\nIN\n2 09022200010100801 E0904000001030102000921\n\n21FFFFFFFF20D227FFFFFFFFFF20\n4 rcode 5 t o t a l 34\n\nWhen you’re getting close, you start to see non-\ncorrupted descriptors that have a longer than ex-\npected length:\n\nIN\n2 09022200010100801 E0904000001030102000921\n\n0001000122920007058103090004090222000101\n4 0080160904000001030102000921000100012292\n\n000705810309000409023B000201008016090400\n6 0001030102000921000100012292000705810309\n\n0004090401000103000000092100010001220F00\n8 07058203400004040309041E035700610063006F\n\n006D00200043006F002E002C004C00740064002E\n10 0010034300540045002D00340035003000100343\n\n00540045002D0036003500300010034D00540045\n12 002D0034003500300010034D00540045002D0036\n\n00350030006802680168026801680268006803F0\n14 00F001F003F00270017002700070037000700370\n\n00B801B800B801B8\n16 rcode 5 t o t a l 268\n\nOnly a little more of that, and we find a glitched\nconfiguration descriptor that’s 65,534 bytes long,\nmore than enough to reconstruct the entire 32 kB\nfirmware ROM. You only get the memory prior to\nthe descriptor if the address space wraps, but fortu-\nnately for us this was the case. All that’s left is to\ndetermine the address offset by looking for clues like\nan IVT at the beginning or unused memory near the\nend of the image, and correctly align the resulting\n32 kB image.\n\nIf you’d like to try this technique on your own\ndevices with the ChipWhisperer, you can grab the\n\nPCB design and source for FaceWhisperer and play\nalong.12\n\nThis sort of side-channel analysis still requires a\nbit of PCB surgery in order to set up the device’s\npower rails and clock for glitching and monitoring.\nIt also helps to have a reset signal and some sort\nof GPIO that can be used as a timing reference. It\nwould be interesting future work to see how far this\nsetup could be reduced. Could the glitching be per-\nformed solely via the USB port, even through what-\never power regulation and conditioning the device\nincludes?\n\n4.2 Coding in Disappearing Ink\n\nThe documentation for the LC87 architecture is\nsparse. I eventually found an instruction encoding\ntable buried in some product-line-specific appendix,\nbut for a while the only resource I could find was\na freeware toolchain, including a compiler and an\non-chip debugger. I had already taken a look at this\ndebugger in an attempt to awaken the debug port on\nmy tablet. It wouldn’t do much without this myste-\nrious TCB87-TypeC dongle, but I tried simulating\nthe TCB87 with a GreatFET that mostly just pre-\ntends things are okay and tells this RD87 debugger\nwhatever it wants to hear. When I get the debugger\nto start up, it begins populating the hex views with\nzeroes. After a quick look with the USB analyzer, I\neasily find the requests that are the same size as the\ndevice’s memory and begin answering those with my\nfirmware dump. Now I have a debugger that I can\nuse for static analysis!\n\nI was looking for some kind of update mech-\nanism. I would later discover that this tablet\n(firmware 1.16) used mask ROM whereas many ear-\nlier tablets (1.13) used flash memory. Those 1.13\ntablets do seem to have a bootloader of some kind\navailable, but I haven’t looked into it yet. With the\n1.16 tablet I had been analyzing, though, I became\nfairly certain there was no intended way to modify\nthe device’s program memory. This gave me a new\nconstraint, which turns out to be interesting any-\nway: Turn the tablet into an RFID reader without\nmodifying its firmware. We’ll do this entirely via\nRAM and return-oriented programming.\n\nThe next step was much easier than expected.\nThere was plenty of hidden functionality in the\nfirmware. These are things that aren’t part of any\n\n12git clone https://github.com/scanlime/facewhisperer\nunzip pocorgtfo13.pdf facewhisperer.tar.bz2\n\n34\n\n\n\nstandard and aren’t used by the official drivers, but\npresumably exist for factory test purposes. There’s\na mode you can put the tablet in which enables\nan additional USB endpoint that returns loads of\ntimers and internal debug info. Oh, and there’s a\nHID request that will just write exactly 16 bytes\ninto RAM anywhere you like!\n\nI think this was used in conjunction with another\nroutine that isn’t called anywhere, which tests the\ncustom silicon Sanyo added for Wacom. Oh, custom\nsilicon. I was hoping not to find that here. Newer\ntablets have chips that are obviously designed by\nWacom to be complete analog frontends. I wanted\nto start with an older tablet that would have fewer\ncustom parts. But perhaps the “W” in LC871W32\nstands for Wacom. The analog frontend is made\nfrom discrete components in this tablet; multiplex-\ners to select from an array of coils, op-amps to inte-\ngrate the received signals, a buffer to excite the coils\nwith a carrier wave. When I first looked at the cir-\ncuit, it seemed like the 750 kHz carrier wave itself as\nwell as the other timing signals would be generated\nusing general-purpose peripherals on the micro. But\nwhen I look for the corresponding GPIO pins, noth-\ning. More reverse engineering, and it was clear that\nI was facing custom hardware. I’ve been calling it\nFEB0h, after its I/O address. At first I thought it\nwas a serial engine of some sort that was being mis-\nused to run the tablet, but now it’s clear that this\nhardware is purpose-built. More on that later. For\nnow, it’s enough to know that the hardware or the\nmask ROM itself had enough engineering risk that\nthey thought it prudent to include such a powerful\ntest feature.\n\nThis is enough to start testing the waters and\nbuilding up more and more complex ROP code. The\nROM is only 32kB, and barely half full, but there are\nsome useful gadgets. We can make function calls, do\nmemcpy, RAM-to-RAM and ROM-to-RAM. Inter-\nrupts are tricky. I tried coexisting with them for a\nwhile, but had to give up on that due to USB packet\ncorruption issues I couldn’t track down. Write an\narbitrary byte? Look up where we’d find that in\nROM and do a memcpy. Loops are the slowest.\nThese ROP stack frames can only execute once be-\nfore they’re corrupted, so we must copy the code\neach time it’s run. It’s slow, but we’re doing arbi-\ntrary things to this peripheral that we haven’t even\nwritten any code to. We can even return it to nor-\nmal operation if we like, by jumping back to the\nmain loop and restoring a normal stack.\n\nThis is not typically the sort of operation your\nOS requires elevated privileges for. The underly-\ning Send Feature Report operation is typically as-\nsociated with harmless device-specific features like\ntoggling your keyboard LEDs, not with writing ar-\nbitrary instructions to a Turing-complete processor\nthat is trusted by the OS just as much as you are.\nApplications can typically reserve access to any HID\ndevice that doesn’t already have a driver loaded.\nIt’s easy to imagine some desktop malware that un-\nloads or subverts the default driver long enough to\nload some malware into a peripheral’s RAM with-\nout subsequent detection by either the user or the\ndriver.\n\n4.3 Amplitude Modulation Alchemy\n\nWacom pens and passive RFID cards are broadly\nsimilar, in that they both use a resonant LC circuit\nto pick up some energy from the reader’s chang-\ning magnetic field, then they send back data bits\nwith backscatter modulation, selectively shorting\nout the coil. The specific mechanism is a bit dif-\nferent though, and it will make our job harder. A\ntypical 125 kHz RFID reader is sending out either a\ncontinuous carrier, or perhaps sending long bursts a\nfew times a second to save energy. During this burst,\nthe reader is continuously listening for a modulated\nresponse, with hardware filters specifically tuned to\nthis job.\n\n35\n\n\n\nWacom tablets, by contrast, are all about se-\nquentially scanning an array of coils. This CTE-450\ntablet has 12 short and wide horizontal coils on the\nfront side (Y00 through Y11) and 17 tall and thin\nvertical coils on the back side (X00 to X16). When it\nhas no idea where the pen might be, it has to scan\neverywhere. After locating the pen, it can adjust\nthe scanning pattern to take differential measure-\nments from the tablet coils nearest the pen coil. In-\nstead of transmitting and receiving simultaneously,\nthe filtering can be simplified by toggling between\ntwo modes. When transmitting, a 74HC125 buffer\ndrives the coil with the tablet’s carrier wave. During\nthis time, the analog integrator is zeroed. Then the\ntablet switches modes, and begins integrating the\nreceived signal.\n\nThese resonant LC circuits are like electromag-\nnetic tuning forks. An RFID tag or a Wacom\npen have a tuning fork at a specific frequency, and\nsome circuitry that communicates each bit by either\ndamping the oscillations or letting them ring. The\nWacom tablet shouts at the tuning fork’s frequency,\nquickly and abruptly, and immediately listens for\nthe reverberation. The whole protocol is designed\naround this mode switch. Gaps in the carrier in-\ndicate the bit boundaries, and longer bursts divide\npackets.\n\nThe trick here is to use this mechanism to read\nsome common RFID access card. Between the slow\nreturn-oriented programming and the limited ana-\nlog frontend, I picked an easy target for the PoC.\nThe EM4100 is a common 125 kHz tag with a fixed\n40-bit ID. It’s no more secure than a pin tumbler\nlock for sure, but it isn’t too far from the tags used\nin many access control systems.\n\nThe EM4100 pads the 40-bit code out to a 64-bit\nrepeating pattern with the addition of a 9-bit header\nand a matrix of parity bits. Each bit is Manchester\nencoded; 0 becomes 10, 1 becomes 01. Each half-bit\nlasts 32 clock cycles, giving us a conveniently slow\ndata rate.\n\nThe pulsed carrier is a problem. The RFID card\ndoes have its little tuning fork, and it keeps ringing\na little bit, but not as much as you might think, es-\npecially when the EM4100 chip is trying to power\nitself from this stored energy and the external car-\nrier has disappeared. A clock cycle or two, but not\nnearly as long as the tablet’s A/D conversion takes.\nThis little bit of unpredictability, though, has so far\nfoiled every plan of mine to stay in sync with the\nsignal in order to sample it at or below the bit rate.\nMy workaround has been to use a short enough car-\nrier pulse in order to have multiple samples per bit,\nallowing me to occasionally use a pile of filters and\nheuristics to recover the correct bits with appropri-\nate deference to Nyquist. The problem with using\na shorter carrier pulse is that it lowers our carrier\nduty cycle, delivering less power to the RFID card.\nSo, there’s a delicate balance: long enough to power\nthe card, short enough for the resulting data to be\nintelligible through this intermittent sampling.\n\nThe returned signal is quite weak, since the\ntablet’s filters are looking for resonance at a very\ndifferent frequency. This is an area where I’ve seen\nmuch difference between individual RFID tags. Un-\nder unrealistic conditions, with the RFID tag placed\ndirectly on the tablet circuit board, many tags read\nsuccessfully without much trouble. With an unmod-\nified and fully assembled tablet, I’ve had very diffi-\ncult to reproduce results, occasionally reading only\none of the several tags I tried the setup with.\n\nIf you want to try this experiment or others, you\ncan find my simple ROP toolkit and signal process-\ning for the CTE-450 and try your luck with the\nreturn-oriented analog hacking.13\n\n4.4 More to do\n\nAlthough so far I’ve only managed to transform this\ntablet into an extremely bad RFID reader, I think\nthis shows that the overall approach may lead some-\nwhere. The main limitations here are in the reliance\non slow ROP, and the relatively low quality A/D\nconverter on the LC871. I’ve done my best to try\n\n13git clone https://github.com/scanlime/cte450-homebrew/\nunzip pocorgtfo13.pdf cte450-homebrew.tar.bz2\n\n36\n\n\n\nand separate the signal from the noise, but I’m no\nDSP guru. It’s possible that a signal processing ex-\npert could be snooping tags with a better success\nrate than I’ve been seeing. As a proof of concept,\nthis shows that the transformation from tablet to\nRFID reader is theoretically doable, though with-\nout a significant improvement in range it’s hard to\nimagine this approach succeeding at reading access\ncards casually left against a victim’s graphics tablet.\n\nIt could be interesting to examine newer tablets.\nThe custom silicon in FEB0h turned out to be one of\nthe best things about the CTE-450 tablet, making it\nrelatively easy to change the timing and carrier fre-\nquency. If newer tablets have a nicer A/D converter\nand a programmable filter on the receive path, they\ncould make a decent RFID reader indeed. A brief\nlook at my newer Intuos Pro tablet shows a Renesas\nprocessor that likely has reprogrammable flash.\n\nThere’s certainly more work to do in discov-\nering the scope of devices vulnerable to glitched\n\nGET_DESCRIPTOR requests. What other devices that\nwe usually think of as black-box peripherals might\nhave firmware that can be read out, or RAM that\nwe can temporarily hide code in?\n\nIt may be possible to mitigate these glitched\nGET_DESCRIPTOR firmware readouts by adding ad-\nditional verification steps in the device’s USB stack,\nwhich would each also need to be glitched. Reducing\nthe number of invalid states that eventually result\nin spilling data will make the glitching process much\nmore tedious.\n\nIn practice, though, I would argue that the best\nsecurity is not to rely on secret firmware at all. Al-\ngorithms shouldn’t need secrecy to keep them se-\ncure. Debug features that are too dangerous to\nleave should be disabled, not hidden. If any sensitive\ndata must be reachable from the CPU, it should be\nunmapped whenever possible, especially when some\nUSB controller asks for your life story.\n\n37\n\n\n\n5 Decoding AMBE+2 in MD380 Firmware in Linux\nby Travis Goodspeed KK4VCZ\n\nwith kind thanks to DD4CR, DF8AV, and AB3TL\n\nHowdy y’all,\nIn PoC‖GTFO 10:8, I shared with you fine folks\n\na method for extracting a cleartext firmware dump\nfrom the Tytera MD380. Since then, a rag-tag gang\nof neighbors has joined me in hacking this device,\nand hundreds of amateur radio operators around\nthe world are using our enhanced firmware for DMR\ncommunications.\n\nAMBE+2 is a fixed bit-rate audio compression\ncodec under some rather strict patents, for which\nthe anonymously-authored Digital Speech Decoder\n(DSD) project14 is the only open source decoder. It\ndoesn’t do encoding, so if for example you’d like to\nconvert your favorite Rick Astley tunes to AMBE\nframes, you’ll have to resort to expensive hardware\nconverters.\n\nIn this article, I’ll show you how I threw to-\ngether a quick and dirty AMBE audio decompressor\nfor Linux by wrapping the firmware into a 32-bit\nARM executable, then running that executable ei-\nther natively or through Qemu. The same tricks\ncould be used to make an AMBE encoder, or to\nconvert nifty libraries from other firmware images\ninto handy command-line tools.\n\nThis article will use an MD380 firmware image\nversion 2.032 for specific examples, but in the spirit\nof building our own bird feeders, the techniques\nought to apply just as well to your own firmware\nimages from other devices.\n\n– — — – — — — — – — –\nSuppose that you are reverse engineering a\n\nfirmware image, and you’ve begun to make good\nprogress. You know where plenty of useful func-\ntions are, and you’ve begun to hook them, but now\nyou are ready to start implementing unit tests and\ndebugging chunks of code. Wouldn’t it be nicer to\ndo that in Unix than inside of an embedded system?\n\nAs luck would have it, I’m writing this article\non an aarch64 Linux machine with eight cores and\na few gigs of RAM, but any old Raspberry Pi or\nAndroid phone has more than enough power to run\nthis code natively.\n\nBe sure to build statically, targeting\narm-linux-gnueabi. The resulting binary will run\non armel and aarch64 devices, as well as damned\n\nnear any Linux platform through Qemu’s userland\ncompatibility layer.\n\n5.1 Dynamic Firmware Loading\nFirst, we need to load the code into our process.\nWhile you can certainly link it into the executable,\nluck would have it that GCC puts its code sections\nvery low in the executable, and we can politely ask\nmmap(2) to load the unpacked firmware image to\nthe appropriate address. The first 48kB of Flash\nare used for a recovery bootloader, which we can\nconveniently skip without consequences, so the load\naddress will be 0x0800c000.\n\ns i ze_t l ength =994304;\n2 int fd=open ( \" experiment . img\" ,0 ) ;\n\nvoid ∗ f i rmware=mmap(\n4 (void ∗) 0x0800c000 , length ,\n\nPROT_EXEC|PROT_READ|PROT_WRITE,\n6 MAP_PRIVATE, // f l a g s\n\nfd , // f i l e\n8 0 // o f f s e t\n\n) ;\n\nAdditionally, we need the 128kB of RAM at\n0x20000000 and 64kB of TCRAM at 0x10000000\nthat the firmware expects on this platform. Since\nwe’d like to have initialized variables, it’s usually\nbetter go with dumps of live memory from a running\nsystem, but /dev/zero works for many functions if\nyou’re in a rush.\n\n14git clone https://github.com/szechyjs/dsd\n\n38\n\n\n\n1 //Load an SRAM image .\nint fdram=open ( \"ram . bin \" ,0 ) ;\n\n3 void ∗sram=mmap(\n(void ∗) 0x20000000 ,\n\n5 ( s i ze_t ) 0x20000 ,\nPROT_EXEC|PROT_READ|PROT_WRITE,\n\n7 MAP_PRIVATE, // f l a g s\nfdram , // f i l e\n\n9 0 // o f f s e t\n) ;\n\n11\n//Create an empty TCRAM region .\n\n13 int fdtcram=open ( \"/dev/ zero \" ,0 ) ;\nvoid ∗ tcram=mmap(\n\n15 (void ∗) 0x10000000 ,\n( s i z e_t ) 0x10000 ,\n\n17 PROT_READ|PROT_WRITE, // p ro t e c t i on s\nMAP_PRIVATE, // f l a g s\n\n19 fdtcram , // f i l e\n0 // o f f s e t\n\n21 ) ;\n\n5.2 Symbol Imports\n\nNow that we’ve got the code loaded, calling it is as\nsimple as calling any other function, except that our\nC program doesn’t yet know the symbol addresses.\nThere are two ways around this:\n\nThe quick but dirty solution is to simply cast a\ndata or function pointer. For a concrete example,\nthere is a null function at 0x08098e14 that sim-\nply returns without doing anything. Because it’s\na Thumb function and not an ARM function, we’ll\nhave to add one to that address before calling it at\n0x08098e15.\n\nvoid (∗ nu l l sub ) ( )=(void ∗) 0x08098e15 ;\n2\n\np r i n t f ( \"Trying to c a l l nu l l sub ( ) . \\ n\" ) ;\n4 nu l l sub ( ) ;\n\np r i n t f ( \" Success ! \\ n\" ) ;\n\nSimilarly, you can access data that’s in Flash or\nRAM.\n\n1 p r i n t f ( \"Manufacturer i s : ’%s ’\\n\" ,\n0 x080f9e4c ) ;\n\nCasting function pointers gets us part of the way,\nbut it’s rather tedious and wastes a bit of memory.\nInstead, it’s more efficient to pass a textfile of sym-\nbols to the linker. Because this is just a textfile, you\n\ncan easily export symbols by script from IDA Pro\nor Radare2.\n\nThe symbol file is just a collection of assignments\nof names to addresses in roughly C syntax.\n/∗ Populates the audio b u f f e r ∗/\n\n2 ambe_decode_wav = 0x08051249 ;\n/∗ Just re turns . ∗/\n\n4 nu l l sub = 0x08098e15 ;\n\nYou can include it in the executable by passing\nGCC parameters to the linker, or by calling ld di-\nrectly.\nCC=arm−l inux−gnueabi−gcc−6 −s t a t i c −g\n\n2 $ (CC) −o test test . c \\\n−Xl inker −−ju s t−symbols=symbols\n\nNow that we can load the firmware into process\nmemory and call its functions, let’s take a step back\nand see a second way to do the linking, by rewrit-\ning the firmware dump into an ELF object and then\nlinking it. After that, we’ll get along to decoding\nsome audio.\n\n5.3 Static Firmware Linking\nWhile it’s nice and easy to load firmware with\nmmap(2) at runtime, it would be nice and correct\nto convert the firmware dump into an object file for\nstatic linking, so that our resulting executable has\nno external dependencies at all. This requires both\na bit of objcopy wizardry and a custom script for\nld.\n\nFirst, let’s convert our firmware image dump to\nan ELF that loads at the proper address.\n\n1 arm−l inux−gnueabi−objcopy \\\n−I b inary experiment . img \\\n\n3 −−change−addre s s e s=0x0800C000 \\\n−−rename−s e c t i o n . data=. experiment \\\n\n5 −O e l f 32−l i t t l e a rm −B arm experiment . o\n\nSadly, ld will ignore our polite request\nto load this image at 0x08000C000, be-\ncause load addresses in Unix are just po-\nlite suggestions, to be thrown away by the\nlinker. We can fix this by passing -Xlinker\n–section-start=.experiment=0x0800C000 to gcc\nat compile time, so ld knows to place the section at\nthe right address.\n\nSimilarly, the SRAM image can be embedded at\nits own load address.\n\n39\n\n\n\n40\n\ncay\n\n|\n\nFor the past 35 years radio amateurs throughout the world have been purchasing equipment\nand supplies from me. Their friendship and loyalty have been the determining factors in\nour success. For this we are grateful and it is time that we made an effort to express our\nappreciation in a material way.\n\nMany amateur radio clubs need financial aid. Many others can use extra funds if these\nfunds can be obtained without assessing their members. We have a plan which will\ngreatly assist all amateur radio clubs.\nFor every order received until March 1, 1955, we will send our check for 15% of your\norder — to your radio club for deposit in their treasury. When you place your order, be\nsure to include the name and address of your club and treasurer.\nMy best wishes for a healthy, happy and prosperous New Year.\n\n73 — CUL\n\nUncledave, W2APF\n\nRADIO. DISTRIBUTING COMPANY\n904 BROADWAY, ALBANY, N. Y.\n“tou TELEPHONE ALBANY 5-1594\n\n40\n\n\n\n\n\n5.4 Decoding the Audio\nTo decode the audio, I decided to begin with the\nsame .amb format that DSD uses. This way, I could\nwork from their reference files and compare my de-\ncoding to theirs.\n\nThe .amb format consists of a four byte header\n(2e 61 6d 62) followed by eight-byte frames. Each\nframe begins with a zero byte and is followed by\n49 bits of data, stored most significant bit first with\nthe final bit in the least significant bit of its own\nbyte.\n\nTo have as few surprises as possible, I take the\neight packed bytes and extract them into an array of\n49 shorts located at 0x20011c8e, because this is the\naddress that the firmware uses to store its buffer.\nShorts are used for convenience in addressing dur-\ning computation, even if they are a bit more verbose\nthan they would be in a convenient calling conven-\ntion.\n\n1 //Re−use the firmware ’ s own AMBE bu f f e r .\nshort ∗ambe=(short ∗) 0 x20011c8e ;\n\n3\nint ambei=0;\n\n5 for ( int i =1; i <7; i++){// Skip f i r s t by te .\nfor ( int j =0; j <8; j++){\n\n7 //MSBit f i r s t\nambe [ ambei++]=(packed [ i ]>>(7− j ) )&1;\n\n9 }\n}\n\n11 //Final b i t in i t s own frame as LSBit .\nambe [ ambei++]=packed [ 7 ]&1 ;\n\nAdditionally, I re-use the output buffers to store\nthe resulting WAV audio. In the MD380, there are\ntwo buffers of audio produced from each frame of\nAMBE.\n\n//80 samples f o r each audio b u f f e r\n2 short ∗ outbuf0=(short ∗) 0x20011aa8 ;\n\nshort ∗ outbuf1=(short ∗) 0x20011b48 ;\n\nThe thread that does the decoding in firmware is\ntied into the MicroC/OS-II realtime operating sys-\ntem of the MD380. Since I don’t have the timers and\ninterrupts to call that thread, nor the I/O ports to\nsupport it, I’ll instead just call the decoding routines\nthat it calls.\n\n1 //Placed at 0x08051249\nint ambe_decode_wav(\n\n3 signed short ∗wavbuffer ,\nsigned int e ighty , // always 80\n\n5 short ∗ b i t bu f f e r , //0x20011c8e\nint a4 , //0\n\n7 short a5 , //0\nshort a6 , // t imes l o t , 0 or 1\n\n9 int a7 //0x20011224\n) ;\n\nFor any parameter that I don’t understand, I\njust copy the value that I’ve seen called through my\nhooks in the firmware running on real hardware. For\nexample, 0x20011224 is some structure used by the\nAMBE code, but I can simply re-use it thanks to\nmy handy RAM dump.\n\nSince everything is now in the right position, we\ncan decode a frame of AMBE to two audio frames\nin quick succession.\n\n//One AMBE frame becomes two audio frames .\n2 ambe_decode_wav(\n\noutbuf0 , 80 , ambe ,\n4 0 , 0 , 0 ,\n\n0x20011224\n6 ) ;\n\nambe_decode_wav(\n8 outbuf1 , 80 , ambe ,\n\n0 , 0 , 1 ,\n10 0x20011224\n\n) ;\n\nAfter dumping these to disk and converting to\na .wav file with sox -r 8000 -e signed-integer\n-L -b 16 -c 1 out.raw out.wav, a proper audio\nfile is produced that is easily played. We can now\ndecode AMBE in Linux!\n\n41\n\n\n\n5.5 Runtime Hooks\n\nSo now we’re able to decode audio frames, but this is\nfirmware, and damned near everything of value ex-\ncept the audio routines will eventually call a function\nthat deals with I/O—a function we’d better replace\nif we don’t want to implement all of the STM32’s\nI/O devices.\n\nLuckily, hooking a function is nice and easy. We\ncan simply scan through the entire image, replac-\ning all BX (Branch and eXchange) instructions to\nthe old functions with ones that direct to the new\nfunctions. False positives are a possibility, but we’ll\nignore them for now, as the alternative would be to\nlist every branch that must be hooked.\n\nThe BL instruction in Thumb is actually two ad-\njacent 16-bit instructions, which load a low and high\nhalf of the address difference into the link register,\nthen BX against that register. (This clobbers the\nlink register, but so does any BL, so the register use\nis effectively free.)\n\n1 /∗ Ca l cu l a t e s Thumb code to branch from\none address to another . ∗/\n\n3 int c a l c b l ( int adr , int t a r g e t ) {\n/∗ Begin with the d i f f e r e n c e o f the t a r g e t\n\n5 and the PC, which po in t s to j u s t a f t e r\nthe current i n s t r u c t i o n . ∗/\n\n7 int o f f s e t=target−adr−4;\n//LSBit doesn ’ t count .\n\n9 o f f s e t =( o f f s e t >>1) ;\n\n11 /∗ The BL in s t r u c t i on i s a c t u a l l y two\nThumb in s t r u c t i on s , wi th one s e t t i n g\n\n13 the h igh par t o f the LR and the other\ns e t t i n g the low part wh i l e swapping\n\n15 LR and PC. ∗/\nint hi=0xF000 | ( ( o f f s e t&0xFFF800)>>11) ;\n\n17 int l o=0xF800 | ( o f f s e t&0x7FF) ;\n\n19 //Return the pa i r as a s i n g l e 32− b i t word .\nreturn ( lo <<16) | h i ;\n\n21 }\n\nNow that we can calculate function call instruc-\ntions, a simple loop can patch all calls from one ad-\ndress into calls to a second address. You can use this\nto hook the I/O functions live, rather than trapping\nthem.\n\n5.6 I/O Traps\nWhat about those I/O functions that we’ve forgot-\nten to hook, or ones that have been inlined to a\ndozen places that we’d rather not hook? Wouldn’t\nit sometimes be easier to trap the access and fake\nthe result, rather than hooking the same function?\n\nYou’re in luck! Because this is Unix, we can sim-\nply create a handler for SIGSEGV, much as Jeffball\ndid in PoC‖GTFO 8:8. Your segfault handler can\nthen fake the action of the I/O device and return.\n\nAlternately, you might not bother with a proper\nhandler. Instead, you can use GDB to debug the\nprocess, printing a backtrace when the I/O region\nat 0x40000000 is accessed. While GDB in Qemu\ndoesn’t support ptrace(2), it has no trouble trap-\nping out the segmentation fault and letting you\nknow which function attempted to perform I/O.\n\n5.7 Conclusion\nThank you kindly for reading my ramblings about\nARM firmware. I hope that you will find them\nhandy in your own work, whenever you need to work\nwith reverse engineered firmware away from its own\nhardware.\n\nIf you’d like to similarly instrument Linux ap-\nplications, take a look at Jonathan Brossard’s\nWitchcraft Compiler Collection,15 an interactive\nELF shell that makes it nice and easy to turn an\nexecutable into a linkable library.\n\nThe emulator from this article has now been in-\ncorporated into my md380tools16 project, for use in\nLinux.\n\nCheers from Varaždin, Croatia,\n–Travis 6A/KK4VCZ\n\n15git clone https://github.com/endrazine/wcc\nunzip pocorgtfo13.pdf wcc.tar.bz2\n\n16git clone https://github.com/travisgoodspeed/md380tools\n\n42\n\n\n\n6 Password Weaknesses in Physical Security:\nSilliness in Three Acts\n\nby Evan Sultanik\n\nDramatis Personæ\nDisembodied Voice of Pastor Manul Laphroaig . . . . . . . . . . . . . . . . . . Bard\n\nAlice Feynman . . . . . . . . . . . . . Disciple of the Church of Weird Machines\n\nBob Schrute . . . . . . . . . . . . . . . . . Assistant to the Facility Security Officer\n\nHavva al-Kindi . . . . . . . . . . . . . . . . . . . . . . Alice’s Old and Wise Officemate\n\nThe Ghost of Paul Erdős . . . . . . . . . . . . . . . . . . . . . . . . Keeper of The Book\n\nAct I: Memorize, Don’t Compromise\n\nPastor: In the windowless bowels of a nonde-\nscript, Class A office building entrenched in-\nside the Washington, D.C. beltway, we meet\nour heroine, Alice Feynman, lost on her way\nto a meeting with the Facility Security Officer.\n\nAlice: Excuse me, which way is it to the secu-\nrity office?\n\nBob: You must be the new hire. Bob Schrute,\nassistant FSO. I can take you there right after\nI finish with this. . .\n\nAlice: Alice. Nice to meet you. What’re you\ndoing?\n\nBob: Kaba Mas X-09 high security spin-lock.\nIt’s DSS-approved for use in our SCIFs. I’m\nresetting this one’s passcode.\n\nAlice: [Blank Stare]\n\nBob: U.S. Department of Defense (DoD) De-\nfense Security Service (DSS). Sensitive Com-\npartmented Information Facilities (SCIFs).\nThe rooms where we are allowed to store and\nprocess classified information?\n\nAlice: I see. I noticed those things all over this\nbuilding.\n\nBob: They’re ubiquitous. You’ll see them any-\nwhere in the country there’s classified work go-\ning on. One on each door, and another on each\nsafe. Super secure, too. Security in this office\nis no joke.\n\nAlice: How do they work?\n\nBob: [Throwing Alice the lock’s manual.] They\nrun off of the electricity generated from spin-\nning them, so you need to spin them a bit to\nget started. You see? The LCD on top shows\nyou the current number. You enter three two-\ndigit numbers. First one clockwise, second\ncounter-clockwise, third clockwise, and then\na final spin counter-clockwise to open. That’s\nthe passcode.\n\nAlice: [Flipping through the manual.] Does\neach lock get a different passcode?\n\nBob: Yes. That’s why we have this [handing\nAlice a magnet stuck to the side of the door ].\n\nAlice: Ah I see. It’s a phone keypad. So you\nuse a mnemonic to remember each passcode?\n\nBob: Exactly. [Pointing to a poster on the wall\nwith his own mugshot and memetic letters em-\nblazoning “MEMORIZE, DON’T COMPRO-\nMISE”, he sternly repeats that slogan:] Mem-\norize, don’t compromise.\n\nAlice: [“Is this guy serious?” face.]\n\nBob: You think you could crack it? FALSE.\n[Flamboyantly produces a pocket calculator\nthat had been hidden somewhere on his per-\nson.] Three two-digit numbers. That’s 100\ntimes 100 times 100, so . . . there are a mil-\nlion possible codes. I’ve set this to have a\ntimeout of four minutes after each failed at-\ntempt. So, trying all possible combinations\n\n43\n\n\n\nwould take . . . [furiously punching at the calcu-\nlator ] . . . almost eight years! We change each\ncode once every couple months, so even if you\ncould continuously try codes for eight hours\na day, you’d have . . . [more furious punching ]\n. . . about seven tenths of one percent chance\nof getting the code right.\n\nAlice: [Handing the manual back.] I didn’t see\nanything in here about an automatic lockout\nafter too many failed attempts.\n\nBob: [Pointing to his minuscule biceps.] These\nprovide the lockout.\n\nAlice: Are you ready to take me to the security\noffice now?\n\nBob: Fine.\n\nAct II: Surely You’re Joking\n\nPastor: Two weeks later, Alice has settled into\nher office, which she shares with Havva al-\nKindi. She hasn’t had a chance to play with\nthose nifty locks at all yet; her clearance is still\nbeing processed. Most of her time is spent\nidling or doing busy-work while she waits to\nbe approved to work on a real project.\n\nAlice: [On her desk phone] Yes. Yes, no prob-\nlem. By close of business today. No problem.\nBye.\n\nPastor: As Alice hangs up the phone, she no-\ntices something odd about the keypad, and\nimmediately remembers the magnet Bob had\nshowed her.\n\nAlice: [Gets up and starts drawing on her\nwhiteboard.]\n\n0\n\n8\ntuv\n\n5\njkl\n\n2\nabc\n\n1 3\ndef\n\n4\nghi\n\n6\nmno\n\n7\npqrs\n\n9\nwxyz\n\nHavva: What are you doing?\n\nAlice: Did you ever notice that the numbers\nzero and one don’t have any letters on the\nphone?\n\nHavva: Sure! You’re probably too young to\nhave ever used a rotary phone, right? Back\nwhen phone numbers were only seven dig-\nits long, the first two numbers represented\nthe exchange, and a mnemonic was given\nto each exchange. [Singing and tapping on\nher desk ] Bum-dah-bum bah-duh-bum bahhh\ndummm! PEnnsylvania Six Five Thousand!\nNo? It was a big Glenn Miller hit! My par-\nents used to play it all the time when I was a\nkid. That song is referring to the phone num-\nber for the Hotel Pennsylvania in New York,\nwhich to this day is still (212) PE6-5000.\n\nAlice: Oh yeah! I went there once for HOPE.\n\nHavva: Hope? Anyhow, for various reasons,\nthe numbers zero and one were never used in\nexchanges, which meant they never occurred\nat the beginning of phone numbers, which\nmeant they couldn’t have letters associated\nwith them.\n\n44\n\n\n\nAlice: Interesting! [Continuing on the white-\nboard ] 86 = . . . [a pause to consult her com-\nputer ] 262144. 1 − 262144 ÷ 1000000 =\n. . . 0.738. Wow! So, if there are only eight\nbuttons with letters, that reduces the number\nof possible phone numbers associated with six-\nletter mnemonics by 74% compared to if all the\nbuttons had letters!\n\nHavva: I guess that’s true. There are also cer-\ntain phone numbers you’ll never be able to\nhave English mnemonics for, because the but-\ntons for 5, 7, and 9 don’t have any vowels. So\nyou can’t make a mnemonic for a phone num-\nber that only uses those three numbers.\n\nAlice: Wow, yeah, that’s another 36 = . . .\n[quickly doing some math in her head this\ntime] 729 codes that don’t have mnemonics.\n\nHavva: Codes?\n\nAlice: Er, I mean “phone numbers.”\n\nHavva: I’ll bet there are certain “codes” that\ndon’t have any English words associated with\nthem. Plus, letters in English words don’t all\noccur at the same frequency: It’s much more\nlikely that a word will have the letter “e” than\nit will have the letter “x.”\n\nAlice: [Opens up a terminal on her computer.]\n$ grep ’^.\\{6\\}$’ /usr/share/dict/words | wc -l\n\n17706\n$ echo `!!` / 1000000 | bc -l\n.01770600000000000000\n\nPastor: And thus, Alice had discovered that\nfewer than 2% of the million possible codes\nactually map to English words.\n\nAlice: [Once again at the whiteboard.]\n\nHA CK ER\n42 25 34\n\n[Back at the computer.]\n$ grep -i ’^.\\{4\\}er$’ /usr/share/dict/words \\\n| wc -l\n1562\n\nAbout 10% of six-letter English words end\nwith the letters “ER”!\n[Back at the board, with long pauses.]\n\nDO SA GE\n36 72 43\nEN RA GE\n36 72 43\nFO RA GE\n36 72 43\nFO RB ID\n36 72 43\n\nPastor: And many words share the same code.\nIn fact, Alice quickly wrote a script to count\nthe number of unique codes possible from six-\nletter English words17.\n\nAlice: There are only 14684 possible codes to\ncheck! That would take . . . only about 40 days\nto brute-force crack!\n\nAct III: The Book\n\nPastor: Later that day, Alice is at her favorite\ndive, decompressing with some of her side\nprojects.\n\nPaul: [Sits down next to Alice at the bar. Wheel\nof Fortune is playing on an ancient CRT.]\nTelevision is something the Russians invented\nto destroy American education.\n\nAlice: [Tippling a brown liquor, neat, while\nworking on her laptop. Paul’s comment draws\nher attention to the TV. Alice notices that\nsome letters are given away “for free” and re-\nmembers what Havva had said about letter fre-\nquency. She quickly grabs her notebook and\njots down the letters as a reminder.] R, S, T,\nL, N, E.\n\nPaul: [Noticing Alice’s notebook.] Yes, these\nare very common letters in English. My native\nlanguage does not use “r” as much. But what\ndo I know about English? I learned it from\nmy father, who taught it to himself by reading\nEnglish novels in one of Joe’s Gulags. [Awk-\nward pause while Alice struggles with how to\nrespond.] Have you discovered anything beau-\ntiful? [Pointing into her notebook.]\n\nAlice: Oh that? I’ve been thinking about\nmnemonics for passcodes.\n\n17$ grep ’^.\\{6\\}$’ /usr/share/dict/words | tr ’[:upper:]’ ’[:lower:]’ | sed ’s/[abc]/2/g; s/[def]/3/g;\ns/[ghi]/4/g; s/[jkl]/5/g; s/[mno]/6/g; s/[pqrs]/7/g; s/[tuv]/8/g; s/[wxyz]/9/g’ | sort | uniq | wc -l\n\n45\n\n\n\nPaul: [Pointing to the drink:] That poison will\nnot help you. [Produces a small pill bottle out\nof his shirt pocket, raises it to eye level, drops\nit, and then catches it with the same hand be-\nfore it hits the bar.]\n\nAlice: Haven’t you heard? The Ballmer Peak\nis real! Or at least that’s what I read on Stack\nExchange.\n\nPaul: Pál Erdős. My brain is open.\n\nPastor: Alice introduces herself and proceeds\nto explain all of her findings to Paul.\n\nAlice: . . .and I just finished sorting the 14684\ndistinct codes by the number of words associ-\nated with them. That way, if I try the codes\nin order of decreasing word associations, then\nit will maximize my chances of cracking the\ncode sooner than later.\n\nPaul: Yes, if codewords are chosen uniformly\nfrom all six-letter English words. Can I see\nthe distribution of word frequency? [Grabbing\na napkin, stealing Alice’s pen, and scribbling\nsome notes.] Using your method, after fewer\nthan 250 attempts, there is a 5% probability\nthat you will have cracked the code. After\nabout 5700 attempts, there will be a 50% prob-\nability of success.\n\nAlice: [Typing on her computer.] That’s only\nabout 16 days!\n\nPastor: An adversary with intermittent access\nto the lock—for example, after hours—could\nquite conceivably crack the code in less than a\nmonth.\n\nPaul: If there exists a method that allows the\ncode-breaker to detect whether each succes-\nsive two-digit subcode is correct before enter-\ning the next two-digit subcode,. . .\n\nPastor: . . .otherwise known as a “vulnerability” . . .\n\nPaul: . . .[annoyed about having been inter-\nrupted, even if by the disembodied voice of\na narrator ] then the expected value for the\nlength of time required to crack the code is on\nthe order of minutes. [Mumbling toward the\nfourth wall:] That Pastor is more annoying\nthan the SF.\n\nAlice: What?\n\nPaul: SF means “Supreme Fascist.” This would\nshow that God is bad. I do not claim that\nthis is correct, or that God exists. It is just a\nsort of half-joke. There is an anecdote I once\nheard. Suppose Israel Gelfand and his advisor,\nAndrei Kolmogorov, were to both arrive in a\ncountry with a lot of mountains. Kolmogorov\nwould immediately try and climb the highest\nmountain. Gelfand would immediately start\nbuilding roads. What would you do?\n\nAlice: I would learn to fly an airplane so I could\ndiscover new mountain ranges. What about\nyou?\n\nPaul: Some might say that is what I do. My\nfriends might add that they pay for the fuel.\nBut really, I just try to keep the SF’s score\nlow. How can we create mnemonics that are\nnot vulnerable to your attack?\n\nAlice: Well, I guess the first thing to do is cre-\nate a keypad layout that uses zero and one.\n\nPaul: Yes, but my academic sibling Pólya\nwould say that we first need to understand\nthe problem. Ideally, we want a keypad lay-\nout that produces an injective mapping from\nthe six-letter English words into the natural\nnumbers from zero to one million.\n\nAlice: Injective?\n\nPaul: Such that no two words produce the same\ncode number.\n\nAlice: Is that even possible?\n\nPaul: I do not know. I believe this is an in-\nstance of the multiple subset sum problem, re-\nlated to the knapsack problem.\n\nAlice: Ah yeah, I remember that from my al-\ngorithms class. It’s NP-Complete, right?\n\nPaul: Yes, and likely intractable for problems\neven as small as this one. The total number\nof possible keypad mappings is 100 million bil-\nlion billion. But it is easy for us to check the\npigeons.\n\nAlice: Huh?\n\nPaul: The pigeonhole principle. For any subset\nof m letters within a word, there can be at\nmost 106−m words that have that pattern of\n\n46\n\n\n\nletters. If there are more, then there must be\na collision, no matter the mapping we choose.\n\nAlice: Ah, I see. That’s easy enough to check!\n[Typing.]\n\n1 for m in range ( 2 , 6 ) :\nh i t s = {}\n\n3 for word in words :\nfor i ndexes in i t e r t o o l s .\n\ncombinat ions (range ( len (word ) ) , m) :\n5 key = tuple ( ( word [ i ] , i )\n\nfor i in i ndexes )\ni f key not in h i t s :\n\n7 h i t s [ key ] = 1\nelse :\n\n9 h i t s [ key ] += 1\nmax_hits = 10∗∗(6−m)\n\n11 for key , h in h i t s . i t e r i t em s ( ) :\ni f h <= max_hits :\n\n13 continue\nk = [ ’ . ’ for i in range (6 ) ]\n\n15 for c , i in key :\nk [ i ] = c\n\n17 print \"\" . j o i n (k ) , h − max_hits\n\nSo, there are fourteen five-letter suffixes like\n“inder”, “aggle”, and “ingle” that will all pro-\nduce at least one collision. I guess there’s no\nway to make a perfect mapping.\n\nPaul: Gelfand advised Endre Szemerédi. This\nproblem is reminiscent of Szemerédi’s use of\nexpander graphs in pseudo-random number\ngeneration. What we want to do is take a rel-\natively small set of inputs (being the six-letter\nEnglish words) and use an expander graph as\nan embedding into the natural numbers be-\ntween one and a million, such that the result-\ning distribution mimics uniformity.\n\nAlice: That sounds . . . difficult.\n\nPaul: Constructing expander graphs is ex-\ntremely difficult. But I think Szemerédi would\nagree that interesting things rarely happen in\nfewer than five dimensions.\n\nAlice: I am a pragmatist. How about we use\na genetic algorithm to evolve a near optimal\nmapping?\n\nPaul: Such a solution would not be from The\nBook, but it would provide you with a map-\nping.\n\nAlice: What book?\n\nPaul: The Book in which the SF keeps all of the\nmost beautiful solutions.\n\nAlice: Well, I think I’ll try my hand at a scruffy\ngenetic algorithm. I need a decent mapping if\nI ever want to publish this in PoC‖GTFO!\n\nPaul: What is PoC‖GTFO?\n\nAlice: It’s. . . I guess it’s a sort of bible.\n\nPaul: Then the only difference between your\nBook and mine are the fascists who created\nthem. Maybe we will continue tomorrow . . . if\nI live.\n\nAlice: [Looking up from her keyboard.] Can I\nbuy you a drink? [Paul has vanished.]\n\nPastor: The moral of the story, dear neighbors,\nis not that these locks are inherently vulnera-\nble; if used properly, they are in fact incredibly\nsecure. We must remember that these locks\nare only as secure as the codes humans choose\nto assign to them. Using a phone keypad map-\nping on six-letter English dictionary words is\nthe physical security equivalent of a website\narbitrarily limiting passwords to eight charac-\nters.\n\n0\not\n\n8\njmuy\n\n5\nfn\n\n2\nbex\n\n1\navwz\n\n3\ncl\n\n4\ndhq\n\n6\ngs\n\n7\nip\n\n9\nkr\n\n‖PoC GTFO\n!\n\n!\n\n!\n\n!\n\nDon’t\nMemorize,\n\nCompromise\nСамиздат\n\n47\n\n\n\n7 Reverse Engineering the LoRa PHY\nby Matt Knight\n\nIt’s 2016, and everyone’s favorite inescapable buz-\nzword is IoT, or the “Internet of Things.” The mere\nmention of this phrase draws myriad reactions, de-\npending on who you ask. A marketing manager\nmay wax philosophical about swarms of connected\ncars eradicating gridlock forever, or the inevitability\nof connected rat traps intelligently coordinating to\neradicate vermin from midtown Manhattan,18 while\na security researcher may just grin and relish in the\nplethora of low-power stacks and new attack surfaces\nbeing applied to cyber-physical applications.\n\nIoT is marketing speak for connected embedded\ndevices. That is, inexpensive, low power, resource\nconstrained computers that talk to each other, possi-\nbly on the capital-I Internet, to exchange data and\ncommand and control information. These devices\nare often installed in hard to reach places and can\nbe expected to operate for years. Thus, easy to con-\nfigure communication interfaces and extreme power\nefficiency are crucial design requirements. While 2G\ncellular has been a popular mechanism for connect-\ning devices in scenarios where a PAN or wired tech-\nnology will not cut it, AT&T’s plans to sunset 2G\non January 1, 2017 and LTE-M Rel 13’s distance\nto widespread adoption presents an opportunity for\nnew wireless specifications to seize market share.\n\nLoRa is one such nascent wireless technology\nthat is poised to capture this opportunity. It is a\nLow Power Wide Area Network (LPWAN), a class of\nwireless communication technology designed to con-\nnect low power embedded devices over long ranges.\nLoRa implements a proprietary PHY layer; there-\nfore the details of its modulation are not published.\n\nThis paper presents a comprehensive blind sig-\nnal analysis and resulting details of LoRa’s PHY,\nchronicles the process and pitfalls encountered along\nthe way, and aspires to offer insight that may assist\nsecurity researchers as they approach their future\nunknowns.\n\n7.1 Casing the Job\n\nI first heard of LoRa in December 2015, when it\nand other LPWANs came up in conversation among\nneighbors. Collectively we were intrigued by its ad-\nvertised performance and unusual modulation, thus\nI was motivated to track it down and learn more.\nIn the following weeks, I occasionally scanned the\n900 MHz ISM spectrum for signs of its distinctive\nwaveform (more on that soon), however searches in\nthe New York metropolitan area, Boston, and a col-\nleague’s search in San Francisco yielded no results.\n\nSometime later I found myself at an IoT security\nmeetup in Cambridge, MA that featured representa-\ntives from Senet and SIGFOX, two major LPWAN\nplayers. Senet’s foray into LoRa started when they\nsought to remotely monitor fluid levels in home heat-\ning oil tank measurement sensors to improve the ex-\nisting process of sending a guy in a truck to read it\nmanually. Senet soon realized that the value of this\ninfrastructure extended far beyond the heating oil\nmarket and has expanded their scope to becoming\na IoT cellular data carrier of sorts. While following\nup on the company I happened upon one of their\nmarketing videos online. A brief segment featured a\ngrainy shot of a coverage map, which revealed just\nenough to suggest the presence of active infrastruc-\nture in Portsmouth, NH. After quick drive with my\nEttus B210 Software Defined Radio, I had my first\nLoRa captures.\n\n7.2 First Observations and OSINT\n\nLoRa’s proprietary PHY uses a unique chirp spread\nspectrum (CSS) modulation scheme, which encodes\ninformation into RF features called chirps. A chirp\n\n18LoRaWan in the IoT Industrial Panel, presentation by Jun Wen of Cisco.\n\n48\n\n\n\nFigure 11. Spectrogram of a LoRa packet.\n\nis a signal whose frequency is increasing or decreas-\ning at a constant rate, and they are unmistakable\nwithin the waterfall. A chirp-based PHY is shown\nin Figure 11.\n\nContrasted with FSK or OFDM, two common\nPHYs, the differences are immediately apparent.\n\nModulation aside, visually inspecting a spectro-\ngram of LoRa’s distinct chirps reveals a PHY struc-\nture that is similar to essentially all other digital\nradio systems: the preamble, start of frame delim-\niter, and then the data or payload.\n\nSince LoRa’s PHY is proprietary, no PHY layer\nspecifications or reference materials were available.\nHowever, thorough analysis of open source and read-\nily available documentation can greatly abbreviate\nreverse engineering processes. When I conducted\nthis investigation, a number of useful documents\nwere available.\n\nFirst, the Layer 2+ LoRaWAN stack is pub-\nlished, containing clues about the PHY.\n\nSecond, several application notes were available\nfor Semtech’s commercial LoRa modules.19 These\nwere not specs, but they did reference some PHY-\nlayer components and definitions.\n\nThird, a European patent filing from Semtech\ndescribed a CSS modulation that could very well be\nLoRa.\n\nFinally, neighbors who came before me had\nproduced open-source prior art in the form of\na partial rtl-sdrangelove implementation and\na wiki page,20 however in my experience the\nrtl-sdrangelove attempt was piecemeal and ne-\nglected and the wiki contained only high level ob-\nservations. These were not enough to decode the\npackets that I had captured in New Hampshire.\n\n7.3 Demodulation\n\nOSINT gathering revealed a number of key defi-\nnitions that informed the reverse engineering pro-\ncess. A crucial notion is that of the spreading fac-\ntor (SF): the spreading factor represents the num-\nber of bits packed into each symbol. A symbol,\nfor the unordained, is a discrete RF energy state\nthat represents some quantity of modulated infor-\nmation (more on this later.) The LoRaWAN spec\nrevealed that the chirp bandwidth, that is the width\nof the channel that the chirps traverse, is 125 kHz,\n\n19Semtech AN1200.18, AN1200.22.\n20Decoding LoRa on the RevSpace Wiki\n\n49\n\n\n\n250 kHz, or 500 kHz within American deployments.\nThe chirp rate, which is intuitively the first deriva-\ntive of the signal’s frequency, is a function of the\nspreading factor and the bandwidth: it is defined as\nbandwidth/2(spreading_factor). Additionally, the\nabsolute value of the downchirp rate is the same as\nthe upchirp rate.21\n\nBack to the crucial concept of symbols. In LoRa,\nsymbols are modulated onto chirps by changing the\ninstantaneous frequency of the signal – the first\nderivative of the frequency, the chirp rate, remains\nconstant, while the signal itself “jumps” through-\nout its channel to represent data. The best way\nto intuitively think of this is that the modulation\nis frequency-modulating an underlying chirp. This\nis analogous to the signal alternating between two\nfrequencies in a 2FSK system, where one frequency\nrepresents a 0 and the other represents a 1. The\nunderlying signal in that case is a signal of constant\nfrequency, rather than a chirp, and the number of\nbits per symbol is 1. How many data bits are en-\ncoded into each frequency jump within LoRa? This\nis determined by the spreading factor.\n\nThe first step to extracting the symbols is to de-\nchirp the received signal. This is done by channeliz-\ning the received signal to the chirp’s bandwidth and\nmultiplying the result against a locally-generated\ncomplex conjugate of whichever chirp is being ex-\ntracted.\n\nA locally generated chirp might look like this.\n\nSince both upchirps and downchirps are present\nin the modulation, the signal should be multiplied\nagainst both a local upchirp and downchirp, which\nproduces two separate IQ streams. Why this works\ncan be reasoned intuitively, since waves obey su-\nperposition, multiplying a signal with frequency f0\nagainst a signal with frequency −f0 results in a sig-\nnal with frequency 0, or DC. If a chirp is multiplied\nagainst a copy of itself, it will result in a signal of\n2 ∗ f0, which will spread its energy throughout the\nband. Thus, generating a local chirp at the nega-\ntive chirp rate of whichever chirp is being processed\n\n21See Semtech AN1200.22.\n\n50\n\n\n\nresults in RF features with constant frequency that\ncan be handled nicely.\n\nIn following examples, the left image shows de-\nchirped upchirps while the right shows de-chirped\ndownchirps:\n\nThis de-chirped signal may be treated similarly\nto MFSK, where the number of possible frequen-\ncies is M = 2(spreading_factor). The Fast Fourier\nTransform (FFT) is the tool used to perform the\nactual symbol measurement. Fourier analysis shows\nthat a signal can be modeled as a summed series of\nbasic periodic functions (i.e., a sine wave) at various\nfrequencies. A FFT decomposes a signal into the fre-\nquency components that comprise it, returning the\npower and phase of each component present. Each\ncomponent to be extracted is colloquially called a\n“bin;” the number of bins is specified as the “FFT\nsize” or “FFT width.”\n\nThus, by taking an M -bin wide FFT of each IQ\nstream, the symbols may be resolved by finding the\nargmax, which is the bin with the most powerful\ncomponent of each FFT. This works out nicely be-\ncause a de-chirped CSS symbol turns into a signal\nwith constant frequency; all of the symbol’s energy\nshould fall into a single bin.22\n\nWith the signal de-chirped, the remainder of\nthe demodulation process can be described in three\nsteps. These steps mimic the process required for\nessentially all digital radio receivers.\n\nFirst, we’ll identify the start of the packet by\nfinding a preamble. Then, we’ll synchronize with\nthe start of the packet, so that we may conclude in\ndemodulating the payload by measuring its aligned\nsymbols.\n\n7.3.1 Finding the Preamble\n\nA preamble is a feature included in modulation\nschemes to announce that a packet is soon to fol-\nlow. By visual inspection, we can infer that LoRa’s\npreamble is represented by a series of continuous\nupchirps. Once de-chirped and passed through an\nFFT, all of the preamble’s symbols wind up resid-\ning within the same FFT bin. Thus, a preamble is\ndetected if enough consecutive FFTs have the same\nargmax.\n\n7.3.2 Synchronizing with the SFD\n\nWith our receiver aware that it’s about to receive\na packet, the next step is to accurately synchronize\nwith it so that symbols can be resolved accurately.\nTo facilitate this, modern radio systems often adver-\ntise the start of the packet’s data unit with a Start of\n\n22It may be possible to do this using FM demodulation rather than FFTs, however using FFTs preserves power information\nthat is useful for framing the packet without knowing its definitive length.\n\n51\n\n\n\nFrame Delimiter, or SFD, which is a known symbol\ndistinct from the preamble that receivers are pro-\ngrammed to look for. For LoRa, this is where the\ndownchirps come in.\n\nThe SFD is composed of two and one quarter\ndownchirps, while all the other symbols are repre-\nsented by upchirps. With preamble having been\nfound, our receiver should look for two consecutive\ndownchirps to synchronize against. It looks some-\nthing like the following:\n\nAccurate synchronization is crucial to properly\nresolving symbols. If synchronization is off by\nenough samples, when FFTs are taken each sym-\nbol’s energy will be divided between two adjacent\nFFTs. Until now, the FFT process used to resolve\nthe symbols processed 2(spreading_factor) samples\nper FFT with each sample being processed exactly\nonce, however after a few trial runs it became evi-\ndent that this coarse synchronization would not be\nsufficiently accurate to guarantee good fidelity.\n\nIncreasing the time-based FFT resolution was\nfound to be a reliable method for achieving an ac-\ncurate sync. This is done by shifting the stream of\nde-chirped samples through the FFT input buffer,\nprocessing each sample multiple times, to “overlap”\nadjacent FFTs. This increases the time-based res-\nolution of the FFT process at the expense of be-\ning more computationally intensive. Thus, overlap-\nping FFTs are only used to frame the SFD; non-\noverlapped FFTs with each sample being processed\nexactly once are taken otherwise to balance accuracy\nand computational requirements.\n\nTechnically there’s also a sync word that pre-\ncedes the SFD, but my demodulation process de-\nscribed in this article does not rely on it.\n\n7.3.3 Demodulating the Payload\n\nNow synchronized against the SFD, we are able\nto efficiently demodulate the symbols in the pay-\nload by using the original non-overlapping FFT\nmethod. However, since our receiver’s locally gen-\nerated chirps are likely out of phase with the chirp\nused by the transmitter, the symbols appear offset\nwithin the set range [0 : 2(spreading_factor)−1] by\nsome constant. It was surmised that the preamble\nwould be a reliable element to represent symbol 0,\nespecially given that the aforementioned sync word’s\nvalue is always referenced from the preamble. A sim-\nple modulo operation to normalize the symbol value\nrelative to the preamble’s zero-valued bin produces\nthe true value of the symbols, and the demodulation\nprocess is complete.\n\n7.4 Decoding, and its Pitfalls\n\nOverall, demodulation proved to not be too difficult,\nespecially when you have someone like Balint See-\nber feeding you advice and sagely wisdom. However,\ndecoding is where the fun (and uncertainty) really\nbegan.\n\nFirst, why encode data? In order to increase\nover the air resiliency, data is encoded before it is\nsent. Thus, the received symbols must be decoded\nin order to extract the data they represent.\n\nThe documentation I was able to gather on LoRa\ncertainly suggested that figuring out the decoding\nwould be a snap. The patent application describ-\ning a LoRa-like modulation described four decoding\nsteps that were likely present. Between the patent\nand some of Semtech’s reference designs, there were\ndocumented algorithms or detailed descriptions of\nevery step. However, these documents slowly proved\nto be lies, and my optimism proved to be misplaced.\n\n7.4.1 OSINT Revisited\n\nPerhaps the richest source of overall hints was\nSemtech’s European patent application.23 The\npatent describes a CSS-based modulation with an\nuncanny resemblance to LoRa, and goes so far as\nto walk step-by-step through the encoding elements\npresent in the PHY. From the encoder’s perspec-\ntive, the patent describes an encoding pipeline of\nforward error correction, a diagonal interleaver, data\nwhitening, and gray indexing, followed by the just-\ndescribed modulation process. The reverse process\n\n23European Patent #13154071.8/EP20130154071\n\n52\n\n\n\nFigure 12. The top is pre-sync and non-overlapped, middle is pre-sync overlapped, bottom is synchronized\nand non-overlapped.\n\n53\n\n\n\nwould be performed by the decoder. The patent\neven defines an interleaver algorithm, and Semtech\ndocumentation includes several candidate whitening\nalgorithms.\n\nThe first thing to try, of course, was to imple-\nment a decoder exactly as described in the docu-\nmentation. This involved, in order:\n\n1. Undoing gray coding applied to the symbols.\n\n2. Dewhitening using the algorithms defined in\nSemtech’s documentation.\n\n3. Deinterleaving using the algorithm defined in\nSemtech’s patent.\n\n4. Processing the Hamming forward error correc-\ntion hinted at in Semtech’s documentation.\n\nFirst, let’s review what we have learned about\neach step listed above based on open-source re-\nsearch, and what would be attempted as a result.\n\nGray Indexing Given the nomenclature ambigu-\nity in the Semtech patent, I also decided to test no\ngray coding and reverse gray coding in addition to\nforward gray coding. These were done using stan-\ndard algorithms.\n\nData Whitening Data whitening was a colossal\nquestion mark while looking at the system. An ideal\nwhitening algorithm is pseudorandom, thus an effec-\ntive obfuscator for all following components of the\nsystem. Luckily, Semtech appeared to have pub-\nlished the algorithm candidates in Application Note\nAN1200.18. Entitled “Implementing Data Whiten-\ning and CRC Calculation in Software on SX12xx\nDevices,” it describes three different whitening algo-\nrithms that were relevant to the Semtech SX12xx-\nseries wireless transceiver ICs, some of which sup-\nport LoRa. The whitening document provided one\nCCITT whitening sequences and two IBM methods\nin C++. As with the gray indexing uncertainty, all\nthree were implemented and permuted.\n\nInterleaver Interleaving refers to methods of de-\nterministically scrambling bits within a packet. It\nimproves the effectiveness of Forward Error Correc-\ntion, and will be elaborated on later in this text.\nThe Semtech patent application defined a diago-\nnal interleaver as LoRa’s probable interleaver. It is\na block-style non-additive diagonal interleaver that\n\nshuffles bits within a block of a fixed size. The in-\nterleaver is defined as: Symbol(j, (i + j)%PPM) =\nCodeword(i, j) where 0 <= i < PPM, 0 <= j <\n4 + RDD In this case, PPM is set to the spreading\nfactor (or spreading_factor−2 for the PHY header\nand when in low data rate modes), and RDD is set\nto the number of parity bits used by the Forward\nError Correction scheme (ranging [1 : 4]).\n\nThere was only one candidate illustrated here,\nso no iteration was necessary.\n\nForward Error Correction The Semtech patent\napplication suggests that Hamming FEC be used.\nOther documentation appeared to confirm this. A\ncustom FEC decoder was implemented that orig-\ninally just extracted the data bits from their stan-\ndard positions within Hamming(8,4) codewords, but\nearly results were negative, so this was extended to\napply the parity bits to repair errors.\n\nUsing a Microchip RN2903 LoRa Mote, a transmit-\nter that was understood to be able to produce raw\nframes, a known payload was sent and decoded us-\ning this process. However, the output that resulted\nbore no resemblance to the expected payload. The\nnext step was to inspect and validate each of the\nalgorithms derived from documentation.\n\nAfter validating each component, attempting ev-\nery permutation of supplied algorithms, and inspect-\ning the produced binary data, I concluded that\nsomething in LoRa’s described encoding sequence\nwas not as advertised.\n\n7.5 Taking Nothing for Granted\nThe nature of analyzing systems like this is that\nbeneath a certain point they become a black box.\nData goes in, some math gets done, RF happens,\nsaid math gets undone, and data comes out. Sim-\nple enough, but when encapsulated as a totality it\nbecomes difficult to isolate and chase down bugs in\neach component. Thus, the place to start was at the\ntop.\n\n54\n\n\n\n7.5.1 How to Bound a Problem\n\nThe Semtech patent describes the first stage of de-\ncoding as “gray indexing.” Gray coding is a process\nthat maps bits in such a way that makes it resilient\nto off-by-one errors. Thus, if a symbol were to be\nmeasured within ±1 index of the correct bin, the\ngray coding would naturally correct the error. “Gray\nindexing,” ambiguously referring to either gray cod-\ning or its inverse process, was initially understood\nto mean forward gray coding.\n\nThe whitening sequence was next in line. Data\nwhitening is a process applied to transmitted data\nto induce randomness into it. To whiten data, the\ndata is XORed against a pseudorandom string that\nis known to both the transmitter and the receiver.\nThis does good things from an RF perspective, since\nit induces lots of features and transitions for a re-\nceiver to perform clock recovery against. This is\nfunctionally analogous to line coding schemes such\nas Manchester encoding, but whitening offers one\npro and one con relative to line coding: data whiten-\ning does not impact the effective bit rate as Manch-\nester encoding does,24 but this comes at the expense\nof legibility due to the pseudorandom string.\n\nAt this point, it is important to address some of\nthe assumptions and inferences that were made to\nframe the following approach. While the four de-\ncoding stages were thrown into question by virtue\nof the fact that at least one of the well-described\nalgorithms was not correct, certain implied proper-\nties could be generalized for each class of algorithm,\neven if the implementation did not match exactly.\n\nI made a number of assumptions at this point,\nwhich I’ll describe in turn.\n\nFirst, the interleaver in use is non-additive. This\nmeans that while it will reorder the bits within each\ninterleaving block, it will not cause any additional\nbits to be set or unset. This was a reasonable\n\nassumption because many block-based interleavers\nare non-additive, and the interleaver defined in the\npatent is non-additive as well. Even if the interleaver\nused a different algorithm, such as a standard block\ninterleaver or a different type of diagonal interleaver,\nit could still fit within this model.\n\nSecond, the forward error correction in use is\nHamming FEC, with 4 data bits and 1-4 parity bits\nper codeword. FEC can be thought of as super-\ncharged parity bits. A single parity bit can indicate\nthe presence of an error, but if you use enough of\nthem they can collectively identify and correct er-\nrors in place, without re-transmission. Hamming is\nspecifically called out by the European patent, and\nthe code rate parameter referenced throughout ref-\nerence designs fits nicely within this model. The use\nof Hamming codes, as opposed to some other FEC\nor a cyclic coding scheme, was fortuitous because\nof a property of the Hamming code words. Ham-\nming codeword mapping is deterministic based on\nthe nybble that is being encoded. Four bits of data\nprovide 16 possible codewords. When looking at\nHamming(8,4) (which is the inferred FEC for LoRa\ncode rate 4/8), 14 of the 16 codewords contain four\nset bits (1s) and four unset bits (0s). However, the\ncode words for 0b0000 and 0b1111 are 0b00000000\nand 0b11111111, respectively.\n\nThus, following on these two assumptions, if a\npayload containing all 0x00s or 0xFFs were sent,\nthen the interleaving and forward error correction\nshould cancel out and not affect the output at all.\nThis reduces our unknown stages in the decoding\nchain from four to just two, with the unknowns be-\ning gray indexing and whitening, and once those are\nresolved then the remaining two can be solved for!\n\nSince “gray indexing” likely refers to gray cod-\ning, reverse gray coding, or no coding should it be\nomitted, this leaves only three permutations to try\nwhile solving for the data whitening sequence.\n\nThe first step was to take a critical look at\nthe data whitening algorithms provided by Semtech\nAN1200.18. Given the detail and granularity in\nwhich they are described, plus the relevance of\nhaving come straight from a LoRa transceiver\ndatasheet, it was almost a given that one of the three\nalgorithms would be the solution. With the inter-\nleaver and FEC effectively zeroed out, and “gray in-\ndexing” reduced to three possible states, it became\npossible to test each of the whitening algorithms.\n\nTesting each whitening algorithm was fairly\n24Manchester’s effective bit rate is 1/2 baud rate.\n\n55\n\n\n\nstraightforward. A known payload of all 0x00s or\n0xFFs (to cancel out interleaving and FEC) was\ntransmitted from the Microchip LoRa Technology\nMote and then decoded using each whitening al-\ngorithm and each of the possible “gray indexing”\nstates. This resulted in 9 total permutations. A\nvisual diff of the decoded data versus the expected\npayload resulted in no close matches. This was re-\nplaced with a diff script with a configurable toler-\nance for bits that did not match. This also resulted\nin no matches as well. One final thought was to\nforward compute the whitening algorithms in case\nthere was a static offset or seed warm-up, as can\nbe the case with other PRNG algorithms. Likewise,\nthis did not reveal any close matches. This meant\nthat either none of the given whitening algorithms\nin the documentation were utilized, or the assump-\ntions that I made about the interleaver and FEC\nwere not correct.\n\nAfter writing off the provided whitening algo-\nrithms as fiction, the next course of action was to\nattempt to derive the real whitening algorithm from\nthe LoRa transmitter itself. This approach was\nbased on the previous observations about the FEC\nand interleaver and a fundamental understanding of\nhow data whitening works. In essence, whitening is\nas simple as XORing a payload against a static pseu-\ndorandom string, with the same string used by both\nthe transmitter and receiver. Since anything XORed\nwith zero is itself, passing in a string of zeroes causes\nthe transmitter to reveal a “gray indexed” version of\nits whitening sequence.\n\nThis payload was received, then transformed into\nthree different versions of itself: one gray-coded, one\nunmodified, and one reverse gray-coded. All three\nwere then tested by transmitting a set of 0xF data\nnybbles and using each of the three “gray indexing”\ncandidates and received whitening sequence to de-\ncode the payload. The gray coded and unmodified\nversions proved to be incorrect, but the reverse gray\ncoding version successfully produced the transmit-\nted nybbles, and thus in one fell swoop, I was able\nto both derive the whitening sequence and discern\nthat “gray indexing” actually referred to the reverse\ngray coding operation. With “gray indexing” and\nwhitening solved, I could turn my attention to the\nbiggest challenge: the interleaver.\n\n7.5.2 The Interleaver\n\nAt this point we’ve resolved two of the four signal\nprocessing stages, disproving their documentation\n\nin the process. Following on this, the validity of the\ninterleaver definition provided in Semtech’s patent\nwas immediately called into question.\n\nA quick test was conducted against a local im-\nplementation of said interleaver: a payload com-\nprised of a repeated data byte that would produce\na Hamming(8,4) codeword with four set and four\nunset bits was transmitted and the de-interleaved\nframe was inspected for signs of the expected code-\nword. A few other iterations were attempted, in-\ncluding reversing the diagonal offset mapping pat-\ntern described by the patent and using the inverse\nof the algorithm (i.e., interleaving the received pay-\nload rather than de-interleaving it). Indeed, I was\nable to conclude that the interleaver implemented by\nthe protocol is not the one suggested by the patent.\nThe next logical step is to attempt to reverse it.\n\nWithin a transmitter, interleaving is often ap-\nplied after forward error correction in order to make\nthe packet more resilient to burst interference. In-\nterleaving scrambles the FEC-encoded bits through-\nout the packet so that if interference occurs it is\nmore likely to damage one bit from many codewords\nrather than several bits from a single codeword. The\nformer error scenario would be recoverable through\nFEC, the latter would result in unrecoverable data\ncorruption.\n\nBlock-based interleavers, like the one described\nin the patent, are functionally straightforward.\nThe interleaver itself can be thought of as a two-\ndimensional array, where each row is as wide as the\nnumber of bits in each FEC codeword and the num-\nber of columns corresponds to the number of FEC\ncodewords in each interleaver block. The data is\nthen written in row-wise and read out column-wise;\nthus the first output “codeword” is comprised of the\nLSB (or MSB) of each FEC codeword. A diagonal\ninterleaver, as suggested in the patent, offsets the\ncolumn of the bit being read out as rows are tra-\nversed.\n\nUnderstanding the aforementioned fundamentals\nof what the interleaver was likely doing was essen-\ntial to approaching this challenge. Ultimately, given\nthat a row-column or row-diagonal relationship de-\nfines most block-based interleavers, I anticipated\nthat patterns that could be revealed if approached\nappropriately. Payloads were therefore constructed\nto reveal the relationship of each row or codeword\nwith a corresponding diagonal or column. In order\nto reveal said mapping, the Hamming(8,4) codeword\nfor 0xF was leveraged, since it would fill each row\n\n56\n\n\n\n0x0000000F 0x000000F0 0x00000F00 0x0000F000 0x000F0000 0x00F00000 0x0F000000 0xF0000000\n00100011 11000000 00001001 11010000 00000011 01000100 01000001 00001000\n00010011 00100101 00000111 00001001 00000011 00000011 10000010 01000101\n00001001 00010001 00000011 00000101 01000001 00000000 00100001 10000011\n00000111 00001101 00000011 00000110 10000010 01000101 00010010 00100011\n00000000 00001100 01000010 00001000 00100010 10001001 00001010 00010011\n00000100 00000000 10000001 01000010 00010001 00100010 00000111 00001011\n01000011 00000001 00100001 10000000 00001001 00010000 00000011 00000111\n10000101 01000111 00010000 00100101 00000000 00001111 00000101 00000111\n\nFigure 13. Symbol Tests\n\nwith eight contiguous bits at a time. Payloads con-\nsisting of seven 0x0 codewords and one 0xF code-\nword were generated, with the nybble position of\n0xF iterating through the payload. See Figure 13.\n\nAs one can see, by visualizing the results as they\nwould be generated by the block, patterns associ-\nated with each codeword’s diagonal mapping can be\nidentified. The diagonals are arbitrarily offset from\nthe corresponding row/codeword position. One im-\nportant oddity to note is that the most significant\nbits of each diagonal are flipped.\n\nWhile we now know how FEC codewords map\ninto block diagonals, we do not know where each\ncodeword starts and ends within the diagonals, or\nhow its bits are mapped. The next step is to map\nthe bit positions of each interleaver diagonal. This\nis done by transmitting a known payload comprised\nof FEC codewords with 4 set and 4 unset bits and\nlooking for patterns within the expected diagonal.\n\n1 Payload : 0xDEADBEEF\nb i t 76543210\n\n3 00110011\n10111110\n\n5 11111010\n11011101\n\n7 10000010\n10000111\n\n9 11000000\n10000010\n\nReading out the mapped diagonals results in the\nfollowing table.\n\nT Bot\nD 1 0 1 0 0 0 0 1\nE 0 1 1 1 0 1 0 0\nA 0 1 0 1 1 0 0 0\nD 1 0 1 1 0 0 0 0\nB 1 1 0 0 0 0 1 0\nE 0 1 1 1 0 1 0 0\nE 0 1 1 1 0 1 0 0\nF 1 1 1 1 1 1 1 1\nWhile no matches immediately leap off the page,\n\nmanipulating and shuffling through the data begins\n\nto reveal patterns. First, reverse the bit order of the\nextracted codewords:\n\nB Top\nD 1 0 0 0 0 1 0 1\nE 0 0 1 0 1 1 1 0\nA 0 0 0 1 1 0 1 0\nD 0 0 0 0 1 1 0 1\nB 0 1 0 0 0 0 1 1\nE 0 0 1 0 1 1 1 0\nE 0 0 1 0 1 1 1 0\nF 1 1 1 1 1 1 1 1\nAnd then have a look at the last nybble for each\n\nof the highlighted codewords:\nB Top\n\nD 1 0 0 0 0 1 0 1\nE 0 0 1 0 1 1 1 0\nA 0 0 0 1 1 0 1 0\nD 0 0 0 0 1 1 0 1\nB 0 1 0 0 0 0 1 1\nE 0 0 1 0 1 1 1 0\nE 0 0 1 0 1 1 1 0\nF 1 1 1 1 1 1 1 1\nSix of the eight diagonals resemble the data em-\n\nbedded into each of the expected FEC encoded code-\nwords! As for the first and fifth codewords, it is\npossible they were damaged during transmission, or\nthat the derived whitening sequence used for those\npositions is not exact. That is where FEC proves its\nmettle – applying Hamming(8,4) FEC would repair\nany single bit errors that occurred in transmission.\nThe Hamming parity bits that are expected with\neach codeword are calculated using the Hamming\nFEC algorithm, or can be looked up for standard\nschemes like Hamming(7,4) or Hamming(8,4).\n\nData (8 , 4 ) Par i ty Bi t s\n2 0xD 1101 1000\n\n0xE 1110 0001\n4 0xA 1010 1010\n\n0xD 1101 1000\n6 0xB 1011 0100\n\n0xE 1110 0001\n8 0xE 1110 0001\n\n0xF 1111 1111\n\n57\n\n\n\nWhile the most standard Hamming(8,4) bit or-\nder is: p1, p2, d1, p3, d2, d3, d4, p4 (where p are\nparity bits and d are data bits), after recognizing the\nabove data values we can infer that the parity bits\nare in a nonstandard order. Looking at the diago-\nnal codeword table and the expected Hamming(8,4)\nencodings together, we can map the actual bit posi-\ntions:\n\nBot Top\np1 p2 p4 p3 d1 d2 d3 d4\n\nD 1 0 0 0 0 1 0 1\nE 0 0 1 0 1 1 1 0\nA 0 0 0 1 1 0 1 0\nD 0 0 0 0 1 1 0 1\nB 0 1 0 0 0 0 1 1\nE 0 0 1 0 1 1 1 0\nE 0 0 1 0 1 1 1 0\nF 1 1 1 1 1 1 1 1\nNote that parity bits three and four are swapped.\n\nWith that resolved, we can use the parity bits to de-\ncode the forward error correction, resulting in four\nbits being corrected, as shown in Figure 14.\n\nThat’s LoRa!\n– — — – — — — — – — –\n\nHaving reversed the protocol, it is important to\nlook back and reflect on how and why this worked.\nAs it turned out, being able to make assumptions\nand inferences about certain goings-on was crucial\nfor bounding the problem and iteratively verify-\ning components and solving for unknowns. Recall\nthat by effectively canceling out interleaving and\nforward error correction, I was able to effectively\nsplit the problem in two. This enabled me to solve\nfor whitening, even though “gray indexing” was un-\nknown there were only three permutations, and with\nthat in hand, I was able to solve for the interleaver,\nsince FEC was understood to some extent. Just like\nalgebra or any other scientific inquiry, it comes down\nto controlling your variables. By stepping through\nthe problem methodically and making the right in-\nferences, we were able to reduce 4 independent vari-\nables to 1, solve for it, and then plug that back in\nand solve for the rest.\n\n7.6 Remaining Work\nWhile the aforementioned process represents a com-\nprehensive description of the PHY, there are a few\npieces that will be filled in over time.\n\nThe LoRa PHY contains an optional header with\nits own checksum. I have not yet reversed the\n\nheader, and the Microchip LoRa module I’ve used\nto generate LoRa traffic does not expose the option\nof disabling the header. Thus I cannot zero those\nbits out to calculate the whitening sequence applied\nto it. It should be straightforward to fill in with the\ncorrect hardware in hand.\n\nThe PHY header and service data unit/payload\nCRCs have not been investigated for the same rea-\nson. This should be easy to resolve through the use\nof a tool like CRC RevEng once the header is known.\n\nIn my experience, for demodulation purposes\nclock recovery has not been necessary beyond get-\nting an accurate initial sync on the SFD. However\nshould clock drift pose a problem, for example if\ntransmitting longer messages or using higher spread-\ning factors which have slower data rates/longer over-\nthe-air transmission times, clock recovery may be\ndesirable.\n\n7.7 Shameless Plug\n\nI recently published an open source GNU Radio\nOOT module that implements a transceiver based\non this derived version of the LoRa PHY. It is pre-\nsented to empower RF and security researchers to\ninvestigate this nascent protocol.25\n\n25git clone https://github.com/BastilleResearch/gr-lora\nunzip pocorgtfo13.pdf gr-lora.tar.bz2\n\n58\n\n\n\nTop\np1 p2 p4 p3 d1 d2 d3 d4\n\nD 1 0 0 0 1 1 0 1 1101 = 0xD\nE 0 0 1 0 1 1 1 0 1110 = 0xE\nA 1 0 0 1 1 0 1 0 1010 = 0xA\nD 1 0 0 0 1 1 0 1 1101 = 0xD\nB 0 1 0 0 1 0 1 1 1011 = 0xB\nE 0 0 1 0 1 1 1 0 1110 = 0xE\nE 0 0 1 0 1 1 1 0 1110 = 0xE\nF 1 1 1 1 1 1 1 1 1111 = 0xF\n\nFigure 14. Forward Error Corrected bits shown in bold\n\n7.8 Conclusions and Key Takeaways\nPresented here is the process that resulted in a com-\nprehensive deconstruction of the LoRa PHY layer,\nand the details one would need to implement the\nprotocol. Beyond that, however, is a testament to\nthe challenges posed by red herrings (or three of\nthem, all at once) encountered throughout the re-\nverse engineering process. While open source in-\ntelligence and documentation can be a boon to re-\nsearchers – and make no mistake, it was enormously\nhelpful in debunking LoRa – one must remember\nthat even the most authentic sources may sometimes\nlie!\n\nAnother point to take away from this is the im-\nportance of bounding problems as you solve them,\nincluding through making informed inferences in the\nabsence of perfect information. This of course must\nbe balanced with the first point about OSINT, is\nknowing when to walk away from a source. How-\never as illustrated above, drawing appropriate con-\nclusions proved integral to reducing and solving for\neach of the decoding elements within a black-box\nmethodology.\n\nThe final thought I will leave you with is that\nwireless doesn’t just mean Wi-Fi anymore - it in-\ncludes cellular, PANs, LPWANs, and everything in\nbetween. Accordingly, a friendly reminder that se-\ncurity monitoring and test tools don’t exist until\nsomeone creates them. Monitor mode and Wire-\nshark weren’t always a thing, so don’t take them\nfor granted: it’s time to make the next generation\nof wireless networks visible to researchers, because\nknow it or not it is already here and is here to stay.\n\n59\n\n\n\n8 Plumbing, not Popper;\nor, the Problem with STEP\n\nby Pastor Manul Laphroaig\n\nGather round, neighbors. We are going to a mag-\nical place. One that we hardly ever notice in our\nbusy lives, but which has a way of taking over your\nentire day when you are forced to visit it. We are\ngoing on a trip to the plumbing closet!26\n\nLook at the miracle that is the clump of pipes,\nlooking right back at you. Its message is clear: do\nnot approach without skill, unless you like wet, gi-\ngantic messes. This message is universal: it speaks\nto a politician, a professor, an NYT columnist, a\nmovie actor, and a hedge fund manager alike. It\ntranscends languages and beliefs.\n\nEven though these worthies and civic leaders\nmight agree the country could use more plumbers,\nit has not yet occurred to them to approach the\nproblem by putting a big P into some popular slo-\ngan like “STEP” (Science, Technology, Engineering,\nPlumbing), by setting up a federal Department of\nPlumbing, or by lionizing a professional coveralls-\nwearer TV personality who goes by “A Plumbing\nGuy,” despite never having fixed a pipe in his life.\n\nThey somehow know that these things will do\ndiddly squat to address the shortage of plumbers.\nThey know deep down that to learn plumbing—and\neven to not sound ridiculous about it—one needs to\n\nstudy with a plumber, attach oneself to a plumber,\nand do what a plumber does for a while. This, neigh-\nbors, is how deep the plumbing magic goes.\n\nScience, alas, has not been so lucky.\n– — — – — — — — – — –\n\nIt is fashionable to talk about how we need more\nscientists, and how we can direct and improve sci-\nence, quoting grand theories that explain science,\nwhile similarly educated people nod approvingly.\nAfter all, they all know what science is, as befits\nall forward-thinking people these days. No one feels\nawkward; everyone feels good.\n\nPerhaps this happens because our social betters\nall experienced helplessness at the sight of broken\nplumbing, but would not recognize broken science,\nmuch less a hopelessly broken science textbook. You\nsee, science lab equipment is OK with a patroniz-\ning, self-satisfied gaze, whereas plumbing has a way\nof glaring back contemptuously, daring you to use\nyour general theoretical understanding.\n\nWith plumbing, it’s either practical skill or\na huge mess in your basement. Messing with\nhow plumbers learn and teach this skill guarantees\nmesses in thousands of basements. If you value your\nplumbing, it’s wise to leave plumbers alone even if\nyou believe every word of every newspaper column\nyou’ve ever read on plumbing economy.\n\nIt may be a surprise to the readers of Karl Pop-\nper and Imre Lakatos27 that actual scientists are\nhelped by philosophy of science in exactly the same\nway as plumbers are helped by the Zen of Plumb-\ning. Although these very same people are likely to\nbelieve they understand plumbing too, they usually\nhave the sense to leave the plumbing profession well\nalone, and not apply their philosophical understand-\nings to it—being empirically familiar with the fact\nthat when you need plumbing done, philosophy is\nuseless; only the skill stands between the water in\nyour pipes and your expensive library.\n\n– — — – — — — — – — –\n26For those of you fortunate to own a house, it’s probably in the corner of your basement, an equally magical place, whence\n\nall science and innovation springs forth—but let us not digress.\n27Lakatos the philosopher is considered to be a great intellectual authority. For what it’s worth, you might also want to read\n\nabout how he applied his philosophy in real life: unzip pocorgtfo13 freudenthal.pdf\n\n60\n\n\n\n61\n\nMceAVITY’S PLUMBER S’\n\nPLUMBERS’ TOOLS\n\nPlate 2213\nShave Hook.\nPrice, per Doz... .$6.00\n\nPlate 2211\nTap Borer. Price, per Doz.$6.00\n\nPlate 2212 Plate 2215\nPlate 2214 Bibb reseating Tool with Cutters Bench Mallet\nPlumbers’ Snips For $6''-19\"-26\"-34\" Bibbs. Price, per Doz : $6.00\nNo. 5 3 % ” Cut Each. .$3.50 Price, Each................-- $5.00 2 es\nNo. 3.00 Extra Cutters, per set......... 2.50\nNo. 10 2 y \"\n\nPlate 2217\nLead Pipe Bending Spring\nSizes 1” 14%\" 1144” 2”\nPlate 2216 Price, Each....... $1.25 $1.50 $1.75 $2.00\n\n. Burner Pliers\nSizes a rr LE ; a\n\nPrice, Each.$ .75 $1.00 $1.25\n\nPlate 22110\n. . . Steel Bend Iron\n\nPlate 2219— Combination Pliers Price, Each.... ......... $ .75\nSizes 6” 8” — 10”\nNickel Plated..$ 1.50 $1.75 $2.00\n\nPlate 2218 Polished Steel.. 1.25 1.50 1.75\n\nBoxwood Lead Dresser Blue finished\nPrice, per Doz..........$15.00 Steel..... 1.00\n\nPlate 21111\n‘* Rivetting Hammer ”’\nSizes 1” 2” 3”\nPrice...... $1.50 $1.25 $1.00\n\nCold Chisel................20000- Yr 5\"\nPrice, Each................02005. $ .50° $.75\n\nPlate 22113—Capé Chisel\nPrice, Each, 34”...........0..0005 $ .50\n\nPlate 22114 Plate 22115 Plate 22116\nStraight Caulking Chisel Picking Chisel Regular Caulking Chisel\nPrice, Each............ $ .75 Price, Each........ $ .75 Size, 34’’ Price, Each. ...$ .75\n\nreo —r\nPlate 22118\nPlate 22117 Rand L Hand Caulking Chisel Plate 22119\nLong Packing Iron Price, Each........... 1.00 Round nose Pliers,\nSize, 18”. Price, Each.... $ .75 rey aE $ Stocked from 4” to 8”\n\n61\n\n\n\n\nBy far the worst hit to a profession is delivered\nwhen a part of the professionals actually welcomes\nphilosophers lauding it, politicians bearing gifts and\ngrants, and governments setting up departments to\npromote it. Forms to fill, ever-growing grant appli-\ncation paperwork, pervasive “performance metrics,”\nand having to explain basic fallacies to the well-\nmeaning but fundamentally ignorant and hugely\npowerful committees come later—and accumulate.\nIn the context of metrics, charlatans always win, be-\ncause they don’t get distracted by trying for actual\nresults.\n\nNot to mention that the money that goes to char-\nlatans is not net-neutral for actual plumbing (or sci-\nence); it is net-negative, because charlatans have a\nway of making the lives of professionals hard where\nit hurts the most. When Tim “the Tool Man” Tay-\nlor waves power tools around with a swagger, the\n\nresults are immediate and obvious. When learned\ncommittees do the professional equivalent thereof to\nmath textbooks and call it nice names like “Discov-\nery Math,” “Common Core,” or “Critical Thinking”\nit takes a generation to notice, and then we wonder—\nhow on earth did school math become unteachable\nand unlearnable?28\n\nPlumbers have wisely avoided it, perhaps due to\nsome secret wisdom passed from master to appren-\ntice through the ages. Scientists, I am sorry to say,\nwalked right into it around the middle of the twen-\ntieth century.\n\nSure enough, national agencies got us to the\nmoon—but it seems that all the good science school-\nbooks have been put on the rockets going there,\nnever to return. Have you met many scientists who\nare happy with what schools do to their sciences\nafter half a century of being improved by various\ngovernment offices?\n\nFunny how it worked out for scientists. Now hear\nthem complain about “publish or perish,” the rapidly\nrising age at which one finally succeeds in getting\none’s first grant, and the relentless race to rebrand\nand follow the current big-ticket grant programs.29\n\nBut don’t blame them, neighbors; it was their\nadvisors or their advisors’ advisors who fell for it.\nBetter to buy them a drink, and remember their\nlesson.\n\nBetter yet, find some plumbers, and buy them\ndrinks. Perhaps they’ll share with you some of their\nsecrets of how to keep the philosophers and their\neducated and benevolent readers interested in the\nresult, but at a safe distance from the actual plumb-\ning.\n\n28We sort of know the answer, neighbors: a roller coaster of reforms and unintelligible standards created a generation of math\nteachers for whom math did not have to make sense. unzip pocorgtfo13.pdf wu-preparing-teachers.pdf and read it. It may\napply to whatever else you hold dear.\n\n29According to Ronald J. Daniels, President of Baltimore’s Johns Hopkins University, no less than the whole generation\nis at risk: “A generation at risk: Young investigators and the future of the biomedical workforce.” (unzip pocorgtfo13.pdf\natrisk.pdf.) For more of this, read “Science in the Age of Selfies” by Donald Geman, Stuart Geman. (selfies.pdf.) It’s hard\nto make these things up, neighbors.\n\n62\n\n\n\n9 Where is ShimDBC.exe?\nby Geoff Chappell\n\nMicrosoft’s Shim Database Compiler might be a\nlegend . . . except that nobody seems ever to have\nmade any story of it. It might be mythical . . . ex-\ncept that it actually does exist. Indeed, it has been\naround for 15 years in more or less plain sight. Yet\nif you ask Google to search the Internet for occur-\nrences of shimdbc, and especially of “shimdbc.exe”\nin quotes, you get either remarkably little or a tan-\ntalising hint, depending on your perspective.\n\nMostly, you get those scam sites that have pre-\npared a page for seemingly every executable that\nhas ever existed and can fix it for you if only you\nwill please download their repair tool. But amongst\nthis dross is a page from Microsoft’s TechNet site.\nGoogle excerpts that “QFixApp uses the support\nutility ShimDBC.exe to test the group of selected\nfixes.” Follow the link and you get to one of those\nrelatively extensive pages that Microsoft sometimes\nwrites to sketch a new feature for system adminis-\ntrators and advanced users (if not also to pat them-\nselves on the back for the great new work). This\npage is from 2001 and is titled Windows XP Appli-\ncation Compatibility Technologies.30\n\n9.1 Application Compatibility?\n\nThere can’t be anything more boring in the whole\nof Windows, you may think. I certainly used to,\nand might still for applications if I cared enough,\nbut Windows 8 brought Application Compatibility\nto kernel mode in a whole new way, and this I do\ncare about.\n\nThe integrity of any kernel-mode driver that you\nor I write nowadays depends on what anyone else,\nwell-meaning or not, can get into the DRVMAIN.SDB\nfile in the AppPatch subdirectory of the Windows\ninstallation. This particular Shim Database file ex-\nists in earlier Windows versions too, but only to list\ndrivers that the kernel is not to load. If you’re the\nwriter of a driver, there’s nothing you can do at run-\ntime about your driver being blocked from loading,\nand in some sense you’re not even affected: you’re\nnot loaded and that’s that. Starting with Win-\ndows 8, however, the DRVMAIN.SDB file defines the\ninstalled shim providers and either the registry or\nthe file can associate your driver with one or more of\nthese defined shim providers. When your driver gets\nloaded, the applicable shim providers get loaded too,\nif they are not already, and before long your driver’s\nimage in memory has been patched, both for how it\ncalls out through its Import Address Table and how\nit gets called, e.g., to handle I/O requests.\n\nIn this brave new world, is your driver really\nyour driver? You might hope that Microsoft would\nat least give you the tools to find out, if only so\nthat you can establish that a reported problem with\nyour driver really is with your driver. After all,\nfor the analogous shimming, patching, and what-\never of applications, Microsoft has long provided an\nApplication Compatibility Toolkit (ACT), recently\nre-branded as the Windows Assessment and Deploy-\nment Kit (ADK). The plausible thoroughness of this\nkit’s Compatibility Administrator in presenting a\ntree view of the details is much of the reason that\nI, for one, regarded the topic as offering, at best,\nslim pickings for research. For the driver database,\nhowever, this kit does nothing—well, except to leave\nme thinking that the SDB file format and the API\nsupport through which SDB files get interpreted,\ncreated, and might be edited, are now questions I\nshould want to answer for myself rather than imag-\n\n30https://technet.microsoft.com/library/bb457032.aspx\n\n63\n\n\n\nine they’ve already been answered well by whoever\nmanaged somehow to care about Application Com-\npatibility all along.\n\n9.2 The SDB File Format\n\nRelax! I’m not taking you to the depths of Applica-\ntion Compatibility, not even just for what’s specific\nto driver shims. Our topic here is reverse engineer-\ning. Now that you know what these SDB files are\nand why we might care to know what’s in them,\nI expect that if you have no interest at all in Ap-\nplication Compatibility, you can treat this part of\nthis article as using SDB files just as an example\nfor some general concerns about how we present\nreverse-engineered file formats. (And please don’t\nskip ahead, but I promise that the final part is pretty\nmuch nothing but ugly hackery.)\n\nLet’s work even more specifically with just one\nexample of an SDB file, shown in Figure 15. It’s a\nlittle long, despite being nearly minimal. It defines\none driver shim but no drivers to which this shim is\nto be applied.\n\nAlthough Microsoft has not documented the\nSDB file format, Microsoft has documented a se-\nlection of API functions that work with SDB files,\nwhich is in some ways preferable. Perhaps by look-\ning at these functions researchers and reverse engi-\nneers have come to know at least something of the\nfile format, as evidenced by various tools they have\npublished which interpret SDB files one way or an-\nother, typically as XML.\n\nAs a rough summary, an SDB file has a 3-dword\nheader, for a major version, minor version, and sig-\nnature, and the rest of the file is a list of variable-size\ntags which each have three parts:\n\n1. a 16-bit TAG, whose numerical value tells of the\ntag’s type and purpose;\n\n2. a size in bytes, which can be given explicitly as\na dword or may be implied by the high 4 bits\nof the TAG;\n\n3. and then that many bytes of data, whose in-\nterpretation depends on the TAG.\n\nImportantly for the power of the file format, the\ndata for some tags (the ones whose high 4 bits are\n7) is itself a list of tags. From this summary and a\nfew details about the recognised TAG values, the im-\nplied sizes and the general interpretation of the data,\n\ne.g., as word, dword, binary, or Unicode string—\nall of which can be gleaned from Microsoft’s admit-\ntedly terse documentation of those API functions—\nyou might think to reorganise the raw dump so that\nit retains every byte but more conveniently shows\nthe hierarchy of tags, each with their TAG, size (if\nexplicit) and data (if present). A decoding of Fig-\nure 15 is shown in Figure 16.\n\nTo manually verify that everything in the file is\nexactly as it should be, there is perhaps no better\nrepresentation to work from than one that retains\nevery byte. In practice, though, you’ll want some\ninterpretation. Indeed, the dump above does this\nalready for the tags whose high 4 bits are 6. The\ndata for any such tag is a string reference, specifi-\ncally the offset of a 0x8801 tag within the 0x7801\ntag (at offset 0x0142 in this example), and an auto-\nmated dump can save you a little trouble by show-\ning the offset’s conversion to the string. Since those\nnumbers for tags soon become tedious, you may pre-\nfer to name them. The names that Microsoft uses\nin its programming are documented for the roughly\n100 tags that were defined ten years ago (for Win-\ndows Vista). All tags, documented or not (and now\nrunning to 260), have friendly names that can be ob-\ntained from the API function SdbTagToString. If\nyou haven’t suspected all along that Microsoft pre-\npares SDB files from XML input, then you’ll likely\ntake “tag” as a hint to represent an SDB file’s tags\nas XML tags. And this, give or take, is where some\nof the dumping tools you can find on the Internet\nleave things, such as in Figure 17.\n\nNotice already that choices are made about what\nto show and how. If you don’t show the offset in\nbytes that each XML tag has as an SDB tag in the\noriginal SDB file, then you risk complicating your\npresentation of data, as with the string references,\nwhose interpretation depends on those file offsets.\nBut show the offsets and your XML quickly looks\nmessy. Once your editorial choices go so far that you\ndon’t reproduce every byte but instead build more\nand more interpretation into the XML, why show\nevery tag? Notably, the string table that’s the data\nfor tag 0x7801 (TAG_STRINGTABLE) and the indexes\nthat are the data for tag 0x7802 (TAG_INDEXES)\nmust be generated automatically from the data for\ntag 0x7001 (TAG_DATABASE) such that the last may\nbe all you want to bother with. Observe that for any\ntag that has children, the subtags that don’t have\nchildren come first, and perhaps you’ll plumb for a\ndifferent style of XML in which each tag that has no\n\n64\n\n\n\n00000000: 02 00 00 00 01 00 00 00-73 64 62 66 02 78 CA 00 ........sdbf.x..\n00000010: 00 00 03 78 14 00 00 00-02 38 07 70 03 38 01 60 ...x.....8.p.8.‘\n00000020: 16 40 01 00 00 00 01 98-00 00 00 00 03 78 0E 00 .@...........x..\n00000030: 00 00 02 38 17 70 03 38-01 60 01 98 00 00 00 00 ...8.p.8.‘......\n00000040: 03 78 0E 00 00 00 02 38-07 70 03 38 04 90 01 98 .x.....8.p.8....\n00000050: 00 00 00 00 03 78 14 00-00 00 02 38 1C 70 03 38 .....x.....8.p.8\n00000060: 01 60 16 40 02 00 00 00-01 98 00 00 00 00 03 78 .‘.@...........x\n00000070: 14 00 00 00 02 38 1C 70-03 38 0B 60 16 40 02 00 .....8.p.8.‘.@..\n00000080: 00 00 01 98 00 00 00 00-03 78 14 00 00 00 02 38 .........x.....8\n00000090: 1A 70 03 38 01 60 16 40-02 00 00 00 01 98 00 00 .p.8.‘.@........\n000000A0: 00 00 03 78 14 00 00 00-02 38 1A 70 03 38 0B 60 ...x.....8.p.8.‘\n000000B0: 16 40 02 00 00 00 01 98-00 00 00 00 03 78 1A 00 .@...........x..\n000000C0: 00 00 02 38 25 70 03 38-01 60 01 98 0C 00 00 00 ...8%p.8.‘......\n000000D0: 00 00 52 45 4B 43 41 48-14 01 00 00 01 70 60 00 ..REKCAH.....p‘.\n000000E0: 00 00 01 50 D8 C1 31 3C-70 10 D2 01 22 60 06 00 ...P..1<p...\"‘..\n000000F0: 00 00 01 60 1C 00 00 00-23 40 01 00 00 00 07 90 ...‘....#@......\n00000100: 10 00 00 00 28 22 AB F9-12 33 73 4A B6 F9 93 6D ....(\"...3sJ...m\n00000110: 70 E1 12 EF 25 70 28 00-00 00 01 60 50 00 00 00 p...%p(....‘P...\n00000120: 10 90 10 00 00 00 C8 E4-9C 91 69 D0 21 45 A5 45 ..........i.!E.E\n00000130: 01 32 B0 63 94 ED 17 40-03 00 00 00 03 60 64 00 .2.c...@.....‘d.\n00000140: 00 00 01 78 7A 00 00 00-01 88 10 00 00 00 32 00 ...xz.........2.\n00000150: 2E 00 31 00 2E 00 30 00-2E 00 33 00 00 00 01 88 ..1...0...3.....\n00000160: 2E 00 00 00 48 00 61 00-63 00 6B 00 65 00 64 00 ....H.a.c.k.e.d.\n00000170: 20 00 44 00 72 00 69 00-76 00 65 00 72 00 20 00 .D.r.i.v.e.r. .\n00000180: 44 00 61 00 74 00 61 00-62 00 61 00 73 00 65 00 D.a.t.a.b.a.s.e.\n00000190: 00 00 01 88 0E 00 00 00-48 00 61 00 63 00 6B 00 ........H.a.c.k.\n000001A0: 65 00 72 00 00 00 01 88-16 00 00 00 68 00 61 00 e.r.........h.a.\n000001B0: 63 00 6B 00 65 00 72 00-2E 00 73 00 79 00 73 00 c.k.e.r...s.y.s.\n000001C0: 00 00 ..\n\nFigure 15. ShimDB File\n\nchild tags is represented as an attribute and value,\ne.g.,\n\n<DATABASE\n2 TIME=\"0x01D210703C31C1D8\"\n\nCOMPILER_VERSION=\" 2 . 1 . 0 . 3 \"\n4 NAME=\"Hacked Driver Database\"\n\nOS_PLATFORM=\"0x00000001\"\n6 DATABASE_ID=\"0x28 0x22 0xAB 0xF9 0x12 0x33\n\n0x73 0x4A 0xB6 0xF9 0x93 0x6D 0x70 0xE1 0\nx12 0xEF\">\n<KSHIM\n\n8 NAME=\"Hacker\"\nFIX_ID=\"0xC8 0xE4 0x9C 0x91 0x69 0xD0 0\n\nx21 0x45 0xA5 0x45 0x01 0x32 0xB0 0x63 0\nx94 0xED\"\n\n10 FLAGS=\"0x00000003\"\nMODULE=\"hacker . sys \" />\n\n12 </DATABASE>\n\nWhether you choose XML in this style or to have\nevery tag’s data between opening and closing tags,\nthere are any number of ways to represent the data\nfor each tag. For instance, once you know that\nthe binary data for tag 0x9007 (TAG_DATABASE_ID)\nor tag 0x9010 (TAG_FIX_ID) is always a GUID, you\nmight more conveniently represent it in the usual\nstring form. Instead of showing the data for tag\n0x5001 (TAG_TIME) as a raw qword, why not show\n\nthat you know it’s a Windows FILETIME and present\nit as 16/09/2016 23:15:37.944? Or, on the grounds\nthat it too must be generated automatically, you\nmight decide not to show it at all!\n\nIf I labour the presentation, it’s to make the\npoint that what’s produced by any number of dump-\ning tools inevitably varies according to purpose and\ntaste. Let’s say a hundred researchers want a tool\nfor the easy reading of SDB files. Yes, that’s doubt-\nful, but 100 is a good round number. Then ninety\nwill try to crib code from someone else—because,\nyou know, who wants to reinvent the wheel—and\nwhat you get from the others will each be different,\npossibly very different, not just for its output but\nespecially for what the source code shows of the file\nformat. Worse, because nine out of ten program-\nmers don’t bother much with commenting, even for\na tool they may intend as showing off their cod-\ning skills, you may have to pick through the source\ncode to extract the file format. That may be easier\nthan reverse-engineering Microsoft’s binaries that\nwork with the file, but not necessarily by much—and\nnot necessarily leaving you with the same confidence\nthat what you’ve learnt about the file format is cor-\n\n65\n\n\n\n00000000: Header: MajorVersion=0x00000002 MinorVersion=0x00000001 Magic=0x66626473\n0000000C: Tag=0x7802 Size=0x000000CA Data=\n00000012: Tag=0x7803 Size=0x00000014 Data=\n00000018: Tag=0x3802 Data=0x7007\n0000001C: Tag=0x3803 Data=0x6001\n00000020: Tag=0x4016 Data=0x00000001\n00000026: Tag=0x9801 Size=0x00000000\n0000002C: Tag=0x7803 Size=0x0000000E Data=\n00000032: Tag=0x3802 Data=0x7017\n00000036: Tag=0x3803 Data=0x6001\n0000003A: Tag=0x9801 Size=0x00000000\n00000040: Tag=0x7803 Size=0x0000000E Data=\n\n...\n\n000000BC: Tag=0x7803 Size=0x0000001A Data=\n000000C2: Tag=0x3802 Data=0x7025\n000000C6: Tag=0x3803 Data=0x6001\n000000CA: Tag=0x9801 Size=0x0000000C Data=0x00 0x00 0x52 0x45 0x4B 0x43 0x41 0x48 0x14 0x01 0x00 0x00\n000000DC: Tag=0x7001 Size=0x00000060\n000000E2: Tag=0x5001 Data=0x01D210703C31C1D8\n000000EC: Tag=0x6022 Data=0x00000006 => L\"2.1.0.3\"\n000000F2: Tag=0x6001 Data=0x0000001C => L\"Hacked Driver Database\"\n000000F8: Tag=0x4023 Data=0x00000001\n000000FE: Tag=0x9007 Size=0x00000010 Data=0x28 0x22 0xAB 0xF9 0x12 0x33 0x73 0x4A 0xB6 0xF9 0x93 0x6D\n\n0x70 0xE1 0x12 0xEF\n00000114: Tag=0x7025 Size=0x00000028\n0000011A: Tag=0x6001 Data=0x00000050 => L\"Hacker\"\n00000120: Tag=0x9010 Size=0x00000010 Data=0xC8 0xE4 0x9C 0x91 0x69 0xD0 0x21 0x45 0xA5 0x45 0x01 0x32\n\n0xB0 0x63 0x94 0xED\n00000136: Tag=0x4017 Data=0x00000003\n0000013A: Tag=0x6003 Data=0x00000064 => L\"hacker.sys\"\n00000142: Tag=0x7801 Size=0x0000007A Data=\n00000148: Tag=0x8801 Size=0x00000010 Data=L\"2.1.0.3\"\n0000015E: Tag=0x8801 Size=0x0000002E Data=L\"Hacked Driver Database\"\n00000192: Tag=0x8801 Size=0x0000000E Data=L\"Hacker\"\n000001A6: Tag=0x8801 Size=0x00000016 Data=L\"hacker.sys\"\n\nFigure 16. ShimDB File (Decoded from Figure 15)\n\n66\n\n\n\n1 <INDEXES>\n<INDEX>\n\n3 <INDEX_TAG>0x7007</INDEX_TAG>\n<INDEX_KEY>0x6001</INDEX_KEY>\n\n5 <INDEX_FLAGS>0x00000001</INDEX_FLAGS>\n<INDEX_BITS></INDEX_BITS>\n\n7 </INDEX>\n<INDEX>\n\n9 <INDEX_TAG>0x7017</INDEX_TAG>\n<INDEX_KEY>0x6001</INDEX_KEY>\n\n11 <INDEX_BITS></INDEX_BITS>\n</INDEX>\n\n13 . . .\n<INDEX>\n\n15 <INDEX_TAG>0x7025</INDEX_TAG>\n<INDEX_KEY>0x6001</INDEX_KEY>\n\n17 <INDEX_BITS>0x00 0x00 0x52 0x45 0x4B 0x43 0x41 0x48 0x14 0x01 0x00 0x00</INDEX_BITS>\n</INDEX>\n\n19 </INDEXES>\n<DATABASE>\n\n21 <TIME>0x01D210703C31C1D8</TIME>\n<COMPILER_VERSION>0x00000006</COMPILER_VERSION>\n\n23 <NAME>0x0000001C</NAME>\n<OS_PLATFORM>0x00000001</OS_PLATFORM>\n\n25 <DATABASE_ID>0x28 0x22 0xAB 0xF9 0x12 0x33 0x73 0x4A 0xB6 0xF9 0x93 0x6D 0x70 0xE1 0x12 0xEF</\nDATABASE_ID>\n\n<KSHIM>\n27 <NAME>0x00000050</NAME>\n\n<FIX_ID>0xC8 0xE4 0x9C 0x91 0x69 0xD0 0x21 0x45 0xA5 0x45 0x01 0x32 0xB0 0x63 0x94 0xED</\nFIX_ID>\n\n29 <FLAGS>0x00000003</FLAGS>\n<MODULE>0x00000064</MODULE>\n\n31 </KSHIM>\n</DATABASE>\n\n33 <STRINGTABLE>\n<STRINGTABLE_ITEM>2 . 1 . 0 . 3</STRINGTABLE_ITEM>\n\n35 <STRINGTABLE_ITEM>Hacked Driver Database</STRINGTABLE_ITEM>\n<STRINGTABLE_ITEM>Hacker</STRINGTABLE_ITEM>\n\n37 <STRINGTABLE_ITEM>hacker . sys</STRINGTABLE_ITEM>\n</STRINGTABLE>\n\nFigure 17. Illegible XML From a ShimDB Dumping Tool\n\n67\n\n\n\nrect and comprehensive. Writing a tool that dumps\nan undocumented file format may be more reward-\ning for you as a programmer but it is not nearly the\nsame as documenting the file format.\n\n9.3 Reversing XML to SDB\nBut is there really no definitive XML for repre-\nsenting SDB files? Of all the purposes that moti-\nvate anyone to work with SDB files closely enough\nto need to know the file format, one has special\nstanding: Microsoft’s creation of SDB files from\nXML input. If we had Microsoft’s tool for that,\nthen wouldn’t most researchers plumb for revers-\ning its work to recover the XML source? After\nall, most reverse engineers and certainly the popular\nreverse-engineering tools don’t take binary code and\nunassemble it just to what you see in the debugger.\nNo, they disassemble it into assembly language that\ncan be edited and re-assembled. Many go further\nand try to decompile it into C or C++ that can be\nedited and re-compiled (even if it doesn’t look re-\nmotely like anything you’d be pleased to have from\na human programmer). In this context, the SDB to\nXML conversion to want is something you could feed\nto Microsoft’s Shim Database Compiler for compila-\ntion back to SDB. Anything else is pseudo-code. It\nmay be fine in its way for understanding the content,\nand some may prefer it to a raw dump interpreted\nwith reference to documentation of the file format,\nbut however widely it gets accepted it is nonetheless\npseudo-code.\n\nThe existence of something that someone at\nMicrosoft refers to as a Shim Database Com-\npiler has been known for at least a decade be-\ncause Microsoft’s documentation of tag 0x6022\n(TAG_COMPILER_VERSION), apparently contempora-\nneous with Windows Vista, describes this tag’s data\nas the “Shim Database Compiler version.” And\nwhat, then, is the ShimDBC.exe from the even older\nTechNet article if it’s not this Shim Database Com-\npiler?\n\nBut has anyone outside Microsoft ever seen this\ncompiler? Dig out an installation disc for Win-\ndows XP from 2001, look in the Support Tools di-\nrectory, install the ACT version 2.0 from its self-\nextracting executable, and perhaps install the Sup-\nport Tools too in case that’s what the TechNet ar-\nticle means by “support utility.” For your troubles,\nwhich may include having to install Windows XP,\nyou’ll get the article’s QFixApp.exe, and the Com-\npatibility Administrator, as CompatAdmin.exe, and\n\nsome other possibly useful or at least instructive\ntools such as GrabMI.exe, but you don’t get any\nfile named ShimDBC.exe. I suspect that Shim-\nDBC.exe never has existed in public as any sort of\nself-standing utility or even as its own file. Even if\nit did once upon a time, we should want a modern\nversion that knows the modern tags such as 0x7025\n(TAG_KSHIM) for defining driver shims.\n\nFor some good news, look into either QFix-\nApp.exe or CompatAdmin.exe using whatever is\nyour tool of choice for inspecting executables. In-\nside each, not as resources but intermingled with the\ncode and data, are several instances of ShimDBC as\ntext. We’ve had Microsoft’s Shim Database Com-\npiler for 15 years since the release of Windows XP.\nAll along, the code and data for the console program\nShimDBC.exe, from its wmain function inwards, has\nbeen linked into the GUI programs QFixApp.exe\nand CompatAdmin.exe (of which only the latter sur-\nvives to modern versions of the ACT). Each of the\nGUI programs has a WinMain function that’s first to\nexecute after the C Run-Time (CRT) initialisation.\nWhenever either of the GUI programs wants to cre-\nate an SDB file, it composes the Unicode text of a\ncommand line for the fake ShimDBC.exe and calls a\nroutine that first parses this into the argc and argv\nthat are expected for a wmain function and which\nthen simply calls the wmain function. Where the\nTechNet article says QFixApp uses ShimDBC.exe,\nit is correct, but it doesn’t mean that QFixApp ex-\necutes ShimDBC.exe as a separate program, more\nthat QFixApp simulates such execution from the\nShimDBC code and data that’s built in.\n\nUnfortunately, CompatAdmin does not provide,\neven in secret, for passing a command line of our\nchoice through WinMain to wmain. But, c’mon, we’re\nhackers. You’ll already be ahead of me: we can\npatch the file. Make a copy of CompatAdmin.exe as\nShimDBC.exe, and use your favourite debugger or\ndisassembler to find three things:\n\n• the program’s WinMain function;\n\n• the routine the program passes the fake com-\nmand line to for parsing and for calling wmain;\n\n• the address of the Import Address Table entry\nfor calling the GetCommandLineW function.\n\n68\n\n\n\nIdeally, you might then assemble something like\nc a l l dword ptr [__imp__GetCommandLineW@0]\n\n2 mov ecx , eax\nc a l l SimulateShimDBCExecution\n\n4 r e t 10h\n\nover the very start of WinMain. In practice, you\nhave to allow for relocations. Our indirect call to\nGetCommandLineW will need a fixup if the program\ndoesn’t get loaded at its preferred address. Worse,\nif we overwrite any fixup sites in WinMain, then our\ncode will get corrupted if fixups get applied. But\nthese are small chores that are bread and butter for\npractised reverse engineers. For concreteness, I give\nthe patch details for the 32-bit CompatAdmin.exe\nfrom the ACT version 6.1 for Windows 8.1 in Ta-\nble 2.\n\nFor hardly any trouble, we get an executable\nthat still contains all its GUI material (except for\nthe 17 bytes we’ve changed) but never executes\nit and instead runs the console-application code\nwith the command line that we give when running\nthe patched program. Microsoft surely has Shim-\nDBC.exe as a self-standing console application, but\nwhat we get from patching CompatAdmin.exe must\nbe close to the next best thing, certainly for so little\neffort. It’s still a GUI program, however, so to see\nwhat it writes to standard output we must explicitly\ngive it a standard output. At a Command Prompt\nwith administrative privilege, enter\n\nshimdbc -? >help.txt\n\nto get the built-in ShimDBC program’s mostly accu-\nrate description of its command-line syntax, includ-\ning most of the recognised command-line options.\n\nTo produce the SDB file that is this article’s ex-\nample, write the following as a Unicode text file\nnamed test.xml:\n<?xml version=\" 1 .0 \" encoding=\"UTF−16\" ?>\n\n2 <DATABASE NAME=\"Hacked Driver Database\"\nID=\"{F9AB2228−3312−4A73−B6F9−936D70E112EF}\">\n\n4 <LIBRARY>\n<KSHIM NAME=\"Hacker\" FILE=\"hacker . sys \"\n\n6 ID=\"{919CE4C8−D069−4521−A545−0132B06394ED}\n\"\nLOGO=\"YES\" ONDEMAND=\"YES\" />\n\n8 </LIBRARY>\n</DATABASE>\n\nand feed it to the compiler via the command line\n1 shimdbc Driver t e s t . xml t e s t . sdb >t e s t . txt\n\nI may be alone in this, but if you’re going to\ntell me that I should know that you know the SDB\nfile format when all you have to show is a tool that\nconverts SDB to XML, then this would better be\nthe XML that your tool produces from this article’s\nexample of an SDB file. Otherwise, as far as I’m\nconcerned for studying any SDB file, I’m better off\nwith a raw dump in combination with actual docu-\nmentation of the file format.\n\nDo not let it go unnoticed, though, that the\nXML that works for Microsoft’s ShimDBC needs at-\ntributes that differ from the programmatic names\nthat Microsoft has documented for the tags or the\nfriendly names that can be obtained from the Sdb-\nTagToString function. For instance, the 0x6003 tag\n(TAG_MODULE) is compiled from an attribute named\nnot MODULE but FILE. The 0x4017 tag (TAG_FLAGS)\nis synthesised from two attributes. Even harder to\nhave guessed is that a LIBRARY tag is needed in the\nXML but does not show at all in the SDB file, i.e.,\nas a tag 0x7002 (TAG_LIBRARY). So, to know what\nXML is acceptable to Microsoft’s compiler for creat-\ning an SDB file, you’ll have to reverse-engineer the\ncompiler or do a lot of inspired guesswork.\n\nHappy hunting!\n\n69\n\n\n\nFile Offset Original Patched Remarks\n0x0002FB54 8B FF EB 08 jump to instruction that will use existing fixup site\n0x0002FB56 55\n0x0002FB57 8B EC\n0x0002FB59 81 EC 88 05 00 00\n0x0002FB5E FF 15 D0 30 49 00 incorporate existing fixup site at file offset 0x0002FB60\n0x0002FB5F A1 00 60 48 00\n0x0002FB64 33 C5 8B C8\n0x0002FB66 89 45 FC E8 55 87 01 00 no fixup required for this direct call within .text section\n0x0002FB69 8B 45 08\n0x0002FB6B C2 10 00\n0x0002FB6C 53\n0x0002FB6D 56\n\nTable 2. Patch details for the 32-bit CompatAdmin.exe from the ACT version 6.1 for Windows 8.1.\n\nba\nse\n\nd \non\n\n h\nttp\n\ns:/\n/d\n\niv\nisb\n\nyz\ner\n\no.c\nom\n\n/2\n01\n\n6/\n07\n\n/0\n6/\n\nm\nak\n\ne-a\n-su\n\ngih\nar\n\na-\ncir\n\ncle\nsq\n\nua\nre\n\n-o\npt\n\nica\nl-i\nllu\n\nsio\nn-\n\nou\nt-o\n\nf-p\nap\n\ner\n/\n\nAmbiguous Cylinder by Kokichi Sugihara\n\nresult\n\n杉原 厚吉 の 多義柱体\n\n70\n\n\n\n10 Post Scriptum: A Schizophrenic Ghost\nby Evan Sultanik and Philippe Teuwen\n\nA while back, we asked ourselves,\n\nWhat if PoC‖GTFO had completely dif-\nferent content depending on whether the\nfile was rendered by a PDF viewer versus\nbeing sent to a printer?\n\nA PostScript/PDF polyglot seemed inevitable. We\nhad already done MBR, ISO, TrueCrypt, HTML,\nRuby, . . . Surely PostScript would be simple, right?\nAs it turns out, it’s actually quite tricky.\n\n$ gv pocorgtfo13.pdf\n\nThere were two new challenges in getting this\npolyglot to work:\n\n1. The PDF format is a subset of the PostScript\nlanguage, meaning that we needed to devise\na way to get a PDF interpreter to ignore the\nPostScript code, and vice versa; and\n\n2. It’s almost impossible to find a PostScript\ninterpreter that doesn’t also support PDF.\nGhostscript is nearly ubiquitous in its use as a\nbackend library for desktop PostScript view-\ners (e.g., Ghostview), and it has PDF sup-\nport, too. Furthermore, it doesn’t have any\nconfiguration parameters to force it to use a\nspecific format, so we needed a way to force\nGhostscript to always interpret the polyglot\nas if it were PostScript.\n\nTo overcome the first challenge, we used a sim-\nilar technique to the Ruby polyglot from pocor-\ngtfo11.pdf, in which the PDF header is embed-\nded into a multi-line string (delimited by parenthesis\nin PostScript), so that it doesn’t get interpreted as\nPostScript commands. We halt the PostScript inter-\npreter at the end of the PostScript content by using\nthe handy stop command following the standard\n%%EOF “Document Structuring Conventions” (DSC)\ndirective.\n\nThis works, in that it produces a file that is\nboth a completely valid PDF as well as a completely\nvalid PostScript program. The trouble is that Adobe\nseems to have blacklisted any PDF that starts with\nan opening parenthesis. We resolved this by wrap-\nping the multi-line string containing the PDF header\ninto a PostScript function we called /pdfheader:\n\n/pdfheader\n{\n(\n%!PS-Adobe\n%PDF-1.5\n%<D0><D4><C5><D8>\n\n9999 0 obj\n<<\n/Length # bytes between “stream”\n\nand “endstream”\n>>\nstream\n)\n}\nPostScript Content\nstop\nendstream\nendobj\n\nRemainder of PDF Content\n\nMulti-Line PostScript String\n\nPostScript Function\n\nPDF Object\n\nTerminates\n\nPostScript\n\nInterpretation\n\nThe trick of starting the file with a PostScript\nfunction worked, and the PDF could be viewed\nin Adobe. That still leaves the second challenge,\nthough: We needed a way to trick Ghostscript into\nbeing “schizophrenic” (cf. PoC‖GTFO 7:6), vi&., to\ninsert a parser-specific inconsistency into the poly-\nglot that would force Ghostscript into thinking it is\nPostScript.\n\nGhostscript’s logic for auto-detecting file types\nseems to be in the dsc_scan_type function in-\nside /psi/dscparse.c. It is quite complex, since\nthis single function must differentiate between seven\ndifferent filetypes, including DSC/PostScript and\nPDF. It classifies a file as a PDF if it contains a\nline starting with “%PDF-”, and PostScript if it con-\ntains a line starting with “%!PS-Adobe”. Therefore,\nif we put %!PS-Adobe anywhere before %PDF-1.5,\nthen Ghostscript should be tricked into thinking it is\nPostScript! The only caveat is that Adobe blacklists\nany PDF that starts with “%!PS-Adobe”, so it can’t\nbe at the beginning of the file (which is typically\nwhere it occurs in DSC files). But that’s okay, be-\ncause Ghostscript only needs it to occur before the\n%PDF-1.5, regardless of where.\n\nThis article continues in the PostScript!\n\n71\n\n\n\n11 Tithe us your Alms of 0day!\nfrom the desk of Pastor Manul Laphroaig,\n\nInternational Church of the Weird Machines\n\nDearest neighbor,\nDo you remember what it was like when you first\n\nlearned to program a computer? Not when you first\nrealized that you could do it well, but when you first\nrealized that you could do it at all? How did it feel?\n\nAnd do you remember what it was like when you\nfirst learned how to use calculus? Not when you\nfirst learned how complicated differential equations\ncould become, but when you first realized that with\na handful of rules, you could bounce back and forth\nbetween position, velocity, acceleration, and jerk as\nif they were all the same thing? How did that feel?\n\nAnd do you remember what it was like when\nyou first learned how to use a screwdriver? Not\nwhen you first learned what to do after removing\nthe screw, but when you first realized that with a\nscrewdriver—with the right screwdriver—you could\ntake apart anything? How did that feel?\n\nWhen I was sixteen, I was a bit of an asshole,\nand I asked my automechanics teacher a question\nabout a distributor’s angular momentum. I don’t\nrecall my exact question, but I do recall that it was\nthe sort of thing no one could be expected to know,\nand that, being a jerk, I asked it in the vocabulary\nof calculus.\n\nCoach Crigger could’ve called me out for be-\ning rude, or he could’ve dodged the question. He\ncould’ve done any number of things that you might\nexpect. Instead, he walked out of the classroom\nwhile two and half dozen hooligans started a racket\naudible from the other side of the campus.\n\nTen minutes later, he returned to the classroom.\nHe walked right up to my desk and slammed a\n’72 Ford’s distributor onto my desk along with the\nscrewdriver to open it. It felt good!\n\nDo this: write an email telling our editors how\nto reproduce ONE clever, technical trick from your\nresearch. If you are uncertain of your English, we’ll\nhappily translate from French, Russian, Southern\nAppalachian, and German. If you don’t speak those\nlanguages, we’ll draft a translator from those poor\nsods who owe us favors.\n\nLike an email, keep it short. Like an email, you\nshould assume that we already know more than a\nbit about hacking, and that we’ll be insulted or—\nWORSE!—that we’ll be bored if you include a long\ntutorial where a quick reminder would do.\n\nJust use 7-bit ASCII if your language doesn’t\nrequire funny letters, as whenever we receive some-\nthing typeset in OpenOffice, we briefly mistake it\nfor a ransom note. Don’t try to make it thorough\nor broad. Don’t use bullet-points, as this isn’t a\ndamned Powerpoint deck. Keep your code samples\nshort and sweet; we can leave the long-form code as\nan attachment. Do not send us LATEX; it’s our job\nto do the typesetting!\n\nDon’t tell us that it’s possible; rather, teach us\nhow to do it ourselves with the absolute minimum\nof formality and bullshit.\n\nLike an email, we expect informal (or faux-\nbiblical) language and hand-sketched diagrams.\nWrite it in a single sitting, and leave any editing\nfor your poor preacherman to do over a bottle of\nfine scotch. Send this to pastor@phrack org and\nhope that the neighborly Phrack folks—praise be to\nthem!—aren’t man-in-the-middling our submission\nprocess.\n\nYours in PoC and Pwnage,\nPastor Manul Laphroaig, D D\n\n72\n\n\n\t0.0: \n\t0.1: \n\t0.2: \n\t0.3: \n\t0.4: \n\t0.5: \n\t0.6: \n\t0.7: \n\t0.8: \n\t0.9: \n\t0.10: \n\t0.11: \n\t0.12: \n\t0.13: \n\t0.14: \n\t0.15: \n\t0.16: \n\t0.17: \n\t0.18: \n\t0.19: \n\t0.20: \n\t0.21: \n\t0.22: \n\t0.23: \n\t0.24: \n\t0.25: \n\t0.26: \n\t0.27: \n\t0.28: \n\t0.29: \n\t0.30: \n\t0.31: \n\t0.32: \n\t0.33: \n\t0.34: \n\t0.35: \n\t0.36: \n\t0.37: \n\t0.38: \n\t0.39: \n\t0.40: \n\t0.41: \n\t0.42: \n\t0.43: \n\t0.44: \n\t0.45: \n\t0.46: \n\t0.47: \n\t0.48: \n\t0.49: \n\t0.50: \n\t0.51: \n\t0.52: \n\t0.53: \n\t0.54: \n\t0.55: \n\tanm0: \n\t1.0: \n\t1.1: \n\t1.2: \n\t1.3: \n\t1.4: \n\t1.5: \n\t1.6: \n\t1.7: \n\t1.8: \n\t1.9: \n\t1.10: \n\t1.11: \n\t1.12: \n\t1.13: \n\t1.14: \n\t1.15: \n\t1.16: \n\t1.17: \n\t1.18: \n\t1.19: \n\t1.20: \n\t1.21: \n\t1.22: \n\t1.23: \n\t1.24: \n\t1.25: \n\t1.26: \n\t1.27: \n\t1.28: \n\t1.29: \n\t1.30: \n\t1.31: \n\t1.32: \n\t1.33: \n\t1.34: \n\t1.35: \n\t1.36: \n\t1.37: \n\t1.38: \n\t1.39: \n\t1.40: \n\t1.41: \n\t1.42: \n\t1.43: \n\t1.44: \n\t1.45: \n\t1.46: \n\t1.47: \n\t1.48: \n\t1.49: \n\t1.50: \n\t1.51: \n\t1.52: \n\t1.53: \n\t1.54: \n\t1.55: \n\t1.56: \n\t1.57: \n\t1.58: \n\t1.59: \n\t1.60: \n\t1.61: \n\t1.62: \n\t1.63: \n\t1.64: \n\t1.65: \n\t1.66: \n\t1.67: \n\t1.68: \n\t1.69: \n\t1.70: \n\t1.71: \n\t1.72: \n\t1.73: \n\t1.74: \n\t1.75: \n\t1.76: \n\t1.77: \n\t1.78: \n\t1.79: \n\t1.80: \n\t1.81: \n\t1.82: \n\t1.83: \n\t1.84: \n\t1.85: \n\t1.86: \n\t1.87: \n\t1.88: \n\t1.89: \n\t1.90: \n\t1.91: \n\t1.92: \n\t1.93: \n\t1.94: \n\t1.95: \n\t1.96: \n\t1.97: \n\t1.98: \n\t1.99: \n\t1.100: \n\t1.101: \n\t1.102: \n\t1.103: \n\t1.104: \n\t1.105: \n\t1.106: \n\t1.107: \n\t1.108: \n\t1.109: \n\t1.110: \n\t1.111: \n\t1.112: \n\t1.113: \n\t1.114: \n\t1.115: \n\t1.116: \n\t1.117: \n\t1.118: \n\t1.119: \n\t1.120: \n\t1.121: \n\t1.122: \n\t1.123: \n\t1.124: \n\t1.125: \n\t1.126: \n\t1.127: \n\t1.128: \n\t1.129: \n\t1.130: \n\t1.131: \n\t1.132: \n\t1.133: \n\t1.134: \n\t1.135: \n\t1.136: \n\t1.137: \n\t1.138: \n\t1.139: \n\t1.140: \n\t1.141: \n\t1.142: \n\t1.143: \n\t1.144: \n\t1.145: \n\t1.146: \n\t1.147: \n\t1.148: \n\t1.149: \n\t1.150: \n\t1.151: \n\t1.152: \n\t1.153: \n\t1.154: \n\t1.155: \n\t1.156: \n\t1.157: \n\t1.158: \n\t1.159: \n\t1.160: \n\t1.161: \n\t1.162: \n\t1.163: \n\t1.164: \n\t1.165: \n\t1.166: \n\t1.167: \n\t1.168: \n\t1.169: \n\t1.170: \n\t1.171: \n\t1.172: \n\t1.173: \n\t1.174: \n\t1.175: \n\t1.176: \n\t1.177: \n\t1.178: \n\t1.179: \n\t1.180: \n\t1.181: \n\t1.182: \n\t1.183: \n\t1.184: \n\t1.185: \n\t1.186: \n\t1.187: \n\t1.188: \n\t1.189: \n\t1.190: \n\t1.191: \n\t1.192: \n\t1.193: \n\t1.194: \n\t1.195: \n\t1.196: \n\t1.197: \n\t1.198: \n\t1.199: \n\t1.200: \n\t1.201: \n\t1.202: \n\t1.203: \n\t1.204: \n\t1.205: \n\t1.206: \n\t1.207: \n\t1.208: \n\t1.209: \n\t1.210: \n\t1.211: \n\t1.212: \n\t1.213: \n\t1.214: \n\t1.215: \n\t1.216: \n\t1.217: \n\t1.218: \n\t1.219: \n\t1.220: \n\t1.221: \n\t1.222: \n\t1.223: \n\t1.224: \n\t1.225: \n\t1.226: \n\t1.227: \n\t1.228: \n\t1.229: \n\t1.230: \n\t1.231: \n\t1.232: \n\t1.233: \n\t1.234: \n\t1.235: \n\t1.236: \n\t1.237: \n\t1.238: \n\t1.239: \n\t1.240: \n\t1.241: \n\t1.242: \n\t1.243: \n\t1.244: \n\t1.245: \n\t1.246: \n\t1.247: \n\t1.248: \n\t1.249: \n\t1.250: \n\t1.251: \n\t1.252: \n\t1.253: \n\t1.254: \n\t1.255: \n\t1.256: \n\t1.257: \n\t1.258: \n\t1.259: \n\t1.260: \n\t1.261: \n\t1.262: \n\t1.263: \n\t1.264: \n\t1.265: \n\t1.266: \n\t1.267: \n\t1.268: \n\t1.269: \n\t1.270: \n\t1.271: \n\t1.272: \n\t1.273: \n\t1.274: \n\t1.275: \n\t1.276: \n\t1.277: \n\t1.278: \n\t1.279: \n\t1.280: \n\t1.281: \n\t1.282: \n\t1.283: \n\t1.284: \n\t1.285: \n\t1.286: \n\t1.287: \n\t1.288: \n\t1.289: \n\t1.290: \n\t1.291: \n\t1.292: \n\t1.293: \n\t1.294: \n\t1.295: \n\t1.296: \n\t1.297: \n\t1.298: \n\t1.299: \n\t1.300: \n\t1.301: \n\t1.302: \n\t1.303: \n\t1.304: \n\t1.305: \n\t1.306: \n\t1.307: \n\t1.308: \n\t1.309: \n\t1.310: \n\t1.311: \n\t1.312: \n\t1.313: \n\t1.314: \n\t1.315: \n\t1.316: \n\t1.317: \n\t1.318: \n\t1.319: \n\t1.320: \n\t1.321: \n\t1.322: \n\t1.323: \n\t1.324: \n\t1.325: \n\t1.326: \n\t1.327: \n\t1.328: \n\t1.329: \n\t1.330: \n\t1.331: \n\t1.332: \n\t1.333: \n\t1.334: \n\t1.335: \n\t1.336: \n\t1.337: \n\t1.338: \n\t1.339: \n\t1.340: \n\t1.341: \n\t1.342: \n\t1.343: \n\t1.344: \n\t1.345: \n\t1.346: \n\t1.347: \n\t1.348: \n\t1.349: \n\t1.350: \n\t1.351: \n\t1.352: \n\t1.353: \n\t1.354: \n\t1.355: \n\t1.356: \n\t1.357: \n\t1.358: \n\t1.359: \n\t1.360: \n\t1.361: \n\t1.362: \n\t1.363: \n\t1.364: \n\t1.365: \n\t1.366: \n\t1.367: \n\t1.368: \n\t1.369: \n\t1.370: \n\t1.371: \n\t1.372: \n\t1.373: \n\t1.374: \n\t1.375: \n\t1.376: \n\t1.377: \n\t1.378: \n\t1.379: \n\t1.380: \n\t1.381: \n\t1.382: \n\t1.383: \n\t1.384: \n\t1.385: \n\t1.386: \n\tanm1: \n\n\n","extracted_metadata":{"PTEX.Fullbanner":["This is pdfTeX, Version 3.14159265-2.6-1.40.15 (TeX Live 2014) kpathsea version 6.2.0"],"access_permission:can_print":["true"],"pdf:annotationSubtypes":["Widget"],"pdf:PDFVersion":["1.5"],"dc:subject":["pocorgtfo,poc,gtfo"],"pdf:totalUnmappedUnicodeChars":["40"],"pdf:hasCollection":["false"],"pdf:producer":["pdfTeX-1.40.15"],"dc:creator":["Pastor Manul Laphroaig"],"pdf:hasXFA":["false"],"pdf:docinfo:modified":["2016-10-18T20:43:26Z"],"xmp:CreatorTool":["ace02468bdf13579"],"access_permission:extract_content":["true"],"pdf:overallPercentageUnmappedUnicodeChars":["2.1356227807700634E-4"],"pdf:charsPerPage":["894","1751","2239","2749","1246","5465","1630","2550","2390","2652","2815","2432","2347","3409","2526","2568","2258","899","3024","1419","16265","8301","2","2639","2908","1692","3068","686","2771","2438","1230","4119","2","3459","3159","3391","1588","2632","2584","2","2164","2728","2318","1797","2624","2922","2095","3045","1827","1737","2047","3251","110","3183","3650","4119","2578","2570","1493","2959","2","2582","2917","3787","3393","1520","1118","3757","2622","621","2879","2685"],"resourceName":["Proof of Concept or GTFO - v13 (October 18th, 2016).pdf"],"pdf:containsDamagedFont":["false"],"dc:title":["PoC||GTFO 13"],"xmpTPg:NPages":["72"],"pdf:hasXMP":["false"],"Content-Type":["application/pdf"],"pdf:unmappedUnicodeCharsPerPage":["0","2","0","1","0","0","0","0","0","8","0","11","0","0","0","0","0","0","0","0","2","4","0","0","0","0","0","0","0","1","0","0","0","0","0","0","0","1","0","0","0","1","0","0","0","0","7","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","2","0"],"pdf:encrypted":["false"],"dcterms:created":["2016-06-23T02:46:00Z"],"pdf:num3DAnnotations":["0"],"access_permission:can_print_degraded":["true"],"dcterms:modified":["2016-10-18T20:43:26Z"],"access_permission:assemble_document":["true"],"pdf:docinfo:trapped":["False"],"pdf:docinfo:producer":["pdfTeX-1.40.15"],"access_permission:extract_for_accessibility":["true"],"access_permission:fill_in_form":["true"],"pdf:hasMarkedContent":["false"],"pdf:docinfo:keywords":["pocorgtfo,poc,gtfo"],"Content-Length":["62061798"],"pdf:docinfo:title":["PoC||GTFO 13"],"pdf:hasAcroFormFields":["true"],"pdf:docinfo:created":["2016-06-23T02:46:00Z"],"pdf:docinfo:custom:PTEX.Fullbanner":["This is pdfTeX, Version 3.14159265-2.6-1.40.15 (TeX Live 2014) kpathsea version 6.2.0"],"access_permission:modify_annotations":["true"],"X-TIKA:Parsed-By-Full-Set":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser","org.apache.tika.parser.ocr.TesseractOCRParser"],"pdf:containsNonEmbeddedFont":["false"],"pdf:docinfo:creator_tool":["ace02468bdf13579"],"access_permission:can_modify":["true"],"dc:format":["application/pdf; version=1.5"],"X-TIKA:Parsed-By":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"pdf:annotationTypes":["null"],"pdf:docinfo:creator":["Pastor Manul Laphroaig"]},"metadata_field_count":48,"attempts":1,"timestamp":1754064869.4173317,"platform":"Linux","python_version":"3.13.5"},{"file_path":"test_documents/pdfs/Intel 64 and IA-32 Architectures Software Developer's Manual - Combined Volumes 1-4 - June 2021 (325462-sdm-vol-1-2abcd-3abcd).pdf","file_size":52916900,"file_type":"pdf","category":"huge","framework":"extractous","iteration":0,"extraction_time":6.970527410507202,"startup_time":null,"peak_memory_mb":698.72265625,"avg_memory_mb":655.7390625,"peak_cpu_percent":99.9,"avg_cpu_percent":19.98,"total_io_mb":null,"status":"success","character_count":500000,"word_count":125052,"error_type":null,"error_message":null,"quality_metrics":{"char_count":500000,"word_count":125052,"sentence_count":6292,"paragraph_count":2207,"avg_word_length":2.9588731087867446,"avg_sentence_length":8.662746344564527,"extraction_completeness":1.0,"text_coherence":0.04993781568060103,"noise_ratio":0.37750000000000006,"gibberish_ratio":0.038461538461538464,"flesch_reading_ease":42.27549675631161,"gunning_fog_index":14.564634416928994,"has_proper_formatting":true,"maintains_line_breaks":true,"preserves_whitespace":true,"table_structure_preserved":true,"format_specific_score":0.8,"expected_content_preserved":false,"has_encoding_issues":false,"has_ocr_artifacts":true,"preserves_pdf_formatting":true},"overall_quality_score":0.45001632486553983,"extracted_text":"\nIntel® 64 and IA-32 Architectures\nSoftware Developer’s Manual\n\nCombined Volumes:\n1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D and 4\n\nNOTE: This document contains all four volumes of the Intel 64 and IA-32 Architectures Software\nDeveloper's Manual: Basic Architecture, Order Number 253665; Instruction Set Reference A-Z, Order\nNumber 325383; System Programming Guide, Order Number 325384; Model-Specific Registers, Order\nNumber 335592. Refer to all four volumes when evaluating your design needs.\n\nOrder Number:  325462-075US\nJune 2021\n\n\n\nIntel technologies features and benefits depend on system configuration and may require enabled hardware, software, or service activation. Learn\nmore at intel.com, or from the OEM or retailer.\n\nNo computer system can be absolutely secure. Intel does not assume any liability for lost or stolen data or systems or any damages resulting\nfrom such losses.\n\nYou may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products\ndescribed herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject\nmatter disclosed herein.\n\nNo license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document.\n\nThe products described may contain design defects or errors known as errata which may cause the product to deviate from published specifica-\ntions. Current characterized errata are available on request.\n\nThis document contains information on products, services and/or processes in development. All information provided here is subject to change\nwithout notice. Contact your Intel representative to obtain the latest Intel product specifications and roadmaps \n\nCopies of documents which have an order number and are referenced in this document, or other Intel literature, may be obtained by calling 1-\n800-548-4725, or by visiting http://www.intel.com/design/literature.htm.\n\nIntel, the Intel logo, Intel Atom, Intel Core, Intel SpeedStep, MMX, Pentium, VTune, and Xeon are trademarks of Intel Corporation in the U.S.\nand/or other countries.\n\n*Other names and brands may be claimed as the property of others.\n\nCopyright © 1997-2021, Intel Corporation. All Rights Reserved.\n\nhttp://www.intel.com/design/literature.htm\nhttp://www.intel.com/design/literature.htm\n\n\nIntel® 64 and IA-32 Architectures\nSoftware Developer’s Manual\n\nVolume 1:\nBasic Architecture\n\nNOTE: The Intel 64 and IA-32 Architectures Software Developer's Manual consists of four volumes:\nBasic Architecture, Order Number 253665; Instruction Set Reference A-Z, Order Number 325383;\nSystem Programming Guide, Order Number 325384; Model-Specific Registers, Order Number\n335592. Refer to all four volumes when evaluating your design needs.\n\nOrder Number:  253665-075US\nJune 2021\n\n\n\nIntel technologies features and benefits depend on system configuration and may require enabled hardware, software, or service activation. Learn\nmore at intel.com, or from the OEM or retailer.\n\nNo computer system can be absolutely secure. Intel does not assume any liability for lost or stolen data or systems or any damages resulting\nfrom such losses.\n\nYou may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products\ndescribed herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject\nmatter disclosed herein.\n\nNo license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document.\n\nThe products described may contain design defects or errors known as errata which may cause the product to deviate from published specifica-\ntions. Current characterized errata are available on request.\n\nThis document contains information on products, services and/or processes in development. All information provided here is subject to change\nwithout notice. Contact your Intel representative to obtain the latest Intel product specifications and roadmaps \n\nCopies of documents which have an order number and are referenced in this document, or other Intel literature, may be obtained by calling 1-\n800-548-4725, or by visiting http://www.intel.com/design/literature.htm.\n\nIntel, the Intel logo, Intel Atom, Intel Core, Intel SpeedStep, MMX, Pentium, VTune, and Xeon are trademarks of Intel Corporation in the U.S.\nand/or other countries.\n\n*Other names and brands may be claimed as the property of others.\n\nCopyright © 1997-2021, Intel Corporation. All Rights Reserved.\n\nhttp://www.intel.com/design/literature.htm\nhttp://www.intel.com/design/literature.htm\n\n\nCONTENTS\nPAGE\nCHAPTER 1\nABOUT THIS MANUAL\n1.1 INTEL® 64 AND IA-32 PROCESSORS COVERED IN THIS MANUAL  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1-1\n1.2 OVERVIEW OF VOLUME 1: BASIC ARCHITECTURE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1-4\n1.3 NOTATIONAL CONVENTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1-5\n1.3.1 Bit and Byte Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-5\n1.3.2 Reserved Bits and Software Compatibility  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-6\n1.3.2.1 Instruction Operands. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-6\n1.3.3 Hexadecimal and Binary Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-7\n1.3.4 Segmented Addressing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-7\n1.3.5 A New Syntax for CPUID, CR, and MSR Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-7\n1.3.6 Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-8\n1.4 RELATED LITERATURE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1-9\n\nCHAPTER 2\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.1 BRIEF HISTORY OF INTEL® 64 AND IA-32 ARCHITECTURE  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2-1\n2.1.1 16-bit Processors and Segmentation (1978) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-1\n2.1.2 The Intel® 286 Processor (1982) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-1\n2.1.3 The Intel386™ Processor (1985) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-1\n2.1.4 The Intel486™ Processor (1989) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-1\n2.1.5 The Intel® Pentium® Processor (1993). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-2\n2.1.6 The P6 Family of Processors (1995-1999) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-2\n2.1.7 The Intel® Pentium® 4 Processor Family (2000-2006). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-3\n2.1.8 The Intel® Xeon® Processor (2001- 2007) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-3\n2.1.9 The Intel® Pentium® M Processor (2003-2006) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-3\n2.1.10 The Intel® Pentium® Processor Extreme Edition (2005)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-4\n2.1.11 The Intel® Core™ Duo and Intel® Core™ Solo Processors (2006-2007)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-4\n2.1.12 The Intel® Xeon® Processor 5100, 5300 Series and Intel® Core™2 Processor Family (2006) . . . . . . . . . . . . . . . . . . . . . . . .2-4\n2.1.13 The Intel® Xeon® Processor 5200, 5400, 7400 Series and Intel® Core™2 Processor Family (2007) . . . . . . . . . . . . . . . . . .2-4\n2.1.14 The Intel® Atom™ Processor Family (2008) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\n2.1.15 The Intel® Atom™ Processor Family Based on Silvermont Microarchitecture (2013) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\n2.1.16 The Intel® Core™i7 Processor Family (2008) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\n2.1.17 The Intel® Xeon® Processor 7500 Series (2010) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\n2.1.18 2010 Intel® Core™ Processor Family (2010) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\n2.1.19 The Intel® Xeon® Processor 5600 Series (2010) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\n2.1.20 The Second Generation Intel® Core™ Processor Family (2011) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\n2.1.21 The Third Generation Intel® Core™ Processor Family (2012) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\n2.1.22 The Fourth Generation Intel® Core™ Processor Family (2013)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-7\n2.2 MORE ON SPECIFIC ADVANCES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2-7\n2.2.1 P6 Family Microarchitecture. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-7\n2.2.2 Intel NetBurst® Microarchitecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-8\n2.2.2.1 The Front End Pipeline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-9\n2.2.2.2 Out-Of-Order Execution Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\n2.2.2.3 Retirement Unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\n2.2.3 Intel® Core™ Microarchitecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\n2.2.3.1 The Front End . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\n2.2.3.2 Execution Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12\n2.2.4 Intel® Atom™ Microarchitecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12\n2.2.5 Intel® Microarchitecture Code Name Nehalem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-13\n2.2.6 Intel® Microarchitecture Code Name Sandy Bridge. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-13\n2.2.7 SIMD Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-14\n2.2.8 Intel® Hyper-Threading Technology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-16\nVol. 1 iii\n\n\n\nCONTENTS\n\nPAGE\n2.2.8.1 Some Implementation Notes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-17\n2.2.9 Multi-Core Technology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-18\n2.2.10 Intel® 64 Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-20\n2.2.11 Intel® Virtualization Technology (Intel® VT) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-20\n2.3 INTEL® 64 AND IA-32 PROCESSOR GENERATIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2-20\n2.4 PROPOSED REMOVAL OF INTEL INSTRUCTION SET ARCHITECTURE AND FEATURES FROM UPCOMING PRODUCTS . . . . .  2-28\n2.5 INTEL INSTRUCTION SET ARCHITECTURE AND FEATURES REMOVED . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2-28\n\nCHAPTER 3\nBASIC EXECUTION ENVIRONMENT\n3.1 MODES OF OPERATION. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-1\n3.1.1 Intel® 64 Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-1\n3.2 OVERVIEW OF THE BASIC EXECUTION ENVIRONMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-2\n3.2.1 64-Bit Mode Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-5\n3.3 MEMORY ORGANIZATION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-6\n3.3.1 IA-32 Memory Models. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-7\n3.3.2 Paging and Virtual Memory. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-8\n3.3.3 Memory Organization in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-8\n3.3.4 Modes of Operation vs. Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-9\n3.3.5 32-Bit and 16-Bit Address and Operand Sizes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-9\n3.3.6 Extended Physical Addressing in Protected Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-9\n3.3.7 Address Calculations in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-10\n3.3.7.1 Canonical Addressing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-10\n3.4 BASIC PROGRAM EXECUTION REGISTERS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-10\n3.4.1 General-Purpose Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-11\n3.4.1.1 General-Purpose Registers in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-12\n3.4.2 Segment Registers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-13\n3.4.2.1 Segment Registers in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-15\n3.4.3 EFLAGS Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-15\n3.4.3.1 Status Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-16\n3.4.3.2 DF Flag. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-17\n3.4.3.3 System Flags and IOPL Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-17\n3.4.3.4 RFLAGS Register in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-18\n3.5 INSTRUCTION POINTER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-18\n3.5.1 Instruction Pointer in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-18\n3.6 OPERAND-SIZE AND ADDRESS-SIZE ATTRIBUTES  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-18\n3.6.1 Operand Size and Address Size in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19\n3.7 OPERAND ADDRESSING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-19\n3.7.1 Immediate Operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-20\n3.7.2 Register Operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-20\n3.7.2.1 Register Operands in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\n3.7.3 Memory Operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\n3.7.3.1 Memory Operands in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\n3.7.4 Specifying a Segment Selector  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\n3.7.4.1 Segmentation in 64-Bit Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-22\n3.7.5 Specifying an Offset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-22\n3.7.5.1 Specifying an Offset in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-24\n3.7.6 Assembler and Compiler Addressing Modes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-24\n3.7.7 I/O Port Addressing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-24\n\nCHAPTER 4\nDATA TYPES\n4.1 FUNDAMENTAL DATA TYPES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-1\n4.1.1 Alignment of Words, Doublewords, Quadwords, and Double Quadwords  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-2\n4.2 NUMERIC DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-2\n4.2.1 Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-3\n4.2.1.1 Unsigned Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-3\n4.2.1.2 Signed Integers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-4\n4.2.2 Floating-Point Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-4\niv Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n4.3 POINTER DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-6\n4.3.1 Pointer Data Types in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\n4.4 BIT FIELD DATA TYPE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-7\n4.5 STRING DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-8\n4.6 PACKED SIMD DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-8\n4.6.1 64-Bit SIMD Packed Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\n4.6.2 128-Bit Packed SIMD Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\n4.7 BCD AND PACKED BCD INTEGERS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-9\n4.8 REAL NUMBERS AND FLOATING-POINT FORMATS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-11\n4.8.1 Real Number System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-11\n4.8.2 Floating-Point Format  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-11\n4.8.2.1 Normalized Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\n4.8.2.2 Biased Exponent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\n4.8.3 Real Number and Non-number Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\n4.8.3.1 Signed Zeros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14\n4.8.3.2 Normalized and Denormalized Finite Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14\n4.8.3.3 Signed Infinities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\n4.8.3.4 NaNs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\n4.8.3.5 Operating on SNaNs and QNaNs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\n4.8.3.6 Using SNaNs and QNaNs in Applications  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\n4.8.3.7 QNaN Floating-Point Indefinite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-17\n4.8.3.8 Half-Precision Floating-Point Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-17\n4.8.4 Rounding  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-17\n4.8.4.1 Rounding Control (RC) Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\n4.8.4.2 Truncation with SSE and SSE2 Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\n4.9 OVERVIEW OF FLOATING-POINT EXCEPTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-18\n4.9.1 Floating-Point Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\n4.9.1.1 Invalid Operation Exception (#I) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\n4.9.1.2 Denormal Operand Exception (#D). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\n4.9.1.3 Divide-By-Zero Exception (#Z) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\n4.9.1.4 Numeric Overflow Exception (#O) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\n4.9.1.5 Numeric Underflow Exception (#U) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\n4.9.1.6 Inexact-Result (Precision) Exception (#P) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-22\n4.9.2 Floating-Point Exception Priority . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-23\n4.9.3 Typical Actions of a Floating-Point Exception Handler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-23\n\nCHAPTER 5\nINSTRUCTION SET SUMMARY\n5.1 GENERAL-PURPOSE INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-4\n5.1.1 Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-4\n5.1.2 Binary Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-5\n5.1.3 Decimal Arithmetic Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\n5.1.4 Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\n5.1.5 Shift and Rotate Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\n5.1.6 Bit and Byte Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\n5.1.7 Control Transfer Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-7\n5.1.8 String Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-8\n5.1.9 I/O Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-8\n5.1.10 Enter and Leave Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9\n5.1.11 Flag Control (EFLAG) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9\n5.1.12 Segment Register Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9\n5.1.13 Miscellaneous Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9\n5.1.14 User Mode Extended Sate Save/Restore Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10\n5.1.15 Random Number Generator Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10\n5.1.16 BMI1, BMI2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10\n5.1.16.1 Detection of VEX-encoded GPR Instructions, LZCNT and TZCNT, PREFETCHW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10\n5.2 X87 FPU INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-11\n5.2.1 x87 FPU Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-11\n5.2.2 x87 FPU Basic Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-11\nVol. 1 v\n\n\n\nCONTENTS\n\nPAGE\n5.2.3 x87 FPU Comparison Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-12\n5.2.4 x87 FPU Transcendental Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-12\n5.2.5 x87 FPU Load Constants Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-12\n5.2.6 x87 FPU Control Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-13\n5.3 X87 FPU AND SIMD STATE MANAGEMENT INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-13\n5.4 MMX™ INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-13\n5.4.1 MMX Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-14\n5.4.2 MMX Conversion Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-14\n5.4.3 MMX Packed Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-14\n5.4.4 MMX Comparison Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\n5.4.5 MMX Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\n5.4.6 MMX Shift and Rotate Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\n5.4.7 MMX State Management Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\n5.5 SSE INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-15\n5.5.1 SSE SIMD Single-Precision Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-16\n5.5.1.1 SSE Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-16\n5.5.1.2 SSE Packed Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-16\n5.5.1.3 SSE Comparison Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\n5.5.1.4 SSE Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\n5.5.1.5 SSE Shuffle and Unpack Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\n5.5.1.6 SSE Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\n5.5.2 SSE MXCSR State Management Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-18\n5.5.3 SSE 64-Bit SIMD Integer Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-18\n5.5.4 SSE Cacheability Control, Prefetch, and Instruction Ordering Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-18\n5.6 SSE2 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-18\n5.6.1 SSE2 Packed and Scalar Double-Precision Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-19\n5.6.1.1 SSE2 Data Movement Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-19\n5.6.1.2 SSE2 Packed Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-19\n5.6.1.3 SSE2 Logical Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\n5.6.1.4 SSE2 Compare Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\n5.6.1.5 SSE2 Shuffle and Unpack Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\n5.6.1.6 SSE2 Conversion Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\n5.6.2 SSE2 Packed Single-Precision Floating-Point Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-21\n5.6.3 SSE2 128-Bit SIMD Integer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-21\n5.6.4 SSE2 Cacheability Control and Ordering Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-21\n5.7 SSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-22\n5.7.1 SSE3 x87-FP Integer Conversion Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\n5.7.2 SSE3 Specialized 128-bit Unaligned Data Load Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\n5.7.3 SSE3 SIMD Floating-Point Packed ADD/SUB Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\n5.7.4 SSE3 SIMD Floating-Point Horizontal ADD/SUB Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\n5.7.5 SSE3 SIMD Floating-Point LOAD/MOVE/DUPLICATE Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-23\n5.7.6 SSE3 Agent Synchronization Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-23\n5.8 SUPPLEMENTAL STREAMING SIMD EXTENSIONS 3 (SSSE3) INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-23\n5.8.1 Horizontal Addition/Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-23\n5.8.2 Packed Absolute Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.3 Multiply and Add Packed Signed and Unsigned Bytes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.4 Packed Multiply High with Round and Scale  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.5 Packed Shuffle Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.6 Packed Sign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.7 Packed Align Right . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.9 SSE4 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-25\n5.10 SSE4.1 INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-25\n5.10.1 Dword Multiply Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-25\n5.10.2 Floating-Point Dot Product Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-25\n5.10.3 Streaming Load Hint Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-25\n5.10.4 Packed Blending Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-26\n5.10.5 Packed Integer MIN/MAX Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-26\n5.10.6 Floating-Point Round Instructions with Selectable Rounding Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-26\n5.10.7 Insertion and Extractions from XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-26\nvi Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n5.10.8 Packed Integer Format Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-27\n5.10.9 Improved Sums of Absolute Differences (SAD) for 4-Byte Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-27\n5.10.10 Horizontal Search  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-27\n5.10.11 Packed Test. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.10.12 Packed Qword Equality Comparisons  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.10.13 Dword Packing With Unsigned Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.11 SSE4.2 INSTRUCTION SET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-28\n5.11.1 String and Text Processing Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.11.2 Packed Comparison SIMD integer Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.12 INTEL® AES-NI AND PCLMULQDQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-28\n5.13 INTEL® ADVANCED VECTOR EXTENSIONS (INTEL® AVX). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-29\n5.14 16-BIT FLOATING-POINT CONVERSION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-29\n5.15 FUSED-MULTIPLY-ADD (FMA)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-29\n5.16 INTEL® ADVANCED VECTOR EXTENSIONS 2 (INTEL® AVX2)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-29\n5.17 INTEL® TRANSACTIONAL SYNCHRONIZATION EXTENSIONS (INTEL® TSX) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-30\n5.18 INTEL® SHA EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-30\n5.19 INTEL® ADVANCED VECTOR EXTENSIONS 512 (INTEL® AVX-512)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-30\n5.20 SYSTEM INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-34\n5.21 64-BIT MODE INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-35\n5.22 VIRTUAL-MACHINE EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-35\n5.23 SAFER MODE EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-36\n5.24 INTEL® MEMORY PROTECTION EXTENSIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-36\n5.25 INTEL® SOFTWARE GUARD EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-37\n5.26 SHADOW STACK MANAGEMENT INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-37\n5.27 CONTROL TRANSFER TERMINATING INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-37\n\nCHAPTER 6\nPROCEDURE CALLS, INTERRUPTS, AND EXCEPTIONS\n6.1 PROCEDURE CALL TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-1\n6.2 STACKS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-1\n6.2.1 Setting Up a Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-2\n6.2.2 Stack Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-2\n6.2.3 Address-Size Attributes for Stack Accesses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3\n6.2.4 Procedure Linking Information  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3\n6.2.4.1 Stack-Frame Base Pointer  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3\n6.2.4.2 Return Instruction Pointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3\n6.2.5 Stack Behavior in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-4\n6.3 SHADOW STACKS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-4\n6.4 CALLING PROCEDURES USING CALL AND RET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-4\n6.4.1 Near CALL and RET Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-4\n6.4.2 Far CALL and RET Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-5\n6.4.3 Parameter Passing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.3.1 Passing Parameters Through the General-Purpose Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.3.2 Passing Parameters on the Stack. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.3.3 Passing Parameters in an Argument List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.4 Saving Procedure State Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.5 Calls to Other Privilege Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.6 CALL and RET Operation Between Privilege Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-8\n6.4.7 Branch Functions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-12\n6.5 INTERRUPTS AND EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-12\n6.5.1 Call and Return Operation for Interrupt or Exception Handling Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-13\n6.5.2 Calls to Interrupt or Exception Handler Tasks  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-18\n6.5.3 Interrupt and Exception Handling in Real-Address Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-18\n6.5.4 INT n, INTO, INT3, INT1, and BOUND Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-18\n6.5.5 Handling Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-19\n6.5.6 Interrupt and Exception Behavior in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-19\n6.6 PROCEDURE CALLS FOR BLOCK-STRUCTURED LANGUAGES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-20\n6.6.1 ENTER Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-20\n6.6.2 LEAVE Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-24\nVol. 1 vii\n\n\n\nCONTENTS\n\nPAGE\nCHAPTER 7\nPROGRAMMING WITH GENERAL-PURPOSE INSTRUCTIONS\n7.1 PROGRAMMING ENVIRONMENT FOR GP INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  7-1\n7.2 PROGRAMMING ENVIRONMENT FOR GP INSTRUCTIONS IN 64-BIT MODE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  7-1\n7.3 SUMMARY OF GP INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  7-2\n7.3.1 Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-2\n7.3.1.1 General Data Movement Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-3\n7.3.1.2 Exchange Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-4\n7.3.1.3 Exchange Instructions in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-5\n7.3.1.4 Stack Manipulation Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-5\n7.3.1.5 Stack Manipulation Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-7\n7.3.1.6 Type Conversion Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-7\n7.3.1.7 Type Conversion Instructions in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2 Binary Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.1 Addition and Subtraction Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.2 Increment and Decrement Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.3 Increment and Decrement Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.4 Comparison and Sign Change Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.5 Multiplication and Division Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-9\n7.3.3 Decimal Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-9\n7.3.3.1 Packed BCD Adjustment Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-9\n7.3.3.2 Unpacked BCD Adjustment Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-9\n7.3.4 Decimal Arithmetic Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-10\n7.3.5 Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-10\n7.3.6 Shift and Rotate Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-10\n7.3.6.1 Shift Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-10\n7.3.6.2 Double-Shift Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-12\n7.3.6.3 Rotate Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-13\n7.3.7 Bit and Byte Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-13\n7.3.7.1 Bit Test and Modify Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.7.2 Bit Scan Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.7.3 Byte Set on Condition Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.7.4 Test Instruction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.8 Control Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.8.1 Unconditional Transfer Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.8.2 Conditional Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-15\n7.3.8.3 Control Transfer Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-17\n7.3.8.4 Software Interrupt Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-17\n7.3.8.5 Software Interrupt Instructions in 64-bit Mode and Compatibility Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-18\n7.3.9 String Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-18\n7.3.9.1 String Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-18\n7.3.9.2 Repeated String Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-19\n7.3.9.3 Fast-String Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-19\n7.3.9.4 String Operations in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-20\n7.3.10 I/O Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-20\n7.3.11 I/O Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-20\n7.3.12 Enter and Leave Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\n7.3.13 Flag Control (EFLAG) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\n7.3.13.1 Carry and Direction Flag Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\n7.3.13.2 EFLAGS Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\n7.3.13.3 Interrupt Flag Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.14 Flag Control (RFLAG) Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.15 Segment Register Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.15.1 Segment-Register Load and Store Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.15.2 Far Control Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.15.3 Software Interrupt Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.15.4 Load Far Pointer Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.16 Miscellaneous Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.16.1 Address Computation Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\nviii Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n7.3.16.2 Table Lookup Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.16.3 Processor Identification Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.16.4 No-Operation and Undefined Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.17 Random Number Generator Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-24\n7.3.17.1 RDRAND . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-24\n7.3.17.2 RDSEED. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-24\n\nCHAPTER 8\nPROGRAMMING WITH THE X87 FPU \n8.1 X87 FPU EXECUTION ENVIRONMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-1\n8.1.1 x87 FPU in 64-Bit Mode and Compatibility Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-1\n8.1.2 x87 FPU Data Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-1\n8.1.2.1 Parameter Passing With the x87 FPU Register Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-3\n8.1.3 x87 FPU Status Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-4\n8.1.3.1 Top of Stack (TOP) Pointer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-4\n8.1.3.2 Condition Code Flags  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-4\n8.1.3.3 x87 FPU Floating-Point Exception Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-5\n8.1.3.4 Stack Fault Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-6\n8.1.4 Branching and Conditional Moves on Condition Codes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-6\n8.1.5 x87 FPU Control Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-7\n8.1.5.1 x87 FPU Floating-Point Exception Mask Bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-7\n8.1.5.2 Precision Control Field . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-7\n8.1.5.3 Rounding Control Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\n8.1.6 Infinity Control Flag. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\n8.1.7 x87 FPU Tag Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\n8.1.8 x87 FPU Instruction and Data (Operand) Pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-9\n8.1.9 Last Instruction Opcode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-10\n8.1.9.1 Fopcode Compatibility Sub-mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-10\n8.1.10 Saving the x87 FPU’s State with FSTENV/FNSTENV and FSAVE/FNSAVE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-11\n8.1.11 Saving the x87 FPU’s State with FXSAVE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12\n8.2 X87 FPU DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-13\n8.2.1 Indefinites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-14\n8.2.2 Unsupported Double Extended-Precision Floating-Point Encodings and Pseudo-Denormals . . . . . . . . . . . . . . . . . . . . . . . . 8-14\n8.3 X87 FPU INSTRUCTION SET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-15\n8.3.1 Escape (ESC) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-15\n8.3.2 x87 FPU Instruction Operands  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-15\n8.3.3 Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-16\n8.3.4 Load Constant Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-17\n8.3.5 Basic Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-17\n8.3.6 Comparison and Classification Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-18\n8.3.6.1 Branching on the x87 FPU Condition Codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-20\n8.3.7 Trigonometric Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-20\n8.3.8 Approximation of Pi  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-21\n8.3.9 Logarithmic, Exponential, and Scale. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-21\n8.3.10 Transcendental Instruction Accuracy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-22\n8.3.11 x87 FPU Control Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-23\n8.3.12 Waiting vs. Non-waiting Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-24\n8.3.13 Unsupported x87 FPU Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-24\n8.4 X87 FPU FLOATING-POINT EXCEPTION HANDLING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-24\n8.4.1 Arithmetic vs. Non-arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-25\n8.5 X87 FPU FLOATING-POINT EXCEPTION CONDITIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-26\n8.5.1 Invalid Operation Exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-26\n8.5.1.1 Stack Overflow or Underflow Exception (#IS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-26\n8.5.1.2 Invalid Arithmetic Operand Exception (#IA)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-27\n8.5.2 Denormal Operand Exception (#D). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-28\n8.5.3 Divide-By-Zero Exception (#Z) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-28\n8.5.4 Numeric Overflow Exception (#O) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-28\n8.5.5 Numeric Underflow Exception (#U) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-29\n8.5.6 Inexact-Result (Precision) Exception (#P) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-30\nVol. 1 ix\n\n\n\nCONTENTS\n\nPAGE\n8.6 X87 FPU EXCEPTION SYNCHRONIZATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-31\n8.7 HANDLING X87 FPU EXCEPTIONS IN SOFTWARE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-32\n8.7.1 Native Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-32\n8.7.2 MS-DOS* Compatibility Sub-mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-32\n8.7.3 Handling x87 FPU Exceptions in Software  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-33\n\nCHAPTER 9 \nPROGRAMMING WITH INTEL® MMX™ TECHNOLOGY\n9.1 OVERVIEW OF MMX TECHNOLOGY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-1\n9.2 THE MMX TECHNOLOGY PROGRAMMING ENVIRONMENT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-1\n9.2.1 MMX Technology in 64-Bit Mode and Compatibility Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-2\n9.2.2 MMX Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-2\n9.2.3 MMX Data Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-3\n9.2.4 Memory Data Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-3\n9.2.5 Single Instruction, Multiple Data (SIMD) Execution Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-4\n9.3 SATURATION AND WRAPAROUND MODES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-4\n9.4 MMX INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-5\n9.4.1 Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-6\n9.4.2 Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-6\n9.4.3 Comparison Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-7\n9.4.4 Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-7\n9.4.5 Unpack Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-7\n9.4.6 Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-7\n9.4.7 Shift Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-8\n9.4.8 EMMS Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-8\n9.5 COMPATIBILITY WITH X87 FPU ARCHITECTURE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-8\n9.5.1 MMX Instructions and the x87 FPU Tag Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-8\n9.6 WRITING APPLICATIONS WITH MMX CODE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-8\n9.6.1 Checking for MMX Technology Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-8\n9.6.2 Transitions Between x87 FPU and MMX Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-9\n9.6.3 Using the EMMS Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-9\n9.6.4 Mixing MMX and x87 FPU Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-10\n9.6.5 Interfacing with MMX Code. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-10\n9.6.6 Using MMX Code in a Multitasking Operating System Environment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-10\n9.6.7 Exception Handling in MMX Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-11\n9.6.8 Register Mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-11\n9.6.9 Effect of Instruction Prefixes on MMX Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-11\n\nCHAPTER 10\nPROGRAMMING WITH INTEL® STREAMING SIMD EXTENSIONS (INTEL® SSE)\n10.1 OVERVIEW OF SSE EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10-1\n10.2 SSE PROGRAMMING ENVIRONMENT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10-2\n10.2.1 SSE in 64-Bit Mode and Compatibility Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-3\n10.2.2 XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-3\n10.2.3 MXCSR Control and Status Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-3\n10.2.3.1 SIMD Floating-Point Mask and Flag Bits  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-4\n10.2.3.2 SIMD Floating-Point Rounding Control Field  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-4\n10.2.3.3 Flush-To-Zero . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-4\n10.2.3.4 Denormals-Are-Zeros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-5\n10.2.4 Compatibility of SSE Extensions with SSE2/SSE3/MMX and the x87 FPU. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-5\n10.3 SSE DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10-5\n10.4 SSE INSTRUCTION SET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10-6\n10.4.1 SSE Packed and Scalar Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-6\n10.4.1.1 SSE Data Movement Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-7\n10.4.1.2 SSE Arithmetic Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-8\n10.4.2 SSE Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-9\n10.4.2.1 SSE Comparison Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-9\n10.4.2.2 SSE Shuffle and Unpack Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-9\n10.4.3 SSE Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-11\nx Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n10.4.4 SSE 64-Bit SIMD Integer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-11\n10.4.5 MXCSR State Management Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-12\n10.4.6 Cacheability Control, Prefetch, and Memory Ordering Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-12\n10.4.6.1 Cacheability Control Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-12\n10.4.6.2 Caching of Temporal vs. Non-Temporal Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-12\n10.4.6.3 PREFETCHh Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-13\n10.4.6.4 SFENCE Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-14\n10.5 FXSAVE AND FXRSTOR INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-14\n10.5.1 FXSAVE Area  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-14\n10.5.1.1 x87 State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-15\n10.5.1.2 SSE State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-16\n10.5.2 Operation of FXSAVE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-16\n10.5.3 Operation of FXRSTOR  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-17\n10.6 HANDLING SSE INSTRUCTION EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-17\n10.7 WRITING APPLICATIONS WITH THE SSE EXTENSIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-17\n\nCHAPTER 11\nPROGRAMMING WITH INTEL® STREAMING SIMD EXTENSIONS 2 (INTEL® SSE2)\n11.1 OVERVIEW OF SSE2 EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11-1\n11.2 SSE2 PROGRAMMING ENVIRONMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11-2\n11.2.1 SSE2 in 64-Bit Mode and Compatibility Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-3\n11.2.2 Compatibility of SSE2 Extensions with SSE, MMX Technology and x87 FPU Programming Environment  . . . . . . . . . . . . 11-3\n11.2.3 Denormals-Are-Zeros Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-3\n11.3 SSE2 DATA TYPES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11-3\n11.4 SSE2 INSTRUCTIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11-4\n11.4.1 Packed and Scalar Double-Precision Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-4\n11.4.1.1 Data Movement Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-5\n11.4.1.2 SSE2 Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-6\n11.4.1.3 SSE2 Logical Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-7\n11.4.1.4 SSE2 Comparison Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-7\n11.4.1.5 SSE2 Shuffle and Unpack Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-7\n11.4.1.6 SSE2 Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-9\n11.4.2 SSE2 64-Bit and 128-Bit SIMD Integer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-10\n11.4.3 128-Bit SIMD Integer Instruction Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-11\n11.4.4 Cacheability Control and Memory Ordering Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.4.1 FLUSH Cache Line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.4.2 Cacheability Control Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.4.3 Memory Ordering Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.4.4 Pause. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.5 Branch Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-13\n11.5 SSE, SSE2, AND SSE3 EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-13\n11.5.1 SIMD Floating-Point Exceptions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-13\n11.5.2 SIMD Floating-Point Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-14\n11.5.2.1 Invalid Operation Exception (#I) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-14\n11.5.2.2 Denormal-Operand Exception (#D)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-15\n11.5.2.3 Divide-By-Zero Exception (#Z) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-15\n11.5.2.4 Numeric Overflow Exception (#O) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-15\n11.5.2.5 Numeric Underflow Exception (#U) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-16\n11.5.2.6 Inexact-Result (Precision) Exception (#P) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-16\n11.5.3 Generating SIMD Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-16\n11.5.3.1 Handling Masked Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-16\n11.5.3.2 Handling Unmasked Exceptions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-17\n11.5.3.3 Handling Combinations of Masked and Unmasked Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-18\n11.5.4 Handling SIMD Floating-Point Exceptions in Software. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-18\n11.5.5 Interaction of SIMD and x87 FPU Floating-Point Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-18\n11.6 WRITING APPLICATIONS WITH SSE/SSE2 EXTENSIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-19\n11.6.1 General Guidelines for Using SSE/SSE2 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-19\n11.6.2 Checking for SSE/SSE2 Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-19\n11.6.3 Checking for the DAZ Flag in the MXCSR Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-20\nVol. 1 xi\n\n\n\nCONTENTS\n\nPAGE\n11.6.4 Initialization of SSE/SSE2 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-20\n11.6.5 Saving and Restoring the SSE/SSE2 State. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-20\n11.6.6 Guidelines for Writing to the MXCSR Register  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-21\n11.6.7 Interaction of SSE/SSE2 Instructions with x87 FPU and MMX Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-21\n11.6.8 Compatibility of SIMD and x87 FPU Floating-Point Data Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-22\n11.6.9 Mixing Packed and Scalar Floating-Point and 128-Bit SIMD Integer Instructions and Data . . . . . . . . . . . . . . . . . . . . . . . . . 11-22\n11.6.10 Interfacing with SSE/SSE2 Procedures and Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-23\n11.6.10.1 Passing Parameters in XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-23\n11.6.10.2 Saving XMM Register State on a Procedure or Function Call . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-23\n11.6.10.3 Caller-Save Recommendation for Procedure and Function Calls. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-24\n11.6.11 Updating Existing MMX Technology Routines Using 128-Bit SIMD Integer Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-24\n11.6.12 Branching on Arithmetic Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-24\n11.6.13 Cacheability Hint Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-25\n11.6.14 Effect of Instruction Prefixes on the SSE/SSE2 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-25\n\nCHAPTER 12\nPROGRAMMING WITH INTEL® SSE3, SSSE3, INTEL® SSE4 AND INTEL® AESNI\n12.1 PROGRAMMING ENVIRONMENT AND DATA TYPES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-1\n12.1.1 SSE3, SSSE3, SSE4 in 64-Bit Mode and Compatibility Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-1\n12.1.2 Compatibility of SSE3/SSSE3 with MMX Technology, the x87 FPU Environment, and SSE/SSE2 Extensions . . . . . . . . . 12-1\n12.1.3 Horizontal and Asymmetric Processing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-1\n12.2 OVERVIEW OF SSE3 INSTRUCTIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-2\n12.3 SSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-2\n12.3.1 x87 FPU Instruction for Integer Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-3\n12.3.2 SIMD Integer Instruction for Specialized 128-bit Unaligned Data Load  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-3\n12.3.3 SIMD Floating-Point Instructions That Enhance LOAD/MOVE/DUPLICATE Performance. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-3\n12.3.4 SIMD Floating-Point Instructions Provide Packed Addition/Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-4\n12.3.5 SIMD Floating-Point Instructions Provide Horizontal Addition/Subtraction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-4\n12.3.6 Two Thread Synchronization Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-5\n12.4 WRITING APPLICATIONS WITH SSE3 EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-5\n12.4.1 Guidelines for Using SSE3 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-5\n12.4.2 Checking for SSE3 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-5\n12.4.3 Enable FTZ and DAZ for SIMD Floating-Point Computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-6\n12.4.4 Programming SSE3 with SSE/SSE2 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-6\n12.5 OVERVIEW OF SSSE3 INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-6\n12.6 SSSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-6\n12.6.1 Horizontal Addition/Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-7\n12.6.2 Packed Absolute Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-7\n12.6.3 Multiply and Add Packed Signed and Unsigned Bytes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.6.4 Packed Multiply High with Round and Scale  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.6.5 Packed Shuffle Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.6.6 Packed Sign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.6.7 Packed Align Right . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.7 WRITING APPLICATIONS WITH SSSE3 EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-9\n12.7.1 Guidelines for Using SSSE3 Extensions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-9\n12.7.2 Checking for SSSE3 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-9\n12.8 SSE3/SSSE3 AND SSE4 EXCEPTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-9\n12.8.1 Device Not Available (DNA) Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-9\n12.8.2 Numeric Error flag and IGNNE# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-9\n12.8.3 Emulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-10\n12.8.4 IEEE 754 Compliance of SSE4.1 Floating-Point Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-10\n12.9 SSE4 OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-10\n12.10 SSE4.1 INSTRUCTION SET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-11\n12.10.1 Dword Multiply Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-11\n12.10.2 Floating-Point Dot Product Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-11\n12.10.3 Streaming Load Hint Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-12\n12.10.4 Packed Blending Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\n12.10.5 Packed Integer MIN/MAX Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\n12.10.6 Floating-Point Round Instructions with Selectable Rounding Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\nxii Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n12.10.7 Insertion and Extractions from XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-15\n12.10.8 Packed Integer Format Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-15\n12.10.9 Improved Sums of Absolute Differences (SAD) for 4-Byte Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-16\n12.10.10 Horizontal Search  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-16\n12.10.11 Packed Test. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.10.12 Packed Qword Equality Comparisons  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.10.13 Dword Packing With Unsigned Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.11 SSE4.2 INSTRUCTION SET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.11.1 String and Text Processing Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.11.1.1 Memory Operand Alignment  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-18\n12.11.2 Packed Comparison SIMD Integer Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-18\n12.12 WRITING APPLICATIONS WITH SSE4 EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-18\n12.12.1 Guidelines for Using SSE4 Extensions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-18\n12.12.2 Checking for SSE4.1 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-19\n12.12.3 Checking for SSE4.2 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-19\n12.13 AESNI OVERVIEW. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-19\n12.13.1 Little-Endian Architecture and Big-Endian Specification (FIPS 197) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-19\n12.13.1.1 AES Data Structure in Intel 64 Architecture. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-20\n12.13.2 AES Transformations and Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-21\n12.13.3 PCLMULQDQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-24\n12.13.4 Checking for AESNI Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-24\n\nCHAPTER 13\nMANAGING STATE USING THE XSAVE FEATURE SET\n13.1 XSAVE-SUPPORTED FEATURES AND STATE-COMPONENT BITMAPS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13-1\n13.2 ENUMERATION OF CPU SUPPORT FOR XSAVE INSTRUCTIONS AND XSAVE-SUPPORTED FEATURES  . . . . . . . . . . . . . . . . . .  13-3\n13.3 ENABLING THE XSAVE FEATURE SET AND XSAVE-ENABLED FEATURES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13-4\n13.4 XSAVE AREA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13-6\n13.4.1 Legacy Region of an XSAVE Area  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-7\n13.4.2 XSAVE Header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-8\n13.4.3 Extended Region of an XSAVE Area . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-8\n13.5 XSAVE-MANAGED STATE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13-9\n13.5.1 x87 State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-9\n13.5.2 SSE State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-10\n13.5.3 AVX State  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-10\n13.5.4 MPX State  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-11\n13.5.5 AVX-512 State. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-11\n13.5.6 PT State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-12\n13.5.7 PKRU State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-13\n13.5.8 CET State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-13\n13.5.9 HDC State. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-13\n13.5.10 HWP State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-14\n13.6 PROCESSOR TRACKING OF XSAVE-MANAGED STATE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-14\n13.7 OPERATION OF XSAVE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-15\n13.8 OPERATION OF XRSTOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-16\n13.8.1 Standard Form of XRSTOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-16\n13.8.2 Compacted Form of XRSTOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-17\n13.8.3 XRSTOR and the Init and Modified Optimizations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-17\n13.9 OPERATION OF XSAVEOPT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-18\n13.10 OPERATION OF XSAVEC  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-19\n13.11 OPERATION OF XSAVES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-20\n13.12 OPERATION OF XRSTORS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-21\n13.13 MEMORY ACCESSES BY THE XSAVE FEATURE SET  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-23\n\nCHAPTER 14\nPROGRAMMING WITH AVX, FMA AND AVX2\n14.1 INTEL AVX OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-1\n14.1.1 256-Bit Wide SIMD Register Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-1\n14.1.2 Instruction Syntax Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-2\nVol. 1 xiii\n\n\n\nCONTENTS\n\nPAGE\n14.1.3 VEX Prefix Instruction Encoding Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-2\n14.2 FUNCTIONAL OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-3\n14.2.1 256-bit Floating-Point Arithmetic Processing Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-9\n14.2.2 256-bit Non-Arithmetic Instruction Enhancements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-9\n14.2.3 Arithmetic Primitives for 128-bit Vector and Scalar processing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-11\n14.2.4 Non-Arithmetic Primitives for 128-bit Vector and Scalar Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-13\n14.3 DETECTION OF AVX INSTRUCTIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-15\n14.3.1 Detection of VEX-Encoded AES and VPCLMULQDQ  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-17\n14.4 HALF-PRECISION FLOATING-POINT CONVERSION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-18\n14.4.1 Detection of F16C Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-20\n14.5 FUSED-MULTIPLY-ADD (FMA) EXTENSIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-21\n14.5.1 FMA Instruction Operand Order and Arithmetic Behavior. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-22\n14.5.2 Fused-Multiply-ADD (FMA) Numeric Behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-22\n14.5.3 Detection of FMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-24\n14.6 OVERVIEW OF INTEL® ADVANCED VECTOR EXTENSIONS 2 (INTEL® AVX2)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-25\n14.6.1 AVX2 and 256-bit Vector Integer Processing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-25\n14.7 PROMOTED VECTOR INTEGER INSTRUCTIONS IN AVX2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-26\n14.7.1 Detection of AVX2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-31\n14.8 ACCESSING YMM REGISTERS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-32\n14.9 MEMORY ALIGNMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-32\n14.10 SIMD FLOATING-POINT EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-34\n14.11 EMULATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-34\n14.12 WRITING AVX FLOATING-POINT EXCEPTION HANDLERS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-34\n14.13 GENERAL PURPOSE INSTRUCTION SET ENHANCEMENTS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-35\n\nCHAPTER 15\nPROGRAMMING WITH INTEL® AVX-512\n15.1 OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-1\n15.1.1 512-Bit Wide SIMD Register Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-1\n15.1.2 32 SIMD Register Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-1\n15.1.3 Eight Opmask Register Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-1\n15.1.4 Instruction Syntax Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-2\n15.1.5 EVEX Instruction Encoding Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-3\n15.2 DETECTION OF AVX-512 FOUNDATION INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-3\n15.2.1 Additional 512-bit Instruction Extensions of the Intel AVX-512 Family . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-4\n15.3 DETECTION OF 512-BIT INSTRUCTION GROUPS OF INTEL® AVX-512 FAMILY. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-5\n15.4 DETECTION OF INTEL AVX-512 INSTRUCTION GROUPS OPERATING AT 256 AND 128-BIT VECTOR LENGTHS  . . . . . . . . .  15-6\n15.5 ACCESSING XMM, YMM AND ZMM REGISTERS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-8\n15.6 ENHANCED VECTOR PROGRAMMING ENVIRONMENT USING EVEX ENCODING  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-8\n15.6.1 OPMASK Register to Predicate Vector Data Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-9\n15.6.1.1 Opmask Register K0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-9\n15.6.1.2 Example of Opmask Usages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-10\n15.6.2 OpMask Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-11\n15.6.3 Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-11\n15.6.4 Static Rounding Mode and Suppress All Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-12\n15.6.5 Compressed Disp8*N Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-13\n15.7 MEMORY ALIGNMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-13\n15.8 SIMD FLOATING-POINT EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-14\n15.9 INSTRUCTION EXCEPTION SPECIFICATION. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-15\n15.10 EMULATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-15\n15.11 WRITING FLOATING-POINT EXCEPTION HANDLERS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-15\n\nCHAPTER 16\nPROGRAMMING WITH INTEL® TRANSACTIONAL SYNCHRONIZATION EXTENSIONS\n16.1 OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  16-1\n16.2 INTEL® TRANSACTIONAL SYNCHRONIZATION EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  16-1\n16.2.1 HLE Software Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-2\n16.2.2 RTM Software Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3 INTEL® TSX APPLICATION PROGRAMMING MODEL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  16-3\nxiv Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n16.3.1 Detection of Transactional Synchronization Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3.1.1 Detection of HLE Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3.1.2 Detection of RTM Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3.1.3 Detection of XTEST Instruction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3.2 Querying Transactional Execution Status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-4\n16.3.3 Requirements for HLE Locks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-4\n16.3.4 Transactional Nesting  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-4\n16.3.4.1 HLE Nesting and Elision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-4\n16.3.4.2 RTM Nesting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\n16.3.4.3 Nesting HLE and RTM. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\n16.3.5 RTM Abort Status Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\n16.3.6 RTM Memory Ordering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\n16.3.7 RTM-Enabled Debugger Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-6\n16.3.8 Programming Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-6\n16.3.8.1 Instruction Based Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-6\n16.3.8.2 Runtime Considerations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-7\n\nCHAPTER 17\nINTEL® MEMORY PROTECTION EXTENSIONS\n17.1 INTEL® MEMORY PROTECTION EXTENSIONS (INTEL® MPX) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-1\n17.2 INTRODUCTION. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-1\n17.3 INTEL MPX PROGRAMMING ENVIRONMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-2\n17.3.1 Detection and Enumeration of Intel MPX Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-2\n17.3.2 Bounds Registers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-2\n17.3.3 Configuration and Status Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-3\n17.3.4 Read and Write of IA32_BNDCFGS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-4\n17.4 INTEL MPX INSTRUCTION SUMMARY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-4\n17.4.1 Instruction Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-5\n17.4.2 Usage and Examples. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-5\n17.4.3 Loading and Storing Bounds in Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-6\n17.4.3.1 BNDLDX and BNDSTX in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-7\n17.4.3.2 BNDLDX and BNDSTX Outside 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-8\n17.5 INTERACTIONS WITH INTEL MPX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-9\n17.5.1 Intel MPX and Operating Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-9\n17.5.2 Intel MPX Support for Pointer Operations with Branching. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-10\n17.5.3 CALL, RET, JMP and All Jcc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-10\n17.5.4 BOUND Instruction and Intel MPX  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\n17.5.5 Programming Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\n17.5.6 Intel MPX and System Management Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\n17.5.7 Support of Intel MPX in VMCS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\n17.5.8 Support of Intel MPX in Intel TSX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-12\n\nCHAPTER 18\nCONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET)\n18.1 INTRODUCTION. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18-1\n18.1.1 Shadow Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-1\n18.1.2 Indirect Branch Tracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-1\n18.1.3 Speculative Behavior when CET is Enabled. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-2\n18.2 SHADOW STACKS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18-2\n18.2.1 Shadow Stack Pointer and its Operand and Address Size Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-2\n18.2.2 Terminology  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-2\n18.2.3 Supervisor Shadow Stack Token  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-3\n18.2.4 Shadow Stack Usage on Task Switch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-5\n18.2.5 Switching Shadow Stacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-5\n18.2.6 Constraining Execution at Targets of RET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-7\n18.3 INDIRECT BRANCH TRACKING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18-7\n18.3.1 No-track Prefix for Near Indirect CALL/JMP  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-8\n18.3.2 Terminology  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-9\n18.3.3 Indirect Branch Tracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-10\nVol. 1 xv\n\n\n\nCONTENTS\n\nPAGE\n18.3.3.1 Control Transfers between CPL 3 and CPL < 3  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-10\n18.3.3.2 Control Transfers within CPL 3 or CPL < 3  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-10\n18.3.4 Indirect Branch Tracking State Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-11\n18.3.5 INT3 Treatment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-12\n18.3.6 Legacy Compatibility Treatment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-12\n18.3.6.1 Legacy Code Page Bitmap Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.7 Other Considerations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.7.1 Intel® Transactional Synchronization Extensions (Intel® TSX) Interactions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.7.2 #CP(ENDBRANCH) Priority w.r.t #NM and #UD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.7.3 #CP(ENDBRANCH) Priority w.r.t #BP and #DB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.8 Constraining Speculation after Missing ENDBRANCH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-14\n18.4 INTEL® TRUSTED EXECUTION TECHNOLOGY (INTEL® TXT) INTERACTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18-14\n\nCHAPTER 19\nINPUT/OUTPUT\n19.1 I/O PORT ADDRESSING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-1\n19.2 I/O PORT HARDWARE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-1\n19.3 I/O ADDRESS SPACE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-1\n19.3.1 Memory-Mapped I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-2\n19.4 I/O INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-3\n19.5 PROTECTED-MODE I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-3\n19.5.1 I/O Privilege Level  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-3\n19.5.2 I/O Permission Bit Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-4\n19.6 ORDERING I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-5\n\nCHAPTER 20 \nPROCESSOR IDENTIFICATION AND FEATURE DETERMINATION\n20.1 USING THE CPUID INSTRUCTION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  20-1\n20.1.1 Notes on Where to Start . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20-1\n20.1.2 Identification of Earlier IA-32 Processors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20-1\n\nAPPENDIX A\nEFLAGS CROSS-REFERENCE\nA.1 EFLAGS AND INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  A-1\n\nAPPENDIX B\nEFLAGS CONDITION CODES\nB.1 CONDITION CODES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  B-1\n\nAPPENDIX C\nFLOATING-POINT EXCEPTIONS SUMMARY\nC.1 OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-1\nC.2 X87 FPU INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-1\nC.3 SSE INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-3\nC.4 SSE2 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-5\nC.5 SSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-7\nC.6 SSSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-7\nC.7 SSE4 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-7\n\nAPPENDIX D\nGUIDELINES FOR WRITING SIMD FLOATING-POINT EXCEPTION HANDLERS\nD.1 TWO OPTIONS FOR HANDLING FLOATING-POINT EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-1\nD.2 SOFTWARE EXCEPTION HANDLING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-1\nD.3 EXCEPTION SYNCHRONIZATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-3\nD.4 SIMD FLOATING-POINT EXCEPTIONS AND THE IEEE STANDARD 754  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-3\nD.4.1 Floating-Point Emulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-3\nD.4.2 SSE/SSE2/SSE3 Response To Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-4\nD.4.2.1 Numeric Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-5\nxvi Vol. 1\n\n\n\nCONTENTS\n\nPAGE\nD.4.2.2 Results of Operations with NaN Operands or a NaN Result for SSE/SSE2/SSE3 Numeric Instructions. . . . . . . . . . . . . .D-5\nD.4.2.3 Condition Codes, Exception Flags, and Response for Masked and Unmasked Numeric Exceptions. . . . . . . . . . . . . . . . . .D-9\nD.4.3 Example SIMD Floating-Point Emulation Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-15\nVol. 1 xvii\n\n\n\nCONTENTS\n\nPAGE\nFIGURES\n\nFigure 1-1. Bit and Byte Order. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\nFigure 1-2. Syntax for CPUID, CR, and MSR Data Presentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-8\nFigure 2-1. The P6 Processor Microarchitecture with Advanced Transfer Cache Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-7\nFigure 2-2. The Intel NetBurst Microarchitecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-9\nFigure 2-3. The Intel Core Microarchitecture Pipeline Functionality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\nFigure 2-4. SIMD Extensions, Register Layouts, and Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-16\nFigure 2-5. Comparison of an IA-32 Processor Supporting Hyper-Threading Technology and a Traditional Dual Processor \n\nSystem  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-17\nFigure 2-6. Intel 64 and IA-32 Processors that Support Dual-Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-18\nFigure 2-7. Intel 64 Processors that Support Quad-Core  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-19\nFigure 2-8. Intel Core i7 Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-19\nFigure 3-1. IA-32 Basic Execution Environment for Non-64-bit Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-3\nFigure 3-2. 64-Bit Mode Execution Environment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-6\nFigure 3-3. Three Memory Management Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-8\nFigure 3-4. General System and Application Programming Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-11\nFigure 3-5. Alternate General-Purpose Register Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-12\nFigure 3-6. Use of Segment Registers for Flat Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-14\nFigure 3-7. Use of Segment Registers in Segmented Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-14\nFigure 3-8. EFLAGS Register  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-16\nFigure 3-9. Memory Operand Address. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\nFigure 3-10. Memory Operand Address in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\nFigure 3-11. Offset (or Effective Address) Computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-23\nFigure 4-1. Fundamental Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\nFigure 4-2. Bytes, Words, Doublewords, Quadwords, and Double Quadwords in Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\nFigure 4-3. Numeric Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-3\nFigure 4-4. Pointer Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\nFigure 4-5. Pointers in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\nFigure 4-6. Bit Field Data Type  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\nFigure 4-7. 64-Bit Packed SIMD Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\nFigure 4-8. 128-Bit Packed SIMD Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-9\nFigure 4-9. BCD Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10\nFigure 4-10. Binary Real Number System. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-12\nFigure 4-11. Binary Floating-Point Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-12\nFigure 4-12. Real Numbers and NaNs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14\nFigure 6-1. Stack Structure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-2\nFigure 6-2. Stack on Near and Far Calls  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-6\nFigure 6-3. Shadow Stack on Near and Far Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-6\nFigure 6-4. Protection Rings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-8\nFigure 6-5. Stack Switch on a Call to a Different Privilege Level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-9\nFigure 6-6. Shadow Stack Switch on a Call to a Different Privilege Level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-10\nFigure 6-7. Stack Usage on Transfers to Interrupt and Exception Handling Routines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-15\nFigure 6-8. Shadow Stack Usage on Transfers to Interrupt and Exception Handling Routines  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-16\nFigure 6-9. Nested Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-21\nFigure 6-10. Stack Frame After Entering the MAIN Procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-22\nFigure 6-11. Stack Frame After Entering Procedure A. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-22\nFigure 6-12. Stack Frame After Entering Procedure B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-23\nFigure 6-13. Stack Frame After Entering Procedure C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-24\nFigure 7-1. Operation of the PUSH Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-5\nFigure 7-2. Operation of the PUSHA Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-6\nFigure 7-3. Operation of the POP Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-6\nFigure 7-4. Operation of the POPA Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-7\nFigure 7-5. Sign Extension  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-7\nFigure 7-6. SHL/SAL Instruction Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-11\nFigure 7-7. SHR Instruction Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-11\nFigure 7-8. SAR Instruction Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-12\nFigure 7-9. SHLD and SHRD Instruction Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-12\nFigure 7-10. ROL, ROR, RCL, and RCR Instruction Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-13\nxviii Vol. 1\n\n\n\nCONTENTS\n\nPAGE\nFigure 7-11. Flags Affected by the PUSHF, POPF, PUSHFD, and POPFD Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\nFigure 8-1. x87 FPU Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-2\nFigure 8-2. x87 FPU Data Register Stack  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-2\nFigure 8-3. Example x87 FPU Dot Product Computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-3\nFigure 8-4. x87 FPU Status Word. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-4\nFigure 8-5. Moving the Condition Codes to the EFLAGS Register  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-6\nFigure 8-6. x87 FPU Control Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-7\nFigure 8-7. x87 FPU Tag Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\nFigure 8-8. Contents of x87 FPU Opcode Registers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-11\nFigure 8-9. Protected Mode x87 FPU State Image in Memory, 32-Bit Format  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-11\nFigure 8-10. Real Mode x87 FPU State Image in Memory, 32-Bit Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12\nFigure 8-11. Protected Mode x87 FPU State Image in Memory, 16-Bit Format  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12\nFigure 8-12. Real Mode x87 FPU State Image in Memory, 16-Bit Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12\nFigure 8-13. x87 FPU Data Type Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-13\nFigure 9-1. MMX Technology Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-2\nFigure 9-2. MMX Register Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-3\nFigure 9-3. Data Types Introduced with the MMX Technology. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-3\nFigure 9-4. SIMD Execution Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-4\nFigure 10-1. SSE Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-2\nFigure 10-2. XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-3\nFigure 10-3. MXCSR Control/Status Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-4\nFigure 10-4. 128-Bit Packed Single-Precision Floating-Point Data Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-6\nFigure 10-5. Packed Single-Precision Floating-Point Operation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-7\nFigure 10-6. Scalar Single-Precision Floating-Point Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-7\nFigure 10-7. SHUFPS Instruction, Packed Shuffle Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10-10\nFigure 10-8. UNPCKHPS Instruction, High Unpack and Interleave Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10-10\nFigure 10-9. UNPCKLPS Instruction, Low Unpack and Interleave Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10-10\nFigure 11-1. Steaming SIMD Extensions 2 Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-2\nFigure 11-2. Data Types Introduced with the SSE2 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-4\nFigure 11-3. Packed Double-Precision Floating-Point Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-5\nFigure 11-4. Scalar Double-Precision Floating-Point Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-5\nFigure 11-5. SHUFPD Instruction, Packed Shuffle Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-8\nFigure 11-6. UNPCKHPD Instruction, High Unpack and Interleave Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-8\nFigure 11-7. UNPCKLPD Instruction, Low Unpack and Interleave Operation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-8\nFigure 11-8. SSE and SSE2 Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-9\nFigure 11-9. Example Masked Response for Packed Operations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .11-17\nFigure 12-1. Asymmetric Processing in ADDSUBPD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-2\nFigure 12-2. Horizontal Data Movement in HADDPD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-2\nFigure 12-3. Horizontal Data Movement in PHADDD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-7\nFigure 12-4. MPSADBW Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .12-16\nFigure 12-5. AES State Flow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .12-19\nFigure 14-1. 256-Bit Wide SIMD Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-2\nFigure 14-2. General Procedural Flow of Application Detection of AVX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .14-15\nFigure 14-3. General Procedural Flow of Application Detection of Float-16. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .14-20\nFigure 15-1. 512-Bit Wide Vectors and SIMD Register Set. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-2\nFigure 15-2. Procedural Flow for Application Detection of AVX-512 Foundation Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-4\nFigure 15-3. Procedural Flow for Application Detection of 512-bit Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-5\nFigure 15-4. Procedural Flow for Application Detection of 512-bit Instruction Groups  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-6\nFigure 15-5. Procedural Flow for Detection of Intel AVX-512 Instructions Operating at Vector Lengths < 512. . . . . . . . . . . . . . . 15-7\nFigure 17-1. Layout of the Bounds Registers BND0-BND3  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-3\nFigure 17-2. Common Layout of the Bound Configuration Registers BNDCFGU and BNDCFGS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-3\nFigure 17-3. Layout of the Bound Status Registers BNDSTATUS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-4\nFigure 17-4. Bound Paging Structure and Address Translation in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-7\nFigure 17-5. Bound Paging Structure and Address Translation Outside 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-9\nFigure 18-1. Supervisor Shadow Stack with a Supervisor Shadow Stack Token. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-4\nFigure 18-2. RSTORSSP to Switch to New Shadow Stack. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-6\nFigure 18-3. SAVEPREVSSP to Save a Restore Point. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-6\nFigure 18-4. Priority of Control Protection Exception on Missing ENDBRANCH. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-8\nFigure 19-1. Memory-Mapped I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-2\nVol. 1 xix\n\n\n\nCONTENTS\n\nPAGE\nFigure 19-2. I/O Permission Bit Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-4\nFigure D-1. Control Flow for Handling Unmasked Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-4\nxx Vol. 1\n\n\n\nCONTENTS\n\nPAGE\nTABLES\n\nTable 2-1. Key Features of Most Recent IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21\nTable 2-2. Key Features of Most Recent Intel 64 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21\nTable 2-3. Key Features of Previous Generations of IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-27\nTable 2-4. Proposed Intel ISA and Features Removal List  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-28\nTable 2-5. Intel ISA and Features Removal List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-28\nTable 3-1. Instruction Pointer Sizes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-10\nTable 3-2. Addressable General Purpose Registers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-13\nTable 3-3. Effective Operand- and Address-Size Attributes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19\nTable 3-4. Effective Operand- and Address-Size Attributes in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19\nTable 3-5. Default Segment Selection Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-22\nTable 4-1. Signed Integer Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\nTable 4-2. Length, Precision, and Range of Floating-Point Data Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\nTable 4-3. Floating-Point Number and NaN Encodings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\nTable 4-4. Packed Decimal Integer Encodings  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10\nTable 4-5. Real and Floating-Point Number Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-12\nTable 4-6. Denormalization Process. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\nTable 4-7. Rules for Handling NaNs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\nTable 4-8. Rounding Modes and Encoding of Rounding Control (RC) Field . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\nTable 4-9. Numeric Overflow Thresholds. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\nTable 4-10. Masked Responses to Numeric Overflow  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\nTable 4-11. Numeric Underflow (Normalized) Thresholds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-22\nTable 5-1. Instruction Groups in Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\nTable 5-2. Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2\nTable 5-3. Supervisor and User Mode Enclave Instruction Leaf Functions in Long-Form of SGX1  . . . . . . . . . . . . . . . . . . . . . . . . . . 5-37\nTable 6-1. Exceptions and Interrupts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-13\nTable 7-1. Move Instruction Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-3\nTable 7-2. Conditional Move Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-4\nTable 7-3. Bit Test and Modify Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\nTable 7-4. Conditional Jump Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-16\nTable 8-1. Condition Code Interpretation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-5\nTable 8-2. Precision Control Field (PC). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\nTable 8-3. Unsupported Double Extended-Precision Floating-Point Encodings and Pseudo-Denormals . . . . . . . . . . . . . . . . . . . . . 8-14\nTable 8-4. Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-16\nTable 8-5. Floating-Point Conditional Move Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-16\nTable 8-6. Setting of x87 FPU Condition Code Flags for Floating-Point Number Comparisons. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-19\nTable 8-7. Setting of EFLAGS Status Flags for Floating-Point Number Comparisons. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-19\nTable 8-8. TEST Instruction Constants for Conditional Branching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-20\nTable 8-9. Arithmetic and Non-arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-25\nTable 8-10. Invalid Arithmetic Operations and the Masked Responses to Them  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-27\nTable 8-11. Divide-By-Zero Conditions and the Masked Responses to Them . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-28\nTable 9-1. Data Range Limits for Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-5\nTable 9-2. MMX Instruction Set Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-6\nTable 9-3. Effect of Prefixes on MMX Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-11\nTable 10-1. PREFETCHh Instructions Caching Hints  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-13\nTable 10-2. Format of an FXSAVE Area  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-15\nTable 11-1. Masked Responses of SSE/SSE2/SSE3 Instructions to Invalid Arithmetic Operations . . . . . . . . . . . . . . . . . . . . . . . . . . 11-14\nTable 11-2. SSE and SSE2 State Following a Power-up/Reset or INIT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-20\nTable 11-3. Effect of Prefixes on SSE, SSE2, and SSE3 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-26\nTable 12-1. SIMD numeric exceptions signaled by SSE4.1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-10\nTable 12-2. Enhanced 32-bit SIMD Multiply Supported by SSE4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-11\nTable 12-3. Blend Field Size and Control Modes Supported by SSE4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\nTable 12-4. Enhanced SIMD Integer MIN/MAX Instructions Supported by SSE4.1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\nTable 12-5. New SIMD Integer conversions supported by SSE4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-15\nTable 12-6. New SIMD Integer Conversions Supported by SSE4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-16\nTable 12-7. Enhanced SIMD Pack support by SSE4.1  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\nTable 12-8. Byte and 32-bit Word Representation of a 128-bit State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-20\nTable 12-9. Matrix Representation of a 128-bit State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-20\nVol. 1 xxi\n\n\n\nCONTENTS\n\nPAGE\nTable 12-10. Little Endian Representation of a 128-bit State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-21\nTable 12-11. Little Endian Representation of a 4x4 Byte Matrix  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-21\nTable 12-12. The ShiftRows Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-22\nTable 12-13. Look-up Table Associated with S-Box Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-22\nTable 12-14. The InvShiftRows Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-23\nTable 12-15. Look-up Table Associated with InvS-Box Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-24\nTable 13-1. Format of the Legacy Region of an XSAVE Area. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-7\nTable 14-1. Promoted SSE/SSE2/SSE3/SSSE3/SSE4 Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-3\nTable 14-2. Promoted 256-Bit and 128-bit Arithmetic AVX Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-9\nTable 14-3. Promoted 256-bit and 128-bit Data Movement AVX Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-9\nTable 14-4. 256-bit AVX Instruction Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-10\nTable 14-5. Promotion of Legacy SIMD ISA to 128-bit Arithmetic AVX instruction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-11\nTable 14-6. 128-bit AVX Instruction Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-13\nTable 14-7. Promotion of Legacy SIMD ISA to 128-bit Non-Arithmetic AVX instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-14\nTable 14-8. Immediate Byte Encoding for 16-bit Floating-Point Conversion Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-18\nTable 14-9. Non-Numerical Behavior for VCVTPH2PS, VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-18\nTable 14-10. Invalid Operation for VCVTPH2PS, VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-18\nTable 14-12. Underflow Condition for VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19\nTable 14-13. Overflow Condition for VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19\nTable 14-14. Inexact Condition for VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19\nTable 14-11. Denormal Condition Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19\nTable 14-15. FMA Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-21\nTable 14-16. Rounding Behavior of Zero Result in FMA Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-23\nTable 14-17. FMA Numeric Behavior. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-23\nTable 14-18. Promoted Vector Integer SIMD Instructions in AVX2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-26\nTable 14-19.  VEX-Only SIMD Instructions in AVX and AVX2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-29\nTable 14-20. New Primitive in AVX2 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-30\nTable 14-21. Alignment Faulting Conditions when Memory Access is Not Aligned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-33\nTable 14-22. Instructions Requiring Explicitly Aligned Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-33\nTable 14-23. Instructions Not Requiring Explicit Memory Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-34\nTable 15-1. 512-bit Instruction Groups in the Intel AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-6\nTable 15-2. Feature flag Collection Required of 256/128 Bit Vector Lengths for Each Instruction Group . . . . . . . . . . . . . . . . . . . . 15-7\nTable 15-3. Instruction Mnemonics That Do Not Support EVEX.128 Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-8\nTable 15-4. Characteristics of Three Rounding Control Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-12\nTable 15-5. Static Rounding Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-12\nTable 15-6.  SIMD Instructions Requiring Explicitly Aligned Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-14\nTable 15-7. Instructions Not Requiring Explicit Memory Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-14\nTable 16-1. RTM Abort Status Definition  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\nTable 17-1.  Error Code Definition of BNDSTATUS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-4\nTable 17-2.  Intel MPX Instruction Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-5\nTable 17-3.  Effective Address Size of Intel MPX Instructions with 67H Prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-10\nTable 17-4.  Bounds Register INIT Behavior Due to BND Prefix with Branch Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\nTable 18-1. Indirect Branch Tracking State Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-11\nTable 19-1. I/O Instruction Serialization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-6\nTable A-1. Codes Describing Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .A-1\nTable A-2. EFLAGS Cross-Reference. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .A-1\nTable B-1. EFLAGS Condition Codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .B-1\nTable C-1. x87 FPU and SIMD Floating-Point Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-1\nTable C-2. Exceptions Generated with x87 FPU Floating-Point Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-1\nTable C-3. Exceptions Generated with SSE Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-3\nTable C-4. Exceptions Generated with SSE2 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-5\nTable C-5. Exceptions Generated with SSE3 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-7\nTable C-6. Exceptions Generated with SSE4 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-8\nTable D-1. ADDPS, ADDSS, SUBPS, SUBSS, MULPS, MULSS, DIVPS, DIVSS, ADDPD, ADDSD, SUBPD, SUBSD, MULPD, MULSD, \n\nDIVPD, DIVSD, ADDSUBPS, ADDSUBPD, HADDPS, HADDPD, HSUBPS, HSUBPD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-5\nTable D-2. CMPPS.EQ, CMPSS.EQ, CMPPS.ORD, CMPSS.ORD, CMPPD.EQ, CMPSD.EQ, CMPPD.ORD, CMPSD.ORD  . . . . . . . . . . . . . . . . .D-6\nTable D-3. CMPPS.NEQ, CMPSS.NEQ, CMPPS.UNORD, CMPSS.UNORD, CMPPD.NEQ, CMPSD.NEQ, CMPPD.UNORD, CMPSD.\n\nUNORD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-6\nTable D-4. CMPPS.LT, CMPSS.LT, CMPPS.LE, CMPSS.LE, CMPPD.LT, CMPSD.LT, CMPPD.LE, CMPSD.LE . . . . . . . . . . . . . . . . . . . . . . . . . .D-6\nxxii Vol. 1\n\n\n\nCONTENTS\n\nPAGE\nTable D-5. CMPPS.NLT, CMPSS.NLT, CMPPS.NLE, CMPSS.NLE, CMPPD.NLT, CMPSD.NLT, CMPPD.NLE, CMPSD.NLE . . . . . . . . . . . . . .D-7\nTable D-6. COMISS, COMISD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-7\nTable D-7. UCOMISS, UCOMISD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-7\nTable D-8. CVTPS2PI, CVTSS2SI, CVTTPS2PI, CVTTSS2SI, CVTPD2PI, CVTSD2SI, CVTTPD2PI, CVTTSD2SI, CVTPS2DQ, \n\nCVTTPS2DQ, CVTPD2DQ, CVTTPD2DQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-7\nTable D-9. MAXPS, MAXSS, MINPS, MINSS, MAXPD, MAXSD, MINPD, MINSD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-8\nTable D-10. SQRTPS, SQRTSS, SQRTPD, SQRTSD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-8\nTable D-11. CVTPS2PD, CVTSS2SD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-8\nTable D-12. CVTPD2PS, CVTSD2SS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-8\nTable D-13. #I - Invalid Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-9\nTable D-14. #Z - Divide-by-Zero. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-11\nTable D-15. #D - Denormal Operand . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-12\nTable D-16. #O - Numeric Overflow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-13\nTable D-17. #U - Numeric Underflow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-14\nTable D-18. #P - Inexact Result (Precision)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-15\nVol. 1 xxiii\n\n\n\nCONTENTS\n\nPAGE\nxxiv Vol. 1\n\n\n\nCHAPTER 1\nABOUT THIS MANUAL\n\nThe Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1: Basic Architecture (order number \n253665) is part of a set that describes the architecture and programming environment of Intel® 64 and IA-32 \narchitecture processors. Other volumes in this set are:\n• The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 2A, 2B, 2C & 2D: Instruction Set \n\nReference (order numbers 253666, 253667, 326018 and 334569).\n• The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 3A, 3B, 3C & 3D: System \n\nProgramming Guide (order numbers 253668, 253669, 326019 and 332831).\n• The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 4: Model-Specific Registers \n\n(order number 335592).\n\nThe Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, describes the basic architecture \nand programming environment of Intel 64 and IA-32 processors. The Intel® 64 and IA-32 Architectures Software \nDeveloper’s Manual, Volumes 2A, 2B, 2C & 2D, describe the instruction set of the processor and the opcode struc-\nture. These volumes apply to application programmers and to programmers who write operating systems or exec-\nutives. The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 3A, 3B, 3C & 3D, describe \nthe operating-system support environment of Intel 64 and IA-32 processors. These volumes target operating-\nsystem and BIOS designers. In addition, the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 3B, addresses the programming environment for classes of software that host operating systems. The \nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 4, describes the model-specific registers \nof Intel 64 and IA-32 processors.\n\n1.1 INTEL® 64 AND IA-32 PROCESSORS COVERED IN THIS MANUAL\nThis manual set includes information pertaining primarily to the most recent Intel 64 and IA-32 processors, which \ninclude: \n• Pentium® processors\n• P6 family processors\n• Pentium® 4 processors\n• Pentium® M processors\n• Intel® Xeon® processors\n• Pentium® D processors\n• Pentium® processor Extreme Editions\n• 64-bit Intel® Xeon® processors\n• Intel® Core™ Duo processor\n• Intel® Core™ Solo processor\n• Dual-Core Intel® Xeon® processor LV\n• Intel® Core™2 Duo processor\n• Intel® Core™2 Quad processor Q6000 series\n• Intel® Xeon® processor 3000, 3200 series\n• Intel® Xeon® processor 5000 series\n• Intel® Xeon® processor 5100, 5300 series\n• Intel® Core™2 Extreme processor X7000 and X6800 series\n• Intel® Core™2 Extreme processor QX6000 series\n• Intel® Xeon® processor 7100 series\nVol. 1 1-1\n\n\n\nABOUT THIS MANUAL\n• Intel® Pentium® Dual-Core processor\n• Intel® Xeon® processor 7200, 7300 series\n• Intel® Xeon® processor 5200, 5400, 7400 series\n• Intel® Core™2 Extreme processor QX9000 and X9000 series\n• Intel® Core™2 Quad processor Q9000 series\n• Intel® Core™2 Duo processor E8000, T9000 series\n• Intel® Atom™ processor family\n• Intel® Atom™ processors 200, 300, D400, D500, D2000, N200, N400, N2000, E2000, Z500, Z600, Z2000, \n\nC1000 series are built from 45 nm and 32 nm processes\n• Intel® Core™ i7 processor\n• Intel® Core™ i5 processor\n• Intel® Xeon® processor E7-8800/4800/2800 product families \n• Intel® Core™ i7-3930K processor\n• 2nd generation Intel® Core™ i7-2xxx, Intel® Core™ i5-2xxx, Intel® Core™ i3-2xxx processor series\n• Intel® Xeon® processor E3-1200 product family\n• Intel® Xeon® processor E5-2400/1400 product family\n• Intel® Xeon® processor E5-4600/2600/1600 product family\n• 3rd generation Intel® Core™ processors\n• Intel® Xeon® processor E3-1200 v2 product family\n• Intel® Xeon® processor E5-2400/1400 v2 product families\n• Intel® Xeon® processor E5-4600/2600/1600 v2 product families\n• Intel® Xeon® processor E7-8800/4800/2800 v2 product families\n• 4th generation Intel® Core™ processors\n• The Intel® Core™ M processor family \n• Intel® Core™ i7-59xx Processor Extreme Edition\n• Intel® Core™ i7-49xx Processor Extreme Edition\n• Intel® Xeon® processor E3-1200 v3 product family\n• Intel® Xeon® processor E5-2600/1600 v3 product families\n• 5th generation Intel® Core™ processors\n• Intel® Xeon® processor D-1500 product family\n• Intel® Xeon® processor E5 v4 family\n• Intel® Atom™ processor X7-Z8000 and X5-Z8000 series\n• Intel® Atom™ processor Z3400 series\n• Intel® Atom™ processor Z3500 series\n• 6th generation Intel® Core™ processors\n• Intel® Xeon® processor E3-1500m v5 product family\n• 7th generation Intel® Core™ processors\n• Intel® Xeon Phi™ Processor 3200, 5200, 7200 Series \n• Intel® Xeon® Processor Scalable Family \n• 8th generation Intel® Core™ processors\n• Intel® Xeon Phi™ Processor 7215, 7285, 7295 Series\n• Intel® Xeon® E processors\n• 9th generation Intel® Core™ processors\n• 2nd generation Intel® Xeon® Processor Scalable Family \n1-2 Vol. 1\n\n\n\nABOUT THIS MANUAL\n• 10th generation Intel® Core™ processors\n• 11th generation Intel® Core™ processors\n• 3rd generation Intel® Xeon® Processor Scalable Family\n\nP6 family processors are IA-32 processors based on the P6 family microarchitecture. This includes the Pentium® \nPro, Pentium® II, Pentium® III, and Pentium® III Xeon® processors.\n\nThe Pentium® 4, Pentium® D, and Pentium® processor Extreme Editions are based on the Intel NetBurst® micro-\narchitecture. Most early Intel® Xeon® processors are based on the Intel NetBurst® microarchitecture. Intel Xeon \nprocessor 5000, 7100 series are based on the Intel NetBurst® microarchitecture.\n\nThe Intel® Core™ Duo, Intel® Core™ Solo and dual-core Intel® Xeon® processor LV are based on an improved \nPentium® M processor microarchitecture. \n\nThe Intel® Xeon® processor 3000, 3200, 5100, 5300, 7200, and 7300 series, Intel® Pentium® dual-core, Intel® \nCore™2 Duo, Intel® Core™2 Quad, and Intel® Core™2 Extreme processors are based on Intel® Core™ microarchi-\ntecture.\n\nThe Intel® Xeon® processor 5200, 5400, 7400 series, Intel® Core™2 Quad processor Q9000 series, and Intel® \nCore™2 Extreme processors QX9000, X9000 series, Intel® Core™2 processor E8000 series are based on Enhanced \nIntel® Core™ microarchitecture.\n\nThe Intel® Atom™ processors 200, 300, D400, D500, D2000, N200, N400, N2000, E2000, Z500, Z600, Z2000, \nC1000 series are based on the Intel® Atom™ microarchitecture and supports Intel 64 architecture.\n\nP6 family, Pentium® M, Intel® Core™ Solo, Intel® Core™ Duo processors, dual-core Intel® Xeon® processor LV, \nand early generations of Pentium 4 and Intel Xeon processors support IA-32 architecture. The Intel® AtomTM \nprocessor Z5xx series support IA-32 architecture.\n\nThe Intel® Xeon® processor 3000, 3200, 5000, 5100, 5200, 5300, 5400, 7100, 7200, 7300, 7400 series, Intel® \nCore™2 Duo, Intel® Core™2 Extreme, Intel® Core™2 Quad processors, Pentium® D processors, Pentium® Dual-\nCore processor, newer generations of Pentium 4 and Intel Xeon processor family support Intel® 64 architecture.\n\nThe Intel® Core™ i7 processor and Intel® Xeon® processor 3400, 5500, 7500 series are based on 45 nm Nehalem \nmicroarchitecture. Westmere microarchitecture is a 32 nm version of the Nehalem microarchitecture. Intel® \nXeon® processor 5600 series, Intel Xeon processor E7 and various Intel Core i7, i5, i3 processors are based on the \nWestmere microarchitecture. These processors support Intel 64 architecture.\n\nThe Intel® Xeon® processor E5 family, Intel® Xeon® processor E3-1200 family, Intel® Xeon® processor E7-\n8800/4800/2800 product families, Intel® Core™ i7-3930K processor, and 2nd generation Intel® Core™ i7-2xxx, \nIntel® CoreTM i5-2xxx, Intel® Core™ i3-2xxx processor series are based on the Sandy Bridge microarchitecture and \nsupport Intel 64 architecture.\n\nThe Intel® Xeon® processor E7-8800/4800/2800 v2 product families, Intel® Xeon® processor E3-1200 v2 product \nfamily and 3rd generation Intel® Core™ processors are based on the Ivy Bridge microarchitecture and support \nIntel 64 architecture.\n\nThe Intel® Xeon® processor E5-4600/2600/1600 v2 product families, Intel® Xeon® processor E5-2400/1400 v2 \nproduct families and Intel® Core™ i7-49xx Processor Extreme Edition are based on the Ivy Bridge-E microarchitec-\nture and support Intel 64 architecture.\n\nThe Intel® Xeon® processor E3-1200 v3 product family and 4th Generation Intel® Core™ processors are based on \nthe Haswell microarchitecture and support Intel 64 architecture.\n\nThe Intel® Xeon® processor E5-2600/1600 v3 product families and the Intel® Core™ i7-59xx Processor Extreme \nEdition are based on the Haswell-E microarchitecture and support Intel 64 architecture.\n\nThe Intel® Atom™ processor Z8000 series is based on the Airmont microarchitecture.\n\nThe Intel® Atom™ processor Z3400 series and the Intel® Atom™ processor Z3500 series are based on the Silver-\nmont microarchitecture.\n\nThe Intel® Core™ M processor family, 5th generation Intel® Core™ processors, Intel® Xeon® processor D-1500 \nproduct family and the Intel® Xeon® processor E5 v4 family are based on the Broadwell microarchitecture and \nsupport Intel 64 architecture. \n\nThe Intel® Xeon® Processor Scalable Family, Intel® Xeon® processor E3-1500m v5 product family and 6th gener-\nation Intel® Core™ processors are based on the Skylake microarchitecture and support Intel 64 architecture.\nVol. 1 1-3\n\n\n\nABOUT THIS MANUAL\nThe 7th generation Intel® Core™ processors are based on the Kaby Lake microarchitecture and support Intel 64 \narchitecture.\n\nThe Intel® Atom™ processor C series, the Intel® Atom™ processor X series, the Intel® Pentium® processor J \nseries, the Intel® Celeron® processor J series, and the Intel® Celeron® processor N series are based on the Gold-\nmont microarchitecture.\n\nThe Intel® Xeon Phi™ Processor 3200, 5200, 7200 Series is based on the Knights Landing microarchitecture and \nsupports Intel 64 architecture.\n\nThe Intel® Pentium® Silver processor series, the Intel® Celeron® processor J series, and the Intel® Celeron® \nprocessor N series are based on the Goldmont Plus microarchitecture.\n\nThe 8th generation Intel® Core™ processors, 9th generation Intel® Core™ processors, and Intel® Xeon® E proces-\nsors are based on the Coffee Lake microarchitecture and support Intel 64 architecture.\n\nThe Intel® Xeon Phi™ Processor 7215, 7285, 7295 Series is based on the Knights Mill microarchitecture and \nsupports Intel 64 architecture.\n\nThe 2nd generation Intel® Xeon® Processor Scalable Family is based on the Cascade Lake product and supports \nIntel 64 architecture.\n\nSome 10th generation Intel® Core™ processors are based on the Ice Lake microarchitecture, and some are based \non the Comet Lake microarchitecture; both support Intel 64 architecture.\n\nSome 11th generation Intel® Core™ processors are based on the Tiger Lake microarchitecture, and some are \nbased on the Rocket Lake microarchitecture; both support Intel 64 architecture.\n\nSome 3rd generation Intel® Xeon® Processor Scalable Family processors are based on the Cooper Lake product, \nand some are based on the Ice Lake microarchitecture; both support Intel 64 architecture.\n\nIA-32 architecture is the instruction set architecture and programming environment for Intel's 32-bit microproces-\nsors. Intel® 64 architecture is the instruction set architecture and programming environment which is the superset \nof Intel’s 32-bit and 64-bit architectures. It is compatible with the IA-32 architecture.\n\n1.2 OVERVIEW OF VOLUME 1: BASIC ARCHITECTURE\nA description of this manual’s content follows:\n\nChapter 1 — About This Manual. Gives an overview of all five volumes of the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual. It also describes the notational conventions in these manuals and lists related Intel \nmanuals and documentation of interest to programmers and hardware designers.\n\nChapter 2 — Intel® 64 and IA-32 Architectures. Introduces the Intel 64 and IA-32 architectures along with the \nfamilies of Intel processors that are based on these architectures. It also gives an overview of the common features \nfound in these processors and brief history of the Intel 64 and IA-32 architectures.\n\nChapter 3 — Basic Execution Environment. Introduces the models of memory organization and describes the \nregister set used by applications.\n\nChapter 4 — Data Types. Describes the data types and addressing modes recognized by the processor; provides \nan overview of real numbers and floating-point formats and of floating-point exceptions.\n\nChapter 5 — Instruction Set Summary. Lists all Intel 64 and IA-32 instructions, divided into technology groups.\n\nChapter 6 — Procedure Calls, Interrupts, and Exceptions. Describes the procedure stack and mechanisms \nprovided for making procedure calls and for servicing interrupts and exceptions.\n\nChapter 7 — Programming with General-Purpose Instructions. Describes basic load and store, program \ncontrol, arithmetic, and string instructions that operate on basic data types, general-purpose and segment regis-\nters; also describes system instructions that are executed in protected mode.\n\nChapter 8 — Programming with the x87 FPU. Describes the x87 floating-point unit (FPU), including floating-\npoint registers and data types; gives an overview of the floating-point instruction set and describes the processor's \nfloating-point exception conditions.\n\nChapter 9 — Programming with Intel® MMX™ Technology. Describes Intel MMX technology, including MMX \nregisters and data types; also provides an overview of the MMX instruction set. \n1-4 Vol. 1\n\n\n\nABOUT THIS MANUAL\nChapter 10 — Programming with Intel® Streaming SIMD Extensions (Intel® SSE). Describes SSE exten-\nsions, including XMM registers, the MXCSR register, and packed single-precision floating-point data types; provides \nan overview of the SSE instruction set and gives guidelines for writing code that accesses the SSE extensions. \n\nChapter 11 — Programming with Intel® Streaming SIMD Extensions 2 (Intel® SSE2). Describes SSE2 \nextensions, including XMM registers and packed double-precision floating-point data types; provides an overview \nof the SSE2 instruction set and gives guidelines for writing code that accesses SSE2 extensions. This chapter also \ndescribes SIMD floating-point exceptions that can be generated with SSE and SSE2 instructions. It also provides \ngeneral guidelines for incorporating support for SSE and SSE2 extensions into operating system and applications \ncode.\n\nChapter 12 — Programming with Intel® Streaming SIMD Extensions 3 (Intel® SSE3), Supplemental \nStreaming SIMD Extensions 3 (SSSE3), Intel® Streaming SIMD Extensions 4 (Intel® SSE4) and Intel® \nAES New Instructions (Intel® AES-NI). Provides an overview of the SSE3 instruction set, Supplemental SSE3, \nSSE4, AESNI instructions, and guidelines for writing code that access these extensions.\n\nChapter 13 — Managing State Using the XSAVE Feature Set. Describes the XSAVE feature set instructions \nand explains how software can enable the XSAVE feature set and XSAVE-enabled features.\n\nChapter 14 — Programming with AVX, FMA and AVX2. Provides an overview of the Intel® AVX instruction set, \nFMA and Intel AVX2 extensions and gives guidelines for writing code that access these extensions.\n\nChapter 15 — Programming with Intel® AVX-512. Provides an overview of the Intel® AVX-512 instruction set \nextensions and gives guidelines for writing code that access these extensions.\n\nChapter 16 — Programming with Intel Transactional Synchronization Extensions. Describes the instruc-\ntion extensions that support lock elision techniques to improve the performance of multi-threaded software with \ncontended locks.\n\nChapter 17 — Intel® Memory Protection Extensions. Provides an overview of the Intel® Memory Protection \nExtensions and gives guidelines for writing code that access these extensions.\n\nChapter 18 — Control-flow Enforcement Technology. Provides an overview of the Control-flow Enforcement \nTechnology (CET) and gives guidelines for writing code that access these extensions.\n\nChapter 19 — Input/Output. Describes the processor’s I/O mechanism, including I/O port addressing, I/O \ninstructions, and I/O protection mechanisms.\n\nChapter 20 — Processor Identification and Feature Determination. Describes how to determine the CPU \ntype and features available in the processor.\n\nAppendix A — EFLAGS Cross-Reference. Summarizes how the IA-32 instructions affect the flags in the EFLAGS \nregister.\n\nAppendix B — EFLAGS Condition Codes. Summarizes how conditional jump, move, and ‘byte set on condition \ncode’ instructions use condition code flags (OF, CF, ZF, SF, and PF) in the EFLAGS register.\n\nAppendix C — Floating-Point Exceptions Summary. Summarizes exceptions raised by the x87 FPU floating-\npoint and SSE/SSE2/SSE3 floating-point instructions.\n\nAppendix D — Guidelines for Writing SIMD Floating-Point Exception Handlers. Gives guidelines for writing \nexception handlers for exceptions generated by SSE/SSE2/SSE3 floating-point instructions.\n\n1.3 NOTATIONAL CONVENTIONS\nThis manual uses specific notation for data-structure formats, for symbolic representation of instructions, and for \nhexadecimal and binary numbers. This notation is described below.\n\n1.3.1 Bit and Byte Order\nIn illustrations of data structures in memory, smaller addresses appear toward the bottom of the figure; addresses \nincrease toward the top. Bit positions are numbered from right to left. The numerical value of a set bit is equal to \ntwo raised to the power of the bit position. Intel 64 and IA-32 processors are “little endian” machines; this means \nthe bytes of a word are numbered starting from the least significant byte. See Figure 1-1.\nVol. 1 1-5\n\n\n\nABOUT THIS MANUAL\n1.3.2 Reserved Bits and Software Compatibility\nIn many register and memory layout descriptions, certain bits are marked as reserved. When bits are marked as \nreserved, it is essential for compatibility with future processors that software treat these bits as having a future, \nthough unknown, effect. The behavior of reserved bits should be regarded as not only undefined, but unpredict-\nable. \n\nSoftware should follow these guidelines in dealing with reserved bits:\n• Do not depend on the states of any reserved bits when testing the values of registers that contain such bits. \n\nMask out the reserved bits before testing.\n• Do not depend on the states of any reserved bits when storing to memory or to a register.\n• Do not depend on the ability to retain information written into any reserved bits.\n• When loading a register, always load the reserved bits with the values indicated in the documentation, if any, or \n\nreload them with values previously read from the same register.\n\nNOTE\nAvoid any software dependence upon the state of reserved bits in Intel 64 and IA-32 registers. \nDepending upon the values of reserved register bits will make software dependent upon the \nunspecified manner in which the processor handles these bits. Programs that depend upon \nreserved values risk incompatibility with future processors.\n\n1.3.2.1  Instruction Operands\nWhen instructions are represented symbolically, a subset of the IA-32 assembly language is used. In this subset, \nan instruction has the following format:\n\nlabel: mnemonic argument1, argument2, argument3\n\nwhere:\n• A label is an identifier which is followed by a colon.\n• A mnemonic is a reserved name for a class of instruction opcodes which have the same function.\n• The operands argument1, argument2, and argument3 are optional. There may be from zero to three \n\noperands, depending on the opcode. When present, they take the form of either literals or identifiers for data \nitems. Operand identifiers are either reserved names of registers or are assumed to be assigned to data items \ndeclared in another part of the program (which may not be shown in the example).\n\nWhen two operands are present in an arithmetic or logical instruction, the right operand is the source and the left \noperand is the destination. \n\nFigure 1-1.  Bit and Byte Order\n\nByte 3\n\nData Structure \n\nByte 1Byte 2 Byte 0\nLowest\n\nBit offset\n\n28\n24\n20\n16\n12\n8\n4\n0\n\nAddress\n\nByte Offset\n\nHighest\nAddress 32 24 23 16 15 8 7 0\n1-6 Vol. 1\n\n\n\nABOUT THIS MANUAL\nFor example:\n\nLOADREG: MOV EAX, SUBTOTAL\n\nIn this example, LOADREG is a label, MOV is the mnemonic identifier of an opcode, EAX is the destination operand, \nand SUBTOTAL is the source operand. Some assembly languages put the source and destination in reverse order.\n\n1.3.3 Hexadecimal and Binary Numbers\nBase 16 (hexadecimal) numbers are represented by a string of hexadecimal digits followed by the character H (for \nexample, 0F82EH). A hexadecimal digit is a character from the following set: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, \nE, and F.\n\nBase 2 (binary) numbers are represented by a string of 1s and 0s, sometimes followed by the character B (for \nexample, 1010B). The “B” designation is only used in situations where confusion as to the type of number might \narise.\n\n1.3.4 Segmented Addressing\nThe processor uses byte addressing. This means memory is organized and accessed as a sequence of bytes. \nWhether one or more bytes are being accessed, a byte address is used to locate the byte or bytes memory. The \nrange of memory that can be addressed is called an address space.\n\nThe processor also supports segmented addressing. This is a form of addressing where a program may have many \nindependent address spaces, called segments. For example, a program can keep its code (instructions) and stack \nin separate segments. Code addresses would always refer to the code space, and stack addresses would always \nrefer to the stack space. The following notation is used to specify a byte address within a segment: \n\nSegment-register:Byte-address\n\nFor example, the following segment address identifies the byte at address FF79H in the segment pointed by the DS \nregister:\n\nDS:FF79H\n\nThe following segment address identifies an instruction address in the code segment. The CS register points to the \ncode segment and the EIP register contains the address of the instruction.\n\nCS:EIP\n\n1.3.5 A New Syntax for CPUID, CR, and MSR Values\nObtain feature flags, status, and system information by using the CPUID instruction, by checking control register \nbits, and by reading model-specific registers. We are moving toward a new syntax to represent this information. \nSee Figure 1-2.\nVol. 1 1-7\n\n\n\nABOUT THIS MANUAL\n1.3.6 Exceptions\nAn exception is an event that typically occurs when an instruction causes an error. For example, an attempt to \ndivide by zero generates an exception. However, some exceptions, such as breakpoints, occur under other condi-\ntions. Some types of exceptions may provide error codes. An error code reports additional information about the \nerror. An example of the notation used to show an exception and error code is shown below:\n\n#PF(fault code)\n\nThis example refers to a page-fault exception under conditions where an error code naming a type of fault is \nreported. Under some conditions, exceptions that produce error codes may not be able to report an accurate code. \nIn this case, the error code is zero, as shown below for a general-protection exception:\n\n#GP(0)\n\nFigure 1-2.  Syntax for CPUID, CR, and MSR Data Presentation\n\nInput value for EAX register\n\nOutput register and feature flag or field \nname with bit position(s)\n\nValue (or range) of output\n\nCPUID.01H:EDX.SSE[bit 25] = 1\n\nCR4.OSFXSR[bit 9] = 1\n\nIA32_MISC_ENABLE.ENABLEFOPCODE[bit 2] = 1\n\nCPUID Input and Output\n\nControl Register Values\n\nModel-Specific Register Values\n\nExample CR name\n\nFeature flag or field name \nwith bit position(s)\n\nValue (or range) of output\n\nExample MSR name\n\nFeature flag or field name with bit position(s)\n\nValue (or range) of output\n\nSDM29002\n1-8 Vol. 1\n\n\n\nABOUT THIS MANUAL\n1.4 RELATED LITERATURE\nLiterature related to Intel 64 and IA-32 processors is listed and viewable on-line at: \nhttps://software.intel.com/en-us/articles/intel-sdm\n\nSee also: \n• The latest security information on Intel® products:\n\nhttps://www.intel.com/content/www/us/en/security-center/default.html\n• Software developer resources, guidance and insights for security advisories:\n\nhttps://software.intel.com/security-software-guidance/\n• The data sheet for a particular Intel 64 or IA-32 processor\n• The specification update for a particular Intel 64 or IA-32 processor\n• Intel® C++ Compiler documentation and online help:\n\nhttp://software.intel.com/en-us/articles/intel-compilers/\n• Intel® Fortran Compiler documentation and online help:\n\nhttp://software.intel.com/en-us/articles/intel-compilers/\n• Intel® Software Development Tools:\n\nhttps://software.intel.com/en-us/intel-sdp-home\n• Intel® 64 and IA-32 Architectures Software Developer’s Manual (in one, four or ten volumes):\n\nhttps://software.intel.com/en-us/articles/intel-sdm\n• Intel® 64 and IA-32 Architectures Optimization Reference Manual: \n\nhttps://software.intel.com/en-us/articles/intel-sdm#optimization\n• Intel® Trusted Execution Technology Measured Launched Environment Programming Guide:\n\nhttp://www.intel.com/content/www/us/en/software-developers/intel-txt-software-development-guide.html\n• Intel® Software Guard Extensions (Intel® SGX) Information\n\nhttps://software.intel.com/en-us/isa-extensions/intel-sgx\n• Developing Multi-threaded Applications: A Platform Consistent Approach:\n\nhttps://software.intel.com/sites/default/files/article/147714/51534-developing-multithreaded-applica-\ntions.pdf\n\n• Using Spin-Loops on Intel® Pentium® 4 Processor and Intel® Xeon® Processor:\nhttps://software.intel.com/sites/default/files/22/30/25602\n\n• Performance Monitoring Unit Sharing Guide\nhttp://software.intel.com/file/30388\n\nLiterature related to select features in future Intel processors are available at:\n• Intel® Architecture Instruction Set Extensions Programming Reference\n\nhttps://software.intel.com/en-us/isa-extensions\n\nMore relevant links are:\n• Intel® Developer Zone:\n\nhttps://software.intel.com/en-us\n• Developer centers:\n\nhttp://www.intel.com/content/www/us/en/hardware-developers/developer-centers.html\n• Processor support general link:\n\nhttp://www.intel.com/support/processors/\n• Intel® Hyper-Threading Technology (Intel® HT Technology):\n\nhttp://www.intel.com/technology/platform-technology/hyper-threading/index.htm\nVol. 1 1-9\n\nhttp://www.intel.com/cd/software/products/asmo-na/eng/index.htm\nhttps://software.intel.com/en-us/isa-extensions/intel-sgx\nhttp://www.intel.com/cd/software/products/asmo-na/eng/index.htm\nhttp://www.intel.com/cd/software/products/asmo-na/eng/index.htm\nhttp://developer.intel.com/products/processor/manuals/index.htm\nhttp://developer.intel.com/products/processor/manuals/index.htm\nhttp://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html\n\nhttp://developer.intel.com/products/processor/manuals/index.htm\nhttp://www.intel.com/support/processors/sb/cs-009861.htm\nhttp://www.intel.com/content/www/us/en/software-developers/intel-txt-software-development-guide.html\nhttp://www3.intel.com/cd/ids/developer/asmo-na/eng/dc/threading/knowledgebase/19083.htm\nhttps://software.intel.com/en-us\nhttp://www.intel.com/cd/ids/developer/asmo-na/eng/dc/index.htm\nhttp://www.intel.com/content/www/us/en/hardware-developers/developer-centers.html\nhttp://www.intel.com/support/processors/\nhttp://www.intel.com/technology/platform-technology/hyper-threading/index.htm\nhttp://developer.intel.com/technology/hyperthread/\nhttps://software.intel.com/en-us\nhttps://software.intel.com/en-us/articles/resource-center/\nhttp://software.intel.com/en-us/articles/intel-compilers/\nhttp://software.intel.com/en-us/articles/intel-compilers/\nhttps://software.intel.com/en-us/isa-extensions\nhttps://software.intel.com/sites/default/files/article/147714/51534-developing-multithreaded-applications.pdf\nhttps://software.intel.com/en-us/intel-sdp-home\nhttps://software.intel.com/en-us/articles/intel-sdm\nhttps://software.intel.com/en-us/articles/intel-sdm#optimization\nhttps://www.intel.com/content/www/us/en/security-center/default.html\nhttps://software.intel.com/sites/default/files/22/30/25602\nhttps://software.intel.com/security-software-guidance/\n\n\nABOUT THIS MANUAL\n1-10 Vol. 1\n\n\n\nCHAPTER 2\nINTEL® 64 AND IA-32 ARCHITECTURES\n\n2.1 BRIEF HISTORY OF INTEL® 64 AND IA-32 ARCHITECTURE\nThe following sections provide a summary of the major technical evolutions from IA-32 to Intel 64 architecture: \nstarting from the Intel 8086 processor to the latest Intel® Core® 2 Duo, Core 2 Quad and Intel Xeon processor \n5300 and 7300 series. Object code created for processors released as early as 1978 still executes on the latest \nprocessors in the Intel 64 and IA-32 architecture families.\n\n2.1.1 16-bit Processors and Segmentation (1978)\nThe IA-32 architecture family was preceded by 16-bit processors, the 8086 and 8088. The 8086 has 16-bit regis-\nters and a 16-bit external data bus, with 20-bit addressing giving a 1-MByte address space. The 8088 is similar to \nthe 8086 except it has an 8-bit external data bus. \n\nThe 8086/8088 introduced segmentation to the IA-32 architecture. With segmentation, a 16-bit segment register \ncontains a pointer to a memory segment of up to 64 KBytes. Using four segment registers at a time, 8086/8088 \nprocessors are able to address up to 256 KBytes without switching between segments. The 20-bit addresses that \ncan be formed using a segment register and an additional 16-bit pointer provide a total address range of 1 MByte.\n\n2.1.2 The Intel® 286 Processor (1982)\nThe Intel 286 processor introduced protected mode operation into the IA-32 architecture. Protected mode uses the \nsegment register content as selectors or pointers into descriptor tables. Descriptors provide 24-bit base addresses \nwith a physical memory size of up to 16 MBytes, support for virtual memory management on a segment swapping \nbasis, and a number of protection mechanisms. These mechanisms include: \n• Segment limit checking\n• Read-only and execute-only segment options\n• Four privilege levels \n\n2.1.3 The Intel386™ Processor (1985)\nThe Intel386 processor was the first 32-bit processor in the IA-32 architecture family. It introduced 32-bit registers \nfor use both to hold operands and for addressing. The lower half of each 32-bit Intel386 register retains the prop-\nerties of the 16-bit registers of earlier generations, permitting backward compatibility. The processor also provides \na virtual-8086 mode that allows for even greater efficiency when executing programs created for 8086/8088 \nprocessors. \n\nIn addition, the Intel386 processor has support for:\n• A 32-bit address bus that supports up to 4-GBytes of physical memory\n• A segmented-memory model and a flat memory model\n• Paging, with a fixed 4-KByte page size providing a method for virtual memory management\n• Support for parallel stages\n\n2.1.4 The Intel486™ Processor (1989)\nThe Intel486™ processor added more parallel execution capability by expanding the Intel386 processor’s instruc-\ntion decode and execution units into five pipelined stages. Each stage operates in parallel with the others on up to \nfive instructions in different stages of execution. \nVol. 1 2-1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIn addition, the processor added:\n• An 8-KByte on-chip first-level cache that increased the percent of instructions that could execute at the scalar \n\nrate of one per clock\n• An integrated x87 FPU\n• Power saving and system management capabilities\n\n2.1.5 The Intel® Pentium® Processor (1993)\nThe introduction of the Intel Pentium processor added a second execution pipeline to achieve superscalar perfor-\nmance (two pipelines, known as u and v, together can execute two instructions per clock). The on-chip first-level \ncache doubled, with 8 KBytes devoted to code and another 8 KBytes devoted to data. The data cache uses the MESI \nprotocol to support more efficient write-back cache in addition to the write-through cache previously used by the \nIntel486 processor. Branch prediction with an on-chip branch table was added to increase performance in looping \nconstructs. \n\nIn addition, the processor added:\n• Extensions to make the virtual-8086 mode more efficient and allow for 4-MByte as well as 4-KByte pages\n• Internal data paths of 128 and 256 bits add speed to internal data transfers\n• Burstable external data bus was increased to 64 bits\n• An APIC to support systems with multiple processors\n• A dual processor mode to support glueless two processor systems\n\nA subsequent stepping of the Pentium family introduced Intel MMX technology (the Pentium Processor with MMX \ntechnology). Intel MMX technology uses the single-instruction, multiple-data (SIMD) execution model to perform \nparallel computations on packed integer data contained in 64-bit registers. \n\nSee Section 2.2.7, “SIMD Instructions.”\n\n2.1.6 The P6 Family of Processors (1995-1999)\nThe P6 family of processors was based on a superscalar microarchitecture that set new performance standards; see \nalso Section 2.2.1, “P6 Family Microarchitecture.” One of the goals in the design of the P6 family microarchitecture \nwas to exceed the performance of the Pentium processor significantly while using the same 0.6-micrometer, four-\nlayer, metal BICMOS manufacturing process. Members of this family include the following: \n• The Intel Pentium Pro processor is three-way superscalar. Using parallel processing techniques, the \n\nprocessor is able on average to decode, dispatch, and complete execution of (retire) three instructions per \nclock cycle. The Pentium Pro introduced the dynamic execution (micro-data flow analysis, out-of-order \nexecution, superior branch prediction, and speculative execution) in a superscalar implementation. The \nprocessor was further enhanced by its caches. It has the same two on-chip 8-KByte 1st-Level caches as the \nPentium processor and an additional 256-KByte Level 2 cache in the same package as the processor.\n\n• The Intel Pentium II processor added Intel MMX technology to the P6 family processors along with new \npackaging and several hardware enhancements. The processor core is packaged in the single edge contact \ncartridge (SECC). The Level l data and instruction caches were enlarged to 16 KBytes each, and Level 2 cache \nsizes of 256 KBytes, 512 KBytes, and 1 MByte are supported. A half-frequency backside bus connects the Level \n2 cache to the processor. Multiple low-power states such as AutoHALT, Stop-Grant, Sleep, and Deep Sleep are \nsupported to conserve power when idling.\n\n• The Pentium II Xeon processor combined the premium characteristics of previous generations of Intel \nprocessors. This includes: 4-way, 8-way (and up) scalability and a 2 MByte 2nd-Level cache running on a full-\nfrequency backside bus.\n\n• The Intel Celeron processor family focused on the value PC market segment. Its introduction offers an \nintegrated 128 KBytes of Level 2 cache and a plastic pin grid array (P.P.G.A.) form factor to lower system design \ncost.\n\n• The Intel Pentium III processor introduced the Streaming SIMD Extensions (SSE) to the IA-32 architecture. \nSSE extensions expand the SIMD execution model introduced with the Intel MMX technology by providing a \n2-2 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nnew set of 128-bit registers and the ability to perform SIMD operations on packed single-precision floating-\npoint values. See Section 2.2.7, “SIMD Instructions.”\n\n• The Pentium III Xeon processor extended the performance levels of the IA-32 processors with the \nenhancement of a full-speed, on-die, and Advanced Transfer Cache.\n\n2.1.7 The Intel® Pentium® 4 Processor Family (2000-2006) \nThe Intel Pentium 4 processor family is based on Intel NetBurst microarchitecture; see Section 2.2.2, “Intel \nNetBurst® Microarchitecture.”\n\nThe Intel Pentium 4 processor introduced Streaming SIMD Extensions 2 (SSE2); see Section 2.2.7, “SIMD Instruc-\ntions.” The Intel Pentium 4 processor 3.40 GHz, supporting Hyper-Threading Technology introduced Streaming \nSIMD Extensions 3 (SSE3); see Section 2.2.7, “SIMD Instructions.”\n\nIntel 64 architecture was introduced in the Intel Pentium 4 Processor Extreme Edition supporting Hyper-Threading \nTechnology and in the Intel Pentium 4 Processor 6xx and 5xx sequences.\n\nIntel® Virtualization Technology (Intel® VT) was introduced in the Intel Pentium 4 processor 672 and 662.\n\n2.1.8 The Intel® Xeon® Processor (2001- 2007)\nIntel Xeon processors (with exception for dual-core Intel Xeon processor LV, Intel Xeon processor 5100 series) are \nbased on the Intel NetBurst microarchitecture; see Section 2.2.2, “Intel NetBurst® Microarchitecture.” As a family, \nthis group of IA-32 processors (more recently Intel 64 processors) is designed for use in multi-processor server \nsystems and high-performance workstations. \n\nThe Intel Xeon processor MP introduced support for Intel® Hyper-Threading Technology; see Section 2.2.8, “Intel® \nHyper-Threading Technology.”\n\nThe 64-bit Intel Xeon processor 3.60 GHz (with an 800 MHz System Bus) was used to introduce Intel 64 architec-\nture. The Dual-Core Intel Xeon processor includes dual core technology. The Intel Xeon processor 70xx series \nincludes Intel Virtualization Technology.\n\nThe Intel Xeon processor 5100 series introduces power-efficient, high performance Intel Core microarchitecture. \nThis processor is based on Intel 64 architecture; it includes Intel Virtualization Technology and dual-core tech-\nnology. The Intel Xeon processor 3000 series are also based on Intel Core microarchitecture. The Intel Xeon \nprocessor 5300 series introduces four processor cores in a physical package, they are also based on Intel Core \nmicroarchitecture. \n\n2.1.9 The Intel® Pentium® M Processor (2003-2006)\nThe Intel Pentium M processor family is a high performance, low power mobile processor family with microarchitec-\ntural enhancements over previous generations of IA-32 Intel mobile processors. This family is designed for \nextending battery life and seamless integration with platform innovations that enable new usage models (such as \nextended mobility, ultra thin form-factors, and integrated wireless networking).\n\nIts enhanced microarchitecture includes:\n• Support for Intel Architecture with Dynamic Execution\n• A high performance, low-power core manufactured using Intel’s advanced process technology with copper \n\ninterconnect\n• On-die, primary 32-KByte instruction cache and 32-KByte write-back data cache\n• On-die, second-level cache (up to 2 MByte) with Advanced Transfer Cache Architecture\n• Advanced Branch Prediction and Data Prefetch Logic\n• Support for MMX technology, Streaming SIMD instructions, and the SSE2 instruction set\n• A 400 or 533 MHz, Source-Synchronous Processor System Bus\n• Advanced power management using Enhanced Intel SpeedStep® technology\nVol. 1 2-3\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.1.10 The Intel® Pentium® Processor Extreme Edition (2005) \nThe Intel Pentium processor Extreme Edition introduced dual-core technology. This technology provides advanced \nhardware multi-threading support. The processor is based on Intel NetBurst microarchitecture and supports SSE, \nSSE2, SSE3, Hyper-Threading Technology, and Intel 64 architecture.\n\nSee also:\n• Section 2.2.2, “Intel NetBurst® Microarchitecture”\n• Section 2.2.3, “Intel® Core™ Microarchitecture”\n• Section 2.2.7, “SIMD Instructions”\n• Section 2.2.8, “Intel® Hyper-Threading Technology”\n• Section 2.2.9, “Multi-Core Technology”\n• Section 2.2.10, “Intel® 64 Architecture”\n\n2.1.11 The Intel® Core™ Duo and Intel® Core™ Solo Processors (2006-2007)\nThe Intel Core Duo processor offers power-efficient, dual-core performance with a low-power design that extends \nbattery life. This family and the single-core Intel Core Solo processor offer microarchitectural enhancements over \nPentium M processor family.\n\nIts enhanced microarchitecture includes:\n• Intel® Smart Cache which allows for efficient data sharing between two processor cores\n• Improved decoding and SIMD execution\n• Intel® Dynamic Power Coordination and Enhanced Intel® Deeper Sleep to reduce power consumption\n• Intel® Advanced Thermal Manager which features digital thermal sensor interfaces\n• Support for power-optimized 667 MHz bus\n\nThe dual-core Intel Xeon processor LV is based on the same microarchitecture as Intel Core Duo processor, and \nsupports IA-32 architecture.\n\n2.1.12 The Intel® Xeon® Processor 5100, 5300 Series and Intel® Core™2 Processor Family \n(2006)\n\nThe Intel Xeon processor 3000, 3200, 5100, 5300, and 7300 series, Intel Pentium Dual-Core, Intel Core 2 Extreme, \nIntel Core 2 Quad processors, and Intel Core 2 Duo processor family support Intel 64 architecture; they are based \non the high-performance, power-efficient Intel® Core microarchitecture built on 65 nm process technology. The \nIntel Core microarchitecture includes the following innovative features:\n• Intel® Wide Dynamic Execution to increase performance and execution throughput\n• Intel® Intelligent Power Capability to reduce power consumption\n• Intel® Advanced Smart Cache which allows for efficient data sharing between two processor cores\n• Intel® Smart Memory Access to increase data bandwidth and hide latency of memory accesses\n• Intel® Advanced Digital Media Boost which improves application performance using multiple generations of \n\nStreaming SIMD extensions \n\nThe Intel Xeon processor 5300 series, Intel Core 2 Extreme processor QX6800 series, and Intel Core 2 Quad \nprocessors support Intel quad-core technology.\n\n2.1.13 The Intel® Xeon® Processor 5200, 5400, 7400 Series and Intel® Core™2 Processor \nFamily (2007)\n\nThe Intel Xeon processor 5200, 5400, and 7400 series, Intel Core 2 Quad processor Q9000 Series, Intel Core 2 Duo \nprocessor E8000 series support Intel 64 architecture; they are based on the Enhanced Intel® Core microarchitec-\n2-4 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nture using 45 nm process technology. The Enhanced Intel Core microarchitecture provides the following improved \nfeatures:\n• A radix-16 divider, faster OS primitives further increases the performance of Intel® Wide Dynamic Execution. \n• Improves Intel® Advanced Smart Cache with Up to 50% larger level-two cache and up to 50% increase in way-\n\nset associativity. \n• A 128-bit shuffler engine significantly improves the performance of Intel® Advanced Digital Media Boost and \n\nSSE4.\n\nIntel Xeon processor 5400 series and Intel Core 2 Quad processor Q9000 Series support Intel quad-core tech-\nnology. Intel Xeon processor 7400 series offers up to six processor cores and an L3 cache up to 16 MBytes.\n\n2.1.14 The Intel® Atom™ Processor Family (2008)\nThe first generation of Intel® AtomTM processors are built on 45 nm process technology. They are based on a new \nmicroarchitecture, Intel® AtomTM microarchitecture, which is optimized for ultra low power devices. The Intel® \nAtomTM microarchitecture features two in-order execution pipelines that minimize power consumption, increase \nbattery life, and enable ultra-small form factors. The initial Intel Atom Processor family and subsequent generations including \nIntel Atom processor D2000, N2000, E2000, Z2000, C1000 series provide the following features:\n• Enhanced Intel® SpeedStep® Technology\n• Intel® Hyper-Threading Technology\n• Deep Power Down Technology with Dynamic Cache Sizing\n• Support for instruction set extensions up to and including Supplemental Streaming SIMD Extensions 3 \n\n(SSSE3).\n• Support for Intel® Virtualization Technology\n• Support for Intel® 64 Architecture (excluding Intel Atom processor Z5xx Series)\n\n2.1.15 The Intel® Atom™ Processor Family Based on Silvermont Microarchitecture (2013)\nIntel Atom Processor C2xxx, E3xxx, S1xxx series are based on the Silvermont microarchitecture. Processors based on the Silvermont \nmicroarchitecture supports instruction set extensions up to and including SSE4.2, AESNI, and PCLMULQDQ.\n\n2.1.16 The Intel® Core™i7 Processor Family (2008)\nThe Intel Core i7 processor 900 series support Intel 64 architecture; they are based on Intel® microarchitecture \ncode name Nehalem using 45 nm process technology. The Intel Core i7 processor and Intel Xeon processor 5500 \nseries include the following innovative features:\n• Intel® Turbo Boost Technology converts thermal headroom into higher performance. \n• Intel® HyperThreading Technology in conjunction with Quadcore to provide four cores and eight threads. \n• Dedicated power control unit to reduce active and idle power consumption.\n• Integrated memory controller on the processor supporting three channel of DDR3 memory.\n• 8 MB inclusive Intel® Smart Cache.\n• Intel® QuickPath interconnect (QPI) providing point-to-point link to chipset.\n• Support for SSE4.2 and SSE4.1 instruction sets.\n• Second generation Intel Virtualization Technology.\n\n2.1.17 The Intel® Xeon® Processor 7500 Series (2010)\nThe Intel Xeon processor 7500 and 6500 series are based on Intel microarchitecture code name Nehalem using 45 \nnm process technology. They support the same features described in Section 2.1.16, plus the following innovative \nfeatures:\nVol. 1 2-5\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n• Up to eight cores per physical processor package.\n• Up to 24 MB inclusive Intel® Smart Cache.\n• Provides Intel® Scalable Memory Interconnect (Intel® SMI) channels with Intel® 7500 Scalable Memory Buffer \n\nto connect to system memory. \n• Advanced RAS supporting software recoverable machine check architecture.\n\n2.1.18 2010 Intel® Core™ Processor Family (2010)\n2010 Intel Core processor family spans Intel Core i7, i5 and i3 processors. They are based on Intel® microarchitec-\nture code name Westmere using 32 nm process technology. The innovative features can include:\n• Deliver smart performance using Intel Hyper-Threading Technology plus Intel Turbo Boost Technology. \n• Enhanced Intel Smart Cache and integrated memory controller.\n• Intelligent power gating.\n• Repartitioned platform with on-die integration of 45 nm integrated graphics.\n• Range of instruction set support up to AESNI, PCLMULQDQ, SSE4.2 and SSE4.1.\n\n2.1.19 The Intel® Xeon® Processor 5600 Series (2010)\nThe Intel Xeon processor 5600 series are based on Intel microarchitecture code name Westmere using 32 nm \nprocess technology. They support the same features described in Section 2.1.16, plus the following innovative \nfeatures:\n• Up to six cores per physical processor package.\n• Up to 12 MB enhanced Intel® Smart Cache.\n• Support for AESNI, PCLMULQDQ, SSE4.2 and SSE4.1 instruction sets.\n• Flexible Intel Virtualization Technologies across processor and I/O.\n\n2.1.20 The Second Generation Intel® Core™ Processor Family (2011)\nThe Second Generation Intel Core processor family spans Intel Core i7, i5 and i3 processors based on the Sandy \nBridge microarchitecture. They are built from 32 nm process technology and have innovative features including:\n• Intel Turbo Boost Technology for Intel Core i5 and i7 processors\n• Intel Hyper-Threading Technology. \n• Enhanced Intel Smart Cache and integrated memory controller.\n• Processor graphics and built-in visual features like Intel® Quick Sync Video, Intel® InsiderTM etc.\n• Range of instruction set support up to AVX, AESNI, PCLMULQDQ, SSE4.2 and SSE4.1.\n\nIntel Xeon processor E3-1200 product family is also based on the Sandy Bridge microarchitecture.\n\nIntel Xeon processor E5-2400/1400 product families are based on the Sandy Bridge-EP microarchitecture.\n\nIntel Xeon processor E5-4600/2600/1600 product families are based on the Sandy Bridge-EP microarchitecture \nand provide support for multiple sockets.\n\n2.1.21 The Third Generation Intel® Core™ Processor Family (2012)\nThe Third Generation Intel Core processor family spans Intel Core i7, i5 and i3 processors based on the Ivy Bridge \nmicroarchitecture. The Intel Xeon processor E7-8800/4800/2800 v2 product families and Intel Xeon processor E3-\n1200 v2 product family are also based on the Ivy Bridge microarchitecture.\n\nThe Intel Xeon processor E5-2400/1400 v2 product families are based on the Ivy Bridge-EP microarchitecture.\n2-6 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nThe Intel Xeon processor E5-4600/2600/1600 v2 product families are based on the Ivy Bridge-EP microarchitec-\nture and provide support for multiple sockets.\n\n2.1.22 The Fourth Generation Intel® Core™ Processor Family (2013)\nThe Fourth Generation Intel Core processor family spans Intel Core i7, i5 and i3 processors based on the Haswell \nmicroarchitecture. Intel Xeon processor E3-1200 v3 product family is also based on the Haswell microarchitecture.\n\n2.2 MORE ON SPECIFIC ADVANCES\nThe following sections provide more information on major innovations.\n\n2.2.1 P6 Family Microarchitecture\nThe Pentium Pro processor introduced a new microarchitecture commonly referred to as P6 processor microarchi-\ntecture. The P6 processor microarchitecture was later enhanced with an on-die, Level 2 cache, called Advanced \nTransfer Cache.\n\nThe microarchitecture is a three-way superscalar, pipelined architecture. Three-way superscalar means that by \nusing parallel processing techniques, the processor is able on average to decode, dispatch, and complete execution \nof (retire) three instructions per clock cycle. To handle this level of instruction throughput, the P6 processor family \nuses a decoupled, 12-stage superpipeline that supports out-of-order instruction execution. \n\nFigure 2-1 shows a conceptual view of the P6 processor microarchitecture pipeline with the Advanced Transfer \nCache enhancement. \n\nTo ensure a steady supply of instructions and data for the instruction execution pipeline, the P6 processor microar-\nchitecture incorporates two cache levels. The Level 1 cache provides an 8-KByte instruction cache and an 8-KByte \n\nFigure 2-1.  The P6 Processor Microarchitecture with Advanced Transfer Cache Enhancement\n\nBus Unit\n\n2nd Level Cache\nOn-die, 8-way\n\n1st  Level  Cache\n4-way, low latency\n\nFetch/\nDecode\n\nExecution\nInstruction\n\nCache\nMicrocode\n\nROM\n\nExecution\nOut-of-Order\n\nCore\nRetirement\n\nBTSs/Branch Prediction\n\nSystem Bus\n\nBranch  History  Update\n\nFrequently  used\n\nLess  frequently  used\n\nFront End\n\nOM16520\nVol. 1 2-7\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\ndata cache, both closely coupled to the pipeline. The Level 2 cache provides 256-KByte, 512-KByte, or 1-MByte \nstatic RAM that is coupled to the core processor through a full clock-speed 64-bit cache bus.\n\nThe centerpiece of the P6 processor microarchitecture is an out-of-order execution mechanism called dynamic \nexecution. Dynamic execution incorporates three data-processing concepts:\n• Deep branch prediction allows the processor to decode instructions beyond branches to keep the instruction \n\npipeline full. The P6 processor family implements highly optimized branch prediction algorithms to predict the \ndirection of the instruction.\n\n• Dynamic data flow analysis requires real-time analysis of the flow of data through the processor to \ndetermine dependencies and to detect opportunities for out-of-order instruction execution. The out-of-order \nexecution core can monitor many instructions and execute these instructions in the order that best optimizes \nthe use of the processor’s multiple execution units, while maintaining the data integrity.\n\n• Speculative execution refers to the processor’s ability to execute instructions that lie beyond a conditional \nbranch that has not yet been resolved, and ultimately to commit the results in the order of the original \ninstruction stream. To make speculative execution possible, the P6 processor microarchitecture decouples the \ndispatch and execution of instructions from the commitment of results. The processor’s out-of-order execution \ncore uses data-flow analysis to execute all available instructions in the instruction pool and store the results in \ntemporary registers. The retirement unit then linearly searches the instruction pool for completed instructions \nthat no longer have data dependencies with other instructions or unresolved branch predictions. When \ncompleted instructions are found, the retirement unit commits the results of these instructions to memory \nand/or the IA-32 registers (the processor’s eight general-purpose registers and eight x87 FPU data registers) \nin the order they were originally issued and retires the instructions from the instruction pool.\n\n2.2.2 Intel NetBurst® Microarchitecture\nThe Intel NetBurst microarchitecture provides:\n• The Rapid Execution Engine\n\n— Arithmetic Logic Units (ALUs) run at twice the processor frequency \n\n— Basic integer operations can dispatch in 1/2 processor clock tick\n• Hyper-Pipelined Technology\n\n— Deep pipeline to enable industry-leading clock rates for desktop PCs and servers\n\n— Frequency headroom and scalability to continue leadership into the future\n• Advanced Dynamic Execution\n\n— Deep, out-of-order, speculative execution engine\n\n• Up to 126 instructions in flight\n\n• Up to 48 loads and 24 stores in pipeline1\n\n— Enhanced branch prediction capability\n\n• Reduces the misprediction penalty associated with deeper pipelines \n\n• Advanced branch prediction algorithm\n\n• 4K-entry branch target array\n• New cache subsystem\n\n— First level caches\n\n• Advanced Execution Trace Cache stores decoded instructions\n\n• Execution Trace Cache removes decoder latency from main execution loops\n\n• Execution Trace Cache integrates path of program execution flow into a single line\n\n1. Intel 64 and IA-32 processors based on the Intel NetBurst microarchitecture at 90 nm process can handle more than 24 stores in \nflight.\n2-8 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n• Low latency data cache\n\n— Second level cache\n\n• Full-speed, unified 8-way Level 2 on-die Advance Transfer Cache\n\n• Bandwidth and performance increases with processor frequency\n• High-performance, quad-pumped bus interface to the Intel NetBurst microarchitecture system bus\n\n— Supports quad-pumped, scalable bus clock to achieve up to 4X effective speed\n\n— Capable of delivering up to 8.5 GBytes of bandwidth per second\n• Superscalar issue to enable parallelism\n• Expanded hardware registers with renaming to avoid register name space limitations\n• 64-byte cache line size (transfers data up to two lines per sector)\n\nFigure 2-2 is an overview of the Intel NetBurst microarchitecture. This microarchitecture pipeline is made up of \nthree sections: (1) the front end pipeline, (2) the out-of-order execution core, and (3) the retirement unit. \n\n2.2.2.1  The Front End Pipeline\nThe front end supplies instructions in program order to the out-of-order execution core. It performs a number of \nfunctions:\n• Prefetches instructions that are likely to be executed\n• Fetches instructions that have not already been prefetched\n• Decodes instructions into micro-operations\n• Generates microcode for complex instructions and special-purpose code\n• Delivers decoded instructions from the execution trace cache\n\nFigure 2-2.  The Intel NetBurst Microarchitecture\n\nFetch/Decode Trace Cache\nMicrocode ROM\n\nExecution\nOut-Of-Order\n\nCore\nRetirement\n\n1st Level Cache\n4-way\n\n2nd Level Cache\n 8-Way\n\nBTBs/Branch Prediction\n\nBus Unit\n\nSystem Bus\nFrequently used paths\n\nLess frequently used\npaths\n\nFront End\n\n3rd Level  Cache\nOptional\n\nBranch History Update\n\nOM16521\nVol. 1 2-9\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n• Predicts branches using highly advanced algorithm\n\nThe pipeline is designed to address common problems in high-speed, pipelined microprocessors. Two of these \nproblems contribute to major sources of delays:\n• time to decode instructions fetched from the target\n• wasted decode bandwidth due to branches or branch target in the middle of cache lines\n\nThe operation of the pipeline’s trace cache addresses these issues. Instructions are constantly being fetched and \ndecoded by the translation engine (part of the fetch/decode logic) and built into sequences of micro-ops called \ntraces. At any time, multiple traces (representing prefetched branches) are being stored in the trace cache. The \ntrace cache is searched for the instruction that follows the active branch. If the instruction also appears as the first \ninstruction in a pre-fetched branch, the fetch and decode of instructions from the memory hierarchy ceases and the \npre-fetched branch becomes the new source of instructions (see Figure 2-2).\n\nThe trace cache and the translation engine have cooperating branch prediction hardware. Branch targets are \npredicted based on their linear addresses using branch target buffers (BTBs) and fetched as soon as possible.\n\n2.2.2.2  Out-Of-Order Execution Core\nThe out-of-order execution core’s ability to execute instructions out of order is a key factor in enabling parallelism. \nThis feature enables the processor to reorder instructions so that if one micro-op is delayed, other micro-ops may \nproceed around it. The processor employs several buffers to smooth the flow of micro-ops.\n\nThe core is designed to facilitate parallel execution. It can dispatch up to six micro-ops per cycle (this exceeds trace \ncache and retirement micro-op bandwidth). Most pipelines can start executing a new micro-op every cycle, so \nseveral instructions can be in flight at a time for each pipeline. A number of arithmetic logical unit (ALU) instruc-\ntions can start at two per cycle; many floating-point instructions can start once every two cycles. \n\n2.2.2.3  Retirement Unit\nThe retirement unit receives the results of the executed micro-ops from the out-of-order execution core and \nprocesses the results so that the architectural state updates according to the original program order. \n\nWhen a micro-op completes and writes its result, it is retired. Up to three micro-ops may be retired per cycle. The \nReorder Buffer (ROB) is the unit in the processor which buffers completed micro-ops, updates the architectural \nstate in order, and manages the ordering of exceptions. The retirement section also keeps track of branches and \nsends updated branch target information to the BTB. The BTB then purges pre-fetched traces that are no longer \nneeded.\n\n2.2.3 Intel® Core™ Microarchitecture\nIntel Core microarchitecture introduces the following features that enable high performance and power-efficient \nperformance for single-threaded as well as multi-threaded workloads:\n• Intel® Wide Dynamic Execution enable each processor core to fetch, dispatch, execute in high bandwidths \n\nto support retirement of up to four instructions per cycle.\n\n— Fourteen-stage efficient pipeline\n\n— Three arithmetic logical units\n\n— Four decoders to decode up to five instruction per cycle \n\n— Macro-fusion and micro-fusion to improve front-end throughput\n\n— Peak issue rate of dispatching up to six micro-ops per cycle\n\n— Peak retirement bandwidth of up to 4 micro-ops per cycle\n\n— Advanced branch prediction\n\n— Stack pointer tracker to improve efficiency of executing function/procedure entries and exits\n• Intel® Advanced Smart Cache delivers higher bandwidth from the second level cache to the core, and \n\noptimal performance and flexibility for single-threaded and multi-threaded applications.\n2-10 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n— Large second level cache up to 4 MB and 16-way associativity\n\n— Optimized for multicore and single-threaded execution environments\n\n— 256 bit internal data path to improve bandwidth from L2 to first-level data cache\n• Intel® Smart Memory Access prefetches data from memory in response to data access patterns and reduces \n\ncache-miss exposure of out-of-order execution.\n\n— Hardware prefetchers to reduce effective latency of second-level cache misses\n\n— Hardware prefetchers to reduce effective latency of first-level data cache misses\n\n— Memory disambiguation to improve efficiency of speculative execution execution engine\n• Intel® Advanced Digital Media Boost improves most 128-bit SIMD instruction with single-cycle throughput \n\nand floating-point operations.\n\n— Single-cycle throughput of most 128-bit SIMD instructions\n\n— Up to eight floating-point operation per cycle\n\n— Three issue ports available to dispatching SIMD instructions for execution\n\nIntel Core 2 Extreme, Intel Core 2 Duo processors and Intel Xeon processor 5100 series implement two processor \ncores based on the Intel Core microarchitecture, the functionality of the subsystems in each core are depicted in \nFigure 2-3. \n\n2.2.3.1  The Front End\nThe front end of Intel Core microarchitecture provides several enhancements to feed the Intel Wide Dynamic \nExecution engine:\n• Instruction fetch unit prefetches instructions into an instruction queue to maintain steady supply of instruction \n\nto the decode units.\n• Four-wide decode unit can decode 4 instructions per cycle or 5 instructions per cycle with Macrofusion.\n\nFigure 2-3.  The Intel Core Microarchitecture Pipeline Functionality\n\nDecode\n\nALU\nBranch\n\nMMX/SSE/FP\nMove\n\nLoad\n\nShared L2 Cache\nUp to 10.7 GB/s \n\nFSB\n\nRetirement Unit \n(Re-Order Buffer)\n\nL1D Cache and DTLB\n\nInstruction Fetch and PreDecode\n\nInstruction Queue\n\nRename/Alloc\n\nALU\nFAdd\n\nMMX/SSE\n\nALU\nFMul\n\nMMX/SSE\n\nScheduler\n\nMicro-\ncode \nROM\n\nStore\nVol. 1 2-11\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n• Macrofusion fuses common sequence of two instructions as one decoded instruction (micro-ops) to increase \ndecoding throughput.\n\n• Microfusion fuses common sequence of two micro-ops as one micro-ops to improve retirement throughput.\n• Instruction queue provides caching of short loops to improve efficiency.\n• Stack pointer tracker improves efficiency of executing procedure/function entries and exits.\n• Branch prediction unit employs dedicated hardware to handle different types of branches for improved branch \n\nprediction.\n• Advanced branch prediction algorithm directs instruction fetch unit to fetch instructions likely in the architec-\n\ntural code path for decoding.\n\n2.2.3.2  Execution Core \nThe execution core of the Intel Core microarchitecture is superscalar and can process instructions out of order to \nincrease the overall rate of instructions executed per cycle (IPC). The execution core employs the following feature \nto improve execution throughput and efficiency:\n• Up to six micro-ops can be dispatched to execute per cycle\n• Up to four instructions can be retired per cycle\n• Three full arithmetic logical units\n• SIMD instructions can be dispatched through three issue ports\n• Most SIMD instructions have 1-cycle throughput (including 128-bit SIMD instructions)\n• Up to eight floating-point operation per cycle\n• Many long-latency computation operation are pipelined in hardware to increase overall throughput\n• Reduced exposure to data access delays using Intel Smart Memory Access\n\n2.2.4 Intel® Atom™ Microarchitecture\nIntel Atom microarchitecture maximizes power-efficient performance for single-threaded and multi-threaded \nworkloads by providing:\n• Advanced Micro-Ops Execution \n\n— Single-micro-op instruction execution from decode to retirement, including instructions with register-only, \nload, and store semantics.\n\n— Sixteen-stage, in-order pipeline optimized for throughput and reduced power consumption.\n\n— Dual pipelines to enable decode, issue, execution and retirement of two instructions per cycle.\n\n— Advanced stack pointer to improve efficiency of executing function entry/returns.\n• Intel® Smart Cache\n\n— Second level cache is 512 KB and 8-way associativity.\n\n— Optimized for multi-threaded and single-threaded execution environments\n\n— 256 bit internal data path between L2 and L1 data cache improves high bandwidth.\n• Efficient Memory Access\n\n— Efficient hardware prefetchers to L1 and L2, speculatively loading data likely to be requested by processor \nto reduce cache miss impact.\n\n• Intel® Digital Media Boost\n\n— Two issue ports for dispatching SIMD instructions to execution units.\n\n— Single-cycle throughput for most 128-bit integer SIMD instructions\n\n— Up to six floating-point operations per cycle\n\n— Up to two 128-bit SIMD integer operations per cycle\n2-12 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n— Safe Instruction Recognition (SIR) to allow long-latency floating-point operations to retire out of order with \nrespect to integer instructions.\n\n2.2.5 Intel® Microarchitecture Code Name Nehalem\nIntel microarchitecture code name Nehalem provides the foundation for many innovative features of Intel Core i7 \nprocessors. It builds on the success of 45 nm Intel Core microarchitecture and provides the following feature \nenhancements:\n• Enhanced processor core\n\n— Improved branch prediction and recovery from misprediction.\n\n— Enhanced loop streaming to improve front end performance and reduce power consumption.\n\n— Deeper buffering in out-of-order engine to extract parallelism.\n\n— Enhanced execution units to provide acceleration in CRC, string/text processing and data shuffling.\n• Smart Memory Access\n\n— Integrated memory controller provides low-latency access to system memory and scalable memory \nbandwidth\n\n— New cache hierarchy organization with shared, inclusive L3 to reduce snoop traffic\n\n— Two level TLBs and increased TLB size.\n\n— Fast unaligned memory access.\n• HyperThreading Technology\n\n— Provides two hardware threads (logical processors) per core.\n\n— Takes advantage of 4-wide execution engine, large L3, and massive memory bandwidth.\n• Dedicated Power management Innovations\n\n— Integrated microcontroller with optimized embedded firmware to manage power consumption.\n\n— Embedded real-time sensors for temperature, current, and power.\n\n— Integrated power gate to turn off/on per-core power consumption\n\n— Versatility to reduce power consumption of memory, link subsystems.\n\n2.2.6 Intel® Microarchitecture Code Name Sandy Bridge\nIntel® microarchitecture code name Sandy Bridge builds on the successes of Intel® Core™ microarchitecture and \nIntel microarchitecture code name Nehalem. It offers the following innovative features:\n• Intel Advanced Vector Extensions (Intel AVX)\n\n— 256-bit floating-point instruction set extensions to the 128-bit Intel Streaming SIMD Extensions, providing \nup to 2X performance benefits relative to 128-bit code.\n\n— Non-destructive destination encoding offers more flexible coding techniques.\n\n— Supports flexible migration and co-existence between 256-bit AVX code, 128-bit AVX code and legacy 128-\nbit SSE code.\n\n• Enhanced front-end and execution engine\n\n— New decoded Icache component that improves front-end bandwidth and reduces branch misprediction \npenalty.\n\n— Advanced branch prediction.\n\n— Additional macro-fusion support.\n\n— Larger dynamic execution window.\n\n— Multi-precision integer arithmetic enhancements (ADC/SBB, MUL/IMUL).\nVol. 1 2-13\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n— LEA bandwidth improvement.\n\n— Reduction of general execution stalls (read ports, writeback conflicts, bypass latency, partial stalls).\n\n— Fast floating-point exception handling.\n\n— XSAVE/XRSTORE performance improvements and XSAVEOPT new instruction.\n• Cache hierarchy improvements for wider data path\n\n— Doubling of bandwidth enabled by two symmetric ports for memory operation.\n\n— Simultaneous handling of more in-flight loads and stores enabled by increased buffers.\n\n— Internal bandwidth of two loads and one store each cycle.\n\n— Improved prefetching.\n\n— High bandwidth low latency LLC architecture.\n\n— High bandwidth ring architecture of on-die interconnect.\n\nFor additional information on Intel® Advanced Vector Extensions (AVX), see Section 5.13, “Intel® Advanced Vector \nExtensions (Intel® AVX)” and Chapter 14, “Programming with AVX, FMA and AVX2” in Intel® 64 and IA-32 Archi-\ntectures Software Developer’s Manual, Volume 1.\n\n2.2.7 SIMD Instructions\nBeginning with the Pentium II and Pentium with Intel MMX technology processor families, six extensions have been \nintroduced into the Intel 64 and IA-32 architectures to perform single-instruction multiple-data (SIMD) operations. \nThese extensions include the MMX technology, SSE extensions, SSE2 extensions, SSE3 extensions, Supplemental \nStreaming SIMD Extensions 3, and SSE4. Each of these extensions provides a group of instructions that perform \nSIMD operations on packed integer and/or packed floating-point data elements. \n\nSIMD integer operations can use the 64-bit MMX or the 128-bit XMM registers. SIMD floating-point operations use \n128-bit XMM registers. Figure 2-4 shows a summary of the various SIMD extensions (MMX technology, SSE, SSE2, \nSSE3, SSSE3, and SSE4), the data types they operate on, and how the data types are packed into MMX and XMM \nregisters.\n\nThe Intel MMX technology was introduced in the Pentium II and Pentium with MMX technology processor families. \nMMX instructions perform SIMD operations on packed byte, word, or doubleword integers located in MMX registers. \nThese instructions are useful in applications that operate on integer arrays and streams of integer data that lend \nthemselves to SIMD processing.\n\nSSE extensions were introduced in the Pentium III processor family. SSE instructions operate on packed single-\nprecision floating-point values contained in XMM registers and on packed integers contained in MMX registers. \nSeveral SSE instructions provide state management, cache control, and memory ordering operations. Other SSE \ninstructions are targeted at applications that operate on arrays of single-precision floating-point data elements (3-\nD geometry, 3-D rendering, and video encoding and decoding applications).\n\nSSE2 extensions were introduced in Pentium 4 and Intel Xeon processors. SSE2 instructions operate on packed \ndouble-precision floating-point values contained in XMM registers and on packed integers contained in MMX and \nXMM registers. SSE2 integer instructions extend IA-32 SIMD operations by adding new 128-bit SIMD integer oper-\nations and by expanding existing 64-bit SIMD integer operations to 128-bit XMM capability. SSE2 instructions also \nprovide new cache control and memory ordering operations.\n\nSSE3 extensions were introduced with the Pentium 4 processor supporting Hyper-Threading Technology (built on \n90 nm process technology). SSE3 offers 13 instructions that accelerate performance of Streaming SIMD Extensions \ntechnology, Streaming SIMD Extensions 2 technology, and x87-FP math capabilities.\n\nSSSE3 extensions were introduced with the Intel Xeon processor 5100 series and Intel Core 2 processor family. \nSSSE3 offer 32 instructions to accelerate processing of SIMD integer data.\n\nSSE4 extensions offer 54 instructions. 47 of them are referred to as SSE4.1 instructions. SSE4.1 are introduced \nwith Intel Xeon processor 5400 series and Intel Core 2 Extreme processor QX9650. The other 7 SSE4 instructions \nare referred to as SSE4.2 instructions.\n2-14 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nAESNI and PCLMULQDQ introduce 7 new instructions. Six of them are primitives for accelerating algorithms based \non AES encryption/decryption standard, referred to as AESNI.\n\nThe PCLMULQDQ instruction accelerates general-purpose block encryption, which can perform carry-less multipli-\ncation for two binary numbers up to 64-bit wide.\n\nIntel 64 architecture allows four generations of 128-bit SIMD extensions to access up to 16 XMM registers. IA-32 \narchitecture provides 8 XMM registers.\n\nIntel® Advanced Vector Extensions offers comprehensive architectural enhancements over previous generations of \nStreaming SIMD Extensions. Intel AVX introduces the following architectural enhancements:\n• Support for 256-bit wide vectors and SIMD register set.\n• 256-bit floating-point instruction set enhancement with up to 2X performance gain relative to 128-bit \n\nStreaming SIMD extensions.\n• Instruction syntax support for generalized three-operand syntax to improve instruction programming flexibility \n\nand efficient encoding of new instruction extensions.\n• Enhancement of legacy 128-bit SIMD instruction extensions to support three operand syntax and to simplify \n\ncompiler vectorization of high-level language expressions.\n• Support flexible deployment of 256-bit AVX code, 128-bit AVX code, legacy 128-bit code and scalar code.\nIn addition to performance considerations, programmers should also be cognizant of the implications of VEX-\nencoded AVX instructions with the expectations of system software components that manage the processor state \ncomponents enabled by XCR0. For additional information see Section 2.3.10.1, “Vector Length Transition and \nProgramming Considerations” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A.\n\nSee also: \n• Section 5.4, “MMX™ Instructions,” and Chapter 9, “Programming with Intel® MMX™ Technology”\n• Section 5.5, “SSE Instructions,” and Chapter 10, “Programming with Intel® Streaming SIMD Extensions \n\n(Intel® SSE)”\n• Section 5.6, “SSE2 Instructions,” and Chapter 11, “Programming with Intel® Streaming SIMD Extensions 2 \n\n(Intel® SSE2)”\n• Section 5.7, “SSE3 Instructions”, Section 5.8, “Supplemental Streaming SIMD Extensions 3 (SSSE3) Instruc-\n\ntions”, Section 5.9, “SSE4 Instructions”, and Chapter 12, “Programming with Intel® SSE3, SSSE3, Intel® \nSSE4 and Intel® AESNI”\nVol. 1 2-15\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.2.8 Intel® Hyper-Threading Technology\nIntel Hyper-Threading Technology (Intel HT Technology) was developed to improve the performance of IA-32 \nprocessors when executing multi-threaded operating system and application code or single-threaded applications \nunder multi-tasking environments. The technology enables a single physical processor to execute two or more \nseparate code streams (threads) concurrently using shared execution resources. \n\nIntel HT Technology is one form of hardware multi-threading capability in IA-32 processor families. It differs from \nmulti-processor capability using separate physically distinct packages with each physical processor package mated \nwith a physical socket. Intel HT Technology provides hardware multi-threading capability with a single physical \npackage by using shared execution resources in a processor core.\n\nArchitecturally, an IA-32 processor that supports Intel HT Technology consists of two or more logical processors, \neach of which has its own IA-32 architectural state. Each logical processor consists of a full set of IA-32 data regis-\nters, segment registers, control registers, debug registers, and most of the MSRs. Each also has its own advanced \nprogrammable interrupt controller (APIC). \n\nFigure 2-5 shows a comparison of a processor that supports Intel HT Technology (implemented with two logical \nprocessors) and a traditional dual processor system. \n\nFigure 2-4.  SIMD Extensions, Register Layouts, and Data Types\n\n4 Packed Word Integers\n\n8 Packed Byte Integers\n\n2 Packed Doubleword Integers\n\nMMX Registers\n\nQuadword\n\nMMX Technology - SSSE3\n\nData TypeRegister LayoutSIMD Extension\n\nSSE - AVX\n\n4 Packed Single-Precision\nFloating-Point Values\n\n2 Packed Double-Precision\nFloating-Point Values\n\n8 Packed Word Integers\n\n16 Packed Byte Integers\n\n4 Packed Doubleword\n\n2 Quadword Integers\n\nDouble Quadword\n\nIntegers\n\nXMM Registers\n\n8 Packed SP FP Values\n\n4 Packed DP FP Values\n\nYMM Registers\nAVX\n\n2 128-bit Data\n2-16 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nUnlike a traditional MP system configuration that uses two or more separate physical IA-32 processors, the logical \nprocessors in an IA-32 processor supporting Intel HT Technology share the core resources of the physical \nprocessor. This includes the execution engine and the system bus interface. After power up and initialization, each \nlogical processor can be independently directed to execute a specified thread, interrupted, or halted.\n\nIntel HT Technology leverages the process and thread-level parallelism found in contemporary operating systems \nand high-performance applications by providing two or more logical processors on a single chip. This configuration \nallows two or more threads1 to be executed simultaneously on each a physical processor. Each logical processor \nexecutes instructions from an application thread using the resources in the processor core. The core executes \nthese threads concurrently, using out-of-order instruction scheduling to maximize the use of execution units during \neach clock cycle.\n\n2.2.8.1  Some Implementation Notes\nAll Intel HT Technology configurations require:\n• A processor that supports Intel HT Technology\n• A chipset and BIOS that utilize the technology\n• Operating system optimizations\n\nSee http://www.intel.com/products/ht/hyperthreading_more.htm for information.\n\nAt the firmware (BIOS) level, the basic procedures to initialize the logical processors in a processor supporting Intel \nHT Technology are the same as those for a traditional DP or MP platform. The mechanisms that are described in the \nMultiprocessor Specification, Version 1.4 to power-up and initialize physical processors in an MP system also apply \nto logical processors in a processor that supports Intel HT Technology. \n\nAn operating system designed to run on a traditional DP or MP platform may use CPUID to determine the presence \nof hardware multi-threading support feature and the number of logical processors they provide.\n\nAlthough existing operating system and application code should run correctly on a processor that supports Intel HT \nTechnology, some code modifications are recommended to get the optimum benefit. These modifications are \ndiscussed in Chapter 7, “Multiple-Processor Management,” Intel® 64 and IA-32 Architectures Software Devel-\noper’s Manual, Volume 3A.\n\nFigure 2-5.  Comparison of an IA-32 Processor Supporting Hyper-Threading Technology and a Traditional Dual \nProcessor System\n\n1. In the remainder of this document, the term “thread” will be used as a general term for the terms “process” and “thread.”\n\nProcessor Core Processor CoreProcessor Core\n\nAS ASASAS\n\nTraditional Multiple Processor (MP) SystemIA-32 Processor Supporting\nHyper-Threading Technology\n\nAS = IA-32 Architectural State\n\nIA-32 processor IA-32 processor\n\nTwo logical \nprocessors that share \na single core\n\nEach processor is a \nseparate physical \npackage\n\nIA-32 processor\n\nOM16522\nVol. 1 2-17\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.2.9 Multi-Core Technology\nMulti-core technology is another form of hardware multi-threading capability in IA-32 processor families. Multi-core \ntechnology enhances hardware multi-threading capability by providing two or more execution cores in a physical \npackage.\n\nThe Intel Pentium processor Extreme Edition is the first member in the IA-32 processor family to introduce multi-\ncore technology. The processor provides hardware multi-threading support with both two processor cores and Intel \nHyper-Threading Technology. This means that the Intel Pentium processor Extreme Edition provides four logical \nprocessors in a physical package (two logical processors for each processor core). The Dual-Core Intel Xeon \nprocessor features multi-core, Intel Hyper-Threading Technology and supports multi-processor platforms. \n\nThe Intel Pentium D processor also features multi-core technology. This processor provides hardware multi-\nthreading support with two processor cores but does not offer Intel Hyper-Threading Technology. This means that \nthe Intel Pentium D processor provides two logical processors in a physical package, with each logical processor \nowning the complete execution resources of a processor core.\n\nThe Intel Core 2 processor family, Intel Xeon processor 3000 series, Intel Xeon processor 5100 series, and Intel \nCore Duo processor offer power-efficient multi-core technology. The processor contains two cores that share a \nsmart second level cache. The Level 2 cache enables efficient data sharing between two cores to reduce memory \ntraffic to the system bus.\n\nThe Pentium® dual-core processor is based on the same technology as the Intel Core 2 Duo processor family.\n\nThe Intel Xeon processor 7300, 5300 and 3200 series, Intel Core 2 Extreme Quad-Core processor, and Intel Core 2 \nQuad processors support Intel quad-core technology. The Quad-core Intel Xeon processors and the Quad-Core \nIntel Core 2 processor family are also in Figure 2-7. \n\nFigure 2-6.  Intel 64 and IA-32 Processors that Support Dual-Core \n\nArchitectual \nState\n\nSystem Bus\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual \nState\n\nBus Interface Bus Interface\n\nLocal APIC Local APIC\n\nArchitectual \nState\n\nArchitectual \nState\n\nPentium Processor Extreme Edition\nSystem Bus\n\nArchitectual State\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual State\n\nBus Interface\n\nIntel Core Duo Processor\nIntel Core 2 Duo Processor\n\nIntel Pentium dual-core Processor\n\nSecond Level Cache\n\nArchitectual State\n\nSystem Bus\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual State\n\nBus Interface Bus Interface\n\nPentium D Processor\n\nOM19809\n2-18 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Core i7 processors support Intel quad-core technology, Intel HyperThreading Technology, provides Intel \nQuickPath interconnect link to the chipset and have integrated memory controller supporting three channel to \nDDR3 memory.\n\nFigure 2-7.  Intel 64 Processors that Support Quad-Core \n\nFigure 2-8.  Intel Core i7 Processor \n\nSystem Bus\n\nIntel Core 2 Extreme Quad-core Processor\nIntel Core 2 Quad Processor\n\nIntel Xeon Processor 3200 Series\nIntel Xeon Processor 5300 Series\n\nArchitectual State\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual State\n\nBus Interface\n\nSecond Level Cache\n\nArchitectual State\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual State\n\nBus Interface\n\nSecond Level Cache\n\nOM19810\n\nChipset\n\nIntel Core i7  Processor\n\nQPI\n\nLogical \nProces\n\nsor\n\nL1 and L2\n\nExecution Engine Execution Engine\n\nL1 and L2 L1 and L2\n\nExecution Engine Execution Engine\n\nL1 and L2\n\nQuickPath Interconnect (QPI) Interface, Integrated Memory Controller\n\nThird Level Cache\n\nOM19810b\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nDDR3\n\nIMC\nVol. 1 2-19\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.2.10 Intel® 64 Architecture\nIntel 64 architecture increases the linear address space for software to 64 bits and supports physical address space \nup to 52 bits. The technology also introduces a new operating mode referred to as IA-32e mode.\n\nIA-32e mode operates in one of two sub-modes: (1) compatibility mode enables a 64-bit operating system to run \nmost legacy 32-bit software unmodified, (2) 64-bit mode enables a 64-bit operating system to run applications \nwritten to access 64-bit address space. \n\nIn the 64-bit mode, applications may access:\n• 64-bit flat linear addressing\n• 8 additional general-purpose registers (GPRs)\n• 8 additional registers for streaming SIMD extensions (SSE, SSE2, SSE3 and SSSE3)\n• 64-bit-wide GPRs and instruction pointers\n• uniform byte-register addressing\n• fast interrupt-prioritization mechanism\n• a new instruction-pointer relative-addressing mode\n\nAn Intel 64 architecture processor supports existing IA-32 software because it is able to run all non-64-bit legacy \nmodes supported by IA-32 architecture. Most existing IA-32 applications also run in compatibility mode.\n\n2.2.11 Intel® Virtualization Technology (Intel® VT)\nIntel® Virtualization Technology for Intel 64 and IA-32 architectures provide extensions that support virtualization. \nThe extensions are referred to as Virtual Machine Extensions (VMX). An Intel 64 or IA-32 platform with VMX can \nfunction as multiple virtual systems (or virtual machines). Each virtual machine can run operating systems and \napplications in separate partitions. \n\nVMX also provides programming interface for a new layer of system software (called the Virtual Machine Monitor \n(VMM)) used to manage the operation of virtual machines. Information on VMX and on the programming of VMMs \nis in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C.\n\nIntel Core i7 processor provides the following enhancements to Intel Virtualization Technology:\n• Virtual processor ID (VPID) to reduce the cost of VMM managing transitions.\n• Extended page table (EPT) to reduce the number of transitions for VMM to manage memory virtualization.\n• Reduced latency of VM transitions.\n\n2.3 INTEL® 64 AND IA-32 PROCESSOR GENERATIONS\nIn the mid-1960s, Intel cofounder and Chairman Emeritus Gordon Moore had this observation: “... the number of \ntransistors that would be incorporated on a silicon die would double every 18 months for the next several years.” \nOver the past three and half decades, this prediction known as “Moore's Law” has continued to hold true.\n\nThe computing power and the complexity (or roughly, the number of transistors per processor) of Intel architecture \nprocessors has grown in close relation to Moore's law. By taking advantage of new process technology and new \nmicroarchitecture designs, each new generation of IA-32 processors has demonstrated frequency-scaling head-\nroom and new performance levels over the previous generation processors.\n2-20 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nThe key features of the Intel Pentium 4 processor, Intel Xeon processor, Intel Xeon processor MP, Pentium III \nprocessor, and Pentium III Xeon processor with advanced transfer cache are shown in Table 2-1. Older generation \nIA-32 processors, which do not employ on-die Level 2 cache, are shown in Table 2-2. \n\nTable 2-1.  Key Features of Most Recent IA-32 Processors \n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architecture Top-Bin Clock \nFre-quency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes1\n\nNOTES:\n1. The register size and external data bus size are given in bits.\n\nSystem \nBus Band-\nwidth\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches2\n\n2. First level cache is denoted using the abbreviation L1, 2nd level cache is denoted as L2. The size\nof L1 includes the first-level data cache and the instruction cache where applicable, but \ndoes not include the trace cache.\n\nIntel Pentium \nM\nProcessor \n7553\n\n3. Intel processor numbers are not a measure of performance. Processor numbers differentiate \nfeatures within each processor family, not across different processor families. \nSee http://www.intel.com/products/processor_number for details.\n\n2004 Intel Pentium M \nProcessor\n\n2.00 GHz 140 M GP: 32 \nFPU: 80 \nMMX: 64\nXMM: 128\n\n3.2 GB/s 4 GB L1: 64 KB\nL2: 2 MB\n\nIntel Core Duo\nProcessor \nT26003\n\n2006 Improved Intel \nPentium M \nProcessor \nMicroarchitecture; \nDual Core;\n\nIntel Smart Cache, \nAdvanced Thermal \nManager\n\n2.16 GHz  152M GP: 32 \nFPU: 80 \nMMX: 64\nXMM: 128\n\n5.3 GB/s 4 GB L1: 64 KB\nL2: 2 MB \n(2MB Total)\n\nIntel Atom\nProcessor \nZ5xx series\n\n2008 Intel Atom \nMicroarchitecture; \n\nIntel Virtualization \nTechnology.\n\n1.86 GHz - \n800 MHz\n\n 47M GP: 32 \nFPU: 80 \nMMX: 64\nXMM: 128\n\nUp to 4.2 \nGB/s\n\n4 GB L1: 56 KB4\n\nL2: 512KB \n\n4. In Intel Atom Processor, the size of L1 instruction cache is 32 KBytes, L1 data cache is 24 KBytes.\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\n\n64-bit Intel \nXeon\nProcessor \nwith 800 MHz \nSystem Bus\n\n2004 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture\n\n3.60 GHz 125 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n6.4 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n1 MB L2\n\n64-bit Intel \nXeon\nProcessor MP \nwith 8MB L3\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture \n\n3.33 GHz 675M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n5.3 GB/s 1 1024 GB \n(1 TB)\n\n12K µop \nExecution \nTrace Cache;\n16 KB L1;\n1 MB L2,\n8 MB L3\nVol. 1 2-21\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Pentium \n4\nProcessor \nExtreme \nEdition \nSupporting \nHyper-\nThreading \nTechnology\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture \n\n3.73 GHz 164 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n2 MB L2\n\nIntel Pentium \nProcessor \nExtreme \nEdition 840\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture;\n\nDual-core 2\n\n3.20 GHz 230 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n6.4 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n1MB L2 \n(2MB Total)\n\nDual-Core Intel \nXeon \nProcessor \n7041\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture;\n\nDual-core 3\n\n3.00 GHz  321M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n6.4 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n2MB L2 \n(4MB Total)\n\nIntel Pentium \n4\nProcessor 672\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n3.80 GHz 164 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n6.4 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n2MB L2 \n\nIntel Pentium \nProcessor \nExtreme \nEdition 955\n\n2006 Intel NetBurst \nMicroarchitecture; \nIntel 64 \nArchitecture; Dual \nCore;\n\nIntel Virtualization \nTechnology.\n\n3.46 GHz  376M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n2MB L2 \n\n(4MB Total)\n\nIntel Core 2 \nExtreme \nProcessor \nX6800\n\n2006 Intel Core \nMicroarchitecture; \nDual Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.93 GHz  291M GP: 32,64 \nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 64 GB L1: 64 KB\nL2: 4MB \n(4MB Total)\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\n2-22 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Xeon\nProcessor \n5160\n\n2006 Intel Core \nMicroarchitecture; \nDual Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n3.00 GHz  291M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n10.6 GB/s 64 GB L1: 64 KB\nL2: 4MB \n(4MB Total)\n\nIntel Xeon\nProcessor \n7140\n\n2006 Intel NetBurst \nMicroarchitecture; \nDual Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n3.40 GHz  1.3 B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n12.8 GB/s 64 GB L1: 64 KB\nL2: 1MB \n(2MB Total)\n\nL3: 16 MB \n(16MB Total)\n\nIntel Core 2 \nExtreme \nProcessor \nQX6700\n\n2006 Intel Core \nMicroarchitecture; \nQuad Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.66 GHz 582M GP: 32,64 \nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 64 GB L1: 64 KB\nL2: 4MB \n(4MB Total)\n\nQuad-core \nIntel Xeon\nProcessor \n5355\n\n2006 Intel Core \nMicroarchitecture; \nQuad Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.66 GHz 582 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n10.6 GB/s 256 GB L1: 64 KB\nL2: 4MB (8 \nMB Total)\n\nIntel Core 2 \nDuo Processor \nE6850\n\n2007 Intel Core \nMicroarchitecture; \nDual Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology;\n\nIntel Trusted \nExecution \nTechnology\n\n3.00 GHz 291 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n10.6 GB/s 64 GB L1: 64 KB\nL2: 4MB \n(4MB Total)\n\nIntel Xeon\nProcessor \n7350\n\n2007 Intel Core \nMicroarchitecture; \nQuad Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.93 GHz  582 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 1024 GB L1: 64 KB\nL2: 4MB \n(8MB Total)\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\nVol. 1 2-23\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Xeon\nProcessor \n5472\n\n2007 Enhanced Intel \nCore \nMicroarchitecture; \nQuad Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n3.00 GHz  820 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n12.8 GB/s 256 GB L1: 64 KB\nL2: 6MB \n(12MB Total)\n\nIntel Atom\nProcessor\n\n2008 Intel Atom \nMicroarchitecture; \nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.0 - 1.60 \nGHz\n\n47 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nUp to 4.2 \nGB/s\n\nUp to \n64GB\n\nL1: 56 KB4\n\nL2: 512KB \n\nIntel Xeon\nProcessor \n7460\n\n2008 Enhanced Intel \nCore \nMicroarchitecture; \nSix Cores; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.67 GHz  1.9 B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 1024 GB L1: 64 KB\nL2: 3MB \n(9MB Total)\n\nL3: 16MB\n\nIntel Atom\nProcessor 330\n\n2008 Intel Atom \nMicroarchitecture; \nIntel 64 \nArchitecture;\n\nDual core;\n\nIntel Virtualization \nTechnology.\n\n1.60 GHz 94 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nUp to 4.2 \nGB/s\n\nUp to \n64GB\n\nL1: 56 KB5\n\nL2: 512KB \n(1MB Total)\n\nIntel Core i7-\n965\nProcessor \nExtreme \nEdition\n\n2008 Intel \nmicroarchitecture \ncode name \nNehalem; \nQuadcore; \nHyperThreading \nTechnology; Intel \nQPI; Intel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n3.20 GHz  731 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nQPI: 6.4 \nGT/s; \nMemory: \n25 GB/s \n\n64 GB L1: 64 KB\nL2: 256KB \n\nL3: 8MB\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\n2-24 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Core i7-\n620M\nProcessor \n\n2010 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name \nWestmere; \nDualcore; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology., \nIntegrated graphics\n\n2.66 GHz  383 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n64 GB L1: 64 KB\nL2: 256KB \n\nL3: 4MB\n\nIntel Xeon-\nProcessor \n5680\n\n2010 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name \nWestmere; Six core; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n3.33 GHz 1.1B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nQPI: 6.4 \nGT/s; 32 \nGB/s\n\n1 TB L1: 64 KB\nL2: 256KB \n\nL3: 12MB\n\nIntel Xeon-\nProcessor \n7560\n\n2010 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name \nNehalem; Eight \ncore; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n2.26 GHz 2.3B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nQPI: 6.4 \nGT/s; \nMemory: \n76 GB/s \n\n16 TB L1: 64 KB\nL2: 256KB \n\nL3: 24MB\n\nIntel Core i7-\n2600K\nProcessor \n\n2011 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name Sandy \nBridge; Four core; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology., \nProcessor graphics, \nQuicksync Video\n\n3.40 GHz  995M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nYMM: 256\n\nDMI: 5 \nGT/s; \nMemory: \n21 GB/s\n\n64 GB L1: 64 KB\nL2: 256KB \n\nL3: 8MB\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\nVol. 1 2-25\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Xeon-\nProcessor E3-\n1280\n\n2011 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name Sandy \nBridge; Four core; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n3.50 GHz GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nYMM: 256\n\nDMI: 5 \nGT/s; \nMemory: \n21 GB/s\n\n1 TB L1: 64 KB\nL2: 256KB \n\nL3: 8MB\n\nIntel Xeon-\nProcessor E7-\n8870\n\n2011 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name \nWestmere; Ten \ncore; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n2.40 GHz 2.2B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nQPI: 6.4 \nGT/s; \nMemory: \n102 GB/s \n\n16 TB L1: 64 KB\nL2: 256KB \n\nL3: 30MB\n\nNOTES:\n1. The 64-bit Intel Xeon Processor MP with an 8-MByte L3 supports a multi-processor platform with a dual system bus; this creates a \n\nplatform bandwidth with 10.6 GBytes.\n2. In Intel Pentium Processor Extreme Edition 840, the size of on-die cache is listed for each core. The total size of L2 in the physical\n\npackage in 2 MBytes.\n3. In Dual-Core Intel Xeon Processor 7041, the size of on-die cache is listed for each core. The total size of L2 in the physical package in\n\n4 MBytes.\n4. In Intel Atom Processor, the size of L1 instruction cache is 32 KBytes, L1 data cache is 24 KBytes.\n5. In Intel Atom Processor, the size of L1 instruction cache is 32 KBytes, L1 data cache is 24 KBytes.\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\n2-26 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nTable 2-3.  Key Features of Previous Generations of IA-32 Processors\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMax. Clock \nFrequency/\nTechnology at \nIntroduction\n\nTran-\nsistors\n\nRegister \nSizes1\n\nExt. Data \nBus Size2\n\nMax. \nExtern. \nAddr. \nSpace\n\nCaches \n\n8086 1978 8 MHz 29 K 16 GP 16 1 MB None\n\nIntel 286 1982 12.5 MHz 134 K 16 GP 16 16 MB Note 3\n\nIntel386 DX \nProcessor\n\n1985 20 MHz 275 K 32 GP 32 4 GB Note 3\n\nIntel486 DX \nProcessor\n\n1989 25 MHz 1.2 M 32 GP\n80 FPU\n\n32 4 GB L1: 8 KB\n\nPentium Processor 1993 60 MHz 3.1 M 32 GP\n80 FPU\n\n64 4 GB L1:16 KB\n\nPentium Pro \nProcessor\n\n1995 200 MHz 5.5 M 32 GP\n80 FPU\n\n64 64 GB L1: 16 KB\nL2: 256 KB or \n512 KB \n\nPentium II Processor 1997 266 MHz 7 M 32 GP\n80 FPU\n64 MMX\n\n64 64 GB L1: 32 KB\nL2: 256 KB or \n512 KB\n\nPentium III Processor 1999 500 MHz 8.2 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB L1: 32 KB\nL2: 512 KB\n\nPentium III and \nPentium III Xeon \nProcessors\n\n1999 700 MHz 28 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB L1: 32 KB\nL2: 256 KB\n\nPentium 4 Processor 2000 1.50 GHz, Intel \nNetBurst \nMicroarchitecture\n\n42 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB 12K µop \nExecution \nTrace Cache; \nL1: 8KB\nL2: 256 KB\n\nIntel Xeon Processor 2001 1.70 GHz, Intel \nNetBurst \nMicroarchitecture\n\n42 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB 12K µop \nExecution \nTrace Cache; \nL1: 8KB\nL2: 512KB\n\nIntel Xeon Processor 2002 2.20 GHz, Intel \nNetBurst \nMicroarchitecture, \nHyperThreading \nTechnology\n\n55 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB 12K µop \nExecution \nTrace Cache; \nL1: 8KB\nL2: 512KB\n\nPentium M Processor 2003 1.60 GHz, Intel \nNetBurst \nMicroarchitecture\n\n77 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 4 GB L1: 64KB\nL2: 1 MB\nVol. 1 2-27\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nNOTE:\n1. The register size and external data bus size are given in bits. Note also that each 32-bit general-purpose (GP) registers can be \n\naddressed as an 8- or a 16-bit data registers in all of the processors.\n2. Internal data paths are 2 to 4 times wider than the external data bus for each processor.\n\n2.4 PROPOSED REMOVAL OF INTEL INSTRUCTION SET ARCHITECTURE AND \nFEATURES FROM UPCOMING PRODUCTS\n\nThis section lists Intel Instruction Set Architecture (ISA) and features that Intel plans to remove from select prod-\nucts starting from a specific year.\n\n2.5 INTEL INSTRUCTION SET ARCHITECTURE AND FEATURES REMOVED\nThis section lists Intel ISA and features that Intel has already removed for select upcoming products. All sections \nrelevant to the removed features will be identified as such and may be moved to an archived section in future \nIntel® 64 and IA-32 Architectures Software Developer's Manual releases.\n\nIntel Pentium 4\nProcessor \nSupporting Hyper-\nThreading \nTechnology at 90 nm \nprocess\n\n2004 3.40 GHz, Intel \nNetBurst \nMicroarchitecture, \nHyperThreading \nTechnology\n\n125 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB 12K µop \nExecution \nTrace Cache; \nL1: 16KB\nL2: 1 MB\n\nTable 2-4.  Proposed Intel ISA and Features Removal List \n\nIntel ISA/Feature Year of Removal\n\nNA NA\n\nTable 2-5.  Intel ISA and Features Removal List \n\nIntel ISA/Feature Year of Removal\n\nIntel® Memory Protection Extensions (Intel® MPX) 2019 onwards\n\n MSR_TEST_CTRL, bit 31 (MSR address 33H) 2019 onwards\n\nHardware Lock Elision (HLE) 2019 onwards\n\nTable 2-3.  Key Features of Previous Generations of IA-32 Processors (Contd.)\n2-28 Vol. 1\n\n\n\nCHAPTER 3\nBASIC EXECUTION ENVIRONMENT\n\nThis chapter describes the basic execution environment of an Intel 64 or IA-32 processor as seen by assembly-\nlanguage programmers. It describes how the processor executes instructions and how it stores and manipulates \ndata. The execution environment described here includes memory (the address space), general-purpose data \nregisters, segment registers, the flag register, and the instruction pointer register.\n\n3.1 MODES OF OPERATION\nThe IA-32 architecture supports three basic operating modes: protected mode, real-address mode, and system \nmanagement mode. The operating mode determines which instructions and architectural features are accessible:\n• Protected mode — This mode is the native state of the processor. Among the capabilities of protected mode \n\nis the ability to directly execute “real-address mode” 8086 software in a protected, multi-tasking environment. \nThis feature is called virtual-8086 mode, although it is not actually a processor mode. Virtual-8086 mode is \nactually a protected mode attribute that can be enabled for any task. \n\n• Real-address mode — This mode implements the programming environment of the Intel 8086 processor with \nextensions (such as the ability to switch to protected or system management mode). The processor is placed in \nreal-address mode following power-up or a reset.\n\n• System management mode (SMM) — This mode provides an operating system or executive with a \ntransparent mechanism for implementing platform-specific functions such as power management and system \nsecurity. The processor enters SMM when the external SMM interrupt pin (SMI#) is activated or an SMI is \nreceived from the advanced programmable interrupt controller (APIC). \nIn SMM, the processor switches to a separate address space while saving the basic context of the currently \nrunning program or task. SMM-specific code may then be executed transparently. Upon returning from SMM, \nthe processor is placed back into its state prior to the system management interrupt. SMM was introduced with \nthe Intel386™ SL and Intel486™ SL processors and became a standard IA-32 feature with the Pentium \nprocessor family. \n\n3.1.1 Intel® 64 Architecture\nIntel 64 architecture adds IA-32e mode. IA-32e mode has two sub-modes.\nThese are:\n• Compatibility mode (sub-mode of IA-32e mode) — Compatibility mode permits most legacy 16-bit and \n\n32-bit applications to run without re-compilation under a 64-bit operating system. For brevity, the compatibility \nsub-mode is referred to as compatibility mode in IA-32 architecture. The execution environment of compati-\nbility mode is the same as described in Section 3.2. Compatibility mode also supports all of the privilege levels \nthat are supported in 64-bit and protected modes. Legacy applications that run in Virtual 8086 mode or use \nhardware task management will not work in this mode. \nCompatibility mode is enabled by the operating system (OS) on a code segment basis. This means that a single \n64-bit OS can support 64-bit applications running in 64-bit mode and support legacy 32-bit applications (not \nrecompiled for 64-bits) running in compatibility mode.\nCompatibility mode is similar to 32-bit protected mode. Applications access only the first 4 GByte of linear-\naddress space. Compatibility mode uses 16-bit and 32-bit address and operand sizes. Like protected mode, this \nmode allows applications to access physical memory greater than 4 GByte using PAE (Physical Address Exten-\nsions). \n\n• 64-bit mode (sub-mode of IA-32e mode) — This mode enables a 64-bit operating system to run applica-\ntions written to access 64-bit linear address space. For brevity, the 64-bit sub-mode is referred to as 64-bit \nmode in IA-32 architecture.\nVol. 1 3-1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n64-bit mode extends the number of general purpose registers and SIMD extension registers from 8 to 16. \nGeneral purpose registers are widened to 64 bits. The mode also introduces a new opcode prefix (REX) to \naccess the register extensions. See Section 3.2.1 for a detailed description.\n64-bit mode is enabled by the operating system on a code-segment basis. Its default address size is 64 bits and \nits default operand size is 32 bits. The default operand size can be overridden on an instruction-by-instruction \nbasis using a REX opcode prefix in conjunction with an operand size override prefix. \nREX prefixes allow a 64-bit operand to be specified when operating in 64-bit mode. By using this mechanism, \nmany existing instructions have been promoted to allow the use of 64-bit registers and 64-bit addresses.\n\n3.2 OVERVIEW OF THE BASIC EXECUTION ENVIRONMENT\nAny program or task running on an IA-32 processor is given a set of resources for executing instructions and for \nstoring code, data, and state information. These resources (described briefly in the following paragraphs and \nshown in Figure 3-1) make up the basic execution environment for an IA-32 processor. \n\nAn Intel 64 processor supports the basic execution environment of an IA-32 processor, and a similar environment \nunder IA-32e mode that can execute 64-bit programs (64-bit sub-mode) and 32-bit programs (compatibility sub-\nmode). \n\nThe basic execution environment is used jointly by the application programs and the operating system or executive \nrunning on the processor.\n• Address space — Any task or program running on an IA-32 processor can address a linear address space of \n\nup to 4 GBytes (232 bytes) and a physical address space of up to 64 GBytes (236 bytes). See Section 3.3.6, \n“Extended Physical Addressing in Protected Mode,” for more information about addressing an address space \ngreater than 4 GBytes.\n\n• Basic program execution registers — The eight general-purpose registers, the six segment registers, the \nEFLAGS register, and the EIP (instruction pointer) register comprise a basic execution environment in which to \nexecute a set of general-purpose instructions. These instructions perform basic integer arithmetic on byte, \nword, and doubleword integers, handle program flow control, operate on bit and byte strings, and address \nmemory. See Section 3.4, “Basic Program Execution Registers,” for more information about these registers.\n\n• x87 FPU registers — The eight x87 FPU data registers, the x87 FPU control register, the status register, the \nx87 FPU instruction pointer register, the x87 FPU operand (data) pointer register, the x87 FPU tag register, and \nthe x87 FPU opcode register provide an execution environment for operating on single-precision, double-\nprecision, and double extended-precision floating-point values, word integers, doubleword integers, quadword \nintegers, and binary coded decimal (BCD) values. See Section 8.1, “x87 FPU Execution Environment,” for more \ninformation about these registers.\n\n• MMX registers — The eight MMX registers support execution of single-instruction, multiple-data (SIMD) \noperations on 64-bit packed byte, word, and doubleword integers. See Section 9.2, “The MMX Technology \nProgramming Environment,” for more information about these registers.\n\n• XMM registers — The eight XMM data registers and the MXCSR register support execution of SIMD operations \non 128-bit packed single-precision and double-precision floating-point values and on 128-bit packed byte, \nword, doubleword, and quadword integers. See Section 10.2, “SSE Programming Environment,” for more \ninformation about these registers.\n\n• YMM registers — The YMM data registers support execution of 256-bit SIMD operations on 256-bit packed \nsingle-precision and double-precision floating-point values and on 256-bit packed byte, word, doubleword, and \nquadword integers. \n\n• Bounds registers — Each of the BND0-BND3 register stores the lower and upper bounds (64 bits each) \nassociated with the pointer to a memory buffer. They support execution of the Intel MPX instructions. \n\n• BNDCFGU and BNDSTATUS— BNDCFGU configures user mode MPX operations on bounds checking. \nBNDSTATUS provides additional information on the #BR caused by an MPX operation.\n3-2 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nFigure 3-1.  IA-32 Basic Execution Environment for Non-64-bit Modes\n\n0\n\n2^32 -1\nEight 32-bit\n\n32-bits\n\n32-bits\n\nGeneral-Purpose Registers\n\nSegment Registers\n\nEFLAGS Register\n\nEIP (Instruction Pointer Register)\n\nAddress Space*\n\n*The address space can be\n\nSix 16-bit\nRegisters\n\nRegisters\n\nEight 80-bit\nRegisters\n\nFloating-Point\nData Registers\n\nEight 64-bit\nRegisters MMX Registers\n\nflat or segmented. Using\n\nXMM Registers\nEight 128-bit\n\nRegisters\n\n16 bits Control Register\n\n16 bits Status Register\n\n48 bits FPU Instruction Pointer Register\n\n48 bits FPU Data (Operand) Pointer Register\n\nFPU Registers\n\nMMX Registers\n\nXMM Registers\n\n32-bits MXCSR Register\n\nOpcode Register (11-bits)\n\nBasic Program Execution Registers\n\n16 bits Tag Register\n\nthe physical address\nextension mechanism, a\nphysical address space of\n2^36 - 1 can be addressed.\n\nYMM Registers\nEight 256-bit\n\nRegisters\n\nYMM Registers\n\nFour 128-bit Registers\n\nBounds Registers\n\nBNDCFGU BNDSTATUS\nVol. 1 3-3\n\n\n\nBASIC EXECUTION ENVIRONMENT\n• Stack — To support procedure or subroutine calls and the passing of parameters between procedures or \nsubroutines, a stack and stack management resources are included in the execution environment. The stack \n(not shown in Figure 3-1) is located in memory. See Section 6.2, “Stacks,” for more information about stack \nstructure.\n\nIn addition to the resources provided in the basic execution environment, the IA-32 architecture provides the \nfollowing resources as part of its system-level architecture. They provide extensive support for operating-system \nand system-development software. Except for the I/O ports, the system resources are described in detail in the \nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 3A & 3B.\n• I/O ports — The IA-32 architecture supports a transfers of data to and from input/output (I/O) ports. See \n\nChapter 19, “Input/Output,” in this volume.\n• Control registers — The five control registers (CR0 through CR4) determine the operating mode of the \n\nprocessor and the characteristics of the currently executing task. See Chapter 2, “System Architecture \nOverview,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\n\n• Memory management registers — The GDTR, IDTR, task register, and LDTR specify the locations of data \nstructures used in protected mode memory management. See Chapter 2, “System Architecture Overview,” in \nthe Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\n\n• Debug registers — The debug registers (DR0 through DR7) control and allow monitoring of the processor’s \ndebugging operations. See in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B.\n\n• Memory type range registers (MTRRs) — The MTRRs are used to assign memory types to regions of \nmemory. See the sections on MTRRs in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolumes 3A & 3B.\n\n• Model-specific registers (MSRs) — The processor provides a variety of model-specific registers that are \nused to control and report on processor performance. Virtually all MSRs handle system related functions and \nare not accessible to an application program. One exception to this rule is the time-stamp counter. The MSRs \nare described in Chapter 2, “Model-Specific Registers (MSRs)” of the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volume 4.\n\n• Machine check registers — The machine check registers consist of a set of control, status, and error-\nreporting MSRs that are used to detect and report on hardware (machine) errors. See Chapter 15, “Machine-\nCheck Architecture,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\n\n• Performance monitoring counters — The performance monitoring counters allow processor performance \nevents to be monitored. See Chapter 18, “Performance Monitoring,” in the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volume 3B.\n\nThe remainder of this chapter describes the organization of memory and the address space, the basic program \nexecution registers, and addressing modes. Refer to the following chapters in this volume for descriptions of the \nother program execution resources shown in Figure 3-1:\n• x87 FPU registers — See Chapter 8, “Programming with the x87 FPU.”\n• MMX Registers — See Chapter 9, “Programming with Intel® MMX™ Technology.”\n• XMM registers — See Chapter 10, “Programming with Intel® Streaming SIMD Extensions (Intel® SSE),” \n\nChapter 11, “Programming with Intel® Streaming SIMD Extensions 2 (Intel® SSE2),” and Chapter 12, \n“Programming with Intel® SSE3, SSSE3, Intel® SSE4 and Intel® AESNI.”\n\n• YMM registers — See Chapter 14, “Programming with AVX, FMA and AVX2”. \n• BND registers, BNDCFGU, BNDSTATUS — See Chapter 13, “Managing State Using the XSAVE Feature Set,” \n\nand Chapter 17, “Intel® MPX”. \n• Stack implementation and procedure calls — See Chapter 6, “Procedure Calls, Interrupts, and Exceptions.”\n3-4 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.2.1 64-Bit Mode Execution Environment\nThe execution environment for 64-bit mode is similar to that described in Section 3.2. The following paragraphs \ndescribe the differences that apply. \n• Address space — A task or program running in 64-bit mode on an IA-32 processor can address linear address \n\nspace of up to 264 bytes (subject to the canonical addressing requirement described in Section 3.3.7.1) and \nphysical address space of up to 252 bytes. Software can query CPUID for the physical address size supported \nby a processor.\n\n• Basic program execution registers — The number of general-purpose registers (GPRs) available is 16. \nGPRs are 64-bits wide and they support operations on byte, word, doubleword and quadword integers. \nAccessing byte registers is done uniformly to the lowest 8 bits. The instruction pointer register becomes 64 bits. \nThe EFLAGS register is extended to 64 bits wide, and is referred to as the RFLAGS register. The upper 32 bits \nof RFLAGS is reserved. The lower 32 bits of RFLAGS is the same as EFLAGS. See Figure 3-2.\n\n• XMM registers — There are 16 XMM data registers for SIMD operations. See Section 10.2, “SSE Programming \nEnvironment,” for more information about these registers.\n\n• YMM registers — There are 16 YMM data registers for SIMD operations. See Chapter 14, “Programming with \nAVX, FMA and AVX2” for more information about these registers.\n\n• BND registers, BNDCFGU, BNDSTATUS — See Chapter 13, “Managing State Using the XSAVE Feature Set,” \nand Chapter 17, “Intel® MPX”. \n\n• Stack — The stack pointer size is 64 bits. Stack size is not controlled by a bit in the SS descriptor (as it is in \nnon-64-bit modes) nor can the pointer size be overridden by an instruction prefix.\n\n• Control registers — Control registers expand to 64 bits. A new control register (the task priority register: CR8 \nor TPR) has been added. See Chapter 2, “Intel® 64 and IA-32 Architectures,” in this volume.\n\n• Debug registers — Debug registers expand to 64 bits. See Chapter 17, “Debug, Branch Profile, TSC, and \nIntel® Resource Director Technology (Intel® RDT) Features,” in the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volume 3A.\nVol. 1 3-5\n\n\n\nBASIC EXECUTION ENVIRONMENT\n• Descriptor table registers — The global descriptor table register (GDTR) and interrupt descriptor table \nregister (IDTR) expand to 10 bytes so that they can hold a full 64-bit base address. The local descriptor table \nregister (LDTR) and the task register (TR) also expand to hold a full 64-bit base address.\n\n3.3 MEMORY ORGANIZATION\nThe memory that the processor addresses on its bus is called physical memory. Physical memory is organized as \na sequence of 8-bit bytes. Each byte is assigned a unique address, called a physical address. The physical \naddress space ranges from zero to a maximum of 236 − 1 (64 GBytes) if the processor does not support Intel \n64 architecture. Intel 64 architecture introduces a set of changes in physical and linear address space; these \nare described in Section 3.3.3, Section 3.3.4, and Section 3.3.7.\n\nFigure 3-2.  64-Bit Mode Execution Environment\n\n0\n\n2^64 -1Sixteen 64-bit\n\n64-bits\n\n64-bits\n\nGeneral-Purpose Registers\n\nSegment Registers\n\nRFLAGS Register\n\nRIP (Instruction Pointer Register)\n\nAddress Space\n\nSix 16-bit\nRegisters\n\nRegisters\n\nEight 80-bit\nRegisters Floating-Point\n\nData Registers\n\nEight 64-bit\nRegisters MMX Registers\n\nXMM Registers\nSixteen 128-bit\n\nRegisters\n\n16 bits Control Register\n\n16 bits Status Register\n\n64 bits FPU Instruction Pointer Register\n\n64 bits FPU Data (Operand) Pointer Register\n\nFPU Registers\n\nMMX Registers\n\nXMM Registers\n\n32-bits MXCSR Register\n\nOpcode Register (11-bits)\n\nBasic Program Execution Registers\n\n16 bits Tag Register\n\nFour 128-bit Registers\n\nBounds Registers\n\nBNDCFGU BNDSTATUS\n\nYMM Registers\nSixteen 256-bit\n\nRegisters\n\nYMM Registers\n3-6 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nVirtually any operating system or executive designed to work with an IA-32 or Intel 64 processor will use the \nprocessor’s memory management facilities to access memory. These facilities provide features such as segmenta-\ntion and paging, which allow memory to be managed efficiently and reliably. Memory management is described in \ndetail in Chapter 3, “Protected-Mode Memory Management,” in the Intel® 64 and IA-32 Architectures Software \nDeveloper’s Manual, Volume 3A. The following paragraphs describe the basic methods of addressing memory when \nmemory management is used.\n\n3.3.1 IA-32 Memory Models\nWhen employing the processor’s memory management facilities, programs do not directly address physical \nmemory. Instead, they access memory using one of three memory models: flat, segmented, or real address mode:\n• Flat memory model — Memory appears to a program as a single, continuous address space (Figure 3-3). This \n\nspace is called a linear address space. Code, data, and stacks are all contained in this address space. Linear \naddress space is byte addressable, with addresses running contiguously from 0 to 232 - 1 (if not in 64-bit \nmode). An address for any byte in linear address space is called a linear address.\n\n• Segmented memory model — Memory appears to a program as a group of independent address spaces \ncalled segments. Code, data, and stacks are typically contained in separate segments. To address a byte in a \nsegment, a program issues a logical address. This consists of a segment selector and an offset (logical \naddresses are often referred to as far pointers). The segment selector identifies the segment to be accessed \nand the offset identifies a byte in the address space of the segment. Programs running on an IA-32 processor \ncan address up to 16,383 segments of different sizes and types, and each segment can be as large as 232 \nbytes.\nInternally, all the segments that are defined for a system are mapped into the processor’s linear address space. \nTo access a memory location, the processor thus translates each logical address into a linear address. This \ntranslation is transparent to the application program.\nThe primary reason for using segmented memory is to increase the reliability of programs and systems. For \nexample, placing a program’s stack in a separate segment prevents the stack from growing into the code or \ndata space and overwriting instructions or data, respectively.\n\n• Real-address mode memory model — This is the memory model for the Intel 8086 processor. It is \nsupported to provide compatibility with existing programs written to run on the Intel 8086 processor. The real-\naddress mode uses a specific implementation of segmented memory in which the linear address space for the \nprogram and the operating system/executive consists of an array of segments of up to 64 KBytes in size each. \nThe maximum size of the linear address space in real-address mode is 220 bytes. \nSee also: Chapter 19, “8086 Emulation,” Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 3B.\nVol. 1 3-7\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.3.2 Paging and Virtual Memory\nWith the flat or the segmented memory model, linear address space is mapped into the processor’s physical \naddress space either directly or through paging. When using direct mapping (paging disabled), each linear address \nhas a one-to-one correspondence with a physical address. Linear addresses are sent out on the processor’s address \nlines without translation. \n\nWhen using the IA-32 architecture’s paging mechanism (paging enabled), linear address space is divided into \npages which are mapped to virtual memory. The pages of virtual memory are then mapped as needed into physical \nmemory. When an operating system or executive uses paging, the paging mechanism is transparent to an applica-\ntion program. All that the application sees is linear address space.\n\nIn addition, IA-32 architecture’s paging mechanism includes extensions that support:\n• Physical Address Extensions (PAE) to address physical address space greater than 4 GBytes.\n• Page Size Extensions (PSE) to map linear address to physical address in 4-MBytes pages.\n\nSee also: Chapter 3, “Protected-Mode Memory Management,” in the Intel® 64 and IA-32 Architectures Software \nDeveloper’s Manual, Volume 3A.\n\n3.3.3 Memory Organization in 64-Bit Mode\nIntel 64 architecture supports physical address space greater than 64 GBytes; the actual physical address size of \nIA-32 processors is implementation specific. In 64-bit mode, there is architectural support for 64-bit linear address \nspace. However, processors supporting Intel 64 architecture may implement less than 64-bits (see Section \n3.3.7.1). The linear address space is mapped into the processor physical address space through the PAE paging \nmechanism.\n\nFigure 3-3.  Three Memory Management Models\n\nLinear Address\n\nFlat Model\n\nLinear\nAddress\nSpace*\n\nSegment Selector\n\nOffset\n\nSegment Selector\n\nSegmented Model\n\nReal-Address Mode Model\n\nLinear Address\n\nLogical\n\nOffset (effective address)\n\nSpace Divided\nInto Equal\n\nSized Segments\n\nAddress\n\nLogical\nAddress\n\nLinear\nAddress\n\nSpace*\n\nSegments\n\n* The linear address space\ncan be paged when using the \nflat or segmented model.\n3-8 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.3.4 Modes of Operation vs. Memory Model\nWhen writing code for an IA-32 or Intel 64 processor, a programmer needs to know the operating mode the \nprocessor is going to be in when executing the code and the memory model being used. The relationship between \noperating modes and memory models is as follows:\n• Protected mode — When in protected mode, the processor can use any of the memory models described in \n\nthis section. (The real-addressing mode memory model is ordinarily used only when the processor is in the \nvirtual-8086 mode.) The memory model used depends on the design of the operating system or executive. \nWhen multitasking is implemented, individual tasks can use different memory models.\n\n• Real-address mode — When in real-address mode, the processor only supports the real-address mode \nmemory model.\n\n• System management mode — When in SMM, the processor switches to a separate address space, called the \nsystem management RAM (SMRAM). The memory model used to address bytes in this address space is similar \nto the real-address mode model. See Chapter 30, “System Management Mode,” in the Intel® 64 and IA-32 \nArchitectures Software Developer’s Manual, Volume 3C, for more information on the memory model used in \nSMM.\n\n• Compatibility mode — Software that needs to run in compatibility mode should observe the same memory \nmodel as those targeted to run in 32-bit protected mode. The effect of segmentation is the same as it is in 32-\nbit protected mode semantics.\n\n• 64-bit mode — Segmentation is generally (but not completely) disabled, creating a flat 64-bit linear-address \nspace. Specifically, the processor treats the segment base of CS, DS, ES, and SS as zero in 64-bit mode (this \nmakes a linear address equal an effective address). Segmented and real address modes are not available in 64-\nbit mode.\n\n3.3.5 32-Bit and 16-Bit Address and Operand Sizes\nIA-32 processors in protected mode can be configured for 32-bit or 16-bit address and operand sizes. With 32-bit \naddress and operand sizes, the maximum linear address or segment offset is FFFFFFFFH (232-1); operand sizes are \ntypically 8 bits or 32 bits. With 16-bit address and operand sizes, the maximum linear address or segment offset is \nFFFFH (216-1); operand sizes are typically 8 bits or 16 bits. \n\nWhen using 32-bit addressing, a logical address (or far pointer) consists of a 16-bit segment selector and a 32-bit \noffset; when using 16-bit addressing, an address consists of a 16-bit segment selector and a 16-bit offset. \n\nInstruction prefixes allow temporary overrides of the default address and/or operand sizes from within a program.\n\nWhen operating in protected mode, the segment descriptor for the currently executing code segment defines the \ndefault address and operand size. A segment descriptor is a system data structure not normally visible to applica-\ntion code. Assembler directives allow the default addressing and operand size to be chosen for a program. The \nassembler and other tools then set up the segment descriptor for the code segment appropriately.\n\nWhen operating in real-address mode, the default addressing and operand size is 16 bits. An address-size override \ncan be used in real-address mode to enable 32-bit addressing. However, the maximum allowable 32-bit linear \naddress is still 000FFFFFH (220-1).\n\n3.3.6 Extended Physical Addressing in Protected Mode\nBeginning with P6 family processors, the IA-32 architecture supports addressing of up to 64 GBytes (236 bytes) of \nphysical memory. A program or task could not address locations in this address space directly. Instead, it \naddresses individual linear address spaces of up to 4 GBytes that mapped to 64-GByte physical address space \nthrough a virtual memory management mechanism. Using this mechanism, an operating system can enable a \nprogram to switch 4-GByte linear address spaces within 64-GByte physical address space.\n\nThe use of extended physical addressing requires the processor to operate in protected mode and the operating \nsystem to provide a virtual memory management system. See “36-Bit Physical Addressing Using the PAE Paging \nMechanism” in Chapter 3, “Protected-Mode Memory Management,” of the Intel® 64 and IA-32 Architectures Soft-\nware Developer’s Manual, Volume 3A.\nVol. 1 3-9\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.3.7 Address Calculations in 64-Bit Mode\nIn most cases, 64-bit mode uses flat address space for code, data, and stacks. In 64-bit mode (if there is no \naddress-size override), the size of effective address calculations is 64 bits. An effective-address calculation uses a \n64-bit base and index registers and sign-extend displacements to 64 bits.\n\nIn the flat address space of 64-bit mode, linear addresses are equal to effective addresses because the base \naddress is zero. In the event that FS or GS segments are used with a non-zero base, this rule does not hold. In 64-\nbit mode, the effective address components are added and the effective address is truncated (See for example the \ninstruction LEA) before adding the full 64-bit segment base. The base is never truncated, regardless of addressing \nmode in 64-bit mode.\n\nThe instruction pointer is extended to 64 bits to support 64-bit code offsets. The 64-bit instruction pointer is called \nthe RIP. Table 3-1 shows the relationship between RIP, EIP, and IP.\n\nTable 3-1.  Instruction Pointer Sizes\n\nGenerally, displacements and immediates in 64-bit mode are not extended to 64 bits. They are still limited to 32 \nbits and sign-extended during effective-address calculations. In 64-bit mode, however, support is provided for 64-\nbit displacement and immediate forms of the MOV instruction. \n\nAll 16-bit and 32-bit address calculations are zero-extended in IA-32e mode to form 64-bit addresses. Address \ncalculations are first truncated to the effective address size of the current mode (64-bit mode or compatibility \nmode), as overridden by any address-size prefix. The result is then zero-extended to the full 64-bit address width. \nBecause of this, 16-bit and 32-bit applications running in compatibility mode can access only the low 4 GBytes of \nthe 64-bit mode effective addresses. Likewise, a 32-bit address generated in 64-bit mode can access only the low \n4 GBytes of the 64-bit mode effective addresses.\n\n3.3.7.1  Canonical Addressing\nIn 64-bit mode, an address is considered to be in canonical form if address bits 63 through to the most-significant \nimplemented bit by the microarchitecture are set to either all ones or all zeros.\n\nIntel 64 architecture defines a 64-bit linear address. Implementations can support less. The first implementation of \nIA-32 processors with Intel 64 architecture supports a 48-bit linear address. This means a canonical address must \nhave bits 63 through 48 set to zeros or ones (depending on whether bit 47 is a zero or one).\n\nAlthough implementations may not use all 64 bits of the linear address, they should check bits 63 through the \nmost-significant implemented bit to see if the address is in canonical form. If a linear-memory reference is not in \ncanonical form, the implementation should generate an exception. In most cases, a general-protection exception \n(#GP) is generated. However, in the case of explicit or implied stack references, a stack fault (#SS) is generated. \n\nInstructions that have implied stack references, by default, use the SS segment register. These include PUSH/POP-\nrelated instructions and instructions using RSP/RBP as base registers. In these cases, the canonical fault is #SS. \n\nIf an instruction uses base registers RSP/RBP and uses a segment override prefix to specify a non-SS segment, a \ncanonical fault generates a #GP (instead of an #SS). In 64-bit mode, only FS and GS segment-overrides are appli-\ncable in this situation. Other segment override prefixes (CS, DS, ES and SS) are ignored. Note that this also means \nthat an SS segment-override applied to a “non-stack” register reference is ignored. Such a sequence still produces \na #GP for a canonical fault (and not an #SS).\n\n3.4 BASIC PROGRAM EXECUTION REGISTERS\nIA-32 architecture provides 16 basic program execution registers for use in general system and application \nprograming (see Figure 3-4). These registers can be grouped as follows:\n\nBits 63:32 Bits 31:16 Bits 15:0\n\n16-bit instruction pointer Not Modified IP\n\n32-bit instruction pointer Zero Extension EIP\n\n64-bit instruction pointer RIP\n3-10 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n• General-purpose registers. These eight registers are available for storing operands and pointers.\n• Segment registers. These registers hold up to six segment selectors.\n• EFLAGS (program status and control) register. The EFLAGS register report on the status of the program \n\nbeing executed and allows limited (application-program level) control of the processor. \n• EIP (instruction pointer) register. The EIP register contains a 32-bit pointer to the next instruction to be \n\nexecuted. \n\n3.4.1 General-Purpose Registers\nThe 32-bit general-purpose registers EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP are provided for holding the \nfollowing items:\n• Operands for logical and arithmetic operations\n• Operands for address calculations\n• Memory pointers\n\nAlthough all of these registers are available for general storage of operands, results, and pointers, caution should \nbe used when referencing the ESP register. The ESP register holds the stack pointer and as a general rule should \nnot be used for another purpose. \n\nMany instructions assign specific registers to hold operands. For example, string instructions use the contents of \nthe ECX, ESI, and EDI registers as operands. When using a segmented memory model, some instructions assume \nthat pointers in certain registers are relative to specific segments. For instance, some instructions assume that a \npointer in the EBX register points to a memory location in the DS segment. \n\nFigure 3-4.  General System and Application Programming Registers\n\n031\nEAX\nEBX\nECX\n\nEDX\nESI\n\nEDI\nEBP\n\nESP\n\nSegment Registers\n\nCS\n\nDS\nSS\n\nES\nFS\n\nGS\n\n015\n\n031\nEFLAGS\n\nEIP\n31 0\n\nGeneral-Purpose Registers\n\nProgram Status and Control Register\n\nInstruction Pointer\nVol. 1 3-11\n\n\n\nBASIC EXECUTION ENVIRONMENT\nThe special uses of general-purpose registers by instructions are described in Chapter 5, “Instruction Set \nSummary,” in this volume. See also: Chapter 3, Chapter 4 and Chapter 5 of Intel® 64 and IA-32 Architectures Soft-\nware Developer’s Manual, Volumes 2A, 2B & 2C. The following is a summary of special uses:\n• EAX — Accumulator for operands and results data\n• EBX — Pointer to data in the DS segment\n• ECX — Counter for string and loop operations\n• EDX — I/O pointer\n• ESI — Pointer to data in the segment pointed to by the DS register; source pointer for string operations\n• EDI — Pointer to data (or destination) in the segment pointed to by the ES register; destination pointer for \n\nstring operations\n• ESP — Stack pointer (in the SS segment)\n• EBP — Pointer to data on the stack (in the SS segment)\n\nAs shown in Figure 3-5, the lower 16 bits of the general-purpose registers map directly to the register set found in \nthe 8086 and Intel 286 processors and can be referenced with the names AX, BX, CX, DX, BP, SI, DI, and SP. Each \nof the lower two bytes of the EAX, EBX, ECX, and EDX registers can be referenced by the names AH, BH, CH, and \nDH (high bytes) and AL, BL, CL, and DL (low bytes).\n\n3.4.1.1  General-Purpose Registers in 64-Bit Mode\nIn 64-bit mode, there are 16 general purpose registers and the default operand size is 32 bits. However, general-\npurpose registers are able to work with either 32-bit or 64-bit operands. If a 32-bit operand size is specified: EAX, \nEBX, ECX, EDX, EDI, ESI, EBP, ESP, R8D - R15D are available. If a 64-bit operand size is specified: RAX, RBX, RCX, \nRDX, RDI, RSI, RBP, RSP, R8-R15 are available. R8D-R15D/R8-R15 represent eight new general-purpose registers. \nAll of these registers can be accessed at the byte, word, dword, and qword level. REX prefixes are used to generate \n64-bit operand sizes or to reference registers R8-R15.\n\nRegisters only available in 64-bit mode (R8-R15 and XMM8-XMM15) are preserved across transitions from 64-bit \nmode into compatibility mode then back into 64-bit mode. However, values of R8-R15 and XMM8-XMM15 are unde-\nfined after transitions from 64-bit mode through compatibility mode to legacy or real mode and then back through \ncompatibility mode to 64-bit mode.\n\nFigure 3-5.  Alternate General-Purpose Register Names\n\n071531 16 8\n\nAH AL\n\nBH BL\n\nCH CL\n\nDH DL\n\nBP\n\nSI\n\nDI\n\nSP\n\n16-bit\n\nAX\n\nDX\n\nCX\n\nBX\n\n32-bit\n\nEAX\n\nEBX\n\nECX\n\nEDX\n\nEBP\n\nESI\n\nESP\n\nGeneral-Purpose Registers\n\nEDI\n3-12 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nIn 64-bit mode, there are limitations on accessing byte registers. An instruction cannot reference legacy high-\nbytes (for example: AH, BH, CH, DH) and one of the new byte registers at the same time (for example: the low \nbyte of the RAX register). However, instructions may reference legacy low-bytes (for example: AL, BL, CL or DL) \nand new byte registers at the same time (for example: the low byte of the R8 register, or RBP). The architecture \nenforces this limitation by changing high-byte references (AH, BH, CH, DH) to low byte references (BPL, SPL, DIL, \nSIL: the low 8 bits for RBP, RSP, RDI and RSI) for instructions using a REX prefix.\n\nWhen in 64-bit mode, operand size determines the number of valid bits in the destination general-purpose \nregister: \n• 64-bit operands generate a 64-bit result in the destination general-purpose register.\n• 32-bit operands generate a 32-bit result, zero-extended to a 64-bit result in the destination general-purpose \n\nregister.\n• 8-bit and 16-bit operands generate an 8-bit or 16-bit result. The upper 56 bits or 48 bits (respectively) of the \n\ndestination general-purpose register are not modified by the operation. If the result of an 8-bit or 16-bit \noperation is intended for 64-bit address calculation, explicitly sign-extend the register to the full 64-bits. \n\nBecause the upper 32 bits of 64-bit general-purpose registers are undefined in 32-bit modes, the upper 32 bits of \nany general-purpose register are not preserved when switching from 64-bit mode to a 32-bit mode (to protected \nmode or compatibility mode). Software must not depend on these bits to maintain a value after a 64-bit to 32-bit \nmode switch.\n\n3.4.2 Segment Registers\nThe segment registers (CS, DS, SS, ES, FS, and GS) hold 16-bit segment selectors. A segment selector is a special \npointer that identifies a segment in memory. To access a particular segment in memory, the segment selector for \nthat segment must be present in the appropriate segment register.\n\nWhen writing application code, programmers generally create segment selectors with assembler directives and \nsymbols. The assembler and other tools then create the actual segment selector values associated with these \ndirectives and symbols. If writing system code, programmers may need to create segment selectors directly. See \nChapter 3, “Protected-Mode Memory Management,” in the Intel® 64 and IA-32 Architectures Software Developer’s \nManual, Volume 3A.\n\nHow segment registers are used depends on the type of memory management model that the operating system or \nexecutive is using. When using the flat (unsegmented) memory model, segment registers are loaded with segment \nselectors that point to overlapping segments, each of which begins at address 0 of the linear address space (see \nFigure 3-6). These overlapping segments then comprise the linear address space for the program. Typically, two \noverlapping segments are defined: one for code and another for data and stacks. The CS segment register points \nto the code segment and all the other segment registers point to the data and stack segment.\n\nWhen using the segmented memory model, each segment register is ordinarily loaded with a different segment \nselector so that each segment register points to a different segment within the linear address space (see \nFigure 3-7). At any time, a program can thus access up to six segments in the linear address space. To access a \nsegment not pointed to by one of the segment registers, a program must first load the segment selector for the \nsegment to be accessed into a segment register.\n\nTable 3-2.  Addressable General Purpose Registers\nRegister Type Without REX With REX\n\nByte Registers AL, BL, CL, DL, AH, BH, CH, DH AL, BL, CL, DL, DIL, SIL, BPL, SPL, R8B - R15B\n\nWord Registers AX, BX, CX, DX, DI, SI, BP, SP AX, BX, CX, DX, DI, SI, BP, SP, R8W - R15W\n\nDoubleword Registers EAX, EBX, ECX, EDX, EDI, ESI, EBP, ESP EAX, EBX, ECX, EDX, EDI, ESI, EBP, ESP, R8D - R15D\n\nQuadword Registers N.A. RAX, RBX, RCX, RDX, RDI, RSI, RBP, RSP, R8 - R15\nVol. 1 3-13\n\n\n\nBASIC EXECUTION ENVIRONMENT\nEach of the segment registers is associated with one of three types of storage: code, data, or stack. For example, \nthe CS register contains the segment selector for the code segment, where the instructions being executed are \nstored. The processor fetches instructions from the code segment, using a logical address that consists of the \nsegment selector in the CS register and the contents of the EIP register. The EIP register contains the offset within \nthe code segment of the next instruction to be executed. The CS register cannot be loaded explicitly by an applica-\ntion program. Instead, it is loaded implicitly by instructions or internal processor operations that change program \ncontrol (such as procedure calls, interrupt handling, or task switching).\n\nThe DS, ES, FS, and GS registers point to four data segments. The availability of four data segments permits effi-\ncient and secure access to different types of data structures. For example, four separate data segments might be \ncreated: one for the data structures of the current module, another for the data exported from a higher-level \nmodule, a third for a dynamically created data structure, and a fourth for data shared with another program. To \naccess additional data segments, the application program must load segment selectors for these segments into the \nDS, ES, FS, and GS registers, as needed.\n\nThe SS register contains the segment selector for the stack segment, where the procedure stack is stored for the \nprogram, task, or handler currently being executed. All stack operations use the SS register to find the stack \n\nFigure 3-6.  Use of Segment Registers for Flat Memory Model\n\nFigure 3-7.  Use of Segment Registers in Segmented Memory Model\n\nSegment Registers\n\nCS\n\nSS\nDS\n\nES\nFS\nGS\n\nLinear Address\nSpace for Program\n\nThe segment selector in\neach segment register\npoints to an overlapping \n\nOverlapping\nSegments\n\nof up to\n4 GBytes\n\nsegment in the linear\naddress space.\n\nBeginning at\nAddress 0\n\nSegment Registers\n\nCS\nDS\nSS\nES\nFS\nGS\n\nCode\nSegment\n\nData\nSegment\n\nStack\nSegment\n\nData\nSegment\n\nData\nSegment\n\nData\nSegment\n\nAll segments\nare mapped\nto the same\nlinear-address\nspace\n3-14 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nsegment. Unlike the CS register, the SS register can be loaded explicitly, which permits application programs to set \nup multiple stacks and switch among them.\n\nSee Section 3.3, “Memory Organization,” for an overview of how the segment registers are used in real-address \nmode.\n\nThe four segment registers CS, DS, SS, and ES are the same as the segment registers found in the Intel 8086 and \nIntel 286 processors and the FS and GS registers were introduced into the IA-32 Architecture with the Intel386™ \nfamily of processors.\n\n3.4.2.1  Segment Registers in 64-Bit Mode\nIn 64-bit mode: CS, DS, ES, SS are treated as if each segment base is 0, regardless of the value of the associated \nsegment descriptor base. This creates a flat address space for code, data, and stack. FS and GS are exceptions. \nBoth segment registers may be used as additional base registers in linear address calculations (in the addressing \nof local data and certain operating system data structures). \n\nEven though segmentation is generally disabled, segment register loads may cause the processor to perform \nsegment access assists. During these activities, enabled processors will still perform most of the legacy checks on \nloaded values (even if the checks are not applicable in 64-bit mode). Such checks are needed because a segment \nregister loaded in 64-bit mode may be used by an application running in compatibility mode. \n\nLimit checks for CS, DS, ES, SS, FS, and GS are disabled in 64-bit mode.\n\n3.4.3 EFLAGS Register\nThe 32-bit EFLAGS register contains a group of status flags, a control flag, and a group of system flags. Figure 3-8 \ndefines the flags within this register. Following initialization of the processor (either by asserting the RESET pin or \nthe INIT pin), the state of the EFLAGS register is 00000002H. Bits 1, 3, 5, 15, and 22 through 31 of this register \nare reserved. Software should not use or depend on the states of any of these bits.\n\nSome of the flags in the EFLAGS register can be modified directly, using special-purpose instructions (described in \nthe following sections). There are no instructions that allow the whole register to be examined or modified directly. \n\nThe following instructions can be used to move groups of flags to and from the procedure stack or the EAX register: \nLAHF, SAHF, PUSHF, PUSHFD, POPF, and POPFD. After the contents of the EFLAGS register have been transferred to \nthe procedure stack or EAX register, the flags can be examined and modified using the processor’s bit manipulation \ninstructions (BT, BTS, BTR, and BTC).\n\nWhen suspending a task (using the processor’s multitasking facilities), the processor automatically saves the state \nof the EFLAGS register in the task state segment (TSS) for the task being suspended. When binding itself to a new \ntask, the processor loads the EFLAGS register with data from the new task’s TSS.\n\nWhen a call is made to an interrupt or exception handler procedure, the processor automatically saves the state of \nthe EFLAGS registers on the procedure stack. When an interrupt or exception is handled with a task switch, the \nstate of the EFLAGS register is saved in the TSS for the task being suspended.\nVol. 1 3-15\n\n\n\nBASIC EXECUTION ENVIRONMENT\nAs the IA-32 Architecture has evolved, flags have been added to the EFLAGS register, but the function and place-\nment of existing flags have remained the same from one family of the IA-32 processors to the next. As a result, \ncode that accesses or modifies these flags for one family of IA-32 processors works as expected when run on later \nfamilies of processors.\n\n3.4.3.1  Status Flags\nThe status flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, \nsuch as the ADD, SUB, MUL, and DIV instructions. The status flag functions are:\nCF (bit 0) Carry flag — Set if an arithmetic operation generates a carry or a borrow out of the most-\n\nsignificant bit of the result; cleared otherwise. This flag indicates an overflow condition for \nunsigned-integer arithmetic. It is also used in multiple-precision arithmetic.\n\nPF (bit 2) Parity flag — Set if the least-significant byte of the result contains an even number of 1 bits; \ncleared otherwise.\n\nAF (bit 4) Auxiliary Carry flag — Set if an arithmetic operation generates a carry or a borrow out of bit \n3 of the result; cleared otherwise. This flag is used in binary-coded decimal (BCD) arithmetic.\n\nZF (bit 6) Zero flag — Set if the result is zero; cleared otherwise.\nSF (bit 7) Sign flag — Set equal to the most-significant bit of the result, which is the sign bit of a signed \n\ninteger. (0 indicates a positive value and 1 indicates a negative value.)\nOF (bit 11) Overflow flag — Set if the integer result is too large a positive number or too small a negative \n\nnumber (excluding the sign-bit) to fit in the destination operand; cleared otherwise. This flag \nindicates an overflow condition for signed-integer (two’s complement) arithmetic.\n\nOf these status flags, only the CF flag can be modified directly, using the STC, CLC, and CMC instructions. Also the \nbit instructions (BT, BTS, BTR, and BTC) copy a specified bit into the CF flag.\n\nFigure 3-8.  EFLAGS Register\n\n31 2930 28 27 26 25 24 23 22 21 20 19 18 17 16\n\n0 R\nF\n\nI\nD\n\nA\nC\n\nV\nM\n\nX  Virtual-8086 Mode (VM)\nX Resume Flag (RF)\nX Nested Task (NT)\nX  I/O Privilege Level (IOPL)\nS Overflow Flag (OF)\nC Direction Flag (DF)\nX  Interrupt Enable Flag (IF)\n\nX  Alignment Check / Access Control (AC)\n\nX ID Flag (ID)\nX Virtual Interrupt Pending (VIP)\n\n15 1314 12 11 10 9 8 7 6 5 4 3 2 1 0\n\n0 C\nF\n\nA\nF\n\nP\nF 1D\n\nF\nI\nF\n\nT\nF\n\nS\nF\n\nZ\nF\n\nN\nT 000 0 0 0 0 0 0 0 0\n\nV\nI\nP\n\nV\nI\nF\n\nO\nF\n\nI\nO\nP\nL\n\nX  Virtual Interrupt Flag (VIF)\n\nX  Trap Flag (TF)\nS  Sign Flag (SF)\nS  Zero Flag (ZF)\nS  Auxiliary Carry Flag (AF)\nS  Parity Flag (PF)\nS  Carry Flag (CF)\n\nS  Indicates a Status Flag\nC  Indicates a Control Flag\nX  Indicates a System Flag\n\nReserved bit positions. DO NOT USE.\nAlways set to values previously read.\n3-16 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nThe status flags allow a single arithmetic operation to produce results for three different data types: unsigned inte-\ngers, signed integers, and BCD integers. If the result of an arithmetic operation is treated as an unsigned integer, \nthe CF flag indicates an out-of-range condition (carry or a borrow); if treated as a signed integer (two’s comple-\nment number), the OF flag indicates a carry or borrow; and if treated as a BCD digit, the AF flag indicates a carry \nor borrow. The SF flag indicates the sign of a signed integer. The ZF flag indicates either a signed- or an unsigned-\ninteger zero.\n\nWhen performing multiple-precision arithmetic on integers, the CF flag is used in conjunction with the add with \ncarry (ADC) and subtract with borrow (SBB) instructions to propagate a carry or borrow from one computation to \nthe next. \n\nThe condition instructions Jcc (jump on condition code cc), SETcc (byte set on condition code cc), LOOPcc, and \nCMOVcc (conditional move) use one or more of the status flags as condition codes and test them for branch, set-\nbyte, or end-loop conditions.\n\n3.4.3.2  DF Flag\nThe direction flag (DF, located in bit 10 of the EFLAGS register) controls string instructions (MOVS, CMPS, SCAS, \nLODS, and STOS). Setting the DF flag causes the string instructions to auto-decrement (to process strings from \nhigh addresses to low addresses). Clearing the DF flag causes the string instructions to auto-increment \n(process strings from low addresses to high addresses).\n\nThe STD and CLD instructions set and clear the DF flag, respectively.\n\n3.4.3.3  System Flags and IOPL Field\nThe system flags and IOPL field in the EFLAGS register control operating-system or executive operations. They \nshould not be modified by application programs. The functions of the system flags are as follows:\nTF (bit 8) Trap flag — Set to enable single-step mode for debugging; clear to disable single-step mode.\nIF (bit 9) Interrupt enable flag — Controls the response of the processor to maskable interrupt \n\nrequests. Set to respond to maskable interrupts; cleared to inhibit maskable interrupts.\nIOPL (bits 12 and 13)\n\nI/O privilege level field — Indicates the I/O privilege level of the currently running program \nor task. The current privilege level (CPL) of the currently running program or task must be less \nthan or equal to the I/O privilege level to access the I/O address space. The POPF and IRET \ninstructions can modify this field only when operating at a CPL of 0.\n\nNT (bit 14) Nested task flag — Controls the chaining of interrupted and called tasks. Set when the \ncurrent task is linked to the previously executed task; cleared when the current task is not \nlinked to another task.\n\nRF (bit 16) Resume flag — Controls the processor’s response to debug exceptions.\nVM (bit 17) Virtual-8086 mode flag — Set to enable virtual-8086 mode; clear to return to protected \n\nmode without virtual-8086 mode semantics.\nAC (bit 18) Alignment check (or access control) flag — If the AM bit is set in the CR0 register, align-\n\nment checking of user-mode data accesses is enabled if and only if this flag is 1.\nIf the SMAP bit is set in the CR4 register, explicit supervisor-mode data accesses to user-mode \npages are allowed if and only if this bit is 1. See Section 4.6, “Access Rights,” in the Intel® 64 \nand IA-32 Architectures Software Developer’s Manual, Volume 3A.\n\nVIF (bit 19) Virtual interrupt flag — Virtual image of the IF flag. Used in conjunction with the VIP flag. \n(To use this flag and the VIP flag the virtual mode extensions are enabled by setting the VME \nflag in control register CR4.)\n\nVIP (bit 20) Virtual interrupt pending flag — Set to indicate that an interrupt is pending; clear when no \ninterrupt is pending. (Software sets and clears this flag; the processor only reads it.) Used in \nconjunction with the VIF flag.\n\nID (bit 21) Identification flag — The ability of a program to set or clear this flag indicates support for \nthe CPUID instruction.\nVol. 1 3-17\n\n\n\nBASIC EXECUTION ENVIRONMENT\nFor a detailed description of these flags: see Chapter 3, “Protected-Mode Memory Management,” in the Intel® 64 \nand IA-32 Architectures Software Developer’s Manual, Volume 3A. \n\n3.4.3.4  RFLAGS Register in 64-Bit Mode\nIn 64-bit mode, EFLAGS is extended to 64 bits and called RFLAGS. The upper 32 bits of RFLAGS register is \nreserved. The lower 32 bits of RFLAGS is the same as EFLAGS.\n\n3.5 INSTRUCTION POINTER\nThe instruction pointer (EIP) register contains the offset in the current code segment for the next instruction to be \nexecuted. It is advanced from one instruction boundary to the next in straight-line code or it is moved ahead or \nbackwards by a number of instructions when executing JMP, Jcc, CALL, RET, and IRET instructions. \n\nThe EIP register cannot be accessed directly by software; it is controlled implicitly by control-transfer instructions \n(such as JMP, Jcc, CALL, and RET), interrupts, and exceptions. The only way to read the EIP register is to execute a \nCALL instruction and then read the value of the return instruction pointer from the procedure stack. The EIP \nregister can be loaded indirectly by modifying the value of a return instruction pointer on the procedure stack and \nexecuting a return instruction (RET or IRET). See Section 6.2.4.2, “Return Instruction Pointer.”\n\nAll IA-32 processors prefetch instructions. Because of instruction prefetching, an instruction address read from the \nbus during an instruction load does not match the value in the EIP register. Even though different processor gener-\nations use different prefetching mechanisms, the function of the EIP register to direct program flow remains fully \ncompatible with all software written to run on IA-32 processors.\n\n3.5.1 Instruction Pointer in 64-Bit Mode\nIn 64-bit mode, the RIP register becomes the instruction pointer. This register holds the 64-bit offset of the next \ninstruction to be executed. 64-bit mode also supports a technique called RIP-relative addressing. Using this tech-\nnique, the effective address is determined by adding a displacement to the RIP of the next instruction.\n\n3.6 OPERAND-SIZE AND ADDRESS-SIZE ATTRIBUTES\nWhen the processor is executing in protected mode, every code segment has a default operand-size attribute and \naddress-size attribute. These attributes are selected with the D (default size) flag in the segment descriptor for the \ncode segment (see Chapter 3, “Protected-Mode Memory Management,” in the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volume 3A). When the D flag is set, the 32-bit operand-size and address-size attri-\nbutes are selected; when the flag is clear, the 16-bit size attributes are selected. When the processor is executing \nin real-address mode, virtual-8086 mode, or SMM, the default operand-size and address-size attributes are always \n16 bits.\n\nThe operand-size attribute selects the size of operands. When the 16-bit operand-size attribute is in force, oper-\nands can generally be either 8 bits or 16 bits, and when the 32-bit operand-size attribute is in force, operands can \ngenerally be 8 bits or 32 bits.\n\nThe address-size attribute selects the sizes of addresses used to address memory: 16 bits or 32 bits. When the 16-\nbit address-size attribute is in force, segment offsets and displacements are 16 bits. This restriction limits the size \nof a segment to 64 KBytes. When the 32-bit address-size attribute is in force, segment offsets and displacements \nare 32 bits, allowing up to 4 GBytes to be addressed.\n\nThe default operand-size attribute and/or address-size attribute can be overridden for a particular instruction by \nadding an operand-size and/or address-size prefix to an instruction. See Chapter 2, “Instruction Format,” in the \nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A. The effect of this prefix applies only \nto the targeted instruction.\n\nTable 3-4 shows effective operand size and address size (when executing in protected mode or compatibility mode) \ndepending on the settings of the D flag and the operand-size and address-size prefixes.\n3-18 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.6.1 Operand Size and Address Size in 64-Bit Mode\nIn 64-bit mode, the default address size is 64 bits and the default operand size is 32 bits. Defaults can be over-\nridden using prefixes. Address-size and operand-size prefixes allow mixing of 32/64-bit data and 32/64-bit \naddresses on an instruction-by-instruction basis. Table 3-4 shows valid combinations of the 66H instruction prefix \nand the REX.W prefix that may be used to specify operand-size overrides in 64-bit mode. Note that 16-bit \naddresses are not supported in 64-bit mode.\n\nREX prefixes consist of 4-bit fields that form 16 different values. The W-bit field in the REX prefixes is referred to as \nREX.W. If the REX.W field is properly set, the prefix specifies an operand size override to 64 bits. Note that software \ncan still use the operand-size 66H prefix to toggle to a 16-bit operand size. However, setting REX.W takes prece-\ndence over the operand-size prefix (66H) when both are used.\n\nIn the case of SSE/SSE2/SSE3/SSSE3 SIMD instructions: the 66H, F2H, and F3H prefixes are mandatory for \nopcode extensions. In such a case, there is no interaction between a valid REX.W prefix and a 66H opcode exten-\nsion prefix.\n\nSee Chapter 2, “Instruction Format,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 2A.\n\n3.7 OPERAND ADDRESSING\nIA-32 machine-instructions act on zero or more operands. Some operands are specified explicitly and others are \nimplicit. The data for a source operand can be located in:\n• the instruction itself (an immediate operand)\n• a register\n• a memory location\n• an I/O port\n\nTable 3-3.  Effective Operand- and Address-Size Attributes\nD Flag in Code Segment Descriptor 0 0 0 0 1 1 1 1 \n\nOperand-Size Prefix 66H N N Y Y N N Y Y \n\nAddress-Size Prefix 67H N Y N Y N Y N Y \n\nEffective Operand Size 16 16 32 32 32 32 16 16 \n\nEffective Address Size 16 32 16 32 32 16 32 16\n\nNOTES:\nY: Yes - this instruction prefix is present.\nN: No - this instruction prefix is not present.\n\nTable 3-4.  Effective Operand- and Address-Size Attributes in 64-Bit Mode\n\nL Flag in Code Segment Descriptor\n1 1 1 1 1 1 1 1 \n\nREX.W Prefix 0 0 0 0 1 1 1 1 \n\nOperand-Size Prefix 66H N N Y Y N N Y Y \n\nAddress-Size Prefix 67H N Y N Y N Y N Y \n\nEffective Operand Size 32 32 16 16 64 64 64 64\n\nEffective Address Size 64 32 64 32 64 32 64 32\n\nNOTES:\nY: Yes - this instruction prefix is present.\nN: No - this instruction prefix is not present.\nVol. 1 3-19\n\n\n\nBASIC EXECUTION ENVIRONMENT\nWhen an instruction returns data to a destination operand, it can be returned to:\n• a register\n• a memory location\n• an I/O port\n\n3.7.1 Immediate Operands\nSome instructions use data encoded in the instruction itself as a source operand. These operands are called imme-\ndiate operands (or simply immediates). For example, the following ADD instruction adds an immediate value of 14 \nto the contents of the EAX register:\n\nADD EAX, 14\n\nAll arithmetic instructions (except the DIV and IDIV instructions) allow the source operand to be an immediate \nvalue. The maximum value allowed for an immediate operand varies among instructions, but can never be greater \nthan the maximum value of an unsigned doubleword integer (232).\n\n3.7.2 Register Operands\nSource and destination operands can be any of the following registers, depending on the instruction being \nexecuted:\n• 32-bit general-purpose registers (EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP)\n• 16-bit general-purpose registers (AX, BX, CX, DX, SI, DI, SP, or BP)\n• 8-bit general-purpose registers (AH, BH, CH, DH, AL, BL, CL, or DL)\n• segment registers (CS, DS, SS, ES, FS, and GS)\n• EFLAGS register\n• x87 FPU registers (ST0 through ST7, status word, control word, tag word, data operand pointer, and instruction \n\npointer)\n• MMX registers (MM0 through MM7)\n• XMM registers (XMM0 through XMM7) and the MXCSR register\n• control registers (CR0, CR2, CR3, and CR4) and system table pointer registers (GDTR, LDTR, IDTR, and task \n\nregister)\n• debug registers (DR0, DR1, DR2, DR3, DR6, and DR7)\n• MSR registers\n\nSome instructions (such as the DIV and MUL instructions) use quadword operands contained in a pair of 32-bit \nregisters. Register pairs are represented with a colon separating them. For example, in the register pair EDX:EAX, \nEDX contains the high order bits and EAX contains the low order bits of a quadword operand. \n\nSeveral instructions (such as the PUSHFD and POPFD instructions) are provided to load and store the contents of \nthe EFLAGS register or to set or clear individual flags in this register. Other instructions (such as the Jcc instruc-\ntions) use the state of the status flags in the EFLAGS register as condition codes for branching or other decision \nmaking operations.\n\nThe processor contains a selection of system registers that are used to control memory management, interrupt and \nexception handling, task management, processor management, and debugging activities. Some of these system \nregisters are accessible by an application program, the operating system, or the executive through a set of system \ninstructions. When accessing a system register with a system instruction, the register is generally an implied \noperand of the instruction.\n3-20 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.7.2.1  Register Operands in 64-Bit Mode\nRegister operands in 64-bit mode can be any of the following:\n• 64-bit general-purpose registers (RAX, RBX, RCX, RDX, RSI, RDI, RSP, RBP, or R8-R15)\n• 32-bit general-purpose registers (EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP, or R8D-R15D)\n• 16-bit general-purpose registers (AX, BX, CX, DX, SI, DI, SP, BP, or R8W-R15W)\n• 8-bit general-purpose registers: AL, BL, CL, DL, SIL, DIL, SPL, BPL, and R8B-R15B are available using REX \n\nprefixes; AL, BL, CL, DL, AH, BH, CH, DH are available without using REX prefixes.\n• Segment registers (CS, DS, SS, ES, FS, and GS)\n• RFLAGS register\n• x87 FPU registers (ST0 through ST7, status word, control word, tag word, data operand pointer, and instruction \n\npointer)\n• MMX registers (MM0 through MM7)\n• XMM registers (XMM0 through XMM15) and the MXCSR register\n• Control registers (CR0, CR2, CR3, CR4, and CR8) and system table pointer registers (GDTR, LDTR, IDTR, and \n\ntask register)\n• Debug registers (DR0, DR1, DR2, DR3, DR6, and DR7)\n• MSR registers\n• RDX:RAX register pair representing a 128-bit operand\n\n3.7.3 Memory Operands\nSource and destination operands in memory are referenced by means of a segment selector and an offset (see \nFigure 3-9). Segment selectors specify the segment containing the operand. Offsets specify the linear or effective \naddress of the operand. Offsets can be 32 bits (represented by the notation m16:32) or 16 bits (represented by the \nnotation m16:16).\n\n3.7.3.1  Memory Operands in 64-Bit Mode\nIn 64-bit mode, a memory operand can be referenced by a segment selector and an offset. The offset can be 16 \nbits, 32 bits or 64 bits (see Figure 3-10).\n\n3.7.4 Specifying a Segment Selector\nThe segment selector can be specified either implicitly or explicitly. The most common method of specifying a \nsegment selector is to load it in a segment register and then allow the processor to select the register implicitly, \ndepending on the type of operation being performed. The processor automatically chooses a segment according to \nthe rules given in Table 3-5. \n\nFigure 3-9.  Memory Operand Address\n\nFigure 3-10.  Memory Operand Address in 64-Bit Mode\n\nOffset (or Linear Address)\n015\n\nSegment\n310\n\nSelector\n\nOffset (or Linear Address)\n015\n\nSegment\n630\n\nSelector\nVol. 1 3-21\n\n\n\nBASIC EXECUTION ENVIRONMENT\nWhen storing data in memory or loading data from memory, the DS segment default can be overridden to allow \nother segments to be accessed. Within an assembler, the segment override is generally handled with a colon “:” \noperator. For example, the following MOV instruction moves a value from register EAX into the segment pointed to \nby the ES register. The offset into the segment is contained in the EBX register:\n\nMOV ES:[EBX], EAX\n\nAt the machine level, a segment override is specified with a segment-override prefix, which is a byte placed at the \nbeginning of an instruction. The following default segment selections cannot be overridden:\n• Instruction fetches must be made from the code segment.\n• Destination strings in string instructions must be stored in the data segment pointed to by the ES register.\n• Push and pop operations must always reference the SS segment.\n\nSome instructions require a segment selector to be specified explicitly. In these cases, the 16-bit segment selector \ncan be located in a memory location or in a 16-bit register. For example, the following MOV instruction moves a \nsegment selector located in register BX into segment register DS:\n\nMOV DS, BX\n\nSegment selectors can also be specified explicitly as part of a 48-bit far pointer in memory. Here, the first double-\nword in memory contains the offset and the next word contains the segment selector.\n\n3.7.4.1  Segmentation in 64-Bit Mode\nIn IA-32e mode, the effects of segmentation depend on whether the processor is running in compatibility mode or \n64-bit mode. In compatibility mode, segmentation functions just as it does in legacy IA-32 mode, using the 16-bit \nor 32-bit protected mode semantics described above.\n\nIn 64-bit mode, segmentation is generally (but not completely) disabled, creating a flat 64-bit linear-address \nspace. The processor treats the segment base of CS, DS, ES, SS as zero, creating a linear address that is equal to \nthe effective address. The exceptions are the FS and GS segments, whose segment registers (which hold the \nsegment base) can be used as additional base registers in some linear address calculations.\n\n3.7.5 Specifying an Offset\nThe offset part of a memory address can be specified directly as a static value (called a displacement) or through \nan address computation made up of one or more of the following components:\n• Displacement — An 8-, 16-, or 32-bit value.\n• Base — The value in a general-purpose register.\n• Index — The value in a general-purpose register.\n• Scale factor — A value of 2, 4, or 8 that is multiplied by the index value.\n\nTable 3-5.  Default Segment Selection Rules\n\nReference Type Register Used Segment Used Default Selection Rule\n\nInstructions CS Code Segment All instruction fetches.\n\nStack SS Stack Segment All stack pushes and pops.\nAny memory reference which uses the ESP or EBP register as a base \nregister.\n\nLocal Data DS Data Segment All data references, except when relative to stack or string destination.\n\nDestination Strings ES Data Segment \npointed to with the \nES register\n\nDestination of string instructions.\n3-22 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nThe offset which results from adding these components is called an effective address. Each of these components \ncan have either a positive or negative (2s complement) value, with the exception of the scaling factor. Figure 3-11 \nshows all the possible ways that these components can be combined to create an effective address in the selected \nsegment.\n\nThe uses of general-purpose registers as base or index components are restricted in the following manner:\n• The ESP register cannot be used as an index register.\n• When the ESP or EBP register is used as the base, the SS segment is the default segment. In all other cases, \n\nthe DS segment is the default segment.\n\nThe base, index, and displacement components can be used in any combination, and any of these components can \nbe NULL. A scale factor may be used only when an index also is used. Each possible combination is useful for data \nstructures commonly used by programmers in high-level languages and assembly language. \n\nThe following addressing modes suggest uses for common combinations of address components.\n• Displacement ⎯ A displacement alone represents a direct (uncomputed) offset to the operand. Because the \n\ndisplacement is encoded in the instruction, this form of an address is sometimes called an absolute or static \naddress. It is commonly used to access a statically allocated scalar operand.\n\n• Base ⎯ A base alone represents an indirect offset to the operand. Since the value in the base register can \nchange, it can be used for dynamic storage of variables and data structures.\n\n• Base + Displacement ⎯ A base register and a displacement can be used together for two distinct purposes:\n\n— As an index into an array when the element size is not 2, 4, or 8 bytes—The displacement component \nencodes the static offset to the beginning of the array. The base register holds the results of a calculation \nto determine the offset to a specific element within the array.\n\n— To access a field of a record: the base register holds the address of the beginning of the record, while the \ndisplacement is a static offset to the field.\n\nAn important special case of this combination is access to parameters in a procedure activation record. A \nprocedure activation record is the stack frame created when a procedure is entered. Here, the EBP register is \nthe best choice for the base register, because it automatically selects the stack segment. This is a compact \nencoding for this common function.\n\n• (Index ∗ Scale) + Displacement ⎯ This address mode offers an efficient way to index into a static array \nwhen the element size is 2, 4, or 8 bytes. The displacement locates the beginning of the array, the index \nregister holds the subscript of the desired array element, and the processor automatically converts the \nsubscript into an index by applying the scaling factor.\n\n• Base + Index + Displacement ⎯ Using two registers together supports either a two-dimensional array (the \ndisplacement holds the address of the beginning of the array) or one of several instances of an array of records \n(the displacement is an offset to a field within the record).\n\n• Base + (Index ∗ Scale) + Displacement ⎯ Using all the addressing components together allows efficient \nindexing of a two-dimensional array when the elements of the array are 2, 4, or 8 bytes in size.\n\nFigure 3-11.  Offset (or Effective Address) Computation\n\nOffset = Base + (Index * Scale) + Displacement\n\nBase\n\nEAX\nEBX\nECX\nEDX\nESP\nEBP\nESI\nEDI\n\nEAX\nEBX\nECX\nEDX\nEBP\nESI\nEDI\n\n1 None\n\n2\n\n4\n\n8\n\n8-bit\n\n16-bit\n\n32-bit\n\nIndex Scale Displacement\n\n*\n+ +\nVol. 1 3-23\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.7.5.1  Specifying an Offset in 64-Bit Mode\nThe offset part of a memory address in 64-bit mode can be specified directly as a static value or through an address \ncomputation made up of one or more of the following components:\n• Displacement — An 8-bit, 16-bit, or 32-bit value.\n• Base — The value in a 64-bit general-purpose register.\n• Index — The value in a 64-bit general-purpose register.\n• Scale factor — A value of 2, 4, or 8 that is multiplied by the index value.\n\nThe base and index value can be specified in one of sixteen available general-purpose registers in most cases. See \nChapter 2, “Instruction Format,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A.\n\nThe following unique combination of address components is also available.\n• RIP + Displacement ⎯ In 64-bit mode, RIP-relative addressing uses a signed 32-bit displacement to \n\ncalculate the effective address of the next instruction by sign-extend the 32-bit value and add to the 64-bit \nvalue in RIP.\n\n3.7.6 Assembler and Compiler Addressing Modes\nAt the machine-code level, the selected combination of displacement, base register, index register, and scale factor \nis encoded in an instruction. All assemblers permit a programmer to use any of the allowable combinations of these \naddressing components to address operands. High-level language compilers will select an appropriate combination \nof these components based on the language construct a programmer defines.\n\n3.7.7 I/O Port Addressing\nThe processor supports an I/O address space that contains up to 65,536 8-bit I/O ports. Ports that are 16-bit and \n32-bit may also be defined in the I/O address space. An I/O port can be addressed with either an immediate \noperand or a value in the DX register. See Chapter 19, “Input/Output,” for more information about I/O port \naddressing.\n3-24 Vol. 1\n\n\n\nCHAPTER 4\nDATA TYPES\n\nThis chapter introduces data types defined for the Intel 64 and IA-32 architectures. A section at the end of this \nchapter describes the real-number and floating-point concepts used in x87 FPU, SSE, SSE2, SSE3, SSSE3, SSE4 \nand Intel AVX extensions.\n\n4.1 FUNDAMENTAL DATA TYPES\nThe fundamental data types are bytes, words, doublewords, quadwords, and double quadwords (see Figure 4-1). \nA byte is eight bits, a word is 2 bytes (16 bits), a doubleword is 4 bytes (32 bits), a quadword is 8 bytes (64 bits), \nand a double quadword is 16 bytes (128 bits). A subset of the IA-32 architecture instructions operates on these \nfundamental data types without any additional operand typing.\n\nThe quadword data type was introduced into the IA-32 architecture in the Intel486 processor; the double quadword \ndata type was introduced in the Pentium III processor with the SSE extensions.\n\nFigure 4-2 shows the byte order of each of the fundamental data types when referenced as operands in memory. \nThe low byte (bits 0 through 7) of each data type occupies the lowest address in memory and that address is also \nthe address of the operand.\n\nFigure 4-1.  Fundamental Data Types\n\n0\n\n63\n\nDouble \n\n0\n\nWord\n\n31\n\n0\n\nDoubleword\n\n15\n\n0\n\nByte\n\n7\n\n78\n\nLow WordHigh Word\n\nLow DoublewordHigh Doubleword\n\n1516\n\n3132\n\nN+1\n\nN+2\n\nN+4\n\nLow\nByte\n\nHigh\nByte\n\nN\n\nLow QuadwordHigh Quadword\nQuadword\n\nN\n\nN\n\nN\n\nN\n\nN+8\n\n0\n\nQuadword\n\n127 6364\nVol. 1 4-1\n\n\n\nDATA TYPES\n4.1.1 Alignment of Words, Doublewords, Quadwords, and Double Quadwords\nWords, doublewords, and quadwords do not need to be aligned in memory on natural boundaries. The natural \nboundaries for words, double words, and quadwords are even-numbered addresses, addresses evenly divisible by \nfour, and addresses evenly divisible by eight, respectively. However, to improve the performance of programs, data \nstructures (especially stacks) should be aligned on natural boundaries whenever possible. The reason for this is \nthat the processor requires two memory accesses to make an unaligned memory access; aligned accesses require \nonly one memory access. A word or doubleword operand that crosses a 4-byte boundary or a quadword operand \nthat crosses an 8-byte boundary is considered unaligned and requires two separate memory bus cycles for access.\n\nSome instructions that operate on double quadwords require memory operands to be aligned on a natural \nboundary. These instructions generate a general-protection exception (#GP) if an unaligned operand is specified. A \nnatural boundary for a double quadword is any address evenly divisible by 16. Other instructions that operate on \ndouble quadwords permit unaligned access (without generating a general-protection exception). However, addi-\ntional memory bus cycles are required to access unaligned data from memory.\n\n4.2 NUMERIC DATA TYPES\nAlthough bytes, words, and doublewords are fundamental data types, some instructions support additional inter-\npretations of these data types to allow operations to be performed on numeric data types (signed and unsigned \nintegers, and floating-point numbers). Single-precision (32-bit) floating-point and double-precision (64-bit) \nfloating-point data types are supported across all generations of SSE extensions and Intel AVX extensions. Half-\nprecision (16-bit) floating-point data type is supported only with F16C extensions (VCVTPH2PS, VCVTPS2PH). See \nFigure 4-3. \n\nFigure 4-2.  Bytes, Words, Doublewords, Quadwords, and Double Quadwords in Memory\n\nEH\n\nDH7AH\n\nCHFEH\n\nBH06H\n\nAH36H\n\n9H1FH\n\n8HA4H\n\n7H23H\n\n6H0BH\n\n5H\n\n4H\n\n3H74H\n\n2HCBH\n\n1H31H\n\n0H\n\nQuadword at Address 6H\nContains \n\nDoubleword at Address AH\nContains 7AFE0636H\n\nWord at Address BH\nContains FE06H\n\nByte at Address 9H\nContains 1FH\n\nWord at Address 6H\nContains 230BH\n\nWord at Address 1H\nContains CB31H\n\nWord at Address 2H\nContains 74CBH\n\nDouble quadword at Address 0H\n\n45H\n\n67H\n\n12H\n\nContains\n\n12H\n\n7AFE06361FA4230BH\n\n4E127AFE06361FA4230B456774CB3112\n\n4EH FH\n4-2 Vol. 1\n\n\n\nDATA TYPES\n4.2.1 Integers\nThe Intel 64 and IA-32 architectures define two types of integers: unsigned and signed. Unsigned integers are ordi-\nnary binary values ranging from 0 to the maximum positive number that can be encoded in the selected operand \nsize. Signed integers are two’s complement binary values that can be used to represent both positive and negative \ninteger values.\n\nSome integer instructions (such as the ADD, SUB, PADDB, and PSUBB instructions) operate on either unsigned or \nsigned integer operands. Other integer instructions (such as IMUL, MUL, IDIV, DIV, FIADD, and FISUB) operate on \nonly one integer type.\n\nThe following sections describe the encodings and ranges of the two types of integers.\n\n4.2.1.1  Unsigned Integers\nUnsigned integers are unsigned binary numbers contained in a byte, word, doubleword, and quadword. Their \nvalues range from 0 to 255 for an unsigned byte integer, from 0 to 65,535 for an unsigned word integer, from 0 \n\nFigure 4-3.  Numeric Data Types\n\n0\n\n0\n\n022\n\n0\n\nDouble Extended Precision\n\n63 62\n\n0\n\nWord Signed Integer\n\n0\n\nByte Signed Integer\n\n7 6\n\nSign\n\nSign\n\nDoubleword Signed Integer\n\n15 14\n\nSign\n\n31 30\n\nSign\n\nQuadword Signed Integer\n\n0\n\n0\n\nWord Unsigned Integer\n\n0\nByte Unsigned Integer\n\n7\n\nDoubleword Unsigned Integer\n\n15\n\n31\n\nQuadword Unsigned Integer\n\n63\n\n0\n\n0\n\n233031\n\n51526263\n\n64 63 62 79 78\nFloating Point\n\nSingle Precision\nFloating Point\n\nDouble Precision\nFloating Point\n\nSign\n\nInteger Bit\n\nSign\n\nSign\n\n091415\n\nHalf Precision\nFloating Point\n\nSign\nVol. 1 4-3\n\n\n\nDATA TYPES\nto 232 – 1 for an unsigned doubleword integer, and from 0 to 264 – 1 for an unsigned quadword integer. Unsigned \nintegers are sometimes referred to as ordinals.\n\n4.2.1.2  Signed Integers\nSigned integers are signed binary numbers held in a byte, word, doubleword, or quadword. All operations on signed \nintegers assume a two's complement representation. The sign bit is located in bit 7 in a byte integer, bit 15 in a \nword integer, bit 31 in a doubleword integer, and bit 63 in a quadword integer (see the signed integer encodings in \nTable 4-1).\n\nThe sign bit is set for negative integers and cleared for positive integers and zero. Integer values range from –128 \nto +127 for a byte integer, from –32,768 to +32,767 for a word integer, from –231 to +231 – 1 for a doubleword \ninteger, and from –263 to +263 – 1 for a quadword integer.\n\nWhen storing integer values in memory, word integers are stored in 2 consecutive bytes; doubleword integers are \nstored in 4 consecutive bytes; and quadword integers are stored in 8 consecutive bytes.\n\nThe integer indefinite is a special value that is sometimes returned by the x87 FPU when operating on integer \nvalues. For more information, see Section 8.2.1, “Indefinites.”\n\n4.2.2 Floating-Point Data Types\nThe IA-32 architecture defines and operates on three floating-point data types: single-precision floating-point, \ndouble-precision floating-point, and double-extended precision floating-point (see Figure 4-3). The data formats \nfor these data types correspond directly to formats specified in the IEEE Standard 754 for Binary Floating-Point \nArithmetic. \n\nHalf-precision (16-bit) floating-point data type is supported only for conversion operation with single-precision \nfloating data using F16C extensions (VCVTPH2PS, VCVTPS2PH).\n\nTable 4-2 gives the length, precision, and approximate normalized range that can be represented by each of these \ndata types. Denormal values are also supported in each of these types.\n\nTable 4-1.  Signed Integer Encodings\nClass Two’s Complement Encoding\n\nSign\n\nPositive Largest 0 11..11\n\n. .\n\n. .\n\nSmallest 0 00..01\n\nZero 0 00..00\n\nNegative Smallest 1 11..11\n\n. .\n\n. .\n\nLargest 1 00..00\n\nInteger indefinite 1 00..00\n\nSigned Byte Integer:\nSigned Word Integer:\nSigned Doubleword Integer:\nSigned Quadword Integer:\n\n← 7 bits →\n← 15 bits →\n← 31 bits →\n← 63 bits →\n4-4 Vol. 1\n\n\n\nDATA TYPES\nNOTE\nSection 4.8, “Real Numbers and Floating-Point Formats,” gives an overview of the IEEE Standard \n754 floating-point formats and defines the terms integer bit, QNaN, SNaN, and denormal value.\n\nTable 4-3 shows the floating-point encodings for zeros, denormalized finite numbers, normalized finite numbers, \ninfinites, and NaNs for each of the three floating-point data types. It also gives the format for the QNaN floating-\npoint indefinite value. (See Section 4.8.3.7, “QNaN Floating-Point Indefinite,” for a discussion of the use of the \nQNaN floating-point indefinite value.)\n\nFor the single-precision and double-precision formats, only the fraction part of the significand is encoded. The \ninteger is assumed to be 1 for all numbers except 0 and denormalized finite numbers. For the double extended-\nprecision format, the integer is contained in bit 63, and the most-significant fraction bit is bit 62. Here, the integer \nis explicitly set to 1 for normalized numbers, infinities, and NaNs, and to 0 for zero and denormalized numbers.\n\nTable 4-2.  Length, Precision, and Range of Floating-Point Data Types\nData Type Length Precision\n\n(Bits)\nApproximate Normalized Range\n\nBinary Decimal\n\nHalf Precision 16 11 2–14 to 215 3.1 × 10–5 to 6.50 × 104\n\nSingle Precision 32 24 2–126 to 2127 1.18 × 10–38 to 3.40 × 1038\n\nDouble Precision 64 53 2–1022 to 21023 2.23 × 10–308 to 1.79 × 10308\n\nDouble Extended \nPrecision\n\n80 64 2–16382 to 216383 3.37 × 10–4932 to 1.18 × 104932\n\nTable 4-3.  Floating-Point Number and NaN Encodings\n\nClass Sign Biased Exponent\nSignificand\n\nInteger1 Fraction\n\nPositive +∞ 0 11..11 1 00..00\n\n+Normals 0\n.\n.\n0\n\n11..10\n    .\n    .\n\n00..01\n\n1\n.\n.\n1\n\n11..11\n    .\n    .\n\n00..00\n\n+Denormals 0\n.\n.\n0\n\n00..00\n    .\n    .\n\n00..00\n\n0\n.\n.\n0\n\n11.11\n    .\n    .\n\n00..01\n\n+Zero 0 00..00 0 00..00\n\nNegative −Zero 1 00..00 0 00..00\n\n−Denormals 1\n.\n.\n1\n\n00..00\n    .\n    .\n\n00..00\n\n0\n.\n.\n0\n\n00..01\n    .\n    .\n\n11..11\n\n−Normals 1\n.\n.\n1\n\n00..01\n    .\n    .\n\n11..10\n\n1\n.\n.\n1\n\n00..00\n    .\n    .\n\n11..11\n\n-∞ 1 11..11 1 00..00\nVol. 1 4-5\n\n\n\nDATA TYPES\nThe exponent of each floating-point data type is encoded in biased format; see Section 4.8.2.2, “Biased Exponent.” \nThe biasing constant is 15 for the half-precision format, 127 for the single-precision format, 1023 for the double-\nprecision format, and 16,383 for the double extended-precision format.\n\nWhen storing floating-point values in memory, half-precision values are stored in 2 consecutive bytes in memory; \nsingle-precision values are stored in 4 consecutive bytes in memory; double-precision values are stored in 8 \nconsecutive bytes; and double extended-precision values are stored in 10 consecutive bytes.\n\nThe single-precision and double-precision floating-point data types are operated on by x87 FPU, and \nSSE/SSE2/SSE3/SSE4.1 and Intel AVX instructions. The double-extended-precision floating-point format is only \noperated on by the x87 FPU. See Section 11.6.8, “Compatibility of SIMD and x87 FPU Floating-Point Data Types,” \nfor a discussion of the compatibility of single-precision and double-precision floating-point data types between the \nx87 FPU and SSE/SSE2/SSE3 extensions.\n\n4.3 POINTER DATA TYPES\nPointers are addresses of locations in memory. \n\nIn non-64-bit modes, the architecture defines two types of pointers: a near pointer and a far pointer. A near \npointer is a 32-bit (or 16-bit) offset (also called an effective address) within a segment. Near pointers are used \nfor all memory references in a flat memory model or for references in a segmented model where the identity of the \nsegment being accessed is implied. \n\nA far pointer is a logical address, consisting of a 16-bit segment selector and a 32-bit (or 16-bit) offset. Far pointers \nare used for memory references in a segmented memory model where the identity of a segment being accessed \nmust be specified explicitly. Near and far pointers with 32-bit offsets are shown in Figure 4-4.\n\nNaNs SNaN X 11..11 1 0X..XX2\n\nQNaN X 11..11 1 1X..XX\n\nQNaN Floating-\nPoint Indefinite\n\n1 11..11 1 10..00\n\nHalf-Precision\n\nSingle-Precision:\nDouble-Precision:\nDouble Extended-Precision:\n\n← 5Bits →\n← 8 Bits →\n← 11 Bits →\n← 15 Bits →\n\n← 10 Bits →\n← 23 Bits →\n← 52 Bits →\n← 63 Bits →\n\nNOTES:\n1. Integer bit is implied and not stored for single-precision and double-precision formats.\n2. The fraction for SNaN encodings must be non-zero with the most-significant bit 0.\n\nFigure 4-4.  Pointer Data Types\n\nTable 4-3.  Floating-Point Number and NaN Encodings (Contd.)\n\nClass Sign Biased Exponent\nSignificand\n\nInteger1 Fraction\n\n047\n\nFar Pointer or Logical Address\nSegment Selector\n\n32 31\nOffset\n\nNear Pointer\n\n031\nOffset\n4-6 Vol. 1\n\n\n\nDATA TYPES\n4.3.1 Pointer Data Types in 64-Bit Mode\nIn 64-bit mode (a sub-mode of IA-32e mode), a near pointer is 64 bits. This equates to an effective address. Far \npointers in 64-bit mode can be one of three forms: \n• 16-bit segment selector, 16-bit offset if the operand size is 32 bits \n• 16-bit segment selector, 32-bit offset if the operand size is 32 bits \n• 16-bit segment selector, 64-bit offset if the operand size is 64 bits\n\nSee Figure 4-5.\n\n4.4 BIT FIELD DATA TYPE\nA bit field (see Figure 4-6) is a contiguous sequence of bits. It can begin at any bit position of any byte in memory \nand can contain up to 32 bits.\n\nFigure 4-5.  Pointers in 64-Bit Mode\n\nFigure 4-6.  Bit Field Data Type\n\n16-bit Segment Selector 16-bit Offset\n\n016 1531\n\n16-bit Segment Selector 32-bit Offset\n\n032 3147\n\n16-bit Segment Selector 64-bit Offset\n\n064 6379\n\n64-bit Offset\n\n063\n\nNear Pointer\n\nFar Pointer with 64-bit Operand Size\n\nFar Pointer with 32-bit Operand Size\n\nFar Pointer with 32-bit Operand Size\n\nBit Field\n\nField Length\n\nLeast\n\nBit\nSignificant\nVol. 1 4-7\n\n\n\nDATA TYPES\n4.5 STRING DATA TYPES\nStrings are continuous sequences of bits, bytes, words, or doublewords. A bit string can begin at any bit position \nof any byte and can contain up to 232 – 1 bits. A byte string can contain bytes, words, or doublewords and can \nrange from zero to 232 – 1 bytes (4 GBytes).\n\n4.6 PACKED SIMD DATA TYPES\nIntel 64 and IA-32 architectures define and operate on a set of 64-bit and 128-bit packed data type for use in SIMD \noperations. These data types consist of fundamental data types (packed bytes, words, doublewords, and quad-\nwords) and numeric interpretations of fundamental types for use in packed integer and packed floating-point oper-\nations.\n\n4.6.1 64-Bit SIMD Packed Data Types\nThe 64-bit packed SIMD data types were introduced into the IA-32 architecture in the Intel MMX technology. They \nare operated on in MMX registers. The fundamental 64-bit packed data types are packed bytes, packed words, and \npacked doublewords (see Figure 4-7). When performing numeric SIMD operations on these data types, these data \ntypes are interpreted as containing byte, word, or doubleword integer values.\n\n4.6.2 128-Bit Packed SIMD Data Types\nThe 128-bit packed SIMD data types were introduced into the IA-32 architecture in the SSE extensions and used \nwith SSE2, SSE3 and SSSE3 extensions. They are operated on primarily in the 128-bit XMM registers and memory. \nThe fundamental 128-bit packed data types are packed bytes, packed words, packed doublewords, and packed \nquadwords (see Figure 4-8). When performing SIMD operations on these fundamental data types in XMM registers, \nthese data types are interpreted as containing packed or scalar single-precision floating-point or double-precision \nfloating-point values, or as containing packed byte, word, doubleword, or quadword integer values.\n\nFigure 4-7.  64-Bit Packed SIMD Data Types\n\nPacked Words\n\nPacked Bytes\n\nPacked Doublewords\n\n063\n\n063\n\n063\n\nPacked Word Integers\n\nPacked Byte Integers\n\nPacked Doubleword Integers\n\n063\n\n063\n\n063\n\nFundamental 64-Bit Packed SIMD Data Types\n\n64-Bit Packed Integer Data Types\n4-8 Vol. 1\n\n\n\nDATA TYPES\n4.7 BCD AND PACKED BCD INTEGERS\nBinary-coded decimal integers (BCD integers) are unsigned 4-bit integers with valid values ranging from 0 to 9. IA-\n32 architecture defines operations on BCD integers located in one or more general-purpose registers or in one or \nmore x87 FPU registers (see Figure 4-9).\n\nFigure 4-8.  128-Bit Packed SIMD Data Types\n\n0127\n\nPacked Words\n\nPacked Bytes\n\nPacked Doublewords\n\nPacked Word Integers\n\nPacked Byte Integers\n\nPacked Doubleword Integers\n\nFundamental 128-Bit Packed SIMD Data Types\n\n128-Bit Packed Floating-Point and Integer Data Types\n\nPacked Quadwords\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\nPacked Quadword Integers\n\nPacked Single Precision \nFloating Point\n\nPacked Double Precision \nFloating Point\nVol. 1 4-9\n\n\n\nDATA TYPES\nWhen operating on BCD integers in general-purpose registers, the BCD values can be unpacked (one BCD digit per \nbyte) or packed (two BCD digits per byte). The value of an unpacked BCD integer is the binary value of the low half-\nbyte (bits 0 through 3). The high half-byte (bits 4 through 7) can be any value during addition and subtraction, but \nmust be zero during multiplication and division. Packed BCD integers allow two BCD digits to be contained in one \nbyte. Here, the digit in the high half-byte is more significant than the digit in the low half-byte.\n\nWhen operating on BCD integers in x87 FPU data registers, BCD values are packed in an 80-bit format and referred \nto as decimal integers. In this format, the first 9 bytes hold 18 BCD digits, 2 digits per byte. The least-significant \ndigit is contained in the lower half-byte of byte 0 and the most-significant digit is contained in the upper half-byte \nof byte 9. The most significant bit of byte 10 contains the sign bit (0 = positive and 1 = negative; bits 0 through 6 \nof byte 10 are don’t care bits). Negative decimal integers are not stored in two's complement form; they are distin-\nguished from positive decimal integers only by the sign bit. The range of decimal integers that can be encoded in \nthis format is –1018 + 1 to 1018 – 1. \nThe decimal integer format exists in memory only. When a decimal integer is loaded in an x87 FPU data register, it \nis automatically converted to the double-extended-precision floating-point format. All decimal integers are exactly \nrepresentable in double extended-precision format.\n\nTable 4-4 gives the possible encodings of value in the decimal integer data type.\n\nFigure 4-9.  BCD Data Types\n\nTable 4-4.  Packed Decimal Integer Encodings\n\nClass Sign\nMagnitude\n\ndigit digit digit digit ... digit\n\nPositive\n\n Largest 0 0000000 1001 1001 1001 1001 ... 1001\n\n. . .\n\n. . .\n\n Smallest 0 0000000 0000 0000 0000 0000 ... 0001\n\n Zero 0 0000000 0000 0000 0000 0000 ... 0000\n\nNegative\n\n Zero 1 0000000 0000 0000 0000 0000 ... 0000\n\n Smallest 1 0000000 0000 0000 0000 0000 ... 0001\n\n. . .\n\n. . .\n\n Largest 1 0000000 1001 1001 1001 1001 ... 1001\n\nPacked BCD Integers\n\nBCDBCD\n\n0\n\nBCD Integers\n\n7\nBCDX\n\n34\n\n0\n\n80-Bit Packed BCD Decimal Integers\n\n79\nD0\n\n4 Bits = 1 BCD Digit\n\nSign\nD1D2D3D4D5D6D7D8D9D10D11D12D13D14D15D16D17\n\n78 72 71\nX\n\n07 34\n4-10 Vol. 1\n\n\n\nDATA TYPES\nThe packed BCD integer indefinite encoding (FFFFC000000000000000H) is stored by the FBSTP instruction in \nresponse to a masked floating-point invalid-operation exception. Attempting to load this value with the FBLD \ninstruction produces an undefined result.\n\n4.8 REAL NUMBERS AND FLOATING-POINT FORMATS\nThis section describes how real numbers are represented in floating-point format in x87 FPU and \nSSE/SSE2/SSE3/SSE4.1 and Intel AVX floating-point instructions. It also introduces terms such as normalized \nnumbers, denormalized numbers, biased exponents, signed zeros, and NaNs. Readers who are already familiar \nwith floating-point processing techniques and the IEEE Standard 754 for Binary Floating-Point Arithmetic may wish \nto skip this section.\n\n4.8.1 Real Number System\nAs shown in Figure 4-10, the real-number system comprises the continuum of real numbers from minus infinity (−\n∞) to plus infinity (+ ∞).\n\nBecause the size and number of registers that any computer can have is limited, only a subset of the real-number \ncontinuum can be used in real-number (floating-point) calculations. As shown at the bottom of Figure 4-10, the \nsubset of real numbers that the IA-32 architecture supports represents an approximation of the real number \nsystem. The range and precision of this real-number subset is determined by the IEEE Standard 754 floating-point \nformats. \n\n4.8.2 Floating-Point Format\nTo increase the speed and efficiency of real-number computations, computers and microprocessors typically repre-\nsent real numbers in a binary floating-point format. In this format, a real number has three parts: a sign, a signif-\nicand, and an exponent (see Figure 4-11).\n\nThe sign is a binary value that indicates whether the number is positive (0) or negative (1). The significand has \ntwo parts: a 1-bit binary integer (also referred to as the J-bit) and a binary fraction. The integer-bit is often not \nrepresented, but instead is an implied value. The exponent is a binary integer that represents the base-2 power by \nwhich the significand is multiplied.\n\nTable 4-5 shows how the real number 178.125 (in ordinary decimal format) is stored in IEEE Standard 754 floating-\npoint format. The table lists a progression of real number notations that leads to the single-precision, 32-bit \nfloating-point format. In this format, the significand is normalized (see Section 4.8.2.1, “Normalized Numbers”) \nand the exponent is biased (see Section 4.8.2.2, “Biased Exponent”). For the single-precision floating-point \nformat, the biasing constant is +127.\n\nPacked BCD \nInteger \nIndefinite\n\n1 1111111 1111 1111 1100 0000 ... 0000\n\n← 1 byte → ← 9 bytes →\n\nTable 4-4.  Packed Decimal Integer Encodings (Contd.)\n\nClass Sign\nMagnitude\n\ndigit digit digit digit ... digit\nVol. 1 4-11\n\n\n\nDATA TYPES\nFigure 4-10.  Binary Real Number System\n\nFigure 4-11.  Binary Floating-Point Format\n\nTable 4-5.  Real and Floating-Point Number Notation\n\nNotation Value\n\nOrdinary Decimal 178.125\n\nScientific Decimal 1.78125E10 2\n\nScientific Binary 1.0110010001E2111\n\nScientific Binary\n(Biased Exponent)\n\n 1.0110010001E210000110\n\nIEEE Single-Precision Format Sign Biased Exponent Normalized Significand\n\n0 10000110 01100100010000000000000\n\n          1. (Implied)\n\nBinary Real Number System\n\nSubset of binary real numbers that can be represented with\nIEEE single-precision (32-bit) floating-point format\n\n+10\n\n10.0000000000000000000000\n\n1.11111111111111111111111\nPrecision 24 Binary Digits\n\nNumbers within this range\ncannot be represented.\n\nςς ςς\n-100 -10 -1 0 1 10 100\n\nςς ςς\n-100 -10 -1 0 1 10 100\n\nSign\n\nInteger or J-Bit\n\nExponent Significand\n\nFraction\n4-12 Vol. 1\n\n\n\nDATA TYPES\n4.8.2.1  Normalized Numbers\nIn most cases, floating-point numbers are encoded in normalized form. This means that except for zero, the signif-\nicand is always made up of an integer of 1 and the following fraction:\n\n1.fff...ff\n\nFor values less than 1, leading zeros are eliminated. (For each leading zero eliminated, the exponent is decre-\nmented by one.)\n\nRepresenting numbers in normalized form maximizes the number of significant digits that can be accommodated \nin a significand of a given width. To summarize, a normalized real number consists of a normalized significand that \nrepresents a real number between 1 and 2 and an exponent that specifies the number’s binary point.\n\n4.8.2.2  Biased Exponent\nIn the IA-32 architecture, the exponents of floating-point numbers are encoded in a biased form. This means that \na constant is added to the actual exponent so that the biased exponent is always a positive number. The value of \nthe biasing constant depends on the number of bits available for representing exponents in the floating-point \nformat being used. The biasing constant is chosen so that the smallest normalized number can be reciprocated \nwithout overflow.\n\nSee Section 4.2.2, “Floating-Point Data Types,” for a list of the biasing constants that the IA-32 architecture uses \nfor the various sizes of floating-point data-types.\n\n4.8.3 Real Number and Non-number Encodings\nA variety of real numbers and special values can be encoded in the IEEE Standard 754 floating-point format. These \nnumbers and values are generally divided into the following classes:\n• Signed zeros\n• Denormalized finite numbers\n• Normalized finite numbers\n• Signed infinities\n• NaNs\n• Indefinite numbers\n\n(The term NaN stands for “Not a Number.”)\n\nFigure 4-12 shows how the encodings for these numbers and non-numbers fit into the real number continuum. The \nencodings shown here are for the IEEE single-precision floating-point format. The term “S” indicates the sign bit, \n“E” the biased exponent, and “Sig” the significand. The exponent values are given in decimal. The integer bit is \nshown for the significands, even though the integer bit is implied in single-precision floating-point format.\nVol. 1 4-13\n\n\n\nDATA TYPES\nAn IA-32 processor can operate on and/or return any of these values, depending on the type of computation being \nperformed. The following sections describe these number and non-number classes.\n\n4.8.3.1  Signed Zeros\nZero can be represented as a +0 or a −0 depending on the sign bit. Both encodings are equal in value. The sign of \na zero result depends on the operation being performed and the rounding mode being used. Signed zeros have \nbeen provided to aid in implementing interval arithmetic. The sign of a zero may indicate the direction from which \nunderflow occurred, or it may indicate the sign of an ∞ that has been reciprocated.\n\n4.8.3.2  Normalized and Denormalized Finite Numbers\nNon-zero, finite numbers are divided into two classes: normalized and denormalized. The normalized finite \nnumbers comprise all the non-zero finite values that can be encoded in a normalized real number format between \nzero and ∞. In the single-precision floating-point format shown in Figure 4-12, this group of numbers includes all \nthe numbers with biased exponents ranging from 1 to 25410 (unbiased, the exponent range is from −12610 to \n+12710).\n\nWhen floating-point numbers become very close to zero, the normalized-number format can no longer be used to \nrepresent the numbers. This is because the range of the exponent is not large enough to compensate for shifting \nthe binary point to the right to eliminate leading zeros.\n\nWhen the biased exponent is zero, smaller numbers can only be represented by making the integer bit (and \nperhaps other leading bits) of the significand zero. The numbers in this range are called denormalized numbers. \nThe use of leading zeros with denormalized numbers allows smaller numbers to be represented. However, this \ndenormalization may cause a loss of precision (the number of significant bits is reduced by the leading zeros).\n\nWhen performing normalized floating-point computations, an IA-32 processor normally operates on normalized \nnumbers and produces normalized numbers as results. Denormalized numbers represent an underflow condition. \nThe exact conditions are specified in Section 4.9.1.5, “Numeric Underflow Exception (#U).”\n\nA denormalized number is computed through a technique called gradual underflow. Table 4-6 gives an example of \ngradual underflow in the denormalization process. Here the single-precision format is being used, so the minimum \nexponent (unbiased) is −12610. The true result in this example requires an exponent of −12910 in order to have a \n\nFigure 4-12.  Real Numbers and NaNs\n\n1 0\nS E Sig1\n\n− 0\n\n1 0 − Denormalized\nFinite\n\nNaN\n\n1 1...254 − Normalized\nFinite\n\n1 255 − ∞\n\n255 SNaN\n\n255 QNaN\n\nNOTES:\n\n3. Sign bit ignored.\n2. Fraction must be non-zero.\n\n0 0\nS E Sig1\n\n0 0\n\nNaN\n\n0 1...254\n\n0 255\n\nX3 255 1.0XX...2\n\n255 1.1XX...\n\n+ 0\n\n+Denormalized\nFinite\n\n+Normalized\nFinite\n\n+ ∞\n\nSNaN\n\nQNaN X3\n\nX3\n\nX3\n\nReal Number and NaN Encodings For 32-Bit Floating-Point Format\n\n− Denormalized Finite\n− Normalized Finite − 0− ∞ + ∞\n\n+ Denormalized Finite\n+ Normalized Finite+ 0\n\n0.XXX...2\n\n0.000...\n\n1.000...\n\n1.XXX...\n\n1.000...\n\n0.000...\n\n0.XXX...2\n\n1.XXX...\n\n1.0XX...2\n\n1.1XX...\n\n1. Integer bit of fraction implied for\nsingle-precision floating-point format.\n4-14 Vol. 1\n\n\n\nDATA TYPES\nnormalized number.   Since  −12910 is beyond the allowable exponent range, the result is denormalized by inserting \nleading zeros until the minimum exponent of −12610 is reached.\n\nIn the extreme case, all the significant bits are shifted out to the right by leading zeros, creating a zero result. \n\nThe Intel 64 and IA-32 architectures deal with denormal values in the following ways:\n• It avoids creating denormals by normalizing numbers whenever possible.\n• It provides the floating-point underflow exception to permit programmers to detect cases when denormals are \n\ncreated.\n• It provides the floating-point denormal-operand exception to permit procedures or programs to detect when \n\ndenormals are being used as source operands for computations.\n\n4.8.3.3  Signed Infinities\nThe two infinities, + ∞ and − ∞, represent the maximum positive and negative real numbers, respectively, that can \nbe represented in the floating-point format. Infinity is always represented by a significand of 1.00...00 (the integer \nbit may be implied) and the maximum biased exponent allowed in the specified format (for example, 25510 for the \nsingle-precision format).\n\nThe signs of infinities are observed, and comparisons are possible. Infinities are always interpreted in the affine \nsense; that is, –∞ is less than any finite number and +∞ is greater than any finite number. Arithmetic on infinities \nis always exact. Exceptions are generated only when the use of an infinity as a source operand constitutes an \ninvalid operation.\n\nWhereas denormalized numbers may represent an underflow condition, the two ∞ numbers may represent the \nresult of an overflow condition. Here, the normalized result of a computation has a biased exponent greater than \nthe largest allowable exponent for the selected result format.\n\n4.8.3.4  NaNs\nSince NaNs are non-numbers, they are not part of the real number line. In Figure 4-12, the encoding space for \nNaNs in the floating-point formats is shown above the ends of the real number line. This space includes any value \nwith the maximum allowable biased exponent and a non-zero fraction (the sign bit is ignored for NaNs).\n\nThe IA-32 architecture defines two classes of NaNs: quiet NaNs (QNaNs) and signaling NaNs (SNaNs). A QNaN is a \nNaN with the most significant fraction bit set; an SNaN is a NaN with the most significant fraction bit clear. QNaNs \nare allowed to propagate through most arithmetic operations without signaling an exception. SNaNs generally \nsignal a floating-point invalid-operation exception whenever they appear as operands in arithmetic operations.\n\nSNaNs are typically used to trap or invoke an exception handler. They must be inserted by software; that is, the \nprocessor never generates an SNaN as a result of a floating-point operation.\n\nTable 4-6.  Denormalization Process\n\nOperation Sign Exponent* Significand\n\nTrue Result 0 −129 1.01011100000...00\n\nDenormalize 0 −128 0.10101110000...00\n\nDenormalize 0 −127 0.01010111000...00\n\nDenormalize 0 −126 0.00101011100...00\n\nDenormal Result 0 −126 0.00101011100...00\n\n* Expressed as an unbiased, decimal number.\nVol. 1 4-15\n\n\n\nDATA TYPES\n4.8.3.5  Operating on SNaNs and QNaNs\nWhen a floating-point operation is performed on an SNaN and/or a QNaN, the result of the operation is either a \nQNaN delivered to the destination operand or the generation of a floating-point invalid operation exception, \ndepending on the following rules:\n• If one of the source operands is an SNaN and the floating-point invalid-operation exception is not masked (see \n\nSection 4.9.1.1, “Invalid Operation Exception (#I)”), then a floating-point invalid-operation exception is \nsignaled and no result is stored in the destination operand. If one of the source operands is a QNaN and the \nfloating-point invalid-operation exception is not masked and the operation is one that generates an invalid-\noperation exception for QNaN operands as described in Section 8.5.1.2, “Invalid Arithmetic Operand Exception \n(#IA),” or Section 11.5.2.1, “Invalid Operation Exception (#I)”, then a floating-point invalid-operation \nexception is signaled and no result is stored in the destination operand.\n\n• If either or both of the source operands are NaNs and floating-point invalid-operation exception is masked, the \nresult is as shown in Table 4-7. When an SNaN is converted to a QNaN, the conversion is handled by setting the \nmost-significant fraction bit of the SNaN to 1. Also, when one of the source operands is an SNaN, or when it is \na QNaN and the operation is one that generates an invalid-operation exception for QNaN operands as described \nin Section 8.5.1.2, “Invalid Arithmetic Operand Exception (#IA),” or Section 11.5.2.1, “Invalid Operation \nException (#I)”, then the floating-point invalid-operation exception flag is set. Note that for some combinations \nof source operands, the result is different for x87 FPU operations and for SSE/SSE2/SSE3/SSE4.1 operations. \nIntel AVX follows the same behavior as SSE/SSE2/SSE3/SSE4.1 in this respect.\n\n• When neither of the source operands is a NaN, but the operation generates a floating-point invalid-operation \nexception (see Tables 8-10 and 11-1), the result is commonly a QNaN FP Indefinite (Section 4.8.3.7).\n\nAny exceptions to the behavior described in Table 4-7 are described in Section 8.5.1.2, “Invalid Arithmetic Operand \nException (#IA),” and Section 11.5.2.1, “Invalid Operation Exception (#I).”\n\n4.8.3.6  Using SNaNs and QNaNs in Applications\nExcept for the rules given at the beginning of Section 4.8.3.4, “NaNs,” for encoding SNaNs and QNaNs, software is \nfree to use the bits in the significand of a NaN for any purpose. Both SNaNs and QNaNs can be encoded to carry and \nstore data, such as diagnostic information.\n\nTable 4-7.  Rules for Handling NaNs \n\nSource Operands Result1\n\nSNaN and QNaN x87 FPU — QNaN source operand.\n\nSSE/SSE2/SSE3/SSE4.1/AVX — First source operand (if this operand is an \nSNaN, it is converted to a QNaN)\n\nTwo SNaNs x87 FPU—SNaN source operand with the larger significand, converted into a \nQNaN\n\nSSE/SSE2/SSE3/SSE4.1/AVX — First source operand converted to a QNaN\n\nTwo QNaNs x87 FPU — QNaN source operand with the larger\nsignificand\n\nSSE/SSE2/SSE3/SSE4.1/AVX — First source operand\n\nSNaN and a floating-point value SNaN source operand, converted into a QNaN\n\nQNaN and a floating-point value QNaN source operand\n\nSNaN (for instructions that take only one operand) SNaN source operand, converted into a QNaN\n\nQNaN (for instructions that take only one operand) QNaN source operand\n\nNOTE:\n1. For SSE/SSE2/SSE3/SSE4.1 instructions, the first operand is generally a source operand that becomes the destination operand. For \n\nAVX instructions, the first source operand is usually the 2nd operand in a non-destructive source syntax. Within the Result column, \nthe x87 FPU notation also applies to the FISTTP instruction in SSE3; the SSE3 notation applies to the SIMD floating-point instruc-\ntions.\n4-16 Vol. 1\n\n\n\nDATA TYPES\nBy unmasking the invalid operation exception, the programmer can use signaling NaNs to trap to the exception \nhandler. The generality of this approach and the large number of NaN values that are available provide the sophis-\nticated programmer with a tool that can be applied to a variety of special situations.\n\nFor example, a compiler can use signaling NaNs as references to uninitialized (real) array elements. The compiler \ncan preinitialize each array element with a signaling NaN whose significand contains the index (relative position) of \nthe element. Then, if an application program attempts to access an element that it has not initialized, it can use the \nNaN placed there by the compiler. If the invalid operation exception is unmasked, an interrupt will occur, and the \nexception handler will be invoked. The exception handler can determine which element has been accessed, since \nthe operand address field of the exception pointer will point to the NaN, and the NaN will contain the index number \nof the array element.\n\nQuiet NaNs are often used to speed up debugging. In its early testing phase, a program often contains multiple \nerrors. An exception handler can be written to save diagnostic information in memory whenever it is invoked. After \nstoring the diagnostic data, it can supply a quiet NaN as the result of the erroneous instruction, and that NaN can \npoint to its associated diagnostic area in memory. The program will then continue, creating a different NaN for each \nerror. When the program ends, the NaN results can be used to access the diagnostic data saved at the time the \nerrors occurred. Many errors can thus be diagnosed and corrected in one test run.\n\nIn embedded applications that use computed results in further computations, an undetected QNaN can invalidate \nall subsequent results. Such applications should therefore periodically check for QNaNs and provide a recovery \nmechanism to be used if a QNaN result is detected. \n\n4.8.3.7  QNaN Floating-Point Indefinite\nFor the floating-point data type encodings (single-precision, double-precision, and double-extended-precision), \none unique encoding (a QNaN) is reserved for representing the special value QNaN floating-point indefinite. The \nx87 FPU and the SSE/SSE2/SSE3/SSE4.1/AVX extensions return these indefinite values as responses to some \nmasked floating-point exceptions. Table 4-3 shows the encoding used for the QNaN floating-point indefinite.\n\n4.8.3.8  Half-Precision Floating-Point Operation\nHalf-precision floating-point values are not used by the processor directly for arithmetic operations. Two instruc-\ntions, VCVTPH2PS, VCVTPS2PH, provide conversion only between half-precision and single-precision floating-point \nvalues.\n\nThe SIMD floating-point exception behavior of VCVTPH2PS and VCVTPS2PH are described in Section 14.4.1.\n\n4.8.4 Rounding\nWhen performing floating-point operations, the processor produces an infinitely precise floating-point result in the \ndestination format (single-precision, double-precision, or double extended-precision floating-point) whenever \npossible. However, because only a subset of the numbers in the real number continuum can be represented in IEEE \nStandard 754 floating-point formats, it is often the case that an infinitely precise result cannot be encoded exactly \nin the format of the destination operand.\n\nFor example, the following value (a) has a 24-bit fraction. The least-significant bit of this fraction (the underlined \nbit) cannot be encoded exactly in the single-precision format (which has only a 23-bit fraction):\n\n(a) 1.0001 0000 1000 0011 1001 0111E2 101\n\nTo round this result (a), the processor first selects two representable fractions b and c that most closely bracket a \nin value (b < a < c).\n\n(b) 1.0001 0000 1000 0011 1001 011E2 101\n\n(c) 1.0001 0000 1000 0011 1001 100E2 101\n\nThe processor then sets the result to b or to c according to the selected rounding mode. Rounding introduces an \nerror in a result that is less than one unit in the last place (the least significant bit position of the floating-point \nvalue) to which the result is rounded.\nVol. 1 4-17\n\n\n\nDATA TYPES\nThe IEEE Standard 754 defines four rounding modes (see Table 4-8): round to nearest, round up, round down, and \nround toward zero. The default rounding mode (for the Intel 64 and IA-32 architectures) is round to nearest. This \nmode provides the most accurate and statistically unbiased estimate of the true result and is suitable for most \napplications. \n\nThe round up and round down modes are termed directed rounding and can be used to implement interval arith-\nmetic. Interval arithmetic is used to determine upper and lower bounds for the true result of a multistep computa-\ntion, when the intermediate results of the computation are subject to rounding. \n\nThe round toward zero mode (sometimes called the “chop” mode) is commonly used when performing integer \narithmetic with the x87 FPU.\n\nThe rounded result is called the inexact result. When the processor produces an inexact result, the floating-point \nprecision (inexact) flag (PE) is set (see Section 4.9.1.6, “Inexact-Result (Precision) Exception (#P)”).\n\nThe rounding modes have no effect on comparison operations, operations that produce exact results, or operations \nthat produce NaN results.\n\n4.8.4.1  Rounding Control (RC) Fields\nIn the Intel 64 and IA-32 architectures, the rounding mode is controlled by a 2-bit rounding-control (RC) field \n(Table 4-8 shows the encoding of this field). The RC field is implemented in two different locations: \n• x87 FPU control register (bits 10 and 11)\n• The MXCSR register (bits 13 and 14)\n\nAlthough these two RC fields perform the same function, they control rounding for different execution environ-\nments within the processor. The RC field in the x87 FPU control register controls rounding for computations \nperformed with the x87 FPU instructions; the RC field in the MXCSR register controls rounding for SIMD floating-\npoint computations performed with the SSE/SSE2 instructions.\n\n4.8.4.2  Truncation with SSE and SSE2 Conversion Instructions\nThe following SSE/SSE2 instructions automatically truncate the results of conversions from floating-point values to \nintegers when the result it inexact: CVTTPD2DQ, CVTTPS2DQ, CVTTPD2PI, CVTTPS2PI, CVTTSD2SI, CVTTSS2SI. \nHere, truncation means the round toward zero mode described in Table 4-8.\n\n4.9 OVERVIEW OF FLOATING-POINT EXCEPTIONS\nThe following section provides an overview of floating-point exceptions and their handling in the IA-32 architecture. \nFor information specific to the x87 FPU and to the SSE/SSE2/SSE3/SSE4.1 extensions, refer to the following \nsections:\n• Section 8.4, “x87 FPU Floating-Point Exception Handling”\n\nTable 4-8.  Rounding Modes and Encoding of Rounding Control (RC) Field\n\nRounding Mode RC Field \nSetting\n\nDescription\n\nRound to \nnearest (even)\n\n00B Rounded result is the closest to the infinitely precise result. If two values are equally close, the \nresult is the even value (that is, the one with the least-significant bit of zero). Default\n\nRound down \n(toward −∞)\n\n01B Rounded result is closest to but no greater than the infinitely precise result.\n\nRound up \n(toward +∞)\n\n10B Rounded result is closest to but no less than the infinitely precise result.\n\nRound toward \nzero (Truncate)\n\n11B Rounded result is closest to but no greater in absolute value than the infinitely precise result.\n4-18 Vol. 1\n\n\n\nDATA TYPES\n• Section 11.5, “SSE, SSE2, and SSE3 Exceptions”\n\nWhen operating on floating-point operands, the IA-32 architecture recognizes and detects six classes of exception \nconditions:\n• Invalid operation (#I)\n• Divide-by-zero (#Z)\n• Denormalized operand (#D)\n• Numeric overflow (#O)\n• Numeric underflow (#U)\n• Inexact result (precision) (#P)\n\nThe nomenclature of “#” symbol followed by one or two letters (for example, #P) is used in this manual to indicate \nexception conditions. It is merely a short-hand form and is not related to assembler mnemonics.\n\nNOTE\nAll of the exceptions listed above except the denormal-operand exception (#D) are defined in IEEE \nStandard 754.\n\nThe invalid-operation, divide-by-zero and denormal-operand exceptions are pre-computation exceptions (that is, \nthey are detected before any arithmetic operation occurs). The numeric-underflow, numeric-overflow and precision \nexceptions are post-computation exceptions.\n\nEach of the six exception classes has a corresponding flag bit (IE, ZE, OE, UE, DE, or PE) and mask bit (IM, ZM, OM, \nUM, DM, or PM). When one or more floating-point exception conditions are detected, the processor sets the appro-\npriate flag bits, then takes one of two possible courses of action, depending on the settings of the corresponding \nmask bits:\n• Mask bit set. Handles the exception automatically, producing a predefined (and often times usable) result, \n\nwhile allowing program execution to continue undisturbed.\n• Mask bit clear. Invokes a software exception handler to handle the exception.\n\nThe masked (default) responses to exceptions have been chosen to deliver a reasonable result for each exception \ncondition and are generally satisfactory for most floating-point applications. By masking or unmasking specific \nfloating-point exceptions, programmers can delegate responsibility for most exceptions to the processor and \nreserve the most severe exception conditions for software exception handlers. \n\nBecause the exception flags are “sticky,” they provide a cumulative record of the exceptions that have occurred \nsince they were last cleared. A programmer can thus mask all exceptions, run a calculation, and then inspect the \nexception flags to see if any exceptions were detected during the calculation.\n\nIn the IA-32 architecture, floating-point exception flag and mask bits are implemented in two different locations: \n• x87 FPU status word and control word. The flag bits are located at bits 0 through 5 of the x87 FPU status word \n\nand the mask bits are located at bits 0 through 5 of the x87 FPU control word (see Figures 8-4 and 8-6).\n• MXCSR register. The flag bits are located at bits 0 through 5 of the MXCSR register and the mask bits are \n\nlocated at bits 7 through 12 of the register (see Figure 10-3).\n\nAlthough these two sets of flag and mask bits perform the same function, they report on and control exceptions for \ndifferent execution environments within the processor. The flag and mask bits in the x87 FPU status and control \nwords control exception reporting and masking for computations performed with the x87 FPU instructions; the \ncompanion bits in the MXCSR register control exception reporting and masking for SIMD floating-point computa-\ntions performed with the SSE/SSE2/SSE3 instructions.\n\nNote that when exceptions are masked, the processor may detect multiple exceptions in a single instruction, \nbecause it continues executing the instruction after performing its masked response. For example, the processor \ncan detect a denormalized operand, perform its masked response to this exception, and then detect numeric \nunderflow.\n\nSee Section 4.9.2, “Floating-Point Exception Priority,” for a description of the rules for exception precedence when \nmore than one floating-point exception condition is detected for an instruction.\nVol. 1 4-19\n\n\n\nDATA TYPES\n4.9.1 Floating-Point Exception Conditions\nThe following sections describe the various conditions that cause a floating-point exception to be generated and the \nmasked response of the processor when these conditions are detected. The Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volumes 3A & 3B, list the floating-point exceptions that can be signaled for each \nfloating-point instruction.\n\n4.9.1.1  Invalid Operation Exception (#I)\nThe processor reports an invalid operation exception in response to one or more invalid arithmetic operands. If the \ninvalid operation exception is masked, the processor sets the IE flag and returns an indefinite value or a QNaN. This \nvalue overwrites the destination register specified by the instruction. If the invalid operation exception is not \nmasked, the IE flag is set, a software exception handler is invoked, and the operands remain unaltered.\n\nSee Section 4.8.3.6, “Using SNaNs and QNaNs in Applications,” for information about the result returned when an \nexception is caused by an SNaN.\n\nThe processor can detect a variety of invalid arithmetic operations that can be coded in a program. These opera-\ntions generally indicate a programming error, such as dividing ∞ by ∞ . See the following sections for information \nregarding the invalid-operation exception when detected while executing x87 FPU or SSE/SSE2/SSE3/SSE4.1 or \nAVX instructions:\n• x87 FPU; Section 8.5.1, “Invalid Operation Exception”.\n• SIMD floating-point exceptions; Section 11.5.2.1, “Invalid Operation Exception (#I)”.\n\n4.9.1.2  Denormal Operand Exception (#D)\nThe processor reports the denormal-operand exception if an arithmetic instruction attempts to operate on a \ndenormal operand (see Section 4.8.3.2, “Normalized and Denormalized Finite Numbers”). When the exception is \nmasked, the processor sets the DE flag and proceeds with the instruction. Operating on denormal numbers will \nproduce results at least as good as, and often better than, what can be obtained when denormal numbers are \nflushed to zero. Programmers can mask this exception so that a computation may proceed, then analyze any loss \nof accuracy when the final result is delivered.\n\nWhen a denormal-operand exception is not masked, the DE flag is set, a software exception handler is invoked, and \nthe operands remain unaltered. When denormal operands have reduced significance due to loss of low-order bits, \nit may be advisable to not operate on them. Precluding denormal operands from computations can be accom-\nplished by an exception handler that responds to unmasked denormal-operand exceptions.\n\nSee the following sections for information regarding the denormal-operand exception when detected while \nexecuting x87 FPU or SSE/SSE2/SSE3 instructions:\n• x87 FPU; Section 8.5.2, “Denormal Operand Exception (#D)”.\n• SIMD floating-point exceptions; Section 11.5.2.2, “Denormal-Operand Exception (#D)”.\n\n4.9.1.3  Divide-By-Zero Exception (#Z)\nThe processor reports the floating-point divide-by-zero exception whenever an instruction attempts to divide a \nfinite non-zero operand by 0. The masked response for the divide-by-zero exception is to set the ZE flag and return \nan infinity signed with the exclusive OR of the sign of the operands. If the divide-by-zero exception is not masked, \nthe ZE flag is set, a software exception handler is invoked, and the operands remain unaltered.\n\nSee the following sections for information regarding the divide-by-zero exception when detected while executing \nx87 FPU or SSE/SSE2 instructions:\n• x87 FPU; Section 8.5.3, “Divide-By-Zero Exception (#Z)”.\n• SIMD floating-point exceptions; Section 11.5.2.3, “Divide-By-Zero Exception (#Z)”.\n4-20 Vol. 1\n\n\n\nDATA TYPES\n4.9.1.4  Numeric Overflow Exception (#O)\nThe processor reports a floating-point numeric overflow exception whenever the rounded result of an instruction \nexceeds the largest allowable finite value that will fit into the destination operand. Table 4-9 shows the threshold \nrange for numeric overflow for each of the floating-point formats; overflow occurs when a rounded result falls at or \noutside this threshold range.\n\nWhen a numeric-overflow exception occurs and the exception is masked, the processor sets the OE flag and \nreturns one of the values shown in Table 4-10, according to the current rounding mode. See Section 4.8.4, \n“Rounding.”\n\nWhen numeric overflow occurs and the numeric-overflow exception is not masked, the OE flag is set, a software \nexception handler is invoked, and the source and destination operands either remain unchanged or a biased result \nis stored in the destination operand (depending whether the overflow exception was generated during an \nSSE/SSE2/SSE3 floating-point operation or an x87 FPU operation).\n\nSee the following sections for information regarding the numeric overflow exception when detected while executing \nx87 FPU instructions or while executing SSE/SSE2/SSE3 instructions:\n• x87 FPU; Section 8.5.4, “Numeric Overflow Exception (#O)”\n• SIMD floating-point exceptions; Section 11.5.2.4, “Numeric Overflow Exception (#O)”\n\n4.9.1.5  Numeric Underflow Exception (#U)\nThe processor detects a potential floating-point numeric underflow condition whenever the result of rounding with \nunbounded exponent (taking into account precision control for x87) is non-zero and tiny; that is, non-zero and less \nthan the smallest possible normalized, finite value that will fit into the destination operand. Table 4-11 shows the \nthreshold range for numeric underflow for each of the floating-point formats (assuming normalized results); \nunderflow occurs when a rounded result falls strictly within the threshold range. The ability to detect and handle \nunderflow is provided to prevent a very small result from propagating through a computation and causing another \nexception (such as overflow during division) to be generated at a later time. Results which trigger underflow are \nalso potentially less accurate.\n\nTable 4-9.  Numeric Overflow Thresholds\n\nFloating-Point Format Overflow Thresholds\n\nSingle Precision | x | ≥ 1.0 ∗ 2128\n\nDouble Precision | x | ≥ 1.0 ∗ 21024\n\nDouble Extended Precision | x | ≥ 1.0 ∗ 216384\n\nTable 4-10.  Masked Responses to Numeric Overflow\n\nRounding Mode Sign of True Result Result\n\nTo nearest + +∞\n\n– –∞\n\nToward –∞ + Largest finite positive number\n\n– –∞\n\nToward +∞ + +∞\n\n– Largest finite negative number\n\nToward zero + Largest finite positive number\n\n– Largest finite negative number\nVol. 1 4-21\n\n\n\nDATA TYPES\nHow the processor handles an underflow condition, depends on two related conditions:\n• creation of a tiny, non-zero result\n• creation of an inexact result; that is, a result that cannot be represented exactly in the destination format\n\nWhich of these events causes an underflow exception to be reported and how the processor responds to the excep-\ntion condition depends on whether the underflow exception is masked:\n• Underflow exception masked — The underflow exception is reported (the UE flag is set) only when the result \n\nis both tiny and inexact. The processor returns a correctly signed result whose magnitude is less than or equal \nto the smallest positive normal floating-point number to the destination operand, regardless of inexactness.\n\n• Underflow exception not masked — The underflow exception is reported when the result is non-zero tiny, \nregardless of inexactness. The processor leaves the source and destination operands unaltered or stores a \nbiased result in the destination operand (depending whether the underflow exception was generated during an \nSSE/SSE2/SSE3 floating-point operation or an x87 FPU operation) and invokes a software exception handler.\n\nSee the following sections for information regarding the numeric underflow exception when detected while \nexecuting x87 FPU instructions or while executing SSE/SSE2/SSE3 instructions:\n• x87 FPU; Section 8.5.5, “Numeric Underflow Exception (#U)”\n• SIMD floating-point exceptions; Section 11.5.2.5, “Numeric Underflow Exception (#U)”\n\n4.9.1.6  Inexact-Result (Precision) Exception (#P)\nThe inexact-result exception (also called the precision exception) occurs if the result of an operation is not exactly \nrepresentable in the destination format. For example, the fraction 1/3 cannot be precisely represented in binary \nfloating-point form. This exception occurs frequently and indicates that some (normally acceptable) accuracy will \nbe lost due to rounding. The exception is supported for applications that need to perform exact arithmetic only. \nBecause the rounded result is generally satisfactory for most applications, this exception is commonly masked.\n\nIf the inexact-result exception is masked when an inexact-result condition occurs and a numeric overflow or under-\nflow condition has not occurred, the processor sets the PE flag and stores the rounded result in the destination \noperand. The current rounding mode determines the method used to round the result. See Section 4.8.4, \n“Rounding.”\n\nIf the inexact-result exception is not masked when an inexact result occurs and numeric overflow or underflow has \nnot occurred, the PE flag is set, the rounded result is stored in the destination operand, and a software exception \nhandler is invoked.\n\nIf an inexact result occurs in conjunction with numeric overflow or underflow, one of the following operations is \ncarried out:\n• If an inexact result occurs along with masked overflow or underflow, the OE flag or UE flag and the PE flag are \n\nset and the result is stored as described for the overflow or underflow exceptions; see Section 4.9.1.4, \n“Numeric Overflow Exception (#O),” or Section 4.9.1.5, “Numeric Underflow Exception (#U).” If the inexact \nresult exception is unmasked, the processor also invokes a software exception handler.\n\n• If an inexact result occurs along with unmasked overflow or underflow and the destination operand is a register, \nthe OE or UE flag and the PE flag are set, the result is stored as described for the overflow or underflow \nexceptions, and a software exception handler is invoked.\n\nIf an unmasked numeric overflow or underflow exception occurs and the destination operand is a memory location \n(which can happen only for a floating-point store), the inexact-result condition is not reported and the C1 flag is \ncleared.\n\nTable 4-11.  Numeric Underflow (Normalized) Thresholds\n\nFloating-Point Format Underflow Thresholds*\n\nSingle Precision | x | < 1.0 ∗ 2−126\n\nDouble Precision | x | < 1.0 ∗ 2−1022\n\nDouble Extended Precision | x | < 1.0 ∗ 2−16382\n\n* Where ‘x’ is the result rounded to destination precision with an unbounded exponent range.\n4-22 Vol. 1\n\n\n\nDATA TYPES\nSee the following sections for information regarding the inexact-result exception when detected while executing \nx87 FPU or SSE/SSE2/SSE3 instructions:\n• x87 FPU; Section 8.5.6, “Inexact-Result (Precision) Exception (#P)”\n• SIMD floating-point exceptions; Section 11.5.2.3, “Divide-By-Zero Exception (#Z)”\n\n4.9.2 Floating-Point Exception Priority\nThe processor handles exceptions according to a predetermined precedence. When an instruction generates two or \nmore exception conditions, the exception precedence sometimes results in the higher-priority exception being \nhandled and the lower-priority exceptions being ignored. For example, dividing an SNaN by zero can potentially \nsignal an invalid-operation exception (due to the SNaN operand) and a divide-by-zero exception. Here, if both \nexceptions are masked, the processor handles the higher-priority exception only (the invalid-operation exception), \nreturning a QNaN to the destination. Alternately, a denormal-operand or inexact-result exception can accompany \na numeric underflow or overflow exception with both exceptions being handled.\n\nThe precedence for floating-point exceptions is as follows:\n\n1. Invalid-operation exception, subdivided as follows:\n\na. stack underflow (occurs with x87 FPU only)\n\nb. stack overflow (occurs with x87 FPU only)\n\nc. operand of unsupported format (occurs with x87 FPU only when using the double extended-precision \nfloating-point format)\n\nd. SNaN operand\n\n2. QNaN operand. Though this is not an exception, the handling of a QNaN operand has precedence over lower-\npriority exceptions. For example, a QNaN divided by zero results in a QNaN, not a zero-divide exception.\n\n3. Any other invalid-operation exception not mentioned above or a divide-by-zero exception.\n\n4. Denormal-operand exception. If masked, then instruction execution continues and a lower-priority exception \ncan occur as well.\n\n5. Numeric overflow and underflow exceptions; possibly in conjunction with the inexact-result exception.\n\n6. Inexact-result exception.\n\nInvalid operation, zero divide, and denormal operand exceptions are detected before a floating-point operation \nbegins. Overflow, underflow, and precision exceptions are not detected until a true result has been computed. \nWhen an unmasked pre-operation exception is detected, the destination operand has not yet been updated, and \nappears as if the offending instruction has not been executed. When an unmasked post-operation exception is \ndetected, the destination operand may be updated with a result, depending on the nature of the exception (except \nfor SSE/SSE2/SSE3 instructions, which do not update their destination operands in such cases).\n\n4.9.3 Typical Actions of a Floating-Point Exception Handler\nAfter the floating-point exception handler is invoked, the processor handles the exception in the same manner that \nit handles non-floating-point exceptions. The floating-point exception handler is normally part of the operating \nsystem or executive software, and it usually invokes a user-registered floating-point exception handle. \n\nA typical action of the exception handler is to store state information in memory. Other typical exception handler \nactions include:\n• Examining the stored state information to determine the nature of the error\n• Taking actions to correct the condition that caused the error\n• Clearing the exception flags\n• Returning to the interrupted program and resuming normal execution\n\nIn lieu of writing recovery procedures, the exception handler can do the following:\n• Increment in software an exception counter for later display or printing\nVol. 1 4-23\n\n\n\nDATA TYPES\n• Print or display diagnostic information (such as the state information)\n• Halt further program execution\n4-24 Vol. 1\n\n\n\nCHAPTER 5\nINSTRUCTION SET SUMMARY\n\nThis chapter provides an abridged overview of Intel 64 and IA-32 instructions. Instructions are divided into the \nfollowing groups:\n• Section 5.1, “General-Purpose Instructions”.\n• Section 5.2, “x87 FPU Instructions”.\n• Section 5.3, “x87 FPU AND SIMD State Management Instructions”.\n• Section 5.4, “MMX™ Instructions”.\n• Section 5.5, “SSE Instructions”.\n• Section 5.6, “SSE2 Instructions”.\n• Section 5.7, “SSE3 Instructions”.\n• Section 5.8, “Supplemental Streaming SIMD Extensions 3 (SSSE3) Instructions”.\n• Section 5.9, “SSE4 Instructions”.\n• Section 5.10, “SSE4.1 Instructions”.\n• Section 5.11, “SSE4.2 Instruction Set”.\n• Section 5.12, “Intel® AES-NI and PCLMULQDQ”.\n• Section 5.13, “Intel® Advanced Vector Extensions (Intel® AVX)”.\n• Section 5.14, “16-bit Floating-Point Conversion”.\n• Section 5.15, “Fused-Multiply-ADD (FMA)”.\n• Section 5.16, “Intel® Advanced Vector Extensions 2 (Intel® AVX2)”.\n• Section 5.17, “Intel® Transactional Synchronization Extensions (Intel® TSX)”.\n• Section 5.18, “Intel® SHA Extensions”.\n• Section 5.19, “Intel® Advanced Vector Extensions 512 (Intel® AVX-512)”.\n• Section 5.20, “System Instructions”.\n• Section 5.21, “64-Bit Mode Instructions”.\n• Section 5.22, “Virtual-Machine Extensions”.\n• Section 5.23, “Safer Mode Extensions”.\n• Section 5.24, “Intel® Memory Protection Extensions”.\n• Section 5.25, “Intel® Software Guard Extensions”.\n• Section 5.26, “Shadow Stack Management Instructions”.\n• Section 5.27, “Control Transfer Terminating Instructions”.\n\nTable 5-1 lists the groups and IA-32 processors that support each group. More recent instruction set extensions are \nlisted in Table 5-2. Within these groups, most instructions are collected into functional subgroups.\n\nTable 5-1.  Instruction Groups in Intel 64 and IA-32 Processors\n\nInstruction Set \nArchitecture Intel 64 and IA-32 Processor Support\n\nGeneral Purpose All Intel 64 and IA-32 processors.\n\n x87 FPU Intel486, Pentium, Pentium with MMX Technology, Celeron, Pentium Pro, Pentium II, Pentium II Xeon, \nPentium III, Pentium III Xeon, Pentium 4, Intel Xeon processors, Pentium M, Intel Core Solo, Intel Core Duo, \nIntel Core 2 Duo processors, Intel Atom processors.\n\nx87 FPU and SIMD State \nManagement\n\nPentium II, Pentium II Xeon, Pentium III, Pentium III Xeon, Pentium 4, Intel Xeon processors, Pentium M, \nIntel Core Solo, Intel Core Duo, Intel Core 2 Duo processors, Intel Atom processors.\nVol. 1 5-1\n\n\n\nINSTRUCTION SET SUMMARY\nMMX Technology Pentium with MMX Technology, Celeron, Pentium II, Pentium II Xeon, Pentium III, Pentium III Xeon, Pentium \n4, Intel Xeon processors, Pentium M, Intel Core Solo, Intel Core Duo, Intel Core 2 Duo processors, Intel Atom \nprocessors.\n\nSSE Extensions Pentium III, Pentium III Xeon, Pentium 4, Intel Xeon processors, Pentium M, Intel Core Solo, Intel Core Duo, \nIntel Core 2 Duo processors, Intel Atom processors.\n\nSSE2 Extensions Pentium 4, Intel Xeon processors, Pentium M, Intel Core Solo, Intel Core Duo, Intel Core 2 Duo processors, \nIntel Atom processors.\n\nSSE3 Extensions Pentium 4 supporting HT Technology (built on 90nm process technology), Intel Core Solo, Intel Core Duo, \nIntel Core 2 Duo processors, Intel Xeon processor 3xxxx, 5xxx, 7xxx Series, Intel Atom processors.\n\nSSSE3 Extensions Intel Xeon processor 3xxx, 5100, 5200, 5300, 5400, 5500, 5600, 7300, 7400, 7500 series, Intel Core 2 \nExtreme processors QX6000 series, Intel Core 2 Duo, Intel Core 2 Quad processors, Intel Pentium Dual-Core \nprocessors, Intel Atom processors.\n\nIA-32e mode: 64-bit \nmode instructions\n\nIntel 64 processors.\n\nSystem Instructions Intel 64 and IA-32 processors.\n\nVMX Instructions Intel 64 and IA-32 processors supporting Intel Virtualization Technology.\n\nSMX Instructions Intel Core 2 Duo processor E6x50, E8xxx; Intel Core 2 Quad processor Q9xxx.\n\nTable 5-2.  Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors\n\nInstruction Set \nArchitecture Processor Generation Introduction\n\nSSE4.1 Extensions Intel® Xeon® processor 3100, 3300, 5200, 5400, 7400, 7500 series, Intel® Core™ 2 Extreme processors \nQX9000 series, Intel® Core™ 2 Quad processor Q9000 series, Intel® Core™ 2 Duo processors 8000 series \nand T9000 series, Intel Atom® processor based on Silvermont microarchitecture.\n\nSSE4.2 Extensions, \nCRC32, POPCNT\n\nIntel® Core™ i7 965 processor, Intel® Xeon® processors X3400, X3500, X5500, X6500, X7500 series, \nIntel Atom processor based on Silvermont microarchitecture.\n\nIntel® AES-NI, \nPCLMULQDQ\n\nIntel® Xeon® processor E7 series, Intel® Xeon® processors X3600 and X5600, Intel® Core™ i7 980X \nprocessor, Intel Atom processor based on Silvermont microarchitecture. Use CPUID to verify presence of \nIntel AES-NI and PCLMULQDQ across Intel® Core™ processor families.\n\nIntel® AVX Intel® Xeon® processor E3 and E5 families, 2nd Generation Intel® Core™ i7, i5, i3 processor 2xxx families.\n\nF16C 3rd Generation Intel® Core™ processors, Intel® Xeon® processor E3-1200 v2 product family, Intel® Xeon® \nprocessor E5 v2 and E7 v2 families.\n\nRDRAND 3rd Generation Intel Core processors, Intel Xeon processor E3-1200 v2 product family, Intel Xeon \nprocessor E5 v2 and E7 v2 families, Intel Atom processor based on Silvermont microarchitecture.\n\nFS/GS base access 3rd Generation Intel Core processors, Intel Xeon processor E3-1200 v2 product family, Intel Xeon \nprocessor E5 v2 and E7 v2 families, Intel Atom® processor based on Goldmont microarchitecture.\n\nFMA, AVX2, BMI1, BMI2, \nINVPCID, LZCNT, Intel® \nTSX\n\nIntel® Xeon® processor E3/E5/E7 v3 product families, 4th Generation Intel® Core™ processor family.\n\nMOVBE Intel Xeon processor E3/E5/E7 v3 product families, 4th Generation Intel Core processor family, Intel Atom \nprocessors.\n\nPREFETCHW Intel® Core™ M processor family; 5th Generation Intel® Core™ processor family, Intel Atom processor based \non Silvermont microarchitecture.\n\nTable 5-1.  Instruction Groups in Intel 64 and IA-32 Processors (Contd.)\n\nInstruction Set \nArchitecture Intel 64 and IA-32 Processor Support\n5-2 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nADX Intel Core M processor family, 5th Generation Intel Core processor family.\n\nRDSEED, CLAC, STAC Intel Core M processor family, 5th Generation Intel Core processor family, Intel Atom processor based on \nGoldmont microarchitecture.\n\nAVX512ER, AVX512PF, \nPREFETCHWT1\n\nIntel® Xeon Phi™ Processor 3200, 5200, 7200 Series.\n\nAVX512F, AVX512CD Intel Xeon Phi Processor 3200, 5200, 7200 Series, Intel® Xeon® Processor Scalable Family, Intel® Core™ i3-\n8121U processor.\n\nCLFLUSHOPT, XSAVEC, \nXSAVES, Intel® MPX\n\nIntel Xeon Processor Scalable Family, 6th Generation Intel® Core™ processor family, Intel Atom processor \nbased on Goldmont microarchitecture.\n\nSGX1 6th Generation Intel Core processor family, Intel Atom® processor based on Goldmont Plus \nmicroarchitecture.\n\nAVX512DQ, AVX512BW, \nAVX512VL\n\nIntel Xeon Processor Scalable Family, Intel Core i3-8121U processor based on Cannon Lake \nmicroarchitecture.\n\nCLWB Intel Xeon Processor Scalable Family, Intel Atom® processor based on Tremont microarchitecture, 11th \nGeneration Intel Core processor family based on Tiger Lake microarchitecture.\n\nPKU Intel Xeon Processor Scalable Family, 10th generation Intel® Core™ processors based on Comet Lake \nmicroarchitecture.\n\nAVX512_IFMA, \nAVX512_VBMI\n\nIntel Core i3-8121U processor based on Cannon Lake microarchitecture.\n\nIntel® SHA Extensions Intel Core i3-8121U processor based on Cannon Lake microarchitecture , Intel Atom processor based on \nGoldmont microarchitecture, 3rd Generation Intel® Xeon® Processor Scalable Family based on Ice Lake \nmicroarchitecture.\n\nUMIP Intel Core i3-8121U processor based on Cannon Lake microarchitecture, Intel Atom processor based on \nGoldmont Plus microarchitecture.\n\nPTWRITE Intel Atom processor based on Goldmont Plus microarchitecture.\n\nRDPID 10th Generation Intel® Core™ processor family based on Ice Lake microarchitecture, Intel Atom processor \nbased on Goldmont Plus microarchitecture.\n\nAVX512_4FMAPS, \nAVX512_4VNNIW\n\nIntel® Xeon Phi™ Processor 7215, 7285, 7295 Series.\n\nAVX512_VNNI 2nd Generation Intel® Xeon® Processor Scalable Family, 10th Generation Intel Core processor family based \non Ice Lake microarchitecture.\n\nAVX512_VPOPCNTDQ Intel Xeon Phi Processor 7215, 7285, 7295 Series, 10th Generation Intel Core processor family based on \nIce Lake microarchitecture.\n\nFast Short REP MOV 10th Generation Intel Core processor family based on Ice Lake microarchitecture.\n\nGFNI (SSE) 10th Generation Intel Core processor family based on Ice Lake microarchitecture, Intel Atom processor \nbased on Tremont microarchitecture.\n\nVAES, \nGFNI (AVX/AVX512), \nAVX512_VBMI2, \nVPCLMULQDQ, \nAVX512_BITALG\n\n10th Generation Intel Core processor family based on Ice Lake microarchitecture.\n\nENCLV Intel Atom processor based on Tremont microarchitecture, 3rd Generation Intel® Xeon® Processor Scalable \nProcessors based on Ice Lake microarchitecture.\n\nSplit Lock Detection 10th Generation Intel Core processor family based on Ice Lake microarchitecture, Intel Atom processor \nbased on Tremont microarchitecture.\n\nTable 5-2.  Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors (Contd.)\n\nInstruction Set \nArchitecture Processor Generation Introduction\nVol. 1 5-3\n\n\n\nINSTRUCTION SET SUMMARY\nThe following sections list instructions in each major group and subgroup. Given for each instruction is its \nmnemonic and descriptive names. When two or more mnemonics are given (for example, CMOVA/CMOVNBE), they \nrepresent different mnemonics for the same instruction opcode. Assemblers support redundant mnemonics for \nsome instructions to make it easier to read code listings. For instance, CMOVA (Conditional move if above) and \nCMOVNBE (Conditional move if not below or equal) represent the same condition. For detailed information about \nspecific instructions, see the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 2A, 2B, 2C \n& 2D.\n\n5.1 GENERAL-PURPOSE INSTRUCTIONS\nThe general-purpose instructions perform basic data movement, arithmetic, logic, program flow, and string opera-\ntions that programmers commonly use to write application and system software to run on Intel 64 and IA-32 \nprocessors. They operate on data contained in memory, in the general-purpose registers (EAX, EBX, ECX, EDX, \nEDI, ESI, EBP, and ESP) and in the EFLAGS register. They also operate on address information contained in \nmemory, the general-purpose registers, and the segment registers (CS, DS, SS, ES, FS, and GS). \n\nThis group of instructions includes the data transfer, binary integer arithmetic, decimal arithmetic, logic operations, \nshift and rotate, bit and byte operations, program control, string, flag control, segment register operations, and \nmiscellaneous subgroups. The sections that follow introduce each subgroup. \n\nFor more detailed information on general purpose-instructions, see Chapter 7, “Programming With General-\nPurpose Instructions.”\n\n5.1.1 Data Transfer Instructions\nThe data transfer instructions move data between memory and the general-purpose and segment registers. They \nalso perform specific operations such as conditional moves, stack access, and data conversion.\n\nCLDEMOTE Intel Atom processor based on Tremont microarchitecture.\n\nDirect stores: MOVDIRI, \nMOVDIR64B \n\nIntel Atom processor based on Tremont microarchitecture, 11th Generation Intel Core processor family \nbased on Tiger Lake microarchitecture.\n\nUser wait: TPAUSE, \nUMONITOR, UMWAIT\n\nIntel Atom processor based on Tremont microarchitecture.\n\nAVX512_BF16 3rd Generation Intel® Xeon® Processor Scalable Processors based on Cooper Lake product.\n\nAVX512_VP2INTERSECT 11th Generation Intel Core processor family based on Tiger Lake microarchitecture.\n\nKey Locker1 11th Generation Intel Core processor family based on Tiger Lake microarchitecture.\n\nControl-flow Enforcement \nTechnology (CET)\n\n11th Generation Intel Core processor family based on Tiger Lake microarchitecture.\n\nMKTME2, PCONFIG 3rd Generation Intel® Xeon® Processor Scalable Family based on Ice Lake microarchitecture.\n\nWBNOINVD 3rd Generation Intel® Xeon® Processor Scalable Family based on Ice Lake microarchitecture.\n\nSupervisor Memory \nProtection Keys (PKS)\n\nFuture Intel processors\n\nNOTES:\n1. Details on Key Locker can be found in the Intel Key Locker Specification here:\n\n https://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html. \n2. Further details on MKTME usage can be found here: \n\nhttps://software.intel.com/sites/default/files/managed/a5/16/Multi-Key-Total-Memory-Encryption-Spec.pdf.\n\nTable 5-2.  Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors (Contd.)\n\nInstruction Set \nArchitecture Processor Generation Introduction\n5-4 Vol. 1\n\nhttps://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html\nhttps://software.intel.com/sites/default/files/managed/a5/16/Multi-Key-Total-Memory-Encryption-Spec.pdf\n\n\nINSTRUCTION SET SUMMARY\nMOV Move data between general-purpose registers; move data between memory and general-\npurpose or segment registers; move immediates to general-purpose registers.\n\nCMOVE/CMOVZ Conditional move if equal/Conditional move if zero.\nCMOVNE/CMOVNZ Conditional move if not equal/Conditional move if not zero.\nCMOVA/CMOVNBE Conditional move if above/Conditional move if not below or equal.\nCMOVAE/CMOVNB Conditional move if above or equal/Conditional move if not below.\nCMOVB/CMOVNAE Conditional move if below/Conditional move if not above or equal.\nCMOVBE/CMOVNA Conditional move if below or equal/Conditional move if not above.\nCMOVG/CMOVNLE Conditional move if greater/Conditional move if not less or equal.\nCMOVGE/CMOVNL Conditional move if greater or equal/Conditional move if not less.\nCMOVL/CMOVNGE Conditional move if less/Conditional move if not greater or equal.\nCMOVLE/CMOVNG Conditional move if less or equal/Conditional move if not greater.\nCMOVC Conditional move if carry.\nCMOVNC Conditional move if not carry.\nCMOVO Conditional move if overflow.\nCMOVNO Conditional move if not overflow.\nCMOVS Conditional move if sign (negative).\nCMOVNS Conditional move if not sign (non-negative).\nCMOVP/CMOVPE Conditional move if parity/Conditional move if parity even.\nCMOVNP/CMOVPO Conditional move if not parity/Conditional move if parity odd.\nXCHG Exchange.\nBSWAP Byte swap.\nXADD Exchange and add.\nCMPXCHG Compare and exchange.\nCMPXCHG8B Compare and exchange 8 bytes.\nPUSH Push onto stack.\nPOP Pop off of stack.\nPUSHA/PUSHAD Push general-purpose registers onto stack.\nPOPA/POPAD Pop general-purpose registers from stack.\nCWD/CDQ Convert word to doubleword/Convert doubleword to quadword.\nCBW/CWDE Convert byte to word/Convert word to doubleword in EAX register.\nMOVSX Move and sign extend.\nMOVZX Move and zero extend.\n\n5.1.2 Binary Arithmetic Instructions\nThe binary arithmetic instructions perform basic binary integer computations on byte, word, and doubleword inte-\ngers located in memory and/or the general purpose registers.\nADCX Unsigned integer add with carry.\nADOX Unsigned integer add with overflow.\nADD Integer add.\nADC Add with carry.\nSUB Subtract.\nSBB Subtract with borrow.\nIMUL Signed multiply.\nMUL Unsigned multiply.\nIDIV Signed divide.\nVol. 1 5-5\n\n\n\nINSTRUCTION SET SUMMARY\nDIV Unsigned divide.\nINC Increment.\nDEC Decrement.\nNEG Negate.\nCMP Compare.\n\n5.1.3 Decimal Arithmetic Instructions\nThe decimal arithmetic instructions perform decimal arithmetic on binary coded decimal (BCD) data.\nDAA Decimal adjust after addition.\nDAS Decimal adjust after subtraction.\nAAA ASCII adjust after addition.\nAAS ASCII adjust after subtraction.\nAAM ASCII adjust after multiplication.\nAAD ASCII adjust before division.\n\n5.1.4 Logical Instructions\nThe logical instructions perform basic AND, OR, XOR, and NOT logical operations on byte, word, and doubleword \nvalues.\nAND Perform bitwise logical AND.\nOR Perform bitwise logical OR.\nXOR Perform bitwise logical exclusive OR.\nNOT Perform bitwise logical NOT.\n\n5.1.5 Shift and Rotate Instructions\nThe shift and rotate instructions shift and rotate the bits in word and doubleword operands.\nSAR Shift arithmetic right.\nSHR Shift logical right.\nSAL/SHL Shift arithmetic left/Shift logical left.\nSHRD Shift right double.\nSHLD Shift left double.\nROR Rotate right.\nROL Rotate left.\nRCR Rotate through carry right.\nRCL Rotate through carry left.\n\n5.1.6 Bit and Byte Instructions\nBit instructions test and modify individual bits in word and doubleword operands. Byte instructions set the value of \na byte operand to indicate the status of flags in the EFLAGS register.\nBT Bit test.\nBTS Bit test and set.\nBTR Bit test and reset.\nBTC Bit test and complement.\nBSF Bit scan forward.\n5-6 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nBSR Bit scan reverse.\nSETE/SETZ Set byte if equal/Set byte if zero.\nSETNE/SETNZ Set byte if not equal/Set byte if not zero.\nSETA/SETNBE Set byte if above/Set byte if not below or equal.\nSETAE/SETNB/SETNC Set byte if above or equal/Set byte if not below/Set byte if not carry.\nSETB/SETNAE/SETC Set byte if below/Set byte if not above or equal/Set byte if carry.\nSETBE/SETNA Set byte if below or equal/Set byte if not above.\nSETG/SETNLE Set byte if greater/Set byte if not less or equal.\nSETGE/SETNL Set byte if greater or equal/Set byte if not less.\nSETL/SETNGE Set byte if less/Set byte if not greater or equal.\nSETLE/SETNG Set byte if less or equal/Set byte if not greater.\nSETS Set byte if sign (negative).\nSETNS Set byte if not sign (non-negative).\nSETO Set byte if overflow.\nSETNO Set byte if not overflow.\nSETPE/SETP Set byte if parity even/Set byte if parity.\nSETPO/SETNP Set byte if parity odd/Set byte if not parity.\nTEST Logical compare.\nCRC321 Provides hardware acceleration to calculate cyclic redundancy checks for fast and efficient \n\nimplementation of data integrity protocols.\nPOPCNT2 This instruction calculates of number of bits set to 1 in the second operand (source) and \n\nreturns the count in the first operand (a destination register).\n\n5.1.7 Control Transfer Instructions\nThe control transfer instructions provide jump, conditional jump, loop, and call and return operations to control \nprogram flow.\nJMP Jump.\nJE/JZ Jump if equal/Jump if zero.\nJNE/JNZ Jump if not equal/Jump if not zero.\nJA/JNBE Jump if above/Jump if not below or equal.\nJAE/JNB Jump if above or equal/Jump if not below.\nJB/JNAE Jump if below/Jump if not above or equal.\nJBE/JNA Jump if below or equal/Jump if not above.\nJG/JNLE Jump if greater/Jump if not less or equal.\nJGE/JNL Jump if greater or equal/Jump if not less.\nJL/JNGE Jump if less/Jump if not greater or equal.\nJLE/JNG Jump if less or equal/Jump if not greater.\nJC Jump if carry.\nJNC Jump if not carry.\nJO Jump if overflow.\nJNO Jump if not overflow.\nJS Jump if sign (negative).\nJNS Jump if not sign (non-negative).\n\n1. Processor support of CRC32 is enumerated by CPUID.01:ECX[SSE4.2] = 1\n\n2. Processor support of POPCNT is enumerated by CPUID.01:ECX[POPCNT] = 1\nVol. 1 5-7\n\n\n\nINSTRUCTION SET SUMMARY\nJPO/JNP Jump if parity odd/Jump if not parity.\nJPE/JP Jump if parity even/Jump if parity.\nJCXZ/JECXZ Jump register CX zero/Jump register ECX zero.\nLOOP Loop with ECX counter.\nLOOPZ/LOOPE Loop with ECX and zero/Loop with ECX and equal.\nLOOPNZ/LOOPNE Loop with ECX and not zero/Loop with ECX and not equal.\nCALL Call procedure.\nRET Return.\nIRET Return from interrupt.\nINT Software interrupt.\nINTO Interrupt on overflow.\nBOUND Detect value out of range.\nENTER High-level procedure entry.\nLEAVE High-level procedure exit.\n\n5.1.8 String Instructions\nThe string instructions operate on strings of bytes, allowing them to be moved to and from memory.\nMOVS/MOVSB Move string/Move byte string.\nMOVS/MOVSW Move string/Move word string.\nMOVS/MOVSD Move string/Move doubleword string.\nCMPS/CMPSB Compare string/Compare byte string.\nCMPS/CMPSW Compare string/Compare word string.\nCMPS/CMPSD Compare string/Compare doubleword string.\nSCAS/SCASB Scan string/Scan byte string.\nSCAS/SCASW Scan string/Scan word string.\nSCAS/SCASD Scan string/Scan doubleword string.\nLODS/LODSB Load string/Load byte string.\nLODS/LODSW Load string/Load word string.\nLODS/LODSD Load string/Load doubleword string.\nSTOS/STOSB Store string/Store byte string.\nSTOS/STOSW Store string/Store word string.\nSTOS/STOSD Store string/Store doubleword string.\nREP Repeat while ECX not zero.\nREPE/REPZ Repeat while equal/Repeat while zero.\nREPNE/REPNZ Repeat while not equal/Repeat while not zero.\n\n5.1.9 I/O Instructions\nThese instructions move data between the processor’s I/O ports and a register or memory.\nIN Read from a port.\nOUT Write to a port.\nINS/INSB Input string from port/Input byte string from port.\nINS/INSW Input string from port/Input word string from port.\nINS/INSD Input string from port/Input doubleword string from port.\nOUTS/OUTSB Output string to port/Output byte string to port.\nOUTS/OUTSW Output string to port/Output word string to port.\n5-8 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nOUTS/OUTSD Output string to port/Output doubleword string to port.\n\n5.1.10 Enter and Leave Instructions\nThese instructions provide machine-language support for procedure calls in block-structured languages.\nENTER High-level procedure entry.\nLEAVE High-level procedure exit.\n\n5.1.11 Flag Control (EFLAG) Instructions\nThe flag control instructions operate on the flags in the EFLAGS register.\nSTC Set carry flag.\nCLC Clear the carry flag.\nCMC Complement the carry flag.\nCLD Clear the direction flag.\nSTD Set direction flag.\nLAHF Load flags into AH register.\nSAHF Store AH register into flags.\nPUSHF/PUSHFD Push EFLAGS onto stack.\nPOPF/POPFD Pop EFLAGS from stack.\nSTI Set interrupt flag.\nCLI Clear the interrupt flag.\n\n5.1.12 Segment Register Instructions\nThe segment register instructions allow far pointers (segment addresses) to be loaded into the segment registers.\nLDS Load far pointer using DS.\nLES Load far pointer using ES.\nLFS Load far pointer using FS.\nLGS Load far pointer using GS.\nLSS Load far pointer using SS.\n\n5.1.13 Miscellaneous Instructions\nThe miscellaneous instructions provide such functions as loading an effective address, executing a “no-operation,” \nand retrieving processor identification information.\nLEA Load effective address.\nNOP No operation.\nUD Undefined instruction.\nXLAT/XLATB Table lookup translation.\nCPUID Processor identification.\nMOVBE1 Move data after swapping data bytes.\nPREFETCHW Prefetch data into cache in anticipation of write.\nPREFETCHWT1 Prefetch hint T1 with intent to write.\n\n1. Processor support of MOVBE is enumerated by CPUID.01:ECX.MOVBE[bit 22] = 1.\nVol. 1 5-9\n\n\n\nINSTRUCTION SET SUMMARY\nCLFLUSH Flushes and invalidates a memory operand and its associated cache line from all levels of \nthe processor’s cache hierarchy.\n\nCLFLUSHOPT Flushes and invalidates a memory operand and its associated cache line from all levels of \nthe processor’s cache hierarchy with optimized memory system throughput.\n\n5.1.14 User Mode Extended Sate Save/Restore Instructions\nXSAVE Save processor extended states to memory.\nXSAVEC Save processor extended states with compaction to memory.\nXSAVEOPT Save processor extended states to memory, optimized.\nXRSTOR Restore processor extended states from memory.\nXGETBV Reads the state of an extended control register.\n\n5.1.15 Random Number Generator Instructions\nRDRAND Retrieves a random number generated from hardware.\nRDSEED Retrieves a random number generated from hardware.\n\n5.1.16 BMI1, BMI2\nANDN Bitwise AND of first source with inverted 2nd source operands.\nBEXTR Contiguous bitwise extract.\nBLSI Extract lowest set bit.\nBLSMSK Set all lower bits below first set bit to 1.\n\nBLSR Reset lowest set bit.\nBZHI Zero high bits starting from specified bit position.\nLZCNT Count the number leading zero bits.\nMULX Unsigned multiply without affecting arithmetic flags.\nPDEP Parallel deposit of bits using a mask.\nPEXT Parallel extraction of bits using a mask.\nRORX Rotate right without affecting arithmetic flags.\nSARX Shift arithmetic right.\nSHLX Shift logic left.\nSHRX Shift logic right.\nTZCNT Count the number trailing zero bits.\n\n5.1.16.1  Detection of VEX-encoded GPR Instructions, LZCNT and TZCNT, PREFETCHW\nVEX-encoded general-purpose instructions do not operate on any vector registers. \nThere are separate feature flags for the following subsets of instructions that operate on general purpose registers, \nand the detection requirements for hardware support are:\nCPUID.(EAX=07H, ECX=0H):EBX.BMI1[bit 3]: if 1 indicates the processor supports the first group of advanced bit \nmanipulation extensions (ANDN, BEXTR, BLSI, BLSMSK, BLSR, TZCNT);\nCPUID.(EAX=07H, ECX=0H):EBX.BMI2[bit 8]: if 1 indicates the processor supports the second group of advanced \nbit manipulation extensions (BZHI, MULX, PDEP, PEXT, RORX, SARX, SHLX, SHRX);\nCPUID.EAX=80000001H:ECX.LZCNT[bit 5]: if 1 indicates the processor supports the LZCNT instruction.\nCPUID.EAX=80000001H:ECX.PREFTEHCHW[bit 8]: if 1 indicates the processor supports the PREFTEHCHW instruc-\ntion. CPUID.(EAX=07H, ECX=0H):ECX.PREFTEHCHWT1[bit 0]: if 1 indicates the processor supports the \nPREFTEHCHWT1 instruction.\n5-10 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\n5.2 X87 FPU INSTRUCTIONS\nThe x87 FPU instructions are executed by the processor’s x87 FPU. These instructions operate on floating-point, \ninteger, and binary-coded decimal (BCD) operands. For more detail on x87 FPU instructions, see Chapter 8, \n“Programming with the x87 FPU.”\n\nThese instructions are divided into the following subgroups: data transfer, load constants, and FPU control instruc-\ntions. The sections that follow introduce each subgroup.\n\n5.2.1 x87 FPU Data Transfer Instructions\nThe data transfer instructions move floating-point, integer, and BCD values between memory and the x87 FPU \nregisters. They also perform conditional move operations on floating-point operands.\nFLD Load floating-point value.\nFST Store floating-point value.\nFSTP Store floating-point value and pop.\nFILD Load integer.\nFIST Store integer.\nFISTP1 Store integer and pop.\nFBLD Load BCD.\nFBSTP Store BCD and pop.\nFXCH Exchange registers.\nFCMOVE Floating-point conditional move if equal.\nFCMOVNE Floating-point conditional move if not equal.\nFCMOVB Floating-point conditional move if below.\nFCMOVBE Floating-point conditional move if below or equal.\nFCMOVNB Floating-point conditional move if not below.\nFCMOVNBE Floating-point conditional move if not below or equal.\nFCMOVU Floating-point conditional move if unordered.\nFCMOVNU Floating-point conditional move if not unordered.\n\n5.2.2 x87 FPU Basic Arithmetic Instructions\nThe basic arithmetic instructions perform basic arithmetic operations on floating-point and integer operands.\nFADD Add floating-point\nFADDP Add floating-point and pop\nFIADD Add integer\nFSUB Subtract floating-point\nFSUBP Subtract floating-point and pop\nFISUB Subtract integer\nFSUBR Subtract floating-point reverse\nFSUBRP Subtract floating-point reverse and pop\nFISUBR Subtract integer reverse\nFMUL Multiply floating-point\nFMULP Multiply floating-point and pop\nFIMUL Multiply integer\nFDIV Divide floating-point\n\n1. SSE3 provides an instruction FISTTP for integer conversion.\nVol. 1 5-11\n\n\n\nINSTRUCTION SET SUMMARY\nFDIVP Divide floating-point and pop\nFIDIV Divide integer\nFDIVR Divide floating-point reverse\nFDIVRP Divide floating-point reverse and pop\nFIDIVR Divide integer reverse\nFPREM Partial remainder\nFPREM1 IEEE Partial remainder\nFABS Absolute value\nFCHS Change sign\nFRNDINT Round to integer\nFSCALE Scale by power of two\nFSQRT Square root\nFXTRACT Extract exponent and significand\n\n5.2.3 x87 FPU Comparison Instructions\nThe compare instructions examine or compare floating-point or integer operands.\nFCOM Compare floating-point.\nFCOMP Compare floating-point and pop.\nFCOMPP Compare floating-point and pop twice.\nFUCOM Unordered compare floating-point.\nFUCOMP Unordered compare floating-point and pop.\nFUCOMPP Unordered compare floating-point and pop twice.\nFICOM Compare integer.\nFICOMP Compare integer and pop.\nFCOMI Compare floating-point and set EFLAGS.\nFUCOMI Unordered compare floating-point and set EFLAGS.\nFCOMIP Compare floating-point, set EFLAGS, and pop.\nFUCOMIP Unordered compare floating-point, set EFLAGS, and pop.\nFTST Test floating-point (compare with 0.0).\nFXAM Examine floating-point.\n\n5.2.4 x87 FPU Transcendental Instructions\nThe transcendental instructions perform basic trigonometric and logarithmic operations on floating-point operands.\nFSIN Sine\nFCOS Cosine\nFSINCOS Sine and cosine\nFPTAN Partial tangent\nFPATAN Partial arctangent\nF2XM1 2x − 1\nFYL2X y∗log2x\nFYL2XP1 y∗log2(x+1)\n\n5.2.5 x87 FPU Load Constants Instructions\nThe load constants instructions load common constants, such as π, into the x87 floating-point registers.\n5-12 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nFLD1 Load +1.0\nFLDZ Load +0.0\nFLDPI Load π\nFLDL2E Load log2e\nFLDLN2 Load loge2\nFLDL2T Load log210\nFLDLG2 Load log102\n\n5.2.6 x87 FPU Control Instructions\nThe x87 FPU control instructions operate on the x87 FPU register stack and save and restore the x87 FPU state.\nFINCSTP Increment FPU register stack pointer.\nFDECSTP Decrement FPU register stack pointer.\nFFREE Free floating-point register.\nFINIT Initialize FPU after checking error conditions.\nFNINIT Initialize FPU without checking error conditions.\nFCLEX Clear floating-point exception flags after checking for error conditions.\nFNCLEX Clear floating-point exception flags without checking for error conditions.\nFSTCW Store FPU control word after checking error conditions.\nFNSTCW Store FPU control word without checking error conditions.\nFLDCW Load FPU control word.\nFSTENV Store FPU environment after checking error conditions.\nFNSTENV Store FPU environment without checking error conditions.\nFLDENV Load FPU environment.\nFSAVE Save FPU state after checking error conditions.\nFNSAVE Save FPU state without checking error conditions.\nFRSTOR Restore FPU state.\nFSTSW Store FPU status word after checking error conditions.\nFNSTSW Store FPU status word without checking error conditions.\nWAIT/FWAIT Wait for FPU.\nFNOP FPU no operation.\n\n5.3 X87 FPU AND SIMD STATE MANAGEMENT INSTRUCTIONS\nTwo state management instructions were introduced into the IA-32 architecture with the Pentium II processor \nfamily:\nFXSAVE Save x87 FPU and SIMD state.\nFXRSTOR Restore x87 FPU and SIMD state.\n\nInitially, these instructions operated only on the x87 FPU (and MMX) registers to perform a fast save and restore, \nrespectively, of the x87 FPU and MMX state. With the introduction of SSE extensions in the Pentium III processor \nfamily, these instructions were expanded to also save and restore the state of the XMM and MXCSR registers. Intel \n64 architecture also supports these instructions.\n\nSee Section 10.5, “FXSAVE and FXRSTOR Instructions,” for more detail.\n\n5.4 MMX™ INSTRUCTIONS\nFour extensions have been introduced into the IA-32 architecture to permit IA-32 processors to perform single-\ninstruction multiple-data (SIMD) operations. These extensions include the MMX technology, SSE extensions, SSE2 \nVol. 1 5-13\n\n\n\nINSTRUCTION SET SUMMARY\nextensions, and SSE3 extensions. For a discussion that puts SIMD instructions in their historical context, see \nSection 2.2.7, “SIMD Instructions.”\n\nMMX instructions operate on packed byte, word, doubleword, or quadword integer operands contained in memory, \nin MMX registers, and/or in general-purpose registers. For more detail on these instructions, see Chapter 9, \n“Programming with Intel® MMX™ Technology.” \n\nMMX instructions can only be executed on Intel 64 and IA-32 processors that support the MMX technology. Support \nfor these instructions can be detected with the CPUID instruction. See the description of the CPUID instruction in \nChapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 2A.\n\nMMX instructions are divided into the following subgroups: data transfer, conversion, packed arithmetic, compar-\nison, logical, shift and rotate, and state management instructions. The sections that follow introduce each \nsubgroup.\n\n5.4.1 MMX Data Transfer Instructions\nThe data transfer instructions move doubleword and quadword operands between MMX registers and between MMX \nregisters and memory.\nMOVD Move doubleword.\nMOVQ Move quadword.\n\n5.4.2 MMX Conversion Instructions\nThe conversion instructions pack and unpack bytes, words, and doublewords\nPACKSSWB Pack words into bytes with signed saturation.\nPACKSSDW Pack doublewords into words with signed saturation.\nPACKUSWB Pack words into bytes with unsigned saturation.\nPUNPCKHBW Unpack high-order bytes.\nPUNPCKHWD Unpack high-order words.\nPUNPCKHDQ Unpack high-order doublewords.\nPUNPCKLBW Unpack low-order bytes.\nPUNPCKLWD Unpack low-order words.\nPUNPCKLDQ Unpack low-order doublewords.\n\n5.4.3 MMX Packed Arithmetic Instructions\nThe packed arithmetic instructions perform packed integer arithmetic on packed byte, word, and doubleword inte-\ngers.\nPADDB Add packed byte integers.\nPADDW Add packed word integers.\nPADDD Add packed doubleword integers.\nPADDSB Add packed signed byte integers with signed saturation.\nPADDSW Add packed signed word integers with signed saturation.\nPADDUSB Add packed unsigned byte integers with unsigned saturation.\nPADDUSW Add packed unsigned word integers with unsigned saturation.\nPSUBB Subtract packed byte integers.\nPSUBW Subtract packed word integers.\nPSUBD Subtract packed doubleword integers.\nPSUBSB Subtract packed signed byte integers with signed saturation.\nPSUBSW Subtract packed signed word integers with signed saturation.\n5-14 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nPSUBUSB Subtract packed unsigned byte integers with unsigned saturation.\nPSUBUSW Subtract packed unsigned word integers with unsigned saturation.\nPMULHW Multiply packed signed word integers and store high result.\nPMULLW Multiply packed signed word integers and store low result.\nPMADDWD Multiply and add packed word integers.\n\n5.4.4 MMX Comparison Instructions\nThe compare instructions compare packed bytes, words, or doublewords.\nPCMPEQB Compare packed bytes for equal.\nPCMPEQW Compare packed words for equal.\nPCMPEQD Compare packed doublewords for equal.\nPCMPGTB Compare packed signed byte integers for greater than.\nPCMPGTW Compare packed signed word integers for greater than.\nPCMPGTD Compare packed signed doubleword integers for greater than.\n\n5.4.5 MMX Logical Instructions\nThe logical instructions perform AND, AND NOT, OR, and XOR operations on quadword operands.\nPAND Bitwise logical AND.\nPANDN Bitwise logical AND NOT.\nPOR Bitwise logical OR.\nPXOR Bitwise logical exclusive OR.\n\n5.4.6 MMX Shift and Rotate Instructions\nThe shift and rotate instructions shift and rotate packed bytes, words, or doublewords, or quadwords in 64-bit \noperands.\nPSLLW Shift packed words left logical.\nPSLLD Shift packed doublewords left logical.\nPSLLQ Shift packed quadword left logical.\nPSRLW Shift packed words right logical.\nPSRLD Shift packed doublewords right logical.\nPSRLQ Shift packed quadword right logical.\nPSRAW Shift packed words right arithmetic.\nPSRAD Shift packed doublewords right arithmetic.\n\n5.4.7 MMX State Management Instructions\nThe EMMS instruction clears the MMX state from the MMX registers.\nEMMS Empty MMX state.\n\n5.5 SSE INSTRUCTIONS\nSSE instructions represent an extension of the SIMD execution model introduced with the MMX technology. For \nmore detail on these instructions, see Chapter 10, “Programming with Intel® Streaming SIMD Extensions (Intel® \nSSE).”\nVol. 1 5-15\n\n\n\nINSTRUCTION SET SUMMARY\nSSE instructions can only be executed on Intel 64 and IA-32 processors that support SSE extensions. Support for \nthese instructions can be detected with the CPUID instruction. See the description of the CPUID instruction in \nChapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 2A.\n\nSSE instructions are divided into four subgroups (note that the first subgroup has subordinate subgroups of its \nown):\n• SIMD single-precision floating-point instructions that operate on the XMM registers.\n• MXCSR state management instructions.\n• 64-bit SIMD integer instructions that operate on the MMX registers.\n• Cacheability control, prefetch, and instruction ordering instructions.\n\nThe following sections provide an overview of these groups.\n\n5.5.1 SSE SIMD Single-Precision Floating-Point Instructions\nThese instructions operate on packed and scalar single-precision floating-point values located in XMM registers \nand/or memory. This subgroup is further divided into the following subordinate subgroups: data transfer, packed \narithmetic, comparison, logical, shuffle and unpack, and conversion instructions.\n\n5.5.1.1  SSE Data Transfer Instructions\nSSE data transfer instructions move packed and scalar single-precision floating-point operands between XMM \nregisters and between XMM registers and memory.\nMOVAPS Move four aligned packed single-precision floating-point values between XMM registers or \n\nbetween and XMM register and memory.\nMOVUPS Move four unaligned packed single-precision floating-point values between XMM registers \n\nor between and XMM register and memory.\nMOVHPS Move two packed single-precision floating-point values to an from the high quadword of an \n\nXMM register and memory.\nMOVHLPS Move two packed single-precision floating-point values from the high quadword of an XMM \n\nregister to the low quadword of another XMM register.\nMOVLPS Move two packed single-precision floating-point values to an from the low quadword of an \n\nXMM register and memory.\nMOVLHPS Move two packed single-precision floating-point values from the low quadword of an XMM \n\nregister to the high quadword of another XMM register.\nMOVMSKPS Extract sign mask from four packed single-precision floating-point values.\nMOVSS Move scalar single-precision floating-point value between XMM registers or between an \n\nXMM register and memory.\n\n5.5.1.2  SSE Packed Arithmetic Instructions\nSSE packed arithmetic instructions perform packed and scalar arithmetic operations on packed and scalar single-\nprecision floating-point operands.\nADDPS Add packed single-precision floating-point values.\nADDSS Add scalar single-precision floating-point values.\nSUBPS Subtract packed single-precision floating-point values.\nSUBSS Subtract scalar single-precision floating-point values.\nMULPS Multiply packed single-precision floating-point values.\nMULSS Multiply scalar single-precision floating-point values.\nDIVPS Divide packed single-precision floating-point values.\nDIVSS Divide scalar single-precision floating-point values.\n5-16 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nRCPPS Compute reciprocals of packed single-precision floating-point values.\nRCPSS Compute reciprocal of scalar single-precision floating-point values.\nSQRTPS Compute square roots of packed single-precision floating-point values.\nSQRTSS Compute square root of scalar single-precision floating-point values.\nRSQRTPS Compute reciprocals of square roots of packed single-precision floating-point values.\nRSQRTSS Compute reciprocal of square root of scalar single-precision floating-point values.\nMAXPS Return maximum packed single-precision floating-point values.\nMAXSS Return maximum scalar single-precision floating-point values.\nMINPS Return minimum packed single-precision floating-point values.\nMINSS Return minimum scalar single-precision floating-point values.\n\n5.5.1.3  SSE Comparison Instructions\nSSE compare instructions compare packed and scalar single-precision floating-point operands.\nCMPPS Compare packed single-precision floating-point values.\nCMPSS Compare scalar single-precision floating-point values.\nCOMISS Perform ordered comparison of scalar single-precision floating-point values and set flags in \n\nEFLAGS register.\nUCOMISS Perform unordered comparison of scalar single-precision floating-point values and set flags \n\nin EFLAGS register.\n\n5.5.1.4  SSE Logical Instructions\nSSE logical instructions perform bitwise AND, AND NOT, OR, and XOR operations on packed single-precision \nfloating-point operands.\nANDPS Perform bitwise logical AND of packed single-precision floating-point values.\nANDNPS Perform bitwise logical AND NOT of packed single-precision floating-point values.\nORPS Perform bitwise logical OR of packed single-precision floating-point values.\nXORPS Perform bitwise logical XOR of packed single-precision floating-point values.\n\n5.5.1.5  SSE Shuffle and Unpack Instructions\nSSE shuffle and unpack instructions shuffle or interleave single-precision floating-point values in packed single-\nprecision floating-point operands.\nSHUFPS Shuffles values in packed single-precision floating-point operands.\nUNPCKHPS Unpacks and interleaves the two high-order values from two single-precision floating-point \n\noperands.\nUNPCKLPS Unpacks and interleaves the two low-order values from two single-precision floating-point \n\noperands.\n\n5.5.1.6  SSE Conversion Instructions\nSSE conversion instructions convert packed and individual doubleword integers into packed and scalar single-\nprecision floating-point values and vice versa.\nCVTPI2PS Convert packed doubleword integers to packed single-precision floating-point values.\nCVTSI2SS Convert doubleword integer to scalar single-precision floating-point value.\nCVTPS2PI Convert packed single-precision floating-point values to packed doubleword integers.\nCVTTPS2PI Convert with truncation packed single-precision floating-point values to packed double-\n\nword integers.\nCVTSS2SI Convert a scalar single-precision floating-point value to a doubleword integer.\nVol. 1 5-17\n\n\n\nINSTRUCTION SET SUMMARY\nCVTTSS2SI Convert with truncation a scalar single-precision floating-point value to a scalar double-\nword integer.\n\n5.5.2 SSE MXCSR State Management Instructions\nMXCSR state management instructions allow saving and restoring the state of the MXCSR control and status \nregister.\nLDMXCSR Load MXCSR register.\nSTMXCSR Save MXCSR register state.\n\n5.5.3 SSE 64-Bit SIMD Integer Instructions\nThese SSE 64-bit SIMD integer instructions perform additional operations on packed bytes, words, or doublewords \ncontained in MMX registers. They represent enhancements to the MMX instruction set described in Section 5.4, \n“MMX™ Instructions.”\nPAVGB Compute average of packed unsigned byte integers.\nPAVGW Compute average of packed unsigned word integers.\nPEXTRW Extract word.\nPINSRW Insert word.\nPMAXUB Maximum of packed unsigned byte integers.\nPMAXSW Maximum of packed signed word integers.\nPMINUB Minimum of packed unsigned byte integers.\nPMINSW Minimum of packed signed word integers.\nPMOVMSKB Move byte mask.\nPMULHUW Multiply packed unsigned integers and store high result.\nPSADBW Compute sum of absolute differences.\nPSHUFW Shuffle packed integer word in MMX register.\n\n5.5.4 SSE Cacheability Control, Prefetch, and Instruction Ordering Instructions\nThe cacheability control instructions provide control over the caching of non-temporal data when storing data from \nthe MMX and XMM registers to memory. The PREFETCHh allows data to be prefetched to a selected cache level. The \nSFENCE instruction controls instruction ordering on store operations.\nMASKMOVQ Non-temporal store of selected bytes from an MMX register into memory.\nMOVNTQ Non-temporal store of quadword from an MMX register into memory.\nMOVNTPS Non-temporal store of four packed single-precision floating-point values from an XMM \n\nregister into memory.\nPREFETCHh Load 32 or more of bytes from memory to a selected level of the processor’s cache hier-\n\narchy\nSFENCE Serializes store operations.\n\n5.6 SSE2 INSTRUCTIONS\nSSE2 extensions represent an extension of the SIMD execution model introduced with MMX technology and the \nSSE extensions. SSE2 instructions operate on packed double-precision floating-point operands and on packed \nbyte, word, doubleword, and quadword operands located in the XMM registers. For more detail on these instruc-\ntions, see Chapter 11, “Programming with Intel® Streaming SIMD Extensions 2 (Intel® SSE2).”\n\nSSE2 instructions can only be executed on Intel 64 and IA-32 processors that support the SSE2 extensions. \nSupport for these instructions can be detected with the CPUID instruction. See the description of the CPUID instruc-\n5-18 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\ntion in Chapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s \nManual, Volume 2A.\n\nThese instructions are divided into four subgroups (note that the first subgroup is further divided into subordinate \nsubgroups):\n• Packed and scalar double-precision floating-point instructions.\n• Packed single-precision floating-point conversion instructions.\n• 128-bit SIMD integer instructions.\n• Cacheability-control and instruction ordering instructions.\n\nThe following sections give an overview of each subgroup.\n\n5.6.1 SSE2 Packed and Scalar Double-Precision Floating-Point Instructions\nSSE2 packed and scalar double-precision floating-point instructions are divided into the following subordinate \nsubgroups: data movement, arithmetic, comparison, conversion, logical, and shuffle operations on double-preci-\nsion floating-point operands. These are introduced in the sections that follow.\n\n5.6.1.1  SSE2 Data Movement Instructions\nSSE2 data movement instructions move double-precision floating-point data between XMM registers and between \nXMM registers and memory.\nMOVAPD Move two aligned packed double-precision floating-point values between XMM registers or \n\nbetween and XMM register and memory.\nMOVUPD Move two unaligned packed double-precision floating-point values between XMM registers \n\nor between and XMM register and memory.\nMOVHPD Move high packed double-precision floating-point value to an from the high quadword of an \n\nXMM register and memory.\nMOVLPD Move low packed single-precision floating-point value to an from the low quadword of an \n\nXMM register and memory.\nMOVMSKPD Extract sign mask from two packed double-precision floating-point values.\nMOVSD Move scalar double-precision floating-point value between XMM registers or between an \n\nXMM register and memory.\n\n5.6.1.2  SSE2 Packed Arithmetic Instructions\nThe arithmetic instructions perform addition, subtraction, multiply, divide, square root, and maximum/minimum \noperations on packed and scalar double-precision floating-point operands.\nADDPD Add packed double-precision floating-point values.\nADDSD Add scalar double precision floating-point values.\nSUBPD Subtract packed double-precision floating-point values.\nSUBSD Subtract scalar double-precision floating-point values.\nMULPD Multiply packed double-precision floating-point values.\nMULSD Multiply scalar double-precision floating-point values.\nDIVPD Divide packed double-precision floating-point values.\nDIVSD Divide scalar double-precision floating-point values.\nSQRTPD Compute packed square roots of packed double-precision floating-point values.\nSQRTSD Compute scalar square root of scalar double-precision floating-point values.\nMAXPD Return maximum packed double-precision floating-point values.\nMAXSD Return maximum scalar double-precision floating-point values.\nMINPD Return minimum packed double-precision floating-point values.\nVol. 1 5-19\n\n\n\nINSTRUCTION SET SUMMARY\nMINSD Return minimum scalar double-precision floating-point values.\n\n5.6.1.3  SSE2 Logical Instructions\nSSE2 logical instructions perform AND, AND NOT, OR, and XOR operations on packed double-precision floating-\npoint values.\nANDPD Perform bitwise logical AND of packed double-precision floating-point values.\nANDNPD Perform bitwise logical AND NOT of packed double-precision floating-point values.\nORPD Perform bitwise logical OR of packed double-precision floating-point values.\nXORPD Perform bitwise logical XOR of packed double-precision floating-point values.\n\n5.6.1.4  SSE2 Compare Instructions\nSSE2 compare instructions compare packed and scalar double-precision floating-point values and return the \nresults of the comparison either to the destination operand or to the EFLAGS register.\nCMPPD Compare packed double-precision floating-point values.\nCMPSD Compare scalar double-precision floating-point values.\nCOMISD Perform ordered comparison of scalar double-precision floating-point values and set flags \n\nin EFLAGS register.\nUCOMISD Perform unordered comparison of scalar double-precision floating-point values and set \n\nflags in EFLAGS register.\n\n5.6.1.5  SSE2 Shuffle and Unpack Instructions\nSSE2 shuffle and unpack instructions shuffle or interleave double-precision floating-point values in packed double-\nprecision floating-point operands.\nSHUFPD Shuffles values in packed double-precision floating-point operands.\nUNPCKHPD Unpacks and interleaves the high values from two packed double-precision floating-point \n\noperands.\nUNPCKLPD Unpacks and interleaves the low values from two packed double-precision floating-point \n\noperands.\n\n5.6.1.6  SSE2 Conversion Instructions\nSSE2 conversion instructions convert packed and individual doubleword integers into packed and scalar double-\nprecision floating-point values and vice versa. They also convert between packed and scalar single-precision and \ndouble-precision floating-point values.\nCVTPD2PI Convert packed double-precision floating-point values to packed doubleword integers.\nCVTTPD2PI Convert with truncation packed double-precision floating-point values to packed double-\n\nword integers.\nCVTPI2PD Convert packed doubleword integers to packed double-precision floating-point values.\nCVTPD2DQ Convert packed double-precision floating-point values to packed doubleword integers.\nCVTTPD2DQ Convert with truncation packed double-precision floating-point values to packed double-\n\nword integers.\nCVTDQ2PD Convert packed doubleword integers to packed double-precision floating-point values.\nCVTPS2PD Convert packed single-precision floating-point values to packed double-precision floating-\n\npoint values.\nCVTPD2PS Convert packed double-precision floating-point values to packed single-precision floating-\n\npoint values.\nCVTSS2SD Convert scalar single-precision floating-point values to scalar double-precision floating-\n\npoint values.\n5-20 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nCVTSD2SS Convert scalar double-precision floating-point values to scalar single-precision floating-\npoint values.\n\nCVTSD2SI Convert scalar double-precision floating-point values to a doubleword integer.\nCVTTSD2SI Convert with truncation scalar double-precision floating-point values to scalar doubleword \n\nintegers.\nCVTSI2SD Convert doubleword integer to scalar double-precision floating-point value.\n\n5.6.2 SSE2 Packed Single-Precision Floating-Point Instructions\nSSE2 packed single-precision floating-point instructions perform conversion operations on single-precision \nfloating-point and integer operands. These instructions represent enhancements to the SSE single-precision \nfloating-point instructions.\nCVTDQ2PS Convert packed doubleword integers to packed single-precision floating-point values.\nCVTPS2DQ Convert packed single-precision floating-point values to packed doubleword integers.\nCVTTPS2DQ Convert with truncation packed single-precision floating-point values to packed double-\n\nword integers.\n\n5.6.3 SSE2 128-Bit SIMD Integer Instructions\nSSE2 SIMD integer instructions perform additional operations on packed words, doublewords, and quadwords \ncontained in XMM and MMX registers.\nMOVDQA Move aligned double quadword.\nMOVDQU Move unaligned double quadword.\nMOVQ2DQ Move quadword integer from MMX to XMM registers.\nMOVDQ2Q Move quadword integer from XMM to MMX registers.\nPMULUDQ Multiply packed unsigned doubleword integers.\nPADDQ Add packed quadword integers.\nPSUBQ Subtract packed quadword integers.\nPSHUFLW Shuffle packed low words.\nPSHUFHW Shuffle packed high words.\nPSHUFD Shuffle packed doublewords.\nPSLLDQ Shift double quadword left logical.\nPSRLDQ Shift double quadword right logical.\nPUNPCKHQDQ Unpack high quadwords.\nPUNPCKLQDQ Unpack low quadwords.\n\n5.6.4 SSE2 Cacheability Control and Ordering Instructions\nSSE2 cacheability control instructions provide additional operations for caching of non-temporal data when storing \ndata from XMM registers to memory. LFENCE and MFENCE provide additional control of instruction ordering on \nstore operations.\nCLFLUSH See Section 5.1.13.\nLFENCE Serializes load operations.\nMFENCE Serializes load and store operations.\nPAUSE Improves the performance of “spin-wait loops”.\nMASKMOVDQU Non-temporal store of selected bytes from an XMM register into memory.\nMOVNTPD Non-temporal store of two packed double-precision floating-point values from an XMM \n\nregister into memory.\nMOVNTDQ Non-temporal store of double quadword from an XMM register into memory.\nVol. 1 5-21\n\n\n\nINSTRUCTION SET SUMMARY\nMOVNTI Non-temporal store of a doubleword from a general-purpose register into memory.\n\n5.7 SSE3 INSTRUCTIONS\nThe SSE3 extensions offers 13 instructions that accelerate performance of Streaming SIMD Extensions technology, \nStreaming SIMD Extensions 2 technology, and x87-FP math capabilities. These instructions can be grouped into the \nfollowing categories:\n• One x87FPU instruction used in integer conversion.\n• One SIMD integer instruction that addresses unaligned data loads.\n• Two SIMD floating-point packed ADD/SUB instructions.\n• Four SIMD floating-point horizontal ADD/SUB instructions.\n• Three SIMD floating-point LOAD/MOVE/DUPLICATE instructions.\n• Two thread synchronization instructions.\n\nSSE3 instructions can only be executed on Intel 64 and IA-32 processors that support SSE3 extensions. Support \nfor these instructions can be detected with the CPUID instruction. See the description of the CPUID instruction in \nChapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 2A.\n\nThe sections that follow describe each subgroup.\n\n5.7.1 SSE3 x87-FP Integer Conversion Instruction\nFISTTP Behaves like the FISTP instruction but uses truncation, irrespective of the rounding mode \n\nspecified in the floating-point control word (FCW).\n\n5.7.2 SSE3 Specialized 128-bit Unaligned Data Load Instruction\nLDDQU Special 128-bit unaligned load designed to avoid cache line splits.\n\n5.7.3 SSE3 SIMD Floating-Point Packed ADD/SUB Instructions\nADDSUBPS Performs single-precision addition on the second and fourth pairs of 32-bit data elements \n\nwithin the operands; single-precision subtraction on the first and third pairs.\nADDSUBPD Performs double-precision addition on the second pair of quadwords, and double-precision \n\nsubtraction on the first pair.\n\n5.7.4 SSE3 SIMD Floating-Point Horizontal ADD/SUB Instructions\nHADDPS Performs a single-precision addition on contiguous data elements. The first data element of \n\nthe result is obtained by adding the first and second elements of the first operand; the \nsecond element by adding the third and fourth elements of the first operand; the third by \nadding the first and second elements of the second operand; and the fourth by adding the \nthird and fourth elements of the second operand.\n\nHSUBPS Performs a single-precision subtraction on contiguous data elements. The first data \nelement of the result is obtained by subtracting the second element of the first operand \nfrom the first element of the first operand; the second element by subtracting the fourth \nelement of the first operand from the third element of the first operand; the third by \nsubtracting the second element of the second operand from the first element of the second \noperand; and the fourth by subtracting the fourth element of the second operand from the \nthird element of the second operand.\n5-22 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nHADDPD Performs a double-precision addition on contiguous data elements. The first data element \nof the result is obtained by adding the first and second elements of the first operand; the \nsecond element by adding the first and second elements of the second operand.\n\nHSUBPD Performs a double-precision subtraction on contiguous data elements. The first data \nelement of the result is obtained by subtracting the second element of the first operand \nfrom the first element of the first operand; the second element by subtracting the second \nelement of the second operand from the first element of the second operand.\n\n5.7.5 SSE3 SIMD Floating-Point LOAD/MOVE/DUPLICATE Instructions\nMOVSHDUP Loads/moves 128 bits; duplicating the second and fourth 32-bit data elements.\nMOVSLDUP Loads/moves 128 bits; duplicating the first and third 32-bit data elements.\nMOVDDUP Loads/moves 64 bits (bits[63:0] if the source is a register) and returns the same 64 bits in \n\nboth the lower and upper halves of the 128-bit result register; duplicates the 64 bits from \nthe source.\n\n5.7.6 SSE3 Agent Synchronization Instructions\nMONITOR Sets up an address range used to monitor write-back stores.\nMWAIT Enables a logical processor to enter into an optimized state while waiting for a write-back \n\nstore to the address range set up by the MONITOR instruction.\n\n5.8 SUPPLEMENTAL STREAMING SIMD EXTENSIONS 3 (SSSE3) INSTRUCTIONS\nSSSE3 provide 32 instructions (represented by 14 mnemonics) to accelerate computations on packed integers. \nThese include:\n• Twelve instructions that perform horizontal addition or subtraction operations.\n• Six instructions that evaluate absolute values.\n• Two instructions that perform multiply and add operations and speed up the evaluation of dot products.\n• Two instructions that accelerate packed-integer multiply operations and produce integer values with scaling.\n• Two instructions that perform a byte-wise, in-place shuffle according to the second shuffle control operand.\n• Six instructions that negate packed integers in the destination operand if the signs of the corresponding \n\nelement in the source operand is less than zero.\n• Two instructions that align data from the composite of two operands.\n\nSSSE3 instructions can only be executed on Intel 64 and IA-32 processors that support SSSE3 extensions. Support \nfor these instructions can be detected with the CPUID instruction. See the description of the CPUID instruction in \nChapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s \nManual, Volume 2A.\n\nThe sections that follow describe each subgroup.\n\n5.8.1 Horizontal Addition/Subtraction\nPHADDW Adds two adjacent, signed 16-bit integers horizontally from the source and destination \n\noperands and packs the signed 16-bit results to the destination operand.\nPHADDSW Adds two adjacent, signed 16-bit integers horizontally from the source and destination \n\noperands and packs the signed, saturated 16-bit results to the destination operand.\nPHADDD Adds two adjacent, signed 32-bit integers horizontally from the source and destination \n\noperands and packs the signed 32-bit results to the destination operand.\nPHSUBW Performs horizontal subtraction on each adjacent pair of 16-bit signed integers by \n\nsubtracting the most significant word from the least significant word of each pair in the \nVol. 1 5-23\n\n\n\nINSTRUCTION SET SUMMARY\nsource and destination operands. The signed 16-bit results are packed and written to the \ndestination operand.\n\nPHSUBSW Performs horizontal subtraction on each adjacent pair of 16-bit signed integers by \nsubtracting the most significant word from the least significant word of each pair in the \nsource and destination operands. The signed, saturated 16-bit results are packed and \nwritten to the destination operand.\n\nPHSUBD Performs horizontal subtraction on each adjacent pair of 32-bit signed integers by \nsubtracting the most significant doubleword from the least significant double word of each \npair in the source and destination operands. The signed 32-bit results are packed and \nwritten to the destination operand.\n\n5.8.2 Packed Absolute Values\nPABSB Computes the absolute value of each signed byte data element.\nPABSW Computes the absolute value of each signed 16-bit data element.\nPABSD Computes the absolute value of each signed 32-bit data element. \n\n5.8.3 Multiply and Add Packed Signed and Unsigned Bytes\nPMADDUBSW Multiplies each unsigned byte value with the corresponding signed byte value to produce \n\nan intermediate, 16-bit signed integer. Each adjacent pair of 16-bit signed values are \nadded horizontally. The signed, saturated 16-bit results are packed to the destination \noperand.\n\n5.8.4 Packed Multiply High with Round and Scale\nPMULHRSW Multiplies vertically each signed 16-bit integer from the destination operand with the corre-\n\nsponding signed 16-bit integer of the source operand, producing intermediate, signed 32-\nbit integers. Each intermediate 32-bit integer is truncated to the 18 most significant bits. \nRounding is always performed by adding 1 to the least significant bit of the 18-bit interme-\ndiate result. The final result is obtained by selecting the 16 bits immediately to the right of \nthe most significant bit of each 18-bit intermediate result and packed to the destination \noperand.\n\n5.8.5 Packed Shuffle Bytes\nPSHUFB Permutes each byte in place, according to a shuffle control mask. The least significant \n\nthree or four bits of each shuffle control byte of the control mask form the shuffle index. \nThe shuffle mask is unaffected. If the most significant bit (bit 7) of a shuffle control byte is \nset, the constant zero is written in the result byte.\n\n5.8.6 Packed Sign\nPSIGNB/W/D Negates each signed integer element of the destination operand if the sign of the corre-\n\nsponding data element in the source operand is less than zero.\n\n5.8.7 Packed Align Right\nPALIGNR Source operand is appended after the destination operand forming an intermediate value \n\nof twice the width of an operand. The result is extracted from the intermediate value into \nthe destination operand by selecting the 128 bit or 64 bit value that are right-aligned to the \nbyte offset specified by the immediate value.\n5-24 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\n5.9 SSE4 INSTRUCTIONS\nIntel® Streaming SIMD Extensions 4 (SSE4) introduces 54 new instructions. 47 of the SSE4 instructions are \nreferred to as SSE4.1 in this document, 7 new SSE4 instructions are referred to as SSE4.2. \n\nSSE4.1 is targeted to improve the performance of media, imaging, and 3D workloads. SSE4.1 adds instructions \nthat improve compiler vectorization and significantly increase support for packed dword computation. The tech-\nnology also provides a hint that can improve memory throughput when reading from uncacheable WC memory \ntype.\n\nThe 47 SSE4.1 instructions include:\n• Two instructions perform packed dword multiplies.\n• Two instructions perform floating-point dot products with input/output selects.\n• One instruction performs a load with a streaming hint.\n• Six instructions simplify packed blending.\n• Eight instructions expand support for packed integer MIN/MAX.\n• Four instructions support floating-point round with selectable rounding mode and precision exception override.\n• Seven instructions improve data insertion and extractions from XMM registers\n• Twelve instructions improve packed integer format conversions (sign and zero extensions).\n• One instruction improves SAD (sum absolute difference) generation for small block sizes.\n• One instruction aids horizontal searching operations.\n• One instruction improves masked comparisons.\n• One instruction adds qword packed equality comparisons.\n• One instruction adds dword packing with unsigned saturation.\n\nThe SSE4.2 instructions operating on XMM registers include:\n• String and text processing that can take advantage of single-instruction multiple-data programming \n\ntechniques.\n• A SIMD integer instruction that enhances the capability of the 128-bit integer SIMD capability in SSE4.1.\n\n5.10 SSE4.1 INSTRUCTIONS\nSSE4.1 instructions can use an XMM register as a source or destination. Programming SSE4.1 is similar to \nprogramming 128-bit Integer SIMD and floating-point SIMD instructions in SSE/SSE2/SSE3/SSSE3. SSE4.1 does \nnot provide any 64-bit integer SIMD instructions operating on MMX registers. The sections that follow describe \neach subgroup.\n\n5.10.1 Dword Multiply Instructions \nPMULLD Returns four lower 32-bits of the 64-bit results of signed 32-bit integer multiplies.\nPMULDQ Returns two 64-bit signed result of signed 32-bit integer multiplies.\n\n5.10.2 Floating-Point Dot Product Instructions\nDPPD Perform double-precision dot product for up to 2 elements and broadcast.\nDPPS Perform single-precision dot products for up to 4 elements and broadcast.\n\n5.10.3 Streaming Load Hint Instruction\nMOVNTDQA Provides a non-temporal hint that can cause adjacent 16-byte items within an aligned 64-\n\nbyte region (a streaming line) to be fetched and held in a small set of temporary buffers \nVol. 1 5-25\n\n\n\nINSTRUCTION SET SUMMARY\n(“streaming load buffers”). Subsequent streaming loads to other aligned 16-byte items in \nthe same streaming line may be supplied from the streaming load buffer and can improve \nthroughput.\n\n5.10.4 Packed Blending Instructions\nBLENDPD Conditionally copies specified double-precision floating-point data elements in the source \n\noperand to the corresponding data elements in the destination, using an immediate byte \ncontrol. \n\nBLENDPS Conditionally copies specified single-precision floating-point data elements in the source \noperand to the corresponding data elements in the destination, using an immediate byte \ncontrol.\n\nBLENDVPD Conditionally copies specified double-precision floating-point data elements in the source \noperand to the corresponding data elements in the destination, using an implied mask. \n\nBLENDVPS Conditionally copies specified single-precision floating-point data elements ","extracted_metadata":{"pdf:PDFVersion":["1.6"],"access_permission:extract_for_accessibility":["true"],"X-TIKA:EXCEPTION:write_limit_reached":["true"],"pdf:docinfo:modified":["2021-06-28T21:13:42Z"],"xmpMM:DocumentID":["uuid:f01d258b-da68-460f-9726-fe37142e8506"],"xmp:ModifyDate":["2021-06-28T21:13:42Z"],"pdf:hasMarkedContent":["false"],"Content-Type":["application/pdf"],"xmp:CreateDate":["2021-06-28T12:21:04Z"],"access_permission:extract_content":["true"],"xmp:CreatorTool":["FrameMaker 10.0.2"],"dc:creator":["Intel Corporation"],"dcterms:created":["2021-06-28T12:21:04Z"],"resourceName":["Intel 64 and IA-32 Architectures Software Developer's Manual - Combined Volumes 1-4 - June 2021 (325462-sdm-vol-1-2abcd-3abcd).pdf"],"access_permission:fill_in_form":["true"],"xmpTPg:NPages":["4778"],"X-TIKA:Parsed-By":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"pdf:docinfo:title":["Intel(R) 64 and IA-32 Architectures Software Developer's Manual, Combined Volumes: 1, 2ABCD, 3ABCD, and 4"],"pdf:unmappedUnicodeCharsPerPage":["0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0"],"Content-Length":["52916900"],"access_permission:modify_annotations":["true"],"X-TIKA:Parsed-By-Full-Set":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"dc:title":["Intel(R) 64 and IA-32 Architectures Software Developer's Manual, Combined Volumes: 1, 2ABCD, 3ABCD, and 4"],"pdf:charsPerPage":["510","1733","463","1733","9242","10567","11233","11450","10983","11312","11084","10649","10927","10604","10692","10169","10690","8265","462","11000","10871","400","10551","10613","2871","22","2568","2086","4320","4108","4071","2397","2164","1328","2431","27","2904","3939","3523","2946","3163","2884","1996","3298","1608","3739","1888","2755","2537","3961","2333","1947","2884","2623","1122","2939","2511","1839","1659","1475","1543","1598","1464","1579","3697","4232","894","3924","2178","1567","3048","2091","4238","4063","1662","2404","4010","2111","3177","2618","3951","4067","2324","2695","2238","3044","3507","1847","1345","2434","1404","2274","1872","2517","994","2047","718","2211","2716","779","2163","3080","3046","3759","4081","3223","3769","3645","2693","4067","3550","123","2355","3483","3120","3424","2191","1387","2159","1864","1566","2461","1939","1494","2203","2452","1844","3039","2906","2598","2876","2865","2474","2853","3336","2820","2747"],"access_permission:assemble_document":["true"],"access_permission:can_print":["true"],"pdf:docinfo:producer":["Acrobat Distiller 21.0 (Windows)"],"pdf:docinfo:creator_tool":["FrameMaker 10.0.2"],"dc:format":["application/pdf; version=1.6"],"access_permission:can_modify":["true"],"pdf:docinfo:created":["2021-06-28T12:21:04Z"],"pdf:docinfo:creator":["Intel Corporation"],"pdf:hasXMP":["true"],"xmp:MetadataDate":["2021-06-28T21:13:42Z"],"access_permission:can_print_degraded":["true"],"pdf:encrypted":["true"],"pdf:hasXFA":["false"],"dcterms:modified":["2021-06-28T21:13:42Z"],"pdf:hasCollection":["false"],"pdf:producer":["Acrobat Distiller 21.0 (Windows)"]},"metadata_field_count":40,"attempts":1,"timestamp":1754064876.4823854,"platform":"Linux","python_version":"3.13.5"},{"file_path":"test_documents/pdfs/Fundamentals_of_Deep_Learning_2014.pdf","file_size":56715281,"file_type":"pdf","category":"huge","framework":"extractous","iteration":0,"extraction_time":0.45452332496643066,"startup_time":null,"peak_memory_mb":412.49609375,"avg_memory_mb":469.74140625,"peak_cpu_percent":94.1,"avg_cpu_percent":36.82,"total_io_mb":null,"status":"success","character_count":38842,"word_count":4872,"error_type":null,"error_message":null,"quality_metrics":{"char_count":38842,"word_count":4872,"sentence_count":285,"paragraph_count":535,"avg_word_length":5.3273809523809526,"avg_sentence_length":17.428070175438595,"extraction_completeness":1.0,"text_coherence":0.6666666666666666,"noise_ratio":0.40676175274187737,"gibberish_ratio":0.006369426751592357,"flesch_reading_ease":30.866139586346748,"gunning_fog_index":17.539937445140875,"has_proper_formatting":true,"maintains_line_breaks":true,"preserves_whitespace":true,"table_structure_preserved":true,"format_specific_score":0.49999999999999994,"expected_content_preserved":false,"has_encoding_issues":true,"has_ocr_artifacts":true,"preserves_pdf_formatting":true},"overall_quality_score":0.5373445602423348,"extracted_text":"\nFundamentals\t\r  of\t\r  Deep\t\r  Learning\t\r  \nof\t\r  Representa5ons\t\r  \n\n\t\r  \t\r  \nTel-­‐Aviv\t\r  University\t\r  \n\nDeep\t\r  Learning\t\r  Master\t\r  Class\t\r  \t\r  \n\t\r  \n\nYoshua\t\r  Bengio\t\r  \t\r  \nNovember\t\r  7,\t\r  2014,\t\r  Tel-­‐Aviv\t\r  \n\n\t\r  \n\n\n\nUltimate Goal \n• Understand\t\r  the\t\r  principles\t\r  \ngiving\t\r  rise\t\r  to\t\r  intelligence\t\r  \n\n\t\r  \n\n2\t\r  \n\n\n\nFocus \n• \t\r  Learning:\t\r  mathema5cal\t\r  \nand\t\r  computa5onal\t\r  \nprinciples\t\r  allowing\t\r  one\t\r  to\t\r  \nlearn\t\r  from\t\r  examples\t\r  in\t\r  \norder\t\r  to\t\r  acquire\t\r  knowledge\t\r  \t\r  \n\n\t\r  \n3\t\r  \n\n\n\nBreakthrough \n• \t\r  Deep\t\r  Learning:\t\r  machine\t\r  \nlearning\t\r  algorithms\t\r  inspired\t\r  \nby\t\r  brains,\t\r  based\t\r  on\t\r  learning\t\r  \nmul5ple\t\r  levels\t\r  of\t\r  \nrepresenta5on\t\r  /\t\r  abstrac5on.\t\r  \n\n\t\r  \n4\t\r  \n\n\n\nImpact \nDeep\t\r  learning\t\r  has\t\r  revolu5onized\t\r  \t\r  \n• Speech\t\r  recogni5on\t\r  \n• Object\t\r  recogni5on\t\r  \nMore\t\r  coming,\t\r  including\t\r  other\t\r  \nareas\t\r  of\t\r  computer\t\r  vision,\t\r  NLP,\t\r  \nmachine\t\r  transla5on,\t\r  dialogue,\t\r  \nreinforcement\t\r  learning…\t\r  \n\t\r  \n5\t\r  \n\n\n\nTechnical Goals Hierarchy \n\nTo\t\r  reach\t\r  AI:\t\r  \n•  Needs\t\r  knowledge\t\r  \n•  Needs\t\r  learning\t\r   \t\r   \t\r   \t\r   \t\r   \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \n\n(involves\t\r  priors\t\r  +\t\r  op#miza#on/search\t\r  +\t\r  efficient\t\r  computa#on)\t\r  \n\n•  Needs\t\r  generaliza5on\t\r   \t\r   \t\r   \t\r   \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \n(guessing\t\r  where\t\r  probability\t\r  mass\t\r  concentrates)\t\r  \n\n•  Needs\t\r  ways\t\r  to\t\r  fight\t\r  the\t\r  curse\t\r  of\t\r  dimensionality\t\r  \n(exponenHally\t\r  many\t\r  configuraHons\t\r  of\t\r  the\t\r  variables\t\r  to\t\r  consider)\t\r  \n\n•  Needs\t\r  disentangling\t\r  the\t\r  underlying\t\r  explanatory\t\r  factors\t\r  \n(making\t\r  sense\t\r  of\t\r  the\t\r  data)\t\r  \n\n6\t\r  \n\n\n\nEasy Learning \n\nlearned function: prediction = f(x)\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n*\n\ntrue unknown function\n\n= example (x,y)*\n\nx\n\ny\n\n\n\nML 101. What We Are Fighting Against:  \nThe Curse of Dimensionality \n\n\t\r  \t\r  \t\r  To\t\r  generalize\t\r  locally,\t\r  \nneed\t\r  representaHve\t\r  \nexamples\t\r  for\t\r  all\t\r  \nrelevant\t\r  variaHons!\t\r  \n\n\t\r  \n\n\n\nNot Dimensionality so much as \nNumber of Variations \n\n•  Theorem:\t\r  Gaussian\t\r  kernel\t\r  machines\t\r  need\t\r  at\t\r  least\t\r  k\t\r  examples\t\r  \nto\t\r  learn\t\r  a\t\r  funcHon\t\r  that\t\r  has\t\r  2k\t\r  zero-­‐crossings\t\r  along\t\r  some\t\r  line\t\r  \n\n\t\r  \n\t\r  \n\t\r  \n\t\r  \n\t\r  \n•  Theorem:\t\r  For\t\r  a\t\r  Gaussian\t\r  kernel\t\r  machine\t\r  to\t\r  learn\t\r  some\t\r  \n\nmaximally\t\r  varying\t\r  funcHons\t\r  \t\r  over\t\r  d\t\r  inputs\t\r  requires\t\r  O(2d)\t\r  \nexamples\t\r  \n\n\t\r  \n\n(Bengio, Dellalleau & Le Roux 2007) \n\n\n\n10\t\r  \n\nFor AI Tasks: Manifold structure \n\n•  examples\t\r  concentrate\t\r  near\t\r  a\t\r  lower\t\r  dimensional\t\r  “manifold\t\r  \n•  Evidence:\t\r  most\t\r  input\t\r  configura5ons\t\r  are\t\r  unlikely\t\r  \n\n\n\n•  Good\t\r  features\t\r  essenHal\t\r  for\t\r  successful\t\r  ML:\t\r  90%\t\r  of\t\r  effort\t\r  \n\n•  HandcraYing\t\r  features\t\r  vs\t\r  learning\t\r  them\t\r  \n\n•  Good\t\r  representaHon?\t\r  \n•  guesses\t\r  \n\t\r  \t\r  \t\r  \t\r  \t\r  the\t\r  features\t\r  /\t\r  factors\t\r  /\t\r  causes\t\r  \n\nRepresentation Learning \n\n11\t\r  \n\nraw\t\r  \ninput\t\r  \ndata\t\r  \n\nrepresented\t\r  \nby\t\r  chosen\t\r  \nfeatures\t\r  \n\nMACHINE\t\r  \nLEARNING\t\r  \t\r  \n\nrepresented\t\r  \nby\t\r  learned\t\r  \nfeatures\t\r  \n\n\n\nInput\n\nHand-\ndesigned \nprogram\n\nOutput\n\nInput\n\nHand-\ndesigned \nfeatures\n\nMapping \nfrom \n\nfeatures\n\nOutput\n\nInput\n\nFeatures\n\nMapping \nfrom \n\nfeatures\n\nOutput\n\nInput\n\nSimplest \nfeatures\n\nMapping \nfrom \n\nfeatures\n\nOutput\n\nMost \ncomplex \nfeatures\n\nRule-based\nsystems\n\nClassic\nmachine\nlearning\n\nRepresentation\nlearning\n\nDeep\nlearning\n\nAutomating \nFeature Discovery \n\n12\t\r  \n\n\n\nLearning multiple levels of \nrepresentation \nThere\t\r  is\t\r  theoreHcal\t\r  and\t\r  empirical\t\r  evidence\t\r  in\t\r  favor\t\r  of\t\r  \nmulHple\t\r  levels\t\r  of\t\r  representaHon\t\r  \n\n\t\r  Exponen5al\t\r  gain\t\r  for\t\r  some\t\r  families\t\r  of\t\r  func5ons\t\r  \n\nBiologically\t\r  inspired\t\r  learning\t\r  \n\nBrain\t\r  has\t\r  a\t\r  deep\t\r  architecture\t\r  \n\nCortex\t\r  seems\t\r  to\t\r  have\t\r  a\t\r  \t\r  \ngeneric\t\r  learning\t\r  algorithm\t\r  \t\r  \n\nHumans\t\r  first\t\r  learn\t\r  simpler\t\r  \t\r  \nconcepts\t\r  and\t\r  compose\t\r  them\t\r  \n\nIt\t\r  works!\t\r  Speech\t\r  +\t\r  vision\t\r  breakthroughs\t\r  \n13\t\r  \n\n\n\nVisualizing and Understanding Convolutional Networks\n\n(a) (b)\n\n(c) (d) (e)\n\nFigure 6. (a): 1st layer features without feature scale clipping. Note that one feature dominates. (b): 1st layer features\nfrom (Krizhevsky et al., 2012). (c): Our 1st layer features. The smaller stride (2 vs 4) and filter size (7x7 vs 11x11)\nresults in more distinctive features and fewer “dead” features. (d): Visualizations of 2nd layer features from (Krizhevsky\net al., 2012). (e): Visualizations of our 2nd layer features. These are cleaner, with no aliasing artifacts that are visible in\n(d).\n\nCar wheel\nRacer\nCab\nPolice van\n\n \n\nPomeranian\nTennis ball\nKeeshond\nPekinese\n\nAfghan hound\nGordon setter\nIrish setter\nMortarboard\nFur coat\nAcademic gown\nAustralian terrier\nIce lolly\nVizsla\nNeck brace\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n0.8\n\n0.9\n\n \n\n \n\n0.05\n\n0.1\n\n0.15\n\n0.2\n\n0.25\n\nTrue Label: Pomeranian\n\n(a) Input Image (b) Layer 5, strongest feature map\n(c) Layer 5, strongest\nfeature map projections\n\n(d) Classifier, probability \nof correct class \n\n(e) Classifier, most \nprobable class \n\nTrue Label: Car Wheel\n\nTrue Label: Afghan Hound\n\nFigure 7. Three test examples where we systematically cover up di↵erent portions of the scene with a gray square (1st\ncolumn) and see how the top (layer 5) feature maps ((b) & (c)) and classifier output ((d) & (e)) changes. (b): for each\nposition of the gray scale, we record the total activation in one layer 5 feature map (the one with the strongest response\nin the unoccluded image). (c): a visualization of this feature map projected down into the input image (black square),\nalong with visualizations of this map from other images. The first row example shows the strongest feature to be the\ndog’s face. When this is covered-up the activity in the feature map decreases (blue area in (b)). (d): a map of correct\nclass probability, as a function of the position of the gray square. E.g. when the dog’s face is obscured, the probability\nfor “pomeranian” drops significantly. (e): the most probable label as a function of occluder position. E.g. in the 1st row,\nfor most locations it is “pomeranian”, but if the dog’s face is obscured but not the ball, then it predicts “tennis ball”. In\nthe 2nd example, text on the car is the strongest feature in layer 5, but the classifier is most sensitive to the wheel. The\n3rd example contains multiple objects. The strongest feature in layer 5 picks out the faces, but the classifier is sensitive\nto the dog (blue region in (d)), since it uses multiple feature maps.\n\nVisualizing and Understanding Convolutional Networks\n\n(a) (b)\n\n(c) (d) (e)\n\nFigure 6. (a): 1st layer features without feature scale clipping. Note that one feature dominates. (b): 1st layer features\nfrom (Krizhevsky et al., 2012). (c): Our 1st layer features. The smaller stride (2 vs 4) and filter size (7x7 vs 11x11)\nresults in more distinctive features and fewer “dead” features. (d): Visualizations of 2nd layer features from (Krizhevsky\net al., 2012). (e): Visualizations of our 2nd layer features. These are cleaner, with no aliasing artifacts that are visible in\n(d).\n\nCar wheel\nRacer\nCab\nPolice van\n\n \n\nPomeranian\nTennis ball\nKeeshond\nPekinese\n\nAfghan hound\nGordon setter\nIrish setter\nMortarboard\nFur coat\nAcademic gown\nAustralian terrier\nIce lolly\nVizsla\nNeck brace\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n0.8\n\n0.9\n\n \n\n \n\n0.05\n\n0.1\n\n0.15\n\n0.2\n\n0.25\n\nTrue Label: Pomeranian\n\n(a) Input Image (b) Layer 5, strongest feature map\n(c) Layer 5, strongest\nfeature map projections\n\n(d) Classifier, probability \nof correct class \n\n(e) Classifier, most \nprobable class \n\nTrue Label: Car Wheel\n\nTrue Label: Afghan Hound\n\nFigure 7. Three test examples where we systematically cover up di↵erent portions of the scene with a gray square (1st\ncolumn) and see how the top (layer 5) feature maps ((b) & (c)) and classifier output ((d) & (e)) changes. (b): for each\nposition of the gray scale, we record the total activation in one layer 5 feature map (the one with the strongest response\nin the unoccluded image). (c): a visualization of this feature map projected down into the input image (black square),\nalong with visualizations of this map from other images. The first row example shows the strongest feature to be the\ndog’s face. When this is covered-up the activity in the feature map decreases (blue area in (b)). (d): a map of correct\nclass probability, as a function of the position of the gray square. E.g. when the dog’s face is obscured, the probability\nfor “pomeranian” drops significantly. (e): the most probable label as a function of occluder position. E.g. in the 1st row,\nfor most locations it is “pomeranian”, but if the dog’s face is obscured but not the ball, then it predicts “tennis ball”. In\nthe 2nd example, text on the car is the strongest feature in layer 5, but the classifier is most sensitive to the wheel. The\n3rd example contains multiple objects. The strongest feature in layer 5 picks out the faces, but the classifier is sensitive\nto the dog (blue region in (d)), since it uses multiple feature maps.\n\nVisualizing and Understanding Convolutional Networks\n\n(a) (b)\n\n(c) (d) (e)\n\nFigure 6. (a): 1st layer features without feature scale clipping. Note that one feature dominates. (b): 1st layer features\nfrom (Krizhevsky et al., 2012). (c): Our 1st layer features. The smaller stride (2 vs 4) and filter size (7x7 vs 11x11)\nresults in more distinctive features and fewer “dead” features. (d): Visualizations of 2nd layer features from (Krizhevsky\net al., 2012). (e): Visualizations of our 2nd layer features. These are cleaner, with no aliasing artifacts that are visible in\n(d).\n\nCar wheel\nRacer\nCab\nPolice van\n\n \n\nPomeranian\nTennis ball\nKeeshond\nPekinese\n\nAfghan hound\nGordon setter\nIrish setter\nMortarboard\nFur coat\nAcademic gown\nAustralian terrier\nIce lolly\nVizsla\nNeck brace\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n0.8\n\n0.9\n\n \n\n \n\n0.05\n\n0.1\n\n0.15\n\n0.2\n\n0.25\n\nTrue Label: Pomeranian\n\n(a) Input Image (b) Layer 5, strongest feature map\n(c) Layer 5, strongest\nfeature map projections\n\n(d) Classifier, probability \nof correct class \n\n(e) Classifier, most \nprobable class \n\nTrue Label: Car Wheel\n\nTrue Label: Afghan Hound\n\nFigure 7. Three test examples where we systematically cover up di↵erent portions of the scene with a gray square (1st\ncolumn) and see how the top (layer 5) feature maps ((b) & (c)) and classifier output ((d) & (e)) changes. (b): for each\nposition of the gray scale, we record the total activation in one layer 5 feature map (the one with the strongest response\nin the unoccluded image). (c): a visualization of this feature map projected down into the input image (black square),\nalong with visualizations of this map from other images. The first row example shows the strongest feature to be the\ndog’s face. When this is covered-up the activity in the feature map decreases (blue area in (b)). (d): a map of correct\nclass probability, as a function of the position of the gray square. E.g. when the dog’s face is obscured, the probability\nfor “pomeranian” drops significantly. (e): the most probable label as a function of occluder position. E.g. in the 1st row,\nfor most locations it is “pomeranian”, but if the dog’s face is obscured but not the ball, then it predicts “tennis ball”. In\nthe 2nd example, text on the car is the strongest feature in layer 5, but the classifier is most sensitive to the wheel. The\n3rd example contains multiple objects. The strongest feature in layer 5 picks out the faces, but the classifier is sensitive\nto the dog (blue region in (d)), since it uses multiple feature maps.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisible layer\n(input pixels)\n\n1st hidden layer\n(edges)\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\n2nd hidden layer\n(corners and\n\ncontours)\n\n3rd hidden layer\n(object parts)\n\nCAR PERSON ANIMAL Output\n(object identity)\n\nComposing Features on Features \n\n14\t\r  \n\nHigher-­‐level\t\r  features\t\r  \n\nare\t\r  defined\t\r  in\t\r  terms\t\r  of\t\r  \n\nlower-­‐level\t\r  \n\nfeatures\t\r  \n\n\n\nGoogle Image Search: \nDifferent object types represented in the \nsame space \n\nGoogle:\t\r  \nS.\t\r  Bengio,\t\r  J.\t\r  \nWeston\t\r  &\t\r  N.\t\r  \nUsunier\t\r  \n\n(IJCAI\t\r  2011,\t\r  \nNIPS’2010,\t\r  \nJMLR\t\r  2010,\t\r  \nMLJ\t\r  2010)\t\r  \n\n\n\nFollowing up on (Bengio et al NIPS’2000) \nNeural word embeddings - visualization \n\n16\t\r  \n\n\n\nNeural Language Models \n•  Meanings\t\r  and\t\r  their\t\r  combinaHon\t\r  all\t\r  ‘learned’\t\r  together.\t\r  \n\nMinimal\t\r  structure\t\r  imposed.\t\r  \t\r  \n\t\r  \n\t\r  \n\t\r  \n\t\r  \nPouHne\t\r   \t\r  is\t\r   \t\r  a\t\r   \t\r  curious\t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  _____________\t\r  .\t\r  \n\n\t\r  \n\na1\t\r  \na2\t\r  \na3\t\r  \na4\t\r  \n….\t\r  \n\t\r  \n\nb1\t\r  \nb2\t\r  \nb3\t\r  \nb4\t\r  \n….\t\r  \n\t\r  \n\nc1\t\r  \nc2\t\r  \nc3\t\r  \nc4\t\r  \n….\t\r  \n\t\r  \n\nd1\t\r  \nd2\t\r  \nd3\t\r  \nd4\t\r  \n….\t\r  \n\t\r  \n\n\t\r  representaHon\t\r  \nx1\t\r  x2\t\r  x3\t\r  x4\t\r  x5\t\r  …\t\r  \n\nA\t\r  guess\t\r  \n\nPARAMETERS\t\r  \n\nMORE\t\r  \nPARAMETERS\t\r  \n\n\n\nAnalogical Representations for Free \n(Mikolov et al, ICLR 2013) \n\n•  SemanHc\t\r  relaHons\t\r  appear\t\r  as\t\r  linear\t\r  relaHonships\t\r  in\t\r  the\t\r  space\t\r  of\t\r  \nlearned\t\r  representaHons\t\r  \n\n•  King\t\r  –\t\r  Queen\t\r  ≈\t\r  \t\r  Man\t\r  –\t\r  Woman\t\r  \n•  Paris\t\r  –\t\r  France\t\r  +\t\r  Italy\t\r  ≈\t\r  Rome\t\r  \n\n18\t\r  \n\nParis\t\r  \n\nFrance\t\r  \nItaly\t\r  \n\nRome\t\r  \n\n\n\nThe Next Challenge: Rich Semantic \nRepresentations for Word Sequences \n\n•  Impressive\t\r  progress\t\r  in\t\r  \ncapturing\t\r  word\t\r  semanHcs\t\r  \nEasier\t\r  learning:\t\r  non-­‐parametric\t\r  \n(table\t\r  look-­‐up)\t\r  \n\n•  OpHmizaHon\t\r  challenge\t\r  for\t\r  \nmapping\t\r  sequences\t\r  to\t\r  rich\t\r  &\t\r  \ncomplete\t\r  representaHons\t\r  \n\n•  Good\t\r  test\t\r  case:\t\r  machine\t\r  \ntranslaHon\t\r  \n\n19\t\r  \n\n\n\nBreakthroughs in Machine Translation \n\n•  (Cho\t\r  et\t\r  al,\t\r  EMNLP\t\r  2014)\t\r  Learning\t\r  Phrase\t\r  RepresentaHons\t\r  using\t\r  \nRNN\t\r  Encoder–Decoder\t\r  for\t\r  StaHsHcal\t\r  Machine\t\r  TranslaHon\t\r  \t\r  \n\n•  (Sutskever\t\r  et\t\r  al,\t\r  NIPS\t\r  2014)\t\r  Sequence\t\r  to\t\r  sequence\t\r  learning\t\r  with\t\r  \nneural\t\r  networks,\t\r  3\t\r  BLEU\t\r  points\t\r  improvement\t\r  for\t\r  English-­‐French\t\r  \n\n•  (Devlin\t\r  et\t\r  al,\t\r  ACL\t\r  2014)\t\r  Fast\t\r  and\t\r  Robust\t\r  Neural\t\r  Network\t\r  Joint\t\r  \nModels\t\r  for\t\r  StaHsHcal\t\r  Machine\t\r  TranslaHon\t\r  \t\r  \n\nBest\t\r  paper\t\r  award,\t\r  6\t\r  BLEU\t\r  points\t\r  improvement\t\r  for\t\r  Arabic-­‐English\t\r  \n\n20\t\r  \n\n�� �� ��\n\n��� �� ��\n\n�\n\n�\t�\n�\t�\n\n\r��\n�\t�\n\nFrench\t\r  \nencoder\t\r  \n\nEnglish\t\r  \ndecoder\t\r  \n\nFrench\t\r  sentence\t\r  \n\nEnglish\t\r  sentence\t\r  \n\nEnglish\t\r  \nencoder\t\r  \n\nEnglish\t\r  \ndecoder\t\r  \n\nEnglish\t\r  sentence\t\r  \n\nEnglish\t\r  sentence\t\r  \n\nFo\nr\t\r  b\n\nite\nxt\n\t\r  d\nat\na\t\r  \n\nFo\nr\t\r  u\n\nni\nlin\ngu\nal\n\t\r  d\nat\na\t\r  \n\n\n\nmain \n\nsubroutine1 includes \nsubsub1 code and \nsubsub2 code and \nsubsubsub1 code \n\n“Shallow” computer program \n\nsubroutine2 includes \nsubsub2 code and \nsubsub3 code and \nsubsubsub3 code and … \n\n\n\nmain \n\nsub1 sub2 sub3 \n\nsubsub1 subsub2 subsub3 \n\nsubsubsub1 subsubsub2 \nsubsubsub3 \n\n“Deep” computer program \n\n\n\nSharing Components in a Deep \nArchitecture \n\nSum-­‐product\t\r  \nnetwork\t\r  \n\nPolynomial\t\r  expressed\t\r  with\t\r  shared\t\r  components:\t\r  advantage\t\r  of\t\r  \ndepth\t\r  may\t\r  grow\t\r  exponenHally\t\r  \t\r  \n\t\r  \n\nTheorems\t\r  in\t\r  \t\r  \n(Bengio\t\r  &\t\r  Delalleau,\t\r  ALT\t\r  2011;\t\r  \nDelalleau\t\r  &\t\r  Bengio\t\r  NIPS\t\r  2011)\t\r  \n\n\n\nDeep Architectures are More \nExpressive \nTheoreHcal\t\r  arguments:\t\r  \n\n…\t\r  \n1\t\r   2\t\r   3\t\r   2n \n\n1\t\r   2\t\r   3\t\r  \n…\t\r  \n\nn\t\r  \n\n= universal approximator 2 layers of \nLogic gates \nFormal neurons \nRBF units \n\nTheorems on advantage of depth: \n(Hastad et al 86 & 91, Bengio et al 2007, \nBengio & Delalleau 2011, Braverman 2011, \nPascanu et al 2014) \n\nSome functions compactly \nrepresented with k layers may \nrequire exponential size with 2 \nlayers \n\nRBMs & auto-encoders = universal approximator \n\n\n\nNew theoretical result: \nExpressiveness of deep nets with \npiecewise-linear activation fns \n\n25\t\r  \n\n(Pascanu,\t\r  Montufar,\t\r  Cho\t\r  &\t\r  Bengio;\t\r  ICLR\t\r  2014)\t\r  \n\nDeeper\t\r  nets\t\r  with\t\r  recHfier/maxout\t\r  units\t\r  are\t\r  exponenHally\t\r  more\t\r  \nexpressive\t\r  than\t\r  shallow\t\r  ones\t\r  (1\t\r  hidden\t\r  layer)\t\r  because\t\r  they\t\r  can\t\r  split\t\r  \nthe\t\r  input\t\r  space\t\r  in\t\r  many\t\r  more\t\r  (not-­‐independent)\t\r  linear\t\r  regions,\t\r  with\t\r  \nconstraints,\t\r  e.g.,\t\r  with\t\r  abs\t\r  units,\t\r  each\t\r  unit\t\r  creates\t\r  mirror\t\r  responses,\t\r  \nfolding\t\r  the\t\r  input\t\r  space:\t\r  \t\r  \n\n\t\r  \n\n\t\r  \n\n\n\n•  Clustering,\t\r  Nearest-­‐\nNeighbors,\t\r  RBF\t\r  SVMs,\t\r  local\t\r  \nnon-­‐parametric\t\r  density\t\r  \nesHmaHon\t\r  &\t\r  predicHon,\t\r  \ndecision\t\r  trees,\t\r  etc.\t\r  \n\n•  Parameters\t\r  for\t\r  each\t\r  \ndisHnguishable\t\r  region\t\r  \n\n•  #\t\r  of\t\r  dis5nguishable\t\r  regions\t\r  \nis\t\r  linear\t\r  in\t\r  #\t\r  of\t\r  parameters\t\r  \n\nNon-distributed representations \n\nClustering\t\r  \n\n26\t\r  \n\nà\t\r  No\t\r  non-­‐trivial\t\r  generalizaHon\t\r  to\t\r  regions\t\r  without\t\r  examples\t\r  \n\n\n\n•  Factor\t\r  models,\t\r  PCA,\t\r  RBMs,\t\r  \nNeural\t\r  Nets,\t\r  Sparse\t\r  Coding,\t\r  \nDeep\t\r  Learning,\t\r  etc.\t\r  \n\n•  Each\t\r  parameter\t\r  influences\t\r  \nmany\t\r  regions,\t\r  not\t\r  just\t\r  local\t\r  \nneighbors\t\r  \n\n•  #\t\r  of\t\r  dis5nguishable\t\r  regions\t\r  \ngrows\t\r  almost\t\r  exponen5ally\t\r  \nwith\t\r  #\t\r  of\t\r  parameters\t\r  \n\n•  GENERALIZE\t\r  NON-­‐LOCALLY\t\r  \nTO\t\r  NEVER-­‐SEEN\t\r  REGIONS\t\r  \n\nThe need for distributed \nrepresentations \n\nMulH-­‐\t\r  \nClustering\t\r  \n\n27\t\r  \n\nC1\t\r   C2\t\r   C3\t\r  \n\ninput\t\r  \n\nNon-­‐mutually\t\r  \nexclusive\t\r  features/\navributes\t\r  create\t\r  a\t\r  \ncombinatorially\t\r  large\t\r  \nset\t\r  of\t\r  disHnguiable\t\r  \nconfiguraHons\t\r  \n\n\n\nThe need for distributed \nrepresentations \n\nMulH-­‐\t\r  \nClustering\t\r  Clustering\t\r  \n\n28\t\r  \n\nLearning\t\r  a\t\r  set\t\r  of\t\r  features\t\r  that\t\r  are\t\r  not\t\r  mutually\t\r  exclusive\t\r  \ncan\t\r  be\t\r  exponenHally\t\r  more\t\r  staHsHcally\t\r  efficient\t\r  than\t\r  \nhaving\t\r  nearest-­‐neighbor-­‐like\t\r  or\t\r  clustering-­‐like\t\r  models\t\r  \n\n\n\nMontréal \nToronto \n\nBengio \n\nHinton \nLe Cun \n\nMajor Breakthrough in 2006 \n\n•  Ability\t\r  to\t\r  train\t\r  deep\t\r  architectures\t\r  by\t\r  \nusing\t\r  layer-­‐wise\t\r  unsupervised\t\r  \nlearning,\t\r  whereas\t\r  previous\t\r  purely\t\r  \nsupervised\t\r  avempts\t\r  had\t\r  failed\t\r  \n\n•  Unsupervised\t\r  feature\t\r  learners:\t\r  \n•  RBMs\t\r  \n•  Auto-­‐encoder\t\r  variants\t\r  \n•  Sparse\t\r  coding\t\r  variants\t\r  \n\nNew York \n29\t\r   (Bengio\t\r  &\t\r  LeCun\t\r  2007),\t\r  Scaling\t\r  Learning\t\r  Algorithms\t\r  towards\t\r  AI\t\r  \t\r  \n\n\n\nIssues with Back-Prop \n•  In\t\r  very\t\r  deep\t\r  nets\t\r  or\t\r  recurrent\t\r  nets\t\r  with\t\r  many\t\r  steps,\t\r  \nnon-­‐lineariHes\t\r  compose\t\r  and\t\r  yield\t\r  sharp\t\r  non-­‐linearity\t\r  \nà\t\r  gradients\t\r  vanish\t\r  or\t\r  explode\t\r  \n\n•  Training\t\r  deeper\t\r  nets:\t\r  harder\t\r  opHmizaHon\t\r  \n•  In\t\r  the\t\r  extreme\t\r  of\t\r  non-­‐linearity:\t\r  discrete\t\r  funcHons,\t\r  \ncan’t\t\r  use\t\r  back-­‐prop\t\r  \n\n•  Not\t\r  biologically\t\r  plausible?\t\r  \n\n¢\t\r   =\t\r  ¢\t\r   …\t\r  \n\n\n\n31\t\r  \n\nEffect of Initial Conditions \nin Deep Nets \n\n•  (Erhan\t\r  et\t\r  al\t\r  2009,\t\r  JMLR)\t\r  \n•  Supervised\t\r  deep\t\r  net\t\r  with\t\r  vs\t\r  w/o\t\r  \t\r  \n\t\r  \t\r  unsupervised\t\r  pre-­‐training\t\r  èvery\t\r  different\t\r  minima\t\r  \n\nNeural\t\r  net\t\r  trajectories\t\r  in\t\r  \t\r  \nfuncHon\t\r  space,\t\r  visualized\t\r  by\t\r  \nt-­‐SNE\t\r  \n\nNo\t\r  two\t\r  training\t\r  trajectories\t\r  \nend\t\r  up\t\r  in\t\r  the\t\r  same\t\r  place\t\r  à\t\r  \nhuge\t\r  number\t\r  of\t\r  effecHve\t\r  \nlocal\t\r  minima\t\r  \n\nw/o\t\r  unsupervised\t\r  pre-­‐training\t\r  \n\nwith\t\r  unsupervised\t\r  pre-­‐training\t\r  \n\n\n\nOrder & Selection of Examples Matters \n(Bengio,\t\r  Louradour,\t\r  Collobert\t\r  &\t\r  Weston,\t\r  ICML’2009)\t\r  \t\r  \t\r  \t\r  A\t\r  \n\n• Curriculum\t\r  learning\t\r  \t\r  \n•  (Bengio\t\r  et\t\r  al\t\r  2009,\t\r  Krueger\t\r  &\t\r  Dayan\t\r  2009)\t\r  \t\r  \t\r  \n\n•  Start\t\r  with\t\r  easier\t\r  examples\t\r  \n\n•  Faster\t\r  convergence\t\r  to\t\r  a\t\r  bever\t\r  local\t\r  \nminimum\t\r  in\t\r  deep\t\r  architectures\t\r  \n\n!\"#$%\n\n&%\n\n&\"!$%\n\n&\"$%\n\n'% $''% ('''% ($''%\n\n!\"\n#\n$%\n&\n'\n(\n)'\n*\n+\n,)\n-\n\"\n%.\n/)\n\n01!!1\"'))\n\n23.&,*4)\n\n)*++,)*-*.%\n\n/01)*++,)*-*.%\n\n!\"#$%\n\n&%\n\n&\"!$%\n\n&\"$%\n\n'% $''% ('''% ($''%\n\n!\"\n#\n$%\n&\n'\n(\n)'\n*\n+\n,)\n-\n\"\n%.\n/)\n\n01!!1\"'))\n\n23.&,*4)\n\n)*++,)*-*.%\n\n/01)*++,)*-*.%\n\n32\t\r  \n\n\n\nCurriculum Learning \n\nGuided learning helps training humans and animals  \n\n Shaping \n\n \n\nStart from simpler examples / easier tasks   (Piaget 1952, Skinner 1958) \n\nEducation \n\n \n\n\n\nContinuation Methods \n\nTrack local minima \n\n \n\nFinal solution \n\n \n\nEasy to find minimum \n\n \n\n\n\nGuided Training, Intermediate \nConcepts \n\n•  In\t\r  (Gulcehre\t\r  &\t\r  Bengio\t\r  ICLR’2013)\t\r  we\t\r  set\t\r  up\t\r  a\t\r  task\t\r  that\t\r  seems\t\r  \nalmost\t\r  impossible\t\r  to\t\r  learn\t\r  by\t\r  shallow\t\r  nets,\t\r  deep\t\r  nets,\t\r  SVMs,\t\r  \ntrees,\t\r  boosHng\t\r  etc\t\r  \n\n•  Breaking\t\r  the\t\r  problem\t\r  in\t\r  two\t\r  sub-­‐problems\t\r  and\t\r  pre-­‐training\t\r  \neach\t\r  module\t\r  separately,\t\r  then\t\r  fine-­‐tuning,\t\r  nails\t\r  it\t\r  \n\n•  Need\t\r  prior\t\r  knowledge\t\r  to\t\r  decompose\t\r  the\t\r  task\t\r  \n•  Guided\t\r  pre-­‐training\t\r  allows\t\r  to\t\r  find\t\r  much\t\r  bever\t\r  soluHons,\t\r  escape\t\r  \n\neffecHve\t\r  local\t\r  minima\t\r  \n\n35\t\r  \n\nHINTS\t\r  \n\n\n\n•  TradiHonal\t\r  thinking\t\r  is\t\r  that\t\r  major\t\r  obstacle\t\r  for\t\r  training\t\r  deep\t\r  nets\t\r  is\t\r  \nlocal\t\r  minima\t\r  \n\n•  TheoreHcal\t\r  and\t\r  empirical\t\r  evidence\t\r  suggest\t\r  instead\t\r  that\t\r  saddle\t\r  \npoints\t\r  are\t\r  exponenHally\t\r  more\t\r  prevalent\t\r  criHcal\t\r  points,\t\r  and\t\r  local\t\r  \nminima\t\r  tend\t\r  to\t\r  be\t\r  of\t\r  cost\t\r  near\t\r  that\t\r  of\t\r  global\t\r  minimum\t\r  \n\n•  (Pascanu,\t\r  Dauphin,\t\r  Ganguli,\t\r  Bengio\t\r  2014):\t\r  On\t\r  the\t\r  saddle\t\r  point\t\r  \nproblem\t\r  for\t\r  non-­‐convex\t\r  opNmizaNon.\t\r  \t\r  \t\r  \n\nSaddle Points, not Local Minima \n\n36\t\r  \n\n\n\nCIFAR\t\r  MNIST\t\r  \n\nSaddle Points \n\n•  Local\t\r  minima\t\r  dominate\t\r  in\t\r  low-­‐D,\t\r  but\t\r  \nsaddle\t\r  points\t\r  dominate\t\r  in\t\r  high-­‐D\t\r  \n\n•  Most\t\r  local\t\r  minima\t\r  are\t\r  close\t\r  to\t\r  the\t\r  \nbovom\t\r  (global\t\r  minimum\t\r  error)\t\r  \n\n37\t\r  \n\n\n\nIt is possible to escape saddle points! \n\n•  NIPS’2014\t\r  paper,\t\r  Dauphin\t\r  et\t\r  al.\t\r  \n•  More\t\r  work\t\r  is\t\r  ongoing\t\r  to\t\r  make\t\r  it\t\r  online\t\r  \n•  Challenge:\t\r  track\t\r  the\t\r  most\t\r  negaHve\t\r  eigenvector,\t\r  which\t\r  is\t\r  easy\t\r  in\t\r  \n\nbatch\t\r  mode\t\r  with\t\r  power\t\r  method,\t\r  if\t\r  we\t\r  also\t\r  track\t\r  most\t\r  posiHve,\t\r  \nvia\t\r  \t\r  \t\r  \n\n38\t\r  \n\nv  (H � �I)v\n\n\n\nSaddle-Free Optimization  \n(Dauphin et al NIPS’2014) \n\n•  Replace\t\r  eigenvalues\t\r  λ\t\r  of\t\r  Hessian\t\r  by\t\r  |λ|\t\r  \n\n39\t\r  \n\n\n\nDeep Supervised Neural Nets \n\n•  Now\t\r  can\t\r  train\t\r  them\t\r  even\t\r  without\t\r  \nunsupervised\t\r  pre-­‐training:\t\r  \t\r  \nbe]er\t\r  ini5aliza5on\t\r  and\t\r  non-­‐\nlineari5es\t\r  (recHfiers,\t\r  maxout),\t\r  \ngeneralize\t\r  well\t\r  with\t\r  large\t\r  labeled\t\r  \nsets\t\r  and\t\r  regularizers\t\r  (dropout)\t\r  \n\n•  Unsupervised\t\r  pre-­‐training:\t\r  \t\r  \nrare\t\r  classes,\t\r  transfer,\t\r  smaller\t\r  \nlabeled\t\r  sets,\t\r  or\t\r  as\t\r  extra\t\r  \nregularizer.\t\r  \n\n40\t\r  \n\n\n\nWhy Unsupervised Learning? \n\n•  Recent\t\r  progress\t\r  mostly\t\r  in\t\r  supervised\t\r  DL\t\r  \n•  \t\r  \t\r  \t\r  \t\r  real\t\r  challenges\t\r  for\t\r  unsupervised\t\r  DL\t\r  \n•  PotenHal\t\r  benefits:\t\r  \n\n•  Exploit\t\r  tons\t\r  of\t\r  unlabeled\t\r  data\t\r  \n•  Answer\t\r  new\t\r  quesHons\t\r  about\t\r  the\t\r  variables\t\r  observed\t\r  \n•  Regularizer\t\r  –\t\r  transfer\t\r  learning\t\r  –\t\r  domain\t\r  adaptaHon\t\r  \n•  Easier\t\r  opHmizaHon\t\r  (local\t\r  training\t\r  signal)\t\r  \n•  Structured\t\r  outputs\t\r  \n\n41\t\r  \n\nE\t\r  \n\n\n\nInvariance and Disentangling \n\n•  Invariant\t\r  features\t\r  \n\n•  Which\t\r  invariances?\t\r  \n\n•  AlternaHve:\t\r  learning\t\r  to\t\r  disentangle\t\r  factors\t\r  \n\n•  Good\t\r  disentangling\t\r  à\t\r  \t\r  \n\t\r  avoid\t\r  the\t\r  curse\t\r  of\t\r  dimensionality\t\r  \n\n42\t\r  \n\n\n\nEmergence of Disentangling \n•  (Goodfellow\t\r  et\t\r  al.\t\r  2009):\t\r  sparse\t\r  auto-­‐encoders\t\r  trained\t\r  \n\non\t\r  images\t\r  \t\r  \n•  some\t\r  higher-­‐level\t\r  features\t\r  more\t\r  invariant\t\r  to\t\r  \ngeometric\t\r  factors\t\r  of\t\r  variaHon\t\r  \t\r  \n\n•  (Glorot\t\r  et\t\r  al.\t\r  2011):\t\r  sparse\t\r  recHfied\t\r  denoising\t\r  auto-­‐\nencoders\t\r  trained\t\r  on\t\r  bags\t\r  of\t\r  words\t\r  for\t\r  senHment\t\r  \nanalysis\t\r  \n•  different\t\r  features\t\r  specialize\t\r  on\t\r  different\t\r  aspects\t\r  \n(domain,\t\r  senHment)\t\r  \n\n43\t\r  \n\nWHY?\t\r  \n\n\n\nHow do humans generalize \nfrom very few examples? \n\n44\t\r  \n\n•  They\t\r  transfer\t\r  knowledge\t\r  from\t\r  previous\t\r  learning:\t\r  \n•  RepresentaHons\t\r  \n\n•  Explanatory\t\r  factors\t\r  \n\n•  Previous\t\r  learning\t\r  from:\t\r  unlabeled\t\r  data\t\r  \t\r  \n\n\t\r   \t\r   \t\r  \t\r  \t\r  \t\r  \t\r   \t\r  +\t\r  labels\t\r  for\t\r  other\t\r  tasks\t\r  \n\n•  Prior:\t\r  shared\t\r  underlying\t\r  explanatory\t\r  factors,\t\r  in\t\r  \npar5cular\t\r  between\t\r  P(x)\t\r  and\t\r  P(Y|x)\t\r  \t\r  \n\n\t\r  \n\n\n\nRaw\t\r  data\t\r  \n1\t\r  layer\t\r   2\t\r  layers\t\r  \n\n4\t\r  layers\t\r  \n3\t\r  layers\t\r  \n\nICML’2011\t\r  \nworkshop\t\r  on\t\r  \nUnsup.\t\r  &\t\r  \nTransfer\t\r  Learning\t\r  \n\nNIPS’2011\t\r  \nTransfer\t\r  \nLearning\t\r  \nChallenge\t\r  \t\r  \nPaper:\t\r  \nICML’2012\t\r  \n\nUnsupervised and Transfer Learning \nChallenge + Transfer Learning \nChallenge: Deep Learning 1st Place \n\n\n\n46\t\r  \n\nAuto-Encoders Learn Salient \nVariations, like a non-linear PCA \n\n•  Minimizing\t\r  reconstrucHon\t\r  error\t\r  forces\t\r  to\t\r  \nkeep\t\r  variaHons\t\r  along\t\r  manifold.\t\r  \n\n•  Regularizer\t\r  wants\t\r  to\t\r  throw\t\r  away\t\r  all\t\r  \nvariaHons.\t\r  \n\n•  With\t\r  both:\t\r  keep\t\r  ONLY\t\r  sensiHvity\t\r  to\t\r  \nvariaHons\t\r  ON\t\r  the\t\r  manifold.\t\r  \n\n\n\nSpace-Filling in Representation-Space \n•  Deeper\t\r  representa5ons\t\r  !\t\r  abstrac5ons\t\r  !\t\r  disentangling\t\r  \n•  Manifolds\t\r  are\t\r  expanded\t\r  and\t\r  fla]ened\t\r  \n\nLinear\t\r  interpolaHon\t\r  at\t\r  layer\t\r  2\t\r  \n\nLinear\t\r  interpolaHon\t\r  at\t\r  layer\t\r  1\t\r  \n\n3’s\t\r  manifold\t\r  \n\n9’s\t\r  manifold\t\r  \n\nLinear\t\r  interpolaHon\t\r  in\t\r  pixel\t\r  space\t\r  \n\nPixel\t\r  space\t\r  \n\n9’s\t\r  manifold\t\r   3’s\t\r  manifold\t\r  \n\nRepresentaHon\t\r  space\t\r  \n\n9’s\t\r  manifold\t\r   3’s\t\r  manifold\t\r  \n\nX-­‐space\t\r  \n\nH-­‐space\t\r  \n\n\n\nWhy Unsupervised Representation \nLearning? Because of Causality. \n\n•  If\t\r  Ys\t\r  of\t\r  interest\t\r  are\t\r  among\t\r  the\t\r  causal\t\r  factors\t\r  of\t\r  X,\t\r  then\t\r  \n\nis\t\r  Hed\t\r  to\t\r  P(X)\t\r  and\t\r  P(X|Y),\t\r  and\t\r  P(X)\t\r  is\t\r  defined\t\r  in\t\r  terms\t\r  of\t\r  P(X|Y),\t\r  i.e.\t\r  \n•  The\t\r  best\t\r  possible\t\r  model\t\r  of\t\r  X\t\r  (unsupervised\t\r  learning)\t\r  MUST\t\r  \n\ninvolve\t\r  Y\t\r  as\t\r  a\t\r  latent\t\r  factor,\t\r  implicitly\t\r  or\t\r  explicitly.\t\r  \n•  RepresentaHon\t\r  learning\t\r  SEEKS\t\r  the\t\r  latent\t\r  variables\t\r  H\t\r  that\t\r  \n\nexplain\t\r  the\t\r  variaHons\t\r  of\t\r  X,\t\r  making\t\r  it\t\r  likely\t\r  to\t\r  also\t\r  uncover\t\r  Y.\t\r  \n•  We\t\r  need\t\r  3\t\r  pieces:\t\r  \t\r  \n\n•  latent\t\r  variable\t\r  model\t\r  P(H),\t\r  \t\r  \n•  generaHve\t\r  decoder\t\r  P(X|H),\t\r  and\t\r  \t\r  \n•  approximate\t\r  inference\t\r  encoder\t\r  Q(H|X).\t\r  \n\n\t\r  \t\r  \n48\t\r  \n\nP (Y |X) =\nP (X|Y )P (Y )\n\nP (X)\n\n\n\nChallenges with Graphical Models with \nLatent Variables \n\n•  Latent\t\r  variables\t\r  help\t\r  to\t\r  avoid\t\r  the\t\r  curse\t\r  of\t\r  dimensionality\t\r  \n\n•  But\t\r  they\t\r  come\t\r  with\t\r  intractabiliHes\t\r  due\t\r  to\t\r  sums\t\r  over\t\r  an\t\r  \nexponenHally\t\r  large\t\r  number\t\r  of\t\r  terms\t\r  (marginalizaHon):\t\r  \n\n•  Exact\t\r  inference\t\r  (P(h|x))\t\r  is\t\r  typically\t\r  intractable\t\r  \n\n• With\t\r  undirected\t\r  models,\t\r  the\t\r  normalizaHon\t\r  constant\t\r  and\t\r  its\t\r  \ngradient\t\r  are\t\r  intractable\t\r  \n\n\t\r  \n\n49\t\r  \n\n\n\nIssues with Boltzmann Machines \n•  Sampling\t\r  from\t\r  the\t\r  MCMC\t\r  of\t\r  the\t\r  model\t\r  is\t\r  required\t\r  in\t\r  the\t\r  inner\t\r  \n\nloop\t\r  of\t\r  training\t\r  \n•  As\t\r  the\t\r  model\t\r  gets\t\r  sharper,\t\r  mixing\t\r  between\t\r  well-­‐separated\t\r  \n\nmodes\t\r  stalls\t\r  \n\n50\t\r  \n\nTraining\t\r  updates\t\r  \n\nMixing\t\r  \nvicious\t\r  circle\t\r  \n\n\n\nparameters\t\r  \n\ngenerated\t\r  \nsamples\t\r  \n\nBypassing Normalization Constants \nwith Generative Black Boxes \n•  Instead\t\r  of\t\r  parametrizing\t\r  p(x),\t\r  \n\nparametrize\t\r  a\t\r  machine\t\r  which\t\r  \ngenerates\t\r  samples\t\r  \n\n•  \t\r  (Goodfellow\t\r  et\t\r  al,\t\r  NIPS\t\r  2014,\t\r  \nGeneraHve\t\r  adversarial\t\r  nets)\t\r  for\t\r  the\t\r  \ncase\t\r  of\t\r  ancestral\t\r  sampling\t\r  in\t\r  a\t\r  deep\t\r  \ngeneraHve\t\r  net.\t\r  VariaHonal\t\r  auto-­‐\nencoders\t\r  are\t\r  closely\t\r  related.\t\r  \n\n•  (Bengio\t\r  et\t\r  al,\t\r  ICML\t\r  2014,\t\r  GeneraHve\t\r  \nStochasHc\t\r  Networks),\t\r  learning\t\r  the\t\r  \ntransiHon\t\r  operator\t\r  of\t\r  a\t\r  Markov\t\r  chain\t\r  \nthat\t\r  generates\t\r  the\t\r  data.\t\r  \n\n51\t\r  \n\nrandom\t\r  \nnumbers\t\r  \n\ngenerated\t\r  \nsamples\t\r  \n\nrandom\t\r  \nnumbers\t\r  \n\nprevious\t\r  state\t\r  \n\n\t\r  next\t\r  state\t\r  \n\ngenerated\t\r  \nsamples\t\r  \n\ngenerated\t\r  \nsamples\t\r  \n\nparameters\t\r  \n\n\n\nAdversarial Nets \nmovies \n\nEach\t\r  movie\t\r  =\t\r  linear\t\r  interpolaHon\t\r  \nbetween\t\r  2\t\r  random\t\r  samples\t\r  in\t\r  \nrepresentaHon-­‐space\t\r  \n\n52\t\r  \n\n\n\nAncestral Sampling with Learned \nApproximate Inference \n\n•  Helmholtz\t\r  machine\t\r  &\t\r  Wake-­‐Sleep\t\r  algorithm\t\r  \n•  (Dayan,\t\r  Hinton,\t\r  Neal,\t\r  Zemel\t\r  1995)\t\r  \n\n•  VariaHonal\t\r  Auto-­‐Encoders\t\r  \n•  (Kingma\t\r  &\t\r  Welling\t\r  2013,\t\r  ICLR\t\r  2014)\t\r  \n•  (Gregor\t\r  et\t\r  al\t\r  ICML\t\r  2014)\t\r  \n•  (Rezende\t\r  et\t\r  al\t\r  ICML\t\r  2014)\t\r  \n•  (Mnih\t\r  &\t\r  Gregor\t\r  ICML\t\r  2014)\t\r  \n\n•  Reweighted\t\r  Wake-­‐Sleep\t\r  (Bornschein\t\r  &\t\r  Bengio\t\r  2014)\t\r  \n•  Target\t\r  PropagaHon\t\r  (Bengio\t\r  2014)\t\r  \n•  Deep\t\r  Directed\t\r  GeneraHve\t\r  Auto-­‐Encoders\t\r  (Ozair\t\r  &\t\r  Bengio\t\r  2014)\t\r  \n•  NICE\t\r  (Dinh\t\r  et\t\r  al\t\r  2014)\t\r  \n53\t\r  \n\nTrained\t\r  approximate\t\r  \ninference\t\r  \n\nvisible\t\r  \n\nlatent\t\r  \n\nP\t\r  Q\t\r  \n\n\n\nExtracting Structure By Gradual \nDisentangling and Manifold Unfolding \n(Bengio 2014, arXiv 1407.7906)  \nEach\t\r  level\t\r  transforms\t\r  the\t\r  \ndata\t\r  into\t\r  a\t\r  representaHon\t\r  in\t\r  \nwhich\t\r  it\t\r  is\t\r  easier\t\r  to\t\r  model,\t\r  \nunfolding\t\r  it\t\r  more,\t\r  \ncontracHng\t\r  the\t\r  noise\t\r  \ndimensions\t\r  and\t\r  mapping\t\r  the\t\r  \nsignal\t\r  dimensions\t\r  to\t\r  a\t\r  \nfactorized\t\r  (uniform-­‐like)\t\r  \ndistribuHon.\t\r  \n\t\r  \n\t\r  \nfor\t\r  each\t\r  intermediate\t\r  level\t\r  h\t\r  \n\n54\t\r  \n\nQ(x)\t\r  \n\nf1\t\r  \ng1\t\r  \n\nQ(h1)\t\r  \nP(h1)\t\r  \n\nfL\t\r   gL\t\r  \n\nQ(hL)\t\r  \nP(hL)\t\r  no\n\nise\n\t\r  \n\nsignal\t\r  \n\n…\t\r  \n\nP(x|h1)\t\r  \nQ(h1|x)\t\r  \n\nQ(h2|h1)\t\r   f2\t\r   P(h2|h1)\t\r  g2\t\r  \n\nminKL(Q(x, h)||P (x, h))\n\n\n\nNICE: \nNonlinear Independent Component Estimation \n\n•  Perfect\t\r  auto-­‐encoder\t\r  g=f-­‐1\t\r  \n•  No\t\r  need\t\r  for\t\r  reconstrucHon\t\r  error\t\r  \n•  DeterminisHc\t\r  encoder,\t\r  no\t\r  need\t\r  for\t\r  entropy\t\r  term\t\r  \n•  But\t\r  need\t\r  to\t\r  correct\t\r  for\t\r  density\t\r  scaling\t\r  \n\n•  Exact\t\r  tractable\t\r  likelihood\t\r  \n\n55\t\r  \n\n(Dinh,\t\r  Krueger\t\r  &\t\r  Bengio\t\r  2014,\t\r  arxiv\t\r  1410.8516)\t\r  \n\nlog pX(x) = log pH(f(x)) + log\n\n����det\n@f(x)\n\n@x\n\n����\n\t\r  \nfactorized\t\r  prior\t\r  \n\nPH(h) =\nY\n\ni\n\nPHi(hi)\n\nf\t\r   g=f-­‐1\t\r  \n\nQ(h)\t\r  \n\nP(h)\t\r  \n\n\n\nNICE \nInpaiting \nMovies \n(not \nconv.) \n\n56\t\r  \n\n\n\nUnfolding AND Disentangling \n\n•  The\t\r  previous\t\r  criteria\t\r  may\t\r  allow\t\r  us\t\r  to\t\r  unfold\t\r  and\t\r  flaven\t\r  the\t\r  data\t\r  \nmanifold\t\r  \n\n•  What\t\r  about\t\r  disentangling\t\r  the\t\r  underflying\t\r  factors\t\r  of\t\r  variaHon?\t\r  \n•  Is\t\r  it\t\r  enough\t\r  to\t\r  assume\t\r  they\t\r  are\t\r  marginally\t\r  independent?\t\r  \n•  They\t\r  are\t\r  not\t\r  condiHonally\t\r  independent…\t\r  \n•  There\t\r  may\t\r  be\t\r  intrinsinc\t\r  ambiguiHes\t\r  what\t\r  makes\t\r  the\t\r  \n\ndisentangling\t\r  job\t\r  impossible\t\r  à\t\r  need\t\r  more\t\r  prior\t\r  knowledge.\t\r  \n\n57\t\r  \n\n\n\nBroad Priors as Hints to Disentangle \nthe Factors of Variation \n\n•  MulNple\t\r  factors:\t\r  distributed\t\r  representaHons\t\r  \n•  MulHple\t\r  levels\t\r  of\t\r  abstracHon:\t\r  depth\t\r  \n•  Semi-­‐supervised\t\r  learning:\t\r  Y\t\r  is\t\r  one\t\r  of\t\r  the\t\r  factors\t\r  explaining\t\r  X\t\r  \n•  MulN-­‐task\t\r  learning:\t\r  different\t\r  tasks\t\r  share\t\r  some\t\r  factors\t\r  \n•  Manifold\t\r  hypothesis:\t\r  probability\t\r  mass\t\r  concentraHon\t\r  \n•  Natural\t\r  clustering:\t\r  class\t\r  =\t\r  manifold,\t\r  well-­‐separated\t\r  manifolds\t\r  \n•  Temporal\t\r  and\t\r  spaHal\t\r  coherence\t\r  \n•  Sparsity:\t\r  most\t\r  factors\t\r  irrelevant\t\r  for\t\r  parHcular\t\r  X\t\r  \n•  Simplicity\t\r  of\t\r  factor\t\r  dependencies\t\r  (in\t\r  the\t\r  right\t\r  representaHon)\t\r  \n\n58\t\r  \n\n\n\nLearning Multiple Levels of \nAbstraction \n\n•  The\t\r  big\t\r  payoff\t\r  of\t\r  deep\t\r  learning\t\r  is\t\r  to\t\r  allow\t\r  learning\t\r  \nhigher\t\r  levels\t\r  of\t\r  abstracHon\t\r  \n\n•  Higher-­‐level\t\r  abstracHons\t\r  disentangle\t\r  the\t\r  factors\t\r  of\t\r  \nvariaHon,\t\r  which\t\r  allows\t\r  much\t\r  easier\t\r  generalizaHon\t\r  and\t\r  \ntransfer\t\r  \n\n59\t\r  \n\n\n\nConclusions \n•  Deep\t\r  Learning\t\r  has\t\r  become\t\r  a\t\r  crucial\t\r  machine\t\r  learning\t\r  tool:\t\r  \t\r  \n\n•  Int.\t\r  Conf.\t\r  on\t\r  Learning\t\r  RepresentaHon\t\r  2013\t\r  &\t\r  2014\t\r  a\t\r  huge\t\r  success!\t\r  \nConference\t\r  &\t\r  workshop\t\r  tracks,\t\r  open\t\r  to\t\r  new\t\r  ideas\t\r  J\t\r  \n\n•  Industrial\t\r  applicaHons\t\r  (Google,\t\r  IBM,\t\r  MicrosoY,\t\r  Baidu,\t\r  Facebook,\t\r  \nSamsung,\t\r  Yahoo,\t\r  Intel,\t\r  Apple,\t\r  Nuance,\t\r  BBN,\t\r  …)\t\r  \n\n•  PotenHal\t\r  for\t\r  more\t\r  breakthroughs\t\r  and\t\r  approaching\t\r  the\t\r  \n“understanding”\t\r  part\t\r  of\t\r  AI\t\r  by\t\r  \n•  Scaling\t\r  computaHon\t\r  \t\r  \n•  Numerical\t\r  opHmizaHon\t\r  (bever\t\r  training\t\r  much\t\r  deeper\t\r  nets,\t\r  RNNs)\t\r  \n•  Bypass\t\r  intractable\t\r  marginalizaHons\t\r  and\t\r  exploit\t\r  broad\t\r  priors\t\r  and\t\r  \nlayer-­‐wise\t\r  training\t\r  signals\t\r  to\t\r  learn\t\r  more\t\r  disentangled\t\r  \nabstracHons\t\r  for\t\r  unsupervised\t\r  &\t\r  structured\t\r  output\t\r  learning\t\r  \n\n60\t\r  \n\n\n\nMerci! Questions? LISA team: \n\n\n","extracted_metadata":{"pdf:docinfo:producer":["Mac OS X 10.9.5 Quartz PDFContext"],"pdf:docinfo:created":["2014-11-06T21:19:27Z"],"dc:title":["Tel-Aviv-6nov2014.pptx"],"access_permission:can_print":["true"],"dcterms:created":["2014-11-06T21:19:27Z"],"access_permission:can_print_degraded":["true"],"xmp:CreatorTool":["PowerPoint"],"pdf:docinfo:creator":["Yoshua Bengio"],"pdf:producer":["Mac OS X 10.9.5 Quartz PDFContext"],"pdf:num3DAnnotations":["0"],"pdf:hasMarkedContent":["false"],"pdf:hasXMP":["false"],"access_permission:can_modify":["true"],"pdf:containsNonEmbeddedFont":["false"],"pdf:hasXFA":["false"],"pdf:PDFVersion":["1.3"],"X-TIKA:Parsed-By-Full-Set":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"pdf:docinfo:title":["Tel-Aviv-6nov2014.pptx"],"dc:format":["application/pdf; version=1.3"],"access_permission:extract_for_accessibility":["true"],"access_permission:extract_content":["true"],"X-TIKA:Parsed-By":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"access_permission:assemble_document":["true"],"pdf:hasCollection":["false"],"Content-Type":["application/pdf"],"pdf:docinfo:creator_tool":["PowerPoint"],"pdf:encrypted":["false"],"pdf:overallPercentageUnmappedUnicodeChars":["0.00590310525149107"],"Content-Length":["56715281"],"pdf:totalUnmappedUnicodeChars":["169"],"dcterms:modified":["2014-11-06T21:19:27Z"],"dc:creator":["Yoshua Bengio"],"pdf:unmappedUnicodeCharsPerPage":["1","0","2","3","4","6","0","2","2","1","3","0","5","0","0","0","3","4","5","7","0","0","1","1","2","6","6","4","1","4","2","1","0","0","4","6","1","2","0","5","5","1","4","2","0","5","7","4","4","0","6","2","3","3","2","0","4","9","4","10","0"],"pdf:docinfo:modified":["2014-11-06T21:19:27Z"],"resourceName":["Fundamentals_of_Deep_Learning_2014.pdf"],"pdf:containsDamagedFont":["false"],"access_permission:modify_annotations":["true"],"access_permission:fill_in_form":["true"],"pdf:charsPerPage":["142","73","129","146","197","429","101","150","337","143","289","301","386","11169","161","83","288","240","285","647","180","101","224","431","433","323","448","236","364","314","373","451","165","79","431","403","166","260","97","319","338","179","361","303","249","252","352","585","367","225","596","108","504","466","375","37","378","537","241","653","29"],"xmpTPg:NPages":["61"]},"metadata_field_count":40,"attempts":1,"timestamp":1754064877.0235262,"platform":"Linux","python_version":"3.13.5"},{"file_path":"test_documents/pdfs/Proof of Concept or GTFO - v13 (October 18th, 2016).pdf","file_size":62061798,"file_type":"pdf","category":"huge","framework":"extractous","iteration":1,"extraction_time":18.938185453414917,"startup_time":null,"peak_memory_mb":534.640625,"avg_memory_mb":510.21171875,"peak_cpu_percent":61.9,"avg_cpu_percent":12.379999999999999,"total_io_mb":null,"status":"success","character_count":249077,"word_count":49251,"error_type":null,"error_message":null,"quality_metrics":{"char_count":249077,"word_count":49251,"sentence_count":2476,"paragraph_count":3887,"avg_word_length":3.931026781182108,"avg_sentence_length":20.149434571890147,"extraction_completeness":1.0,"text_coherence":0.65130336229694,"noise_ratio":0.4415935634362065,"gibberish_ratio":0.0,"flesch_reading_ease":63.174401982914816,"gunning_fog_index":14.645896292590756,"has_proper_formatting":true,"maintains_line_breaks":true,"preserves_whitespace":true,"table_structure_preserved":true,"format_specific_score":0.8,"expected_content_preserved":false,"has_encoding_issues":false,"has_ocr_artifacts":true,"preserves_pdf_formatting":true},"overall_quality_score":0.6344930384824043,"extracted_text":"\nPoC||GTFOPoC||GTFOP\nr\no\no\nf\n\nCo\nncep\nt\n\nGe\nt\n\nT\nh\ne\n\nF\nu\nc\nk\n\nO\nu\nt\n\no r\n\nfo\n\nPASTOR LAPHROAIG’S MERCY SHIPPASTOR LAPHROAIG’S MERCY SHIP\nHOLDS STONES FROM THE IVORY TOWER,HOLDS STONES FROM THE IVORY TOWER,\n\nBUT ONLY AS BALLAST!BUT ONLY AS BALLAST!\n\ne0, $0 USD, 10s 6d GBP, 0 RSD, 0 SEK, $50 CAD, 6× 1029 Pengő (3× 108 Adópengő).\nÜres hasnak elég a szép szó; это самиздат. pocorgtfo13.pdf. October 18, 2016.\n\n13:213:2 Atari Star RaidersAtari Star Raiders\n\n13:313:3 Slowing Down a Race ConditionSlowing Down a Race Condition\n\n13:413:4 Glitching Attacks over USB; or,Glitching Attacks over USB; or,\n\nA Wacom Tablet Reads RFIDsA Wacom Tablet Reads RFIDs\n\n13:513:5 Running AMBE Firmware in LinuxRunning AMBE Firmware in Linux\n\n13:613:6 A Rogue Strategy for SpinlocksA Rogue Strategy for Spinlocks\n\n13:713:7 Reverse Engineering LoRa’s PHYReverse Engineering LoRa’s PHY\n\n13:813:8 Concerning Plumbers and PopperConcerning Plumbers and Popper\n\n13:913:9 Where is ShimDBC.exe?Where is ShimDBC.exe?\n\n13:1013:10 Postscript for Schizophrenic GhostsPostscript for Schizophrenic Ghosts\n\n\n\nLegal Note: In solidarity with , the Author Formerly Known as Homer Hickam, we place no restrictions\nof any kind upon our authors. They are quite welcome to do whatever the hell they like with their own\nwork, in any medium they like, including but not limited to endeavors of theater and interpretive dance.\n\nReprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please\nmirror—don’t merely link!—pocorgtfo13.pdf and our other issues far and wide, so our articles can help fight\nthe coming flame deluge. We like the following mirrors.\nhttps://unpack.debug.su/pocorgtfo/\nhttps://pocorgtfo.hacke.rs/\nhttps://www.alchemistowl.org/pocorgtfo/\nhttp://www.sultanik.com/pocorgtfo/\n\nTechnical Note: As described in PoC‖GTFO 13:10, pocorgtfo13.pdf is a polyglot that may be inter-\npreted as both a PDF and a PostScript file. As a PDF, this file is mostly harmless, but we warn you that\nthe Postscript will render differently each time, including both a randomly generated maze and—if Tavis\nOrmandy hasn’t killed such a lovely bug yet—a copy of your /etc/passwd file.\n\nCover Art: The cover artwork from this issue is by Harry Clarke, first used to illustrate the poem Sea\nFever by John Masefield in the collection The Year’s at the Spring, 1920.\n\nPrinting Instructions: Pirate print runs of this journal are most welcome! PoC‖GTFO is to be printed\nduplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper in\nSamland, then fold to get a booklet in A4 or Letter size. Secret volcano labs in Canada may use P3 (280 mm\nx 430 mm) if they like, folded to make P4. The outermost sheet should be on thicker paper to form a cover.\n\n# This is how to convert an issue for duplex printing.\nsudo apt-get install pdfjam\npdfbook --short-edge --vanilla --paper a3paper pocorgtfo13.pdf -o pocorgtfo13-book.pdf\n\nMan of The Book Manul Laphroaig\nEditor of Last Resort Melilot\nTEXnician Evan Sultanik\nEditorial Whipping Boy Jacob Torrey\nFunky File Supervisor Ange Albertini\nAssistant Scenic Designer Philippe Teuwen\n\nand sundry others\n\n2\n\n\n\n1 Read me if you want to live!\n\nNeighbors, please join me in reading this four-\nteenth release of the International Journal of Proof\nof Concept or Get the Fuck Out, a friendly little\ncollection of articles for ladies and gentlemen of dis-\ntinguished ability and taste in the field of reverse en-\ngineering and worshippers of weird machines. This\nfourteenth release is given on paper to the fine neigh-\nbors of São Paulo, San Diego, and Budapest.\n\nIf you are missing the first thirteen issues, we the\neditors suggest pirating them from the usual loca-\ntions, or on paper from a neighbor who picked up a\ncopy of the first in Vegas, the second in São Paulo,\nthe third in Hamburg, the fourth in Heidelberg, the\nfifth in Montréal, the sixth in Las Vegas, the seventh\nfrom his parents’ inkjet printer during the Thanks-\ngiving holiday, the eighth in Heidelberg, the ninth in\nMontréal, the tenth in Novi Sad or Stockholm, the\neleventh in Washington D.C., the twelfth in Heidel-\nberg, or the thirteenth in Montréal.\n\nAfter our paper release, and only when qual-\nity control has been passed, we will make an elec-\ntronic release named pocorgtfo13.pdf. It is valid\nas PDF, ZIP, and PostScript; please read it with\nAdobe Reader, unzip, and gv.\n\nWe begin on page 5 with the story of how STAR\nRAIDERS by Doug Neubauer for the Atari 400 was\ntaken apart by Lorenz Weist, from a mere ROM car-\ntridge dump to annotated and literate 6502 disas-\nsembly. By a stroke of luck, Lorenz was able to read\nDoug’s original source code for the game after com-\n\npleting his reverse engineering project, giving him\nthe rare opportunity to confirm his understanding\nof the game’s design and behavior.\n\nOn page 24, James Forshaw introduces us to a\nnifty little trick for simplifying reliable exploitation\nof race condition vulnerabilities. Rather than spin\nup a dozen attempts to improve racetrack odds, he\ninstead induces situations with pathological perfor-\nmance penalties to Windows NT system calls, stun-\nning the threads of execution that might interfere\nwith his exploit for twenty minutes or more!\n\nMicah Elizabeth Scott continues to send us bril-\nliant articles that refuse to be described by a single\nabstract, so let’s just say that on page 30 she ex-\nplains a USB magic trick in which her FaceWhis-\nperer board—combining the Facedancer and the\nChip Whisperer—is able to reliably glitch the USB\nstack of an embedded device to dump its firmware.\nOr, we could say that on page 30 she explains how\nto use undocumented commands from that firmware\ndump to program the Harvard device by ROP. Or,\nwe could say that on page 30 she shows you to read\nRFID tags with a Wacom tablet. These tricks are\nall the same article, and you’d be a fool not to read\nit.\n\n3\n\n\n\nIn PoC‖GTFO 10:8, Travis Goodspeed jailbroke\nthe Tytera MD380 radio to allow for firmware ex-\ntraction and patching. Since then, a lively open\nsource project has sprung up, with fancy new fea-\ntures and fixes to old bugs. On page 38, he describes\nhow to rip the AMBE audio codec out of the radio\nfirmware, transforming it into a command line audio\nprocessing tool that runs on any Linux workstation.\nSimilar tricks can be used to quickly toss together\nemulators for many ARM and PowerPC embedded\nsystems, re-using their library functions, or fuzzing\ntheir parsers in the familiar environment of an ev-\neryday laptop.\n\nEvan Sultanik is back with a safe cracking adven-\nture that could only be expressed as a play in three\nacts, narrated by our own Pastor Manul Laphroaig.\nSpeaking parts are available for Alice Feynman, Bob\nSchrute, Havva al-Kindi, and the ghost of Paul\nErdős. You’ll find Evan’s script on page 43.\n\nMatt Knight has been reverse engineering the\nPHY of LoRa, a low-power protocol for sub-GHz\nwireless networking over long distances. On page 48\nyou will find not just the protocol details that al-\nlowed him to write an open source receiver, but, far\nmore importantly, you will also find the methods by\nwhich he reverse engineered this information from\ncaptured packets, vague application notes, and the\noutright lies of the patent application.\n\nPastor Manul Laphroaig, your friendly neighbor-\nhood evangelist of the gospel of the weird machines,\n\nhas a sermon for you on page 60. He reminds us\nthat science takes place neither on stage in front of\na live studio audience nor in committees and gov-\nernment offices, but over a glass of fine scotch that’s\naccompanied by finer conversation of practitioners.\nIn the same way that we oughtn’t put Tim the “Tool\nMan” Taylor in charge of vocational education, we\nought to leave the teaching of science to those who\ndo it, not those who talk about it on TV.\n\nGeoff Chappell is an old-school reverse engineer,\nan x86 archaeologist who has spent the past twenty-\nfour years reading Windows binaries to identify all\nthe forgotten features and corner cases that the rest\nof us might take for granted.1 On page 63, he\nintroduces us to the mystery of Microsoft’s Shim\nDatabase Compiler, an unpublished tool for compil-\ning driver shims that doesn’t seem to be available\nto the outside world. Geoff shows us that, in fact,\nthe tool is available, wrapped up inside of a GUI\nas QFixApp.exe or CompatAdmin.exe. By patch-\ning the program to expose its intact winmain(), he\ncan recover the long-lost ShimDBC.exe for compiling\nWindows driver compatibility shims from XML!\n\nEvan Sultanik and Philippe Teuwen have teamed\nup on page 71, to explain the inner workings of\npocorgtfo13.pdf, which you can rename to read\nas pocorgtfo13.zip or pocorgtfo13.ps.\n\nOn page 72, the last page, we pass around the\ncollection plate. Our church has no interest in cash\nor cheques, but we’d love your donation of a nifty\nreverse engineering story. Please send one our way.\n\n1Geoff was the first to discover Aaron R. Reynolds’ “AARD” code from the beta release of Windows 3.1 that intentionally\nbroke compatibility with DR-DOS. He also has a delightful article on exactly how AOL exploited a buffer overflow in their own\nAOL Instant Messenger client to distinguish it from Microsoft’s clone, MSN Messenger.\n\n4\n\n\n\n2 Reverse Engineering Star Raiders\nby Lorenz Wiest\n\n2.1 Introduction\n\nSTAR RAIDERS is a seminal computer game pub-\nlished by Atari Inc. in 1979 as one of the first titles\nfor the original Atari 8-bit Home Computer System\n(Atari 400 and Atari 800). It was written by Atari\nengineer Doug Neubauer, who also created the sys-\ntem’s POKEY sound chip. STAR RAIDERS is consid-\n\nered to be one of the ten most important computer\ngames of all time.2.\n\nCONTROLLER JACKS\n\nSYSTEM\nRESET\n\nOPTION\n\nSELECT\n\nSTART\n\n21 3 4\n\nPLYR 1 PLYR 2 PLYR 3 PLYR 4\n\nThe game is a 3D space combat flight simulation\nwhere you fly your starship through space, shooting\nat attacking Zylon spaceships.The game’s universe\nis made up of a 16 × 8 grid of sectors Some of\nthem contain enemy Zylon units some a friendly\nstarbase The Zylon units converge toward the star-\nbases and try to destroy them. The starbases serve\nas repair and refueling points for your starship. You\nmove your starship between sectors with your hyper-\nwarp drive The game is over if you have destroyed\nall Zylon ships, have ran out of energy, or if the\nZylons have destroyed all starbases.\n\nAt a time when home computer games were\npretty static – think SPACE INVADERS (1978) and\nPAC MAN (1980) – STAR RAIDERS was a huge hit\nbecause the game play centered on the very dynamic\n3D first-person view out of your starship’s cockpit\nwindow.\n\nThe original Atari 8-bit Home Computer System\n2“Is That Just Some Game? No, It’s a Cultural Artifact.” Heather Chaplin, The New York Times, March 12, 2007.\n\n5\n\n\n\nhas up to 48 KB RAM and uses a Motorola 6502\nCPU. The same CPU is also used in the Apple II,\nthe Commodore C64 (a 6502 variant), and the T-\n800 Terminator 3 Several proprietary Atari custom\nchips provide additional capabilities to the system.\nSTAR RAIDERS shows off many of them: 5 Play-\ners (sprites), mixed text and pixel graphics modes,\ndynamic Display Lists, a custom character set, 4-\nchannel sound, Vertical Blank Interrupt and Dis-\nplay List Interrupt code – even the BCD mode of\nthe 6502 CPU is used C\n\nCONTROLLER JACKS21 3 4\n\nPULL     OPEN SYSTEMRESETOPTIONSELECTSTART\n\n@angealbertini 2016\n\nlig\nht\n\n p\nen\n\nso\nun\n\nd\n\nse\nri\n\nal\nbu\n\ns\n\npi\nct\n\nur\ne\n\nco\nns\n\nol\ne \n\nsw\nit\nch\n\nes\n\njo\nys\n\nti\nck\n\n t\nri\n\ngg\ner\n\ns\n\nke\nyb\n\noa\nrd\n\nkeyboard\nspeaker\n\npa\ndd\n\nle\ns\n\nke\nyb\n\noa\nrd\n\nco\nnt\n\nro\nlle\n\nrs\n\njo\nys\n\nti\nck\n\npa\ndd\n\nle\ntr\n\nig\nge\n\nrs\n\nMOS\n6502\n\nRAM left\ncartridge\n\nright\ncartridge OS\n\nROM\ndisk\n\ndrives\n\nother\nperiph.\n\nPOtentiometer\nKEYboard\nintegrated circuit\n\nPeripheral\nInterface\nAdaptor\n\nColor/Graphics\nTelevision\n\nInterface Adaptor16KB - 48KB\n\n1.77-1,79Mhz\n\n16bit freq counter mode\nkeyboard/paddle scanning\nIRQ generator\n\nAlpha-Numeric\nTelevision\nInterface\nControllerSALLY\n\nSprites: player/missile\n\ndisplay lists\n\nprocessor busprocessor bus\n\nI have been always wondering what made STAR\nRAIDERS tick. I was especially curious how that\n3D first-person view star field worked, in particu-\nlar the rotations of the stars when you fly a turn.\nSo I decided to reverse engineer the game, aiming\nat a complete, fully documented assembly language\nsource code of STAR RAIDERS.\n\n;*********************************************************************\n;*                                                                  *\n;*                      S T A R   R A I D E R S                     *\n;*                                                                  *\n;*             for the Atari 8-bit Home Computer System             *\n;*                                                                  *\n;*  Reverse-engineered and documented assembly language source code  *\n;*                                                                  *\n;*                                by                                *\n;*                                                                  *\n;*                           Lorenz Wiest                           *\n;*                                                                  *\n;*                       (lo.wiest(at)web.de)                       *\n;*                                                                  *\n;*                           First Release                          *\n;*                            22-SEP-2015                           *\n;*                                                                  *\n;*                            Last Update                           *\n;*                            10-AUG-2016                           *\n;*                                                                  *\n;*           STAR RAIDERS was created by Douglas Neubauer           *\n;*             STAR RAIDERS was published by Atari Inc.             *\n;*                                                                  *\n;*********************************************************************\n\nIn the following sections I’ll show you how I ap-\nproached the reverse engineering effort, introduce\nmy favorite piece of code in STAR RAIDERS, talk\nabout how the tight memory limits influenced the\nimplementation, reveal some bugs, point at some\nmysterious code, and explain how I got a grip on\ndocumenting STAR RAIDERS. From time to time, to\nprovide some context to you, I will reference memory\nlocations of the game, which you can look up in the\nreverse engineered, complete, and fully documented\nassembly language source code of STAR RAIDERS\navailable on GitHub.4\n\n2.2 Getting Started\n\nSTAR RAIDERS is distributed as an 8 KB ROM car-\ntridge, occupying memory locations $A000 to $BFFF.\n\nThe obvious first step was to prod a ROM dump\nwith a disassembler and to apply Atari’s published\nhardware and OS symbols to the disassembly. To\nmy surprise this soon revealed that code and data\nwere clearly separated into three parts:\n$A000 – $A149 Data (Part 1 of 2)\n$A14A – $B8DE Code (6502 instructions)\n$B8DF – $BFFF Data (Part 2 of 2)\nThis clear separation helped me instantly to get\n\nan overview of the code part, as I could create a\ndisassembly of the code in one go and not having to\nsift slowly through the bytes of the ROM, deciding\nwhich ones are instructions and which ones are data.\n\nCloser inspection of the code part revealed that it\nwas composed of neatly separated subroutines. Each\nsubroutine handles a specific task. The largest sub-\nroutine is the main game loop GAMELOOP ($A1F3),\nshown in Figure 1. What I expected to be spaghetti\ncode – given the development tools of 1979 and the\nsubstantial amount of game features crammed into\nthe 8K ROM – turned out to be surprisingly struc-\ntured code. Table 1 lists all subroutines of STAR\nRAIDERS, as their function emerged during the re-\nverse engineering effort, giving a good overview how\nthe STAR RAIDERS code is organized.\n\nFigure 2 shows the “genome sequence” of the\nSTAR RAIDERS 8 KB ROM: The 8192 bytes of the\ngame are stacked vertically, with each byte repre-\nsented by a tiny, solid horizontal line of 8 pixels.\nThis stack is split into strips of 192 bytes, arranged\nside-by-side. Alternating light and dark blue areas\nrepresent bytes of distinct subroutines. Alternat-\ning light and dark green and purple areas repre-\nsent bytes of distinct sections of data (lookup tables,\ngraphical shapes, etc.). When data bytes represent\ngraphical shapes, the solid line of a byte is replaced\nby its actual bit pattern (in purple color).\n\nThere are a couple of interesting things to see:\n\n• The figure reflects the ROM’s separation into\na data part (green and purple), a code part\n(blue), and one more data part (green and pur-\nple).\n\n• The first data part contains mostly the custom\n3In the movie TERMINATOR (1984) there are scenes showing the Terminator’s point of view in shades of red. In these\n\nscenes lines of source code are listed onscreen. Close inspection of still frames of the movie reveal this to be 6502 assembly\nlanguage source code.\n\n4git clone https://github.com/lwiest/StarRaiders or unzip pocorgtfo13.pdf StarRaiders.zip\n\n6\n\n\n\nGAMELOOP\n$A1F3\n\nUPDATTCOMP Update Attack Computer Display\n$A7BF\n\nHYPERWARP Handle hyperwarp\n$A89B\n\nMANEUVER Maneuver our starship's and Zylon\nphoton torpedoes and Zylon ships$AA79\n\nINITEXPL Initialize explosion\n$AC6B\n\nDOCKING Handle docking at starbase,\nlaunch and return of transfer vessel$ACE6\n\nMODDLST Modify Display List\n$ADF1\n\nCLRPLAYFIELD Clear PLAYFIELD memory\n$AE0D\n\nTRIGGER Handle joystick trigger\n$AE29\n\nNOISE Copy noise sound pattern\n$AEA8\n\nDAMAGE Damage or destroy one of our starship's subsystems\n$AEE1\n\nCOLLISION Detect a collision of our starship's photon torpedoes\n$AF3D\n\nGAMEOVER Handle Game Over\n$B10A\n\nFLUSHGAMELOOP Handle remaining tasks at the end\nof a game loop iteration$B4E4\n\nDRAWLINES Draw horizontal and vertical lines\n$A76F\n\nPROJECTION Calculate pixel column (or row) number\nfrom position vector$AA21\n\nKEYBOARD Handle Keyboard Input\n$AFFE\n\nSETVIEW Set Front view\n$B045\n\nSELECTWARP Select hyperwarp arrival location\non Galactic Chart$B162\n\nROTATE Rotate position vector component\n(coordinate) by fixed angle$B69B\n\nSCREENCOLUMN Calculate pixel column number\nfrom centered pixel column number$B6FB\n\nSCREENROW Calculate pixel row number\nfrom centered pixel row number$B71E\n\nINITPOSVEC Initialize position vector of a space object\n$B764\n\nUPDPANEL Update Control Panel Display\n$B804\n\nDECENERGYDecrease energy\n$B86F\n\nInitialize program (cold start)\n$A14A\nINITCOLD\n\nEntry point when SELECT function key was pressed\n$A15A\nINITSELECT\n\nEntry point when program switches into demo mode\n$A15C\nINITDEMO\n\nEntry point when START function key was pressed\n$A15E\nINITSTART\n\nUPDTITLE Update title line\n$B216\n\nA B A is followed by B in memory A B A calls B (and returns)\n\nA B A jumps to B (no return)\n\n$A6D0\n\nFigure 1. Simplified Call Graph of Start Up and Game Loop\n\n7\n\n\n\n1 $A14A INITCOLD I n i t i a l i z e program (Cold s t a r t )\n$A15A INITSELECT Entry po int when SELECT func t i on key was pre s sed\n\n3 $A15C INITDEMO Entry po int when program swi t che s in to demo mode\n$A15E INITSTART Entry po int when START func t i on key was pre s sed\n\n5 $A1F3 GAMELOOP Game loop\n$A6D1 VBIHNDLR Ve r t i c a l Blank In t e r rup t Handler\n\n7 $A718 DLSTHNDLR Display L i s t In t e r rup t Handler\n$A751 IRQHNDLR Int e r rup t Request (IRQ) Handler\n\n9 $A76F DRAWLINES Draw ho r i z on t a l and v e r t i c a l l i n e s\n$A782 DRAWLINE Draw a s i n g l e ho r i z on t a l or v e r t i c a l l i n e\n\n11 $A784 DRAWLINE2 Draw b l i p in Attack Computer\n$A7BF UPDATTCOMP Update Attack Computer Display\n\n13 $A89B HYPERWARP Handle hyperwarp\n$A980 ABORTWARP Abort hyperwarp\n\n15 $A987 ENDWARP End hyperwarp\n$A98D CLEANUPWARP Clean up hyperwarp v a r i a b l e s\n\n17 $A9B4 INITTRAIL I n i t i a l i z e s t a r t r a i l dur ing STAR TRAIL PHASE of hyperwarp\n$AA21 PROJECTION Calcu la te p i x e l column ( or row ) number from po s i t i o n vec to r\n\n19 $AA79 MANEUVER Maneuver our s t a r s h i p ’ s and Zylon photon torpedoes and Zylon sh ip s\n$AC6B INITEXPL I n i t i a l i z e exp l o s i on\n\n21 $ACAF COPYPOSVEC Copy a po s i t i o n vec to r\n$ACC1 COPYPOSXY Copy x and y components ( coo rd ina t e s ) o f p o s i t i o n vec to r\n\n23 $ACE6 DOCKING Handle docking at s tarbase , launch and return o f t r a n s f e r v e s s e l\n$ADF1 MODDLST Modify Display L i s t\n\n25 $AE0D CLRPLAYFIELD Clear PLAYFIELD memory\n$AE0F CLRMEM Clear memory\n\n27 $AE29 TRIGGER Handle j o y s t i c k t r i g g e r\n$AEA8 NOISE Copy no i s e sound pattern\n\n29 $AECA HOMINGVEL Calcu la te homing v e l o c i t y o f our s t a r s h i p ’ s photon torpedo 0 or 1\n$AEE1 DAMAGE Damage or des t roy one o f our s t a r s h i p ’ s subsystems\n\n31 $AF3D COLLISION Detect a c o l l i s i o n o f our s t a r s h i p ’ s photon torpedoes\n$AFFE KEYBOARD Handle Keyboard Input\n\n33 $B045 SETVIEW Set Front view\n$B07B UPDSCREEN Clear PLAYFIELD, draw Attack\n\n35 $B10A GAMEOVER Handle game over\n$B121 GAMEOVER2 Game over ( Miss ion s u c c e s s f u l )\n\n37 $B162 SELECTWARP Se l e c t hyperwarp a r r i v a l l o c a t i o n on Ga lac t i c Chart\n$B1A7 CALCWARP Calcu la te and d i sp l ay hyperwarp energy\n\n39 $B216 UPDTITLE Update t i t l e l i n e\n$B223 SETTITLE Set t i t l e phrase in t i t l e l i n e\n\n41 $B2AB SOUND Handle sound e f f e c t s\n$B3A6 BEEP Copy beeper sound pattern\n\n43 $B3BA INITIALIZE More game i n i t i a l i z a t i o n\n$B4B9 DRAWGC Draw Galac t i c Chart\n\n45 $B4E4 FLUSHGAMELOOP Handle remaining ta sk s at the end o f a game loop i t e r a t i o n\n$B69B ROTATE Rotate p o s i t i o n vec to r component ( coord inate ) by f i x ed ang le\n\n47 $B6FB SCREENCOLUMN Calcu la te p i x e l column number from cente red p i x e l column number\n$B71E SCREENROW Calcu la te p i x e l row number from cente red p i x e l row number\n\n49 $B764 INITPOSVEC I n i t i a l i z e p o s i t i o n vec to r o f a space ob j e c t\n$B7BE RNDINVXY Randomly i nv e r t the x and y components o f a po s i t i o n vec to r\n\n51 $B7F1 ISSURROUNDED Check i f a s e c t o r i s surrounded by Zylon un i t s\n$B804 UPDPANEL Control Panel Display\n\n53 $B86F DECENERGY Decrease energy\n$B8A7 SHOWCOORD Display a po s i t i o n vec to r component ( coord inate ) in\n\n55 Control Panel Display\n$B8CD SHOWDIGITS Display a value by a readout o f the Control Panel Display\n\nTable 1. Star Raiders Subroutines\n\n8\n\n\n\nCODE DATABITMAP\n\n+00\n\n+08\n\n+10\n\n+18\n\n+20\n\n+28\n\n+30\n\n+38\n\n+40\n\n+48\n\n+50\n\n+58\n\n+60\n\n+68\n\n+70\n\n+78\n\n+80\n\n+88\n\n+90\n\n+98\n\n+A0\n\n+A8\n\n+B0\n\n+B8\n\n+C0\n\nGA\nME\nLO\nOP\n\n## 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43\n\nA000    A180    A300    A480    A600    A780    A900    AA80    AC00    AD80    AF00    B080    B200    B380    B500    B680    B800    B980    BB00    BC80    BE00    BF80\n    A0C0    A240    A3C0    A540    A6C0    A840    A9C0    AB40    ACC0    AE40    AFC0    B140    B2C0    B440    B5C0    B740    B8C0    BA40    BBC0    BD40    BEC0\n\nW\nO\nR\nD\nT\nA\nB\n\nW\nO\nR\nD\nT\nA\nB\n\nMA\nNE\nUV\nER\n\nMA\nNE\nUV\nER\n\nF\nL\nU\nS\nH\nG\nA\nM\nE\nL\nO\nO\nP\n\nFigure 2. Genome Sequence of the STAR RAIDERS ROM\n\nfont (in strips 1-2).\n\n• The largest contiguous (dark) blue chunk rep-\nresents the 1246 bytes of the main game loop\nGAMELOOP ($A1F3) (in strips 3-10).\n\n• At the beginning of the second data part are\nthe shapes for the Players (sprites) (in strips\n34-36).\n\n• The largest contiguous (light) green chunk rep-\nresents the 503 bytes of the game’s word table\nWORDTAB ($BC2B) (in strips 38-41).\n\nA good reverse engineering strategy was to start\nworking from code locations that used Atari’s pub-\nlished symbols, the equivalent of piecing together\nthe border of a jigsaw puzzle first before starting to\ntackle the puzzle’s center. Then, however, came the\ninevitable and very long stretch of reconstructing\nthe game’s logic and variables with a combination\nof educated guesses, trial-and-error, and lots of pa-\ntience. At this stage, the tools I used mostly were\nnothing but a text editor (Notepad) and a word pro-\ncessor (Microsoft Word) to fill the gaps in the doc-\numentation of the code and the data. I also created\n\na memory map text file to list the used memory lo-\ncations and their purpose. These entries were con-\ntinually updated – and more than often discarded\nafter it turned out that I had taken a wrong turn.\n\n2.3 A Programming Gem: Rotating\n3D Vectors\n\nWhat is the most interesting, fascinating, and un-\nexpected piece of code in STAR RAIDERS? My pick\nwould be the very code that started me to reverse\nengineer STAR RAIDERS in the first place: subrou-\ntine ROTATE ($B69B), which rotates objects in the\ngame’s 3D coordinate space (shown in Figure 3).\nAnd here is why: Rotation calculations usually in-\nvolve trigonometry, matrices, and so on – at least\nsome multiplications. But the 6502 CPU has only\n8-bit addition and subtraction operations. It does\nnot provide either a multiplication or a division op-\neration – and certainly no trig operation! So how do\nthe rotation calculations work, then?\n\nLet’s start with the basics: The game uses a 3D\ncoordinate system with the position of our starship\nat the center of the coordinate system. The loca-\ntions of all space objects (Zylon ships, meteors, pho-\n\n9\n\n\n\nton torpedoes, starbase, transfer vessel, Hyperwarp\nTarget Marker, stars, and explosion fragments) are\ndescribed by a position vector relative to our star-\nship.\n\nA position vector is composed of an x, y, and z\ncomponent, whose values I call the x, y, and z coor-\ndinates with the arbitrary unit <KM>. The range\nof a coordinate is −65536 to +65535 <KM>.\n\nEach coordinate is a signed 17-bit integer num-\nber, which fits into three bytes. Bit 16 contains\nthe sign bit, which is 1 for positive and 0 for nega-\ntive sign. Bits 15 to 0 are the mantissa as a two’s-\ncomplement integer.\n\nSign Mantissa\n2 B16 B15 . . . B8 B7 . . . . B0\n\n| | | | |\n4 0000000∗ ∗∗∗∗∗∗∗∗ ∗∗∗∗∗∗∗∗\n\nSome example bit patterns for coordinates:\n\n00000001 11111111 11111111 = +65535 <KM>\n2 00000001 00000001 00000000 = +256 <KM>\n\n00000001 00000000 11111111 = +255 <KM>\n4 00000001 00000000 00000001 = +1 <KM>\n\n00000001 00000000 00000000 = +0 <KM>\n6 00000000 11111111 11111111 = −1 <KM>\n\n00000000 11111111 11111110 = −2 <KM>\n8 00000000 11111111 00000001 = −255 <KM>\n\n00000000 11111111 00000000 = −256 <KM>\n10 00000000 00000000 00000000 = −65536 <KM>\n\nThe position vector for each space object is\nstored in nine tables (3 coordinates × 3 bytes for\neach coordinate). There are up to 49 space objects\nused in the game simultaneously, so each table is 49\nbytes long:\n\nXPOSSIGN XPOSHI XPOSLO\n($09DE..$0A0E) ($0A71..$0AA1) ($0B04..$0B34)\n\nYPOSSIGN YPOSHI YPOSLO\n($0A0F..$0A3F) ($0AA2..$0AD2) ($0B35..$0B65)\n\nZPOSSIGN ZPOSHI ZPOSLO\n($09AD..$09DD) ($0A40..$0A70) ($0AD3..$0B03)\n\nWith that explained, let’s have a look at sub-\nroutine ROTATE ($B69B). This subroutine rotates a\nposition vector component (coordinate) of a space\nobject by a fixed angle around the center of the\n3D coordinate system, the location of our starship.\nThis operation is used in 3 out of 4 of the game’s\nview modes (Front view, Aft view, Long-Range Scan\nview) to rotate space objects in and out of the view.\n\n2.3.1 Rotation Mathematics\n\nThe game uses a left-handed 3D coordinate system\nwith the positive x-axis pointing to the right, the\npositive y-axis pointing up, and the positive z-axis\npointing into flight direction.\n\nry\n\nz-axis\n\nx-axis\nx x’\n\nz\n\nz’\n\ny--axis\n\nx-axis\n\nz-axis\n\nA rotation in this coordinate system around the\ny-axis (horizontal rotation) can be expressed as\n\nx′ = cos(ry)x+ sin(ry)z (1)\nz′ = − sin(ry)x+ cos(ry)z\n\nwhere ry is the clockwise rotation angle around the\ny-axis, x and z are the coordinates before this ro-\ntation, and the primed coordinates x′ and z′ the\ncoordinates after this rotation. The y-coordinate is\nnot changed by this rotation.\n\nrx\n\ny-axis\n\nz-axis\nz z’\n\ny\n\ny’\n\ny-axis\n\nx-axis\n\nz-axis\n\nA rotation in this coordinate system around the\nx-axis (vertical rotation) can be expressed as\n\nz′ = cos(rx)z + sin(rx)y (2)\ny′ = − sin(rx)z + cos(rx)y\n\nwhere rx is the clockwise rotation angle around the\nx-axis, z and y are the coordinates before this ro-\ntation, and the primed coordinates z′ and y′ the\ncoordinates after this rotation. The x-coordinate is\nnot changed by this rotation.\n\n2.3.2 Subroutine Implementation Overview\n\nA single call of subroutine ROTATE ($B69B) is able\nto compute one of the four expressions in Equa-\ntions 1 and 2. To compute all four expressions to\n\n10\n\n\n\nget the new set of coordinates, this subroutine has\nto be called four times. This is done twice in pairs\nin GAMELOOP ($A1F3) at $A391 and $A398, and at\n$A3AE and $A3B5, respectively.\n\nThe first pair of calls calculates the new x and\nz coordinates of a space object due to a horizon-\ntal (left/right) rotation of our starship around the\ny-axis following the expressions of Equation 1.\n\nThe second pair of calls calculates the new y and\nz coordinates of the same space object due to a ver-\ntical (up/down) rotation of our starship around the\nx-axis following the expressions of Equation 2.\n\nIf you look at the code of ROTATE ($B69B), you\nmay be wondering how this calculation is actually\nexecuted, as there is neither a sine nor cosine func-\ntion call. What you’ll actually find implemented,\nhowever, are the following calculations:\n\nJoystick Left\n\nx := x+ z/64 (3)\nz := −x/64 + z\n\nJoystick Right\n\nx := x− z/64 (4)\nz := x/64 + z\n\nJoystick Down\n\ny := y + z/64 (5)\nz := −y/64 + z\n\nJoystick Up\n\ny := y − z/64 (6)\nz := y/64 + z\n\n2.3.3 CORDIC Algorithm\n\nWhen you compare the expressions of Equations 1–2\nwith expressions of Equations 3–6, notice the simi-\nlarity between the expressions if you substitute5\n\nsin(ry)→ 1/64\n\ncos(ry)→ 1\n\nsin(rx)→ 1/64\n\ncos(rx)→ 1\n\nFrom sin(ry) = 1/64 and sin(rx) = 1/64 you can\nderive that the rotation angles ry and rx by which\nthe space object is rotated (per game loop iteration)\nhave a constant value of 0.89◦, as arcsin(1/64) =\n0.89◦.\n\nWhat about cos(ry) and cos(rx)? The substi-\ntution does not match our derived angle exactly,\nbecause cos(0.89◦) = 0.99988 and is not exactly\n1. However, this value is so close that substitut-\ning cos(0.89◦) with 1 is a very good approximation,\nsimplifying calculations significantly.\n\nAnother significant simplification results from\nthe division by 64, as the actual division operation\ncan be replaced with a much faster bit shift opera-\ntion.\n\nThis calculation-friendly way of computing rota-\ntions is also known as the “CORDIC (COordinate\nRotation DIgital Computer)” algorithm.\n\n2.3.4 Minsky Rotation\n\nThere is one more interesting mathematical sub-\ntlety: Did you notice that expressions of Equa-\ntions 1 and 2 use a new (primed) pair of variables\nto store the resulting coordinates, whereas in the\nimplemented Equations 3–6, the value of the first\ncoordinate of a coordinate pair is overwritten with\nits new value and this value is used in the subsequent\ncalculation of the second coordinate? For example,\nwhen the joystick is pushed left, the first call of this\nsubroutine calculates the new value of x according\nto first expression of Equation 3, overwriting the old\nvalue of x. During the second call to calculate z ac-\ncording to the second expression of Equation 3, the\nnew value of x is used instead of the old one. Is this\nto save the memory needed to temporarily store the\nold value of x? Is this a bug? If so, why does the\nrotation calculation actually work?\n\nHave a look at the expressions of Equation 3 (the\nother Equations 4–6 work in a similar fashion):\n\nx := x+ z/64\n\nz := −x/64 + z\n\nIf we substitute 1/64 with e, we get\n\nx := x+ ez\n\nz := −ex+ z\n\n5This substitution gave a friendly mathematician who happened to see it a nasty shock. She yelled at us that cos2x+sin2x = 1\nfor all real x and forever, and therefore this could not possibly be a rotation; it’s a rotation with a stretch! We reminded her\nof the old joke that in wartime the value of the cosine has been known to reach 4. —PML\n\n11\n\n\n\nNote that x is calculated first and then used in\nthe second expression. When using primed coordi-\nnates for the resulting coordinates after calculating\nthe two expressions we get\n\nx′ := x+ ez\n\nz′ :=− ex′ + z\n\n=− e(x+ ez) + z\n\n=− ex+ (1− e2)z\n\nor in matrix form(\nx′\n\nz′\n\n)\n=\n\n(\n1 e\n−e 1− e2\n\n)(\nx\nz\n\n)\nSurprisingly, this turns out to be a rotation ma-\n\ntrix, because its determinant is (1× (1−e2)− (−e×\ne)) = 1. (Incidentally, the column vectors of this\nmatrix do not form an orthogonal basis, as their\nscalar product is 1 × e + (−e × (1 − e2)) = −e2.\nOrthogonality holds for e = 0 only.)\n\nThis kind of rotation calculation is described\nby Marvin Minsky in AIM 239 HAKMEM6 and is\ncalled “Minsky Rotation.”\n\n2.3.5 Subroutine Implementation Details\n\nTo better understand how the implementation of\nthis subroutine works, we must again look at Equa-\ntions 3–6. If you rearrange the expressions a little,\ntheir structure is always of the form:\n\nTERM1 := TERM1 SIGN TERM2/64\n\nor shorter\n\nTERM1 := TERM1 SIGN TERM3\n\nwhere TERM3 := TERM2/64 and SIGN := + or − and\nwhere TERM1 and TERM2 are coordinates. In fact, this\nis all this subroutine actually does: It simply adds\nTERM2 divided by 64 to TERM1 or subtracts TERM2\ndivided by 64 from TERM1.\n\nWhen calling this subroutine the correct table\nindices for the appropriate coordinates TERM1 and\nTERM2 are passed in the CPU’s Y and X registers,\nrespectively.\n\nWhat about SIGN between TERM1 and TERM3?\nAgain, have a look at Equations 3–6. To compute\n\nthe two new coordinates after a rotation, the SIGN\ntoggles from plus to minus and vice versa. The SIGN\nis initialized with the value of JOYSTICKDELTA ($6D)\nbefore calling subroutine ROTATE ($B69B, Figure 3)\nand is toggled in every call of this subroutine. The\ninitial value of SIGN should be positive (+, byte\nvalue $01) if the rotation is clockwise (the joystick is\npushed right or up) and negative (−, byte value $FF)\nif the rotation is counter-clockwise (the joystick is\npushed left or down), respectively. Because SIGN is\nalways toggled in ROTATE ($B69B) before the adding\nor subtraction operation of TERM1 and TERM3 takes\nplace, you have to pass the already toggled value\nwith the first call.\n\nUnclear still are three instructions starting at ad-\ndress $B6AD. They seem to set the two least signifi-\ncant bits of TERM3 in a random fashion. Could this\nbe some quick hack to avoid messing with exact but\npotentially lengthy two’s-complement arithmetic?\n\nCX40\n\n2.4 Dodging Memory Limitations\n\nIt is impressing how much functionality was\nsqueezed into STAR RAIDERS. Not surprisingly, the\nbytes of the 8 KB ROM are used up almost com-\npletely. Only a single byte is left unused at the very\nend of the code. When counting four more bytes\nfrom three orphaned entries in the game’s lookup\ntables, only five bytes in total out of 8,192 bytes are\nactually not used. ROMmemory was extremely pre-\ncious. Here are some techniques that demonstrate\n\n6unzip pocorgtfo13.pdf AIM-239.pdf #Item 149, page 73.\n\n12\n\nNote that x is calculated first and then used in\nthe second expression. When using primed coordi-\nnates for the resulting coordinates after calculating\nthe two expressions we get\n\ny\n\nv= “4+ ez\n\ng:=—ea' +2\n=—e(atez) +z\n=—exr+(1—e?)z\n\nor in matrix form\n\n(2 )-(20 122 )G)\n\nSurprisingly, this turns out to be a rotation ma-\ntrix, because its determinant is (1 x (1 —e?) — (—e x\ne)) = 1. (Incidentally, the column vectors of this\nmatrix do not form an orthogonal basis, as their\nscalar product is 1 x e + (—e x (1 — e?)) = —e?.\nOrthogonality holds for e = 0 only.)\n\nThis kind of rotation calculation is described\nby Marvin Minsky in AIM 239 HAKMEM® and is\n\ncalled “Minsky Rotation.”\n\n2.3.5 Subroutine Implementation Details\n\nTo better understand how the implementation of\nthis subroutine works, we must again look at Equa-\ntions 3-6. If you rearrange the expressions a little,\ntheir structure is always of the form:\n\nTERM1 := TERM1 SIGN TERM2/64\n\nor shorter\n\nTERM1 := TERM1 SIGN TERM3\n\nwhere TERM3 := TERM2/64 and SIGN := + or — and\nwhere TERM1 and TERM2 are coordinates. In fact, this\nis all this subroutine actually does: It simply adds\nTERM2 divided by 64 to TERM1 or subtracts TERM2\ndivided by 64 from TERM1.\n\nWhen calling this subroutine the correct table\nindices for the appropriate coordinates TERM1 and\nTERM2 are passed in the CPU’s Y and X registers,\nrespectively.\n\nWhat about SIGN between TERM1 and TERM3?\nAgain, have a look at Equations 3-6. To compute\n\nSunzip pocorgtfo13.pdf AIM-239.pdf #Item 149, page 73.\n\n12\n\nthe two new coordinates after a rotation, the SIGN\ntoggles from plus to minus and vice versa. The SIGN\nis initialized with the value of JOYSTICKDELTA ($6D)\nbefore calling subroutine ROTATE ($B69B, Figure 3)\nand is toggled in every call of this subroutine. The\ninitial value of SIGN should be positive (+, byte\nvalue $01) if the rotation is clockwise (the joystick is\npushed right or up) and negative (—, byte value $FF)\nif the rotation is counter-clockwise (the joystick is\npushed left or down), respectively. Because SIGN is\nalways toggled in ROTATE ($B69B) before the adding\nor subtraction operation of TERM1 and TERM3 takes\nplace, you have to pass the already toggled value\nwith the first call.\n\nUnclear still are three instructions starting at ad-\ndress $B6AD. They seem to set the two least signifi-\ncant bits of TERM3 in a random fashion. Could this\nbe some quick hack to avoid messing with exact but\npotentially lengthy two’s-complement arithmetic?\n\n2.4 Dodging Memory Limitations\n\nIt is impressing how much functionality was\nsqueezed into STAR RAIDERS. Not surprisingly, the\nbytes of the 8 KB ROM are used up almost com-\npletely. Only a single byte is left unused at the very\nend of the code. When counting four more bytes\nfrom three orphaned entries in the game’s lookup\ntables, only five bytes in total out of 8,192 bytes are\nactually not used. ROM memory was extremely pre-\ncious. Here are some techniques that demonstrate\n\n\n\n\n; INPUT\n2 ;\n\n; X = Pos i t i on vector component index o f TERM2. Used va lues are :\n4 ; $00 . . $30 −> z−component ( z−coord inate ) o f po s i t i on vector 0 . . 4 8\n\n; $31 . . $61 −> x−component (x−coord inate ) o f po s i t i on vector 0 . . 4 8\n6 ; $62 . . $92 −> y−component (y−coord inate ) o f po s i t i on vector 0 . . 4 8\n\n;\n8 ; Y = Pos i t i on vector component index o f TERM1. Used va lues are :\n\n; $00 . . $30 −> z−component ( z−coord inate ) o f po s i t i on vector 0 . . 4 8\n10 ; $31 . . $61 −> x−component (x−coord inate ) o f po s i t i on vector 0 . . 4 8\n\n; $62 . . $92 −> y−component (y−coord inate ) o f po s i t i on vector 0 . . 4 8\n12 ;\n\n; JOYSTICKDELTA ($6D) = I n i t i a l value o f SIGN . Used va lues are :\n14 ; $01 −> (= Pos i t i v e ) Rotate r i gh t or up\n\n; $FF −> (= Negative ) Rotate l e f t or down\n16\n\n; TERM3 i s a 24−b i t value , r epre sented by 3 bytes as\n18 ; $ ( s i gn ) ( high byte ) ( low byte )\n\n=006A L .TERM3LO = $6A ; TERM3 ( high byte ) , where TERM3 := TERM2 / 64\n20 =006B L .TERM3HI = $6B ; TERM3 ( low byte ) , where TERM3 := TERM2 / 64\n\n=006C L .TERM3SIGN = $6C ; TERM3 ( s ign ) , where TERM3 := TERM2 / 64\n22\n\nB69B BDAD09 ROTATE LDA ZPOSSIGN,X ;\n24 B69E 4901 EOR #$01 ;\n\nB6A0 F002 BEQ SKIP224 ; Skip i f s i gn o f TERM2 i s p o s i t i v e\n26 B6A2 A9FF LDA #$FF ;\n\n28 B6A4 856B SKIP224 STA L .TERM3HI ; I f TERM2 pos . −> TERM3 := $0000xx (= TERM2 / 256)\nB6A6 856C STA L .TERM3SIGN ; I f TERM2 neg . −> TERM3 := $FFFFxx (= TERM2 / 256)\n\n30 B6A8 BD400A LDA ZPOSHI ,X ; where xx := TERM2 ( high byte )\nB6AB 856A STA L .TERM3LO ;\n\n32\nB6AD AD0AD2 LDA RANDOM ; (? ) Hack to avoid messing with two−complement ’ s\n\n34 B6B0 09BF ORA #$BF ; (? ) a r i thmet i c ? Provides two l e a s t s i g n i f i c a n t\nB6B2 5DD30A EOR ZPOSLO,X ; (? ) b i t s B1 . . 0 in TERM3.\n\n36\nB6B5 0A ASL A ; TERM3 := TERM3 ∗ 4 (= TERM2 / 256 ∗ 4 = TERM2 / 64)\n\n38 B6B6 266A ROL L .TERM3LO ;\nB6B8 266B ROL L .TERM3HI ;\n\n40 B6BA 0A ASL A ;\nB6BB 266A ROL L .TERM3LO ;\n\n42 B6BD 266B ROL L .TERM3HI ;\n\n44 B6BF A56D LDA JOYSTICKDELTA ; Toggle SIGN fo r next c a l l o f ROTATE\nB6C1 49FF EOR #$FF ;\n\n46 B6C3 856D STA JOYSTICKDELTA ;\nB6C5 301A BMI SKIP225 ; I f SIGN negat ive then subtract , e l s e add TERM3\n\n48\n;∗∗∗ Addition ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗\n\n50 B6C7 18 CLC ; TERM1 := TERM1 + TERM3\nB6C8 B9D30A LDA ZPOSLO,Y ; (24− b i t add i t i on )\n\n52 B6CB 656A ADC L .TERM3LO ;\nB6CD 99D30A STA ZPOSLO,Y ;\n\n54\nB6D0 B9400A LDA ZPOSHI ,Y ;\n\n56 B6D3 656B ADC L .TERM3HI ;\nB6D5 99400A STA ZPOSHI ,Y ;\n\n58\nB6D8 B9AD09 LDA ZPOSSIGN,Y ;\n\n60 B6DB 656C ADC L .TERM3SIGN ;\nB6DD 99AD09 STA ZPOSSIGN,Y ;\n\n62 B6E0 60 RTS ;\n\n64 ;∗∗∗ Subtract ion ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗\nB6E1 38 SKIP225 SEC ; TERM1 := TERM1 − TERM3\n\n66 B6E2 B9D30A LDA ZPOSLO,Y ; (24− b i t subt rac t i on )\nB6E5 E56A SBC L .TERM3LO ;\n\n68 B6E7 99D30A STA ZPOSLO,Y ;\n\n70 B6EA B9400A LDA ZPOSHI ,Y ;\nB6ED E56B SBC L .TERM3HI ;\n\n72 B6EF 99400A STA ZPOSHI ,Y ;\n\n74 B6F2 B9AD09 LDA ZPOSSIGN,Y ;\nB6F5 E56C SBC L .TERM3SIGN ;\n\n76 B6F7 99AD09 STA ZPOSSIGN,Y ;\nB6FA 60 RTS ;\n\nFigure 3. ROTATE Subroutine at $B69B\n\n13\n\n\n\nthe fierce fight for each spare ROM byte.\n\n2.4.1 Loop Jamming\n\nLoop jamming is the technique of combining two\nloops into one, reusing the loop index and option-\nally skipping operations of one loop when the loop\nindex overshoots.\n\nHow much bytes are saved by loop jamming? As\nan example, Figure 4 shows an original 19-byte frag-\nment of subroutine INITIALIZE ($B3BA) using loop\njamming. The same fragment without loop jam-\nming, shown in Figure 5, is 20 bytes long. So loop\njamming saved one single byte.\n\nAnother example is the loop that is set up at\n$A165 in INITCOLD ($A14A). A third example is the\nloop set up at $B413 in INITIALIZE ($B3BA). This\nloop does not explicitly skip loop indices, thus sav-\ning four more bytes (the CMP and BCS instructions)\non top of the one byte saved by regular loop jam-\nming. Thus, seven bytes are saved in total by loop\njamming.\n\n2.4.2 Sharing Blank Characters\n\nOne more technique to save bytes is to let strings\nshare their leading and trailing blank characters. In\nthe game there is a header text line of twenty char-\nacters that displays one of the strings “LONG RANGE\nSCAN,” “AFT VIEW,” or “GALACTIC CHART.” The dis-\nplay hardware directly points to their location in the\nROM. They are enclosed in blank characters (bytes\nof value $00) so that they appear horizontally cen-\ntered.\n\nA naive implementation would use 3 × 20 = 60\nbytes to store these strings in ROM. In the actual\nimplementation, however, the trailing blanks of one\nheader string are reused as leading blanks of the\nfollowing header, as shown in Figure 6. By shar-\ning blank characters the required memory is reduced\nfrom 60 bytes to 54 bytes, saving six bytes.\n\n2.4.3 Reusing Interrupt Exit Code\n\nYet another, rather traditional technique is to reuse\ncode, of course. Figure 7 shows the exit code of the\nVertical Blank Interrupt handler VBIHNDLR ($A6D1)\nat $A715, which jumps into the exit code of the Dis-\nplay List Interrupt handler DLSTHNDLR ($A718) at\n$A74B, reusing the code that restores the registers\nthat were put on the CPU stack before entering the\nVertical Blank Interrupt handler.\n\nThis saves another six bytes (PLA, TAY, PLA, TAX,\nPLA, RTI), but spends three bytes (JMP JUMP004), in\ntotal saving three bytes.\n\n2.5 Bugs\nThere are a few bugs, or let’s call them glitches, in\nSTAR RAIDERS. This is quite astonishing, given the\ncomplex game and the development tools of 1979,\nand is a testament to thorough play testing. The\ninteresting thing is that the often intense game play\ndistracts the players’ attention from noticing these\nglitches, just like what a skilled parlor magician\nwould do.\n\n2.5.1 A Starbase Without Wings\n\nWhen a starbase reaches the lower edge of the graph-\nics screen and overlaps with the Control Panel Dis-\nplay below (Figure 8 (left), screenshot) and you\nnudge the starbase a little bit more downward, its\nwings suddenly vanish (Figure 8 (right), screenshot).\n\nThe reason is shown in the insert on the right\nside of the figure: The starbase is a composite of\nthree Players (sprites). Their bounding boxes are\nindicated by three white rectangles. If the verti-\ncal position of the top border of a Player is larger\nthan a vertical position limit, indicated by the tip\nof the white arrow, the Player is not displayed. The\nrelevant location of the comparison is at $A534 in\nGAMELOOP ($A1F3). While the Player of the central\npart of the starbase does not exceed this vertical\nlimit, the Players that form the starbase’s wings do\nso, and are thus not rendered.\n\nThis glitch is rarely noticed because players do\ntheir best to keep the starbase centered on the\nscreen, a prerequisite for a successful docking.\n\n2.5.2 Shuffling Priorities\n\nThere are two glitches that are almost impossible to\nnotice (and I admit some twisted kind of pleasure to\nexpose them, ;-):\n\n• During regular gameplay, the Zylon ships and\nthe photon torpedoes appear in front of the\ncross hairs (Figure 9 (left)), as if the cross hairs\nwere light years away.\n\n• During docking, the starbase not only appears\nbehind the stars (Figure 9 (right)) as if the\nstarbase is light years away, but the transfer\nvessel moves in front of the cross hairs!\n\n14\n\n\n\n1 B3BA A259 INITIALIZE LDX #89 ; Set 89(+1) GRAPHICS7 rows from DSPLST+5 on\nB3BC A90D LOOP060 LDA #$0D ; Prep DL in s t r u c t i o n $0D ( one row of GRAPHICS7)\n\n3 B3BE 9D8502 STA DSPLST+5,X ; DSPLST+5,X := one row of GRAPHICS7\nB3C1 E00A CPX #10 ;\n\n5 B3C3 B005 BCS SKIP195 ;\nB3C5 BDA9BF LDA PFCOLORTAB,X ; Copy PLAYFIELD co l o r tab l e to zero−page tab l e\n\n7 B3C8 95F2 STA PF0COLOR,X ; ( loop jamming )\nB3CA CA SKIP195 DEX ;\n\n9 B3CB 10EF BPL LOOP060 ;\n\nFigure 4. INITIALIZE Subroutine at $B3BA (Excerpt)\n\n1 B3BA A259 INITIALIZE LDX #89 ; Set 89(+1) GRAPHICS7 rows from DSPLST+5 on\nB3BC A90D LOOP060 LDA #$0D ; Prep DL in s t r u c t i o n $0D ( one row of GRAPHICS7)\n\n3 B3BE 9D8502 STA DSPLST+5,X ; DSPLST+5,X := one row of GRAPHICS7\nB3C1 CA DEX ;\n\n5 B3C2 10F8 BPL LOOP060 ;\nB3C4 A209 LDX #9 ;\n\n7 B3C6 BDAABF LOOP060B LDA PFCOLORTAB,X ; Copy PLAYFIELD co l o r tab l e to zero−page tab l e\nB3C9 95F2 STA PF0COLOR,X ;\n\n9 B3CB CA DEX ;\nB3CC 10F8 BPL LOOP060B ;\n\nFigure 5. INITIALIZE Subroutine Without Loop Jamming (Excerpt)\n\nThe reason is the drawing order or “graphics pri-\nority” of the bit-mapped graphics and the Players\n(sprites). It is controlled by the PRIOR ($D01B) hard-\nware register.\n\nDuring regular flight, see Figure 9 (left), PRIOR\n($D01B) has a value of $11. This arranges the dis-\nplayed elements in the following order, from front to\nback:\n\n• Players 0-4 (photon torpedoes, Zylon ships,\n. . . )\n\n• Bit-mapped graphics (stars, cross hairs)\n\n• Background.\n\nThis arrangement is fine for the stars as they are\nbit-mapped graphics and need to appear behind the\nphoton torpedoes and the Zylon ships, but this ar-\nrangement applies also to the cross hairs – causing\nthe glitch.\n\nDuring docking, see Figure 9 (right), PRIOR\n($D01B) has a value of $14. This arranges the dis-\nplayed elements the following order, from front to\nback:\n\n• Player 4 (transfer vessel)\n\n• Bit-mapped graphics (stars, cross hairs)\n\n• Players 0-3 (starbase, . . . )\n\n• Background.\n\nThis time the arrangement is fine for the cross\nhairs as they are bit-mapped graphics and need to\nappear in front of the starbase, but this arrangement\nalso applies to the stars. In addition, the Player of\nthe white transfer vessel correctly appears in front\nof the bit-mapped stars, but also in front of the bit-\nmapped cross hairs.\n\nFixing these glitches is hardly possible, as the\ndisplay hardware does not allow for a finer control\nof graphics priorities for individual Players.\n\n2.6 A Mysterious Finding\nA simple instruction at location $A175 contained\nthe most mysterious finding in the game’s code.\nThe disassembler reported the following instruction,\nwhich is equivalent to STA $0067,X. (ISVBISYNC has\na value of $67.)\nA175 9D6700 STA ISVBISYNC,X\n\nThe object code assembled from this instruction\nis unusual as its address operand was assembled\nas a 16-bit address and not as an 8-bit zero-page\naddress. Standard 6502 assemblers would always\ngenerate shorter object code, producing 9567 (STA\n$67,X) instead of 9D6700 and saving a byte.\n\nIn my reverse engineered source code, the only\nway to reproduce the original object code was the\nfollowing:\n\n15\n\n\n\n;∗∗∗ Header text o f Long−Range Scan view ( share s spaces with f o l l ow ing header ) ∗\n2 A0F8 00006C6F LRSHEADER .BYTE $00 , $00 , $6C , $6F , $6E , $67 , $00 , $72 ; ‘ ‘ LONG RANGE SCAN’ ’\n\nA0FC 6E670072\n4 A100 616E6765 .BYTE $61 , $6E , $67 , $65 , $00 , $73 , $63 , $61\n\nA104 00736361\n6 A108 6E .BYTE $6E\n\n8 ;∗∗∗ Header text o f Aft view ( share s spaces with f o l l ow ing header ) ∗∗∗∗∗∗∗∗∗∗∗∗∗\nA109 00000000 AFTHEADER .BYTE $00 , $00 , $00 , $00 , $00 , $00 , $61 , $66 ; ‘ ‘ AFT VIEW ‘ ‘\n\n10 A10D 00006166\nA111 74007669 .BYTE $74 , $00 , $76 , $69 , $65 , $77 , $00 , $00\n\n12 A115 65770000\nA119 00 .BYTE $00\n\n14\n;∗∗∗ Header text o f Ga lac t i c Chart view ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗\n\n16 A11A 00000067 GCHEADER .BYTE $00 , $00 , $00 , $67 , $61 , $6C , $61 , $63 ; ‘ ‘ GALACTIC CHART ‘ ‘\nA11E 616C6163\n\n18 A122 74696300 .BYTE $74 , $69 , $63 , $00 , $63 , $68 , $61 , $72\nA126 63686172\n\n20 A12A 74000000 .BYTE $74 , $00 , $00 , $00\n\nFigure 6. Header Texts at $A0F8\n\nA6D1 A9FF VBIHNDLR LDA #$FF ; Star t o f Ve r t i c a l Blank In t e r rupt handler\n2 . . .\n\nA715 4C4BA7 SKIP046 JMP JUMP004 ; End of Ve r t i c a l Blank In t e r rupt handler\n4 . . .\n\nA718 48 DLSTHNDLR PHA ; Star t o f Display L i s t In t e r rupt handler\n6 . . .\n\nA74B 68 JUMP004 PLA ; Restore r e g i s t e r s\n8 A74C A8 TAY ;\n\nA74D 68 PLA ;\n10 A74E AA TAX ;\n\nA74F 68 PLA ;\n12 A750 40 RTI ; End of Display L i s t In t e r rupt Handler\n\nFigure 7. VBIHNDLR and DLSTHNDLR Handlers Share Exit Code\n\n1 ; HACK: Fake STA ISVBISYNC,X with 16b addr\nA175 9D .BYTE $9D\n\n3 A176 6700 .WORD ISVBISYNC\n\nI speculated for a long time whether this strange\nassembler output indicated that the object code of\nthe original ROM cartridge was produced with a\nnon-standard 6502 assembler. I have heard that\nAtari’s in-house development systems ran on PDP-\n11 hardware. Luckily, the month after I finished\nmy reverse engineering effort, the original STAR\nRAIDERS source code re-surfaced.7 To my aston-\nishment it uses exactly the same “hack” to repro-\nduce the three-byte form of the STA ISVBISYNC,X\ninstruction:\n\n1 A175 9D .BYTE $9D ; STA ABS,X\nA176 67 00 .WORD PAGE0 ; STA PAGE0,X (ABSOLUTE)\n\nUnfortunately the comments do not give a clue\nwhy this pattern was chosen. After quite some time\n\nit made click: The instruction STA ISVBISYNC,X is\nused in a loop which iterates the CPU’s X register\nfrom 0 to 255 to clear memory. By using this instruc-\ntion with a 16-bit address (“indexed” mode operand)\nmemory from $0067 to $0166 is cleared. Had the\ncode been using the same operation with an 8-bit ad-\ndress (“indexed, zero-page” mode operand), memory\nfrom $0067 to $00FF would have been cleared, then\nthe indexed address would have wrapped back to\n$0000 clearing memory $0000 to $0066, effectively\noverwriting already initialized memory locations.\n\n2.7 Documenting Star Raiders\n\nRight from the start of reverse engineering STAR\nRAIDERS I not only wanted to understand how the\ngame worked, but I also wanted to document the re-\nsult of my effort. But what would be an appropriate\nform?\n\nFirst, I combined the emerging memory map file\nwith the fledgling assembly language source code in\n\n7https://archive.org/details/AtariStarRaidersSourceCode\nunzip pocorgtfo13.pdf StarRaidersOrig.pdf\n\n16\n\n\n\nFigure 8. A Starbase’s Wings Vanish\n\nFigure 9. Photon torpedo in front of cross hairs and a starbase behind the stars!\n\norder to work with just one file. Then, I switched\nthe source code format to that of MAC/65, a well-\nknown and powerful macro assembler for the Atari\n8-bit Home Computer System. I also planned, at\nsome then distant point in the future, to assemble\nthe finished source code with this assembler on an\n8-bit Atari.\n\nAnother major influence on the emerging docu-\nmentation was the Atari BASIC Source Book, which\nI came across by accident8. It reproduced the com-\nplete, commented assembly language source code of\nthe 8 KB Atari BASIC interpreter cartridge, a truly\nnon-trivial piece of software. But what was more:\nThe source code was accompanied by several chap-\nters of text that explained in increasing detail its\nconcepts and architecture, that is, how Atari BASIC\nactually worked. Deeply impressed, I decided on\nthe spot that my reverse engineered STAR RAIDERS\nsource code should be documented at the same level\nof detail.\n\nThe overall documentation structure for the\nsource code, which I ended up with was fourfold: On\nthe lowest level, end-of-line comments documented\nthe functionality of individual instructions. On the\nnext level, line comments explained groups of in-\nstructions. One level higher still, comments com-\n\nposed of several paragraphs introduced each sub-\nroutine. These paragraphs provided a summary of\nthe subroutine’s implementation and a description\nof all input and output parameters, including the\nvalid value ranges, if possible. On the highest level,\nI added the memory map to the source code as a\nhandy reference. I also planned to add some chap-\nters on the game’s general concepts and overall ar-\nchitecture, just like the Atari BASIC Source Book\nhad done. Unfortunately, I had to drop that idea\ndue to lack of time. I also felt that the detailed sub-\nroutine documentation was quite sufficient. How-\never, I did add sections on the 3D coordinate system\nand the position and velocity vectors to the source\ncode as a tip of the hat to the Atari BASIC Source\nBook.\n\nAfter I was well into reverse engineering STAR\nRAIDERS, slowly adding bits and pieces of informa-\ntion to the raw disassembly of the STAR RAIDERS\nROM and fleshing out the ever growing documen-\ntation, I started to struggle with establishing a con-\nsistent and uniform terminology for the documenta-\ntion (Is it “asteroid,” “meteorite,” or “meteor”? “Ex-\nplosion bits,” “explosion debris,” or “explosion frag-\nments”? “Gun sights” or “cross hairs”?) A look into\nthe STAR RAIDERS instruction manual clarified only\n\n8The Atari BASIC Source Book by Wilkinson, O’Brien, and Laughton. A COMPUTE! publication.\n\n17\n\n\n\na painfully small amount of cases. Incidentally, it\nalso contradicted itself as it called the enemies “Cy-\nlons” while the game called them “Zylons,” such as\nin the message “SHIP DESTROYED BY ZYLON FIRE.”\n\nBut I was not only after uniform documenta-\ntion, I also wanted to unify the symbol names of\nthe source code. For example, I had created a\nhodge-podge of color-related symbol names, which\ncontained fragments such as “COL,” “CLR,” “COLR,”\nand “COLOR.” To make matters worse, color-related\nsymbol names containing “COL” could be confused\nwith symbol names related to (pixel) columns. The\nsame occurred with symbol names related to Players\n(sprites), which contained fragments such as “PL,”\n“PLY,” “PLYR,” “PLAY,” and “PLAYER,” or with sym-\nbol names of lookup tables, which ended in “TB,”\n“TBL,” “TAB,” and “TABLE,” and so on. In addition\nto inventing uniform symbol names I also did not\nwant to exceed a self-imposed symbol name limit of\n15 characters. So I refactored the source code with\nthe search-and-replace functionality of the text edi-\ntor over and over again.\n\n18\n\n\n\nI noticed that I spent more and more time\non refactoring the documentation and the symbol\nnames and less time on adding actual content. In\naddition, the actual formatting of the emerging doc-\numented source code had to be re-adjusted after ev-\nery refactoring step. Handling the source code be-\ncame very unwieldy. And worst of all: How could\nI be sure that the source code still represented the\nexact binary image of the ROM cartridge?\n\nThe solution I found to this problem eventually\nwas to create an automated build pipeline, which\ndealt with the monotonous chores of formatting and\nassembling the source code, as well as comparing the\nproduced ROM cartridge image with a reference im-\nage. This freed time for me to concentrate on the\nactual source code content. Yet another incarnation\nof “separation of form and content,” the automated\nbuild pipeline was always a pleasure to watch work-\ning its magic. (Mental note: I should have created\nthis pipeline much earlier in the reverse engineering\neffort.) These are the steps of the automated build\npipeline:\n\n1. The pipeline starts with a raw, documented as-\nsembly language source code file. It is already\nroughly formatted and uses a little propri-\netary markup, just enough to mark up sections\nof meta-comments that are to be removed in\nthe output as well as subroutine documen-\ntation containing multiple paragraphs, num-\nbered, and unnumbered lists. This source code\nfile is fed to a pre-formatter program, which\nI implemented in Java. The pre-formatter re-\nmoves the meta-comments. It also formats the\nentries of the memory map and the subroutine\n\ndocumentation by wrapping multi-line text at\na preset right margin, out- and indenting list\nitems, numbering lists, and vertically aligning\nparameter descriptions. It also corrects the\nnumber of trailing asterisks in line comments,\nand adjusts the number of asterisks of the box\nheaders that introduce subroutine comments,\ncentering their text content inside the asterisk\nboxes.\n\n2. The output of the pre-formatter from step 1 is\nfed into an Atari 6502 assembler, which I also\nwrote in Java. It is available as open-source\non GitHub.9 Why write an Atari 6502 assem-\nbler? There are other 6502 assemblers readily\navailable, but not all produce object code for\nthe Atari 8-bit Home Computer System, not\nall use the MAC/65 source code format, and\nnot all of them can be easily tweaked when\nnecessary. The output of this step is both an\nassembler output listing and an object file.\n\n3. The assembler output listing from step 2 is the\nfinished, formatted, reverse engineered STAR\nRAIDERS source code, containing the docu-\nmentation, the source code, and the object\ncode listing.\n\n4. The assembler output listing from step 2 is fed\ninto a symbol checker program, which I again\nwrote in Java. It searches the documenta-\ntion parts of the assembler output listing and\nchecks if every symbol, such as “GAMELOOP,” is\nfollowed by its correct hex value, “($A1F3).” It\nreports any symbol with missing or incorrect\nhex values. This ensures further consistency\nof the documentation.\n\n5. The object file of step 2 is converted by yet an-\nother program I wrote in Java from the Atari\nexecutable format into the final Atari ROM\ncartridge format.\n\n6. The output from step 5 is compared with a\nreference binary image of the original STAR\nRAIDERS 8 KB ROM cartridge. If both im-\nages are the same, then the entire build was\nsuccessful: The raw assembly language source\ncode really represents the exact image of the\nSTAR RAIDERS 8 KB ROM cartridge\n\n9git clone https://github.com/lwiest/Atari6502Assembler\nunzip pocorgtfo13.pdf Atari6502Assembler.zip\n\n19\n\n\n\nTypical build times on my not-so-recent Win-\ndows XP box (512 MB) were 15 seconds.\n\nFor some finishing touches, I ran a spell-checker\nover the documented assembly language source code\nfile from time to time, which also helped to improve\ndocumentation quality.\n\n2.8 Conclusion\nAfter quite some time, I achieved my goal to create a\nreverse engineered, complete, and fully documented\nassembly language source code of STAR RAIDERS.\nFor final verification, I successfully assembled it with\nMAC/65 on an Atari 800 XL with 64 KB RAM (em-\nulated with Atari800Win Plus). MAC/65 is able to\nassemble source code larger than the available RAM\nby reading the source code as several chained files.\nSo I split the source code (560 KB) into chunks of 32\nKB and simply had the emulator point to a hard disk\nfolder containing these files. The resulting assembler\noutput listing and the object file were written back\nto the same hard disk folder. The object file, after\nbeing transformed into the Atari cartridge format,\nexactly reproduced the original STAR RAIDERS 8 KB\nROM cartridge.\n\n2.9 Postscript\nI finished my reverse engineering effort in Septem-\nber 2015. I was absolutely thrilled to learn that in\nOctober 2015 scans of the original STAR RAIDERS\nsource code re-surfaced. To my delight, inspection\nof the original source code confirmed the findings of\nmy reverse engineered version and caused only a few\ntrivial corrections. Even more, the documentation\nof my reverse engineered version added a substan-\ntial amount of information – from overall theory of\noperation down to some tricky details – to the un-\nderstanding of the often sparsely commented origi-\nnal (quite expected for source code never meant for\npublication).\n\n20\n\n\n\n21\n\n00 7f 47 47 47 47 47 7f 00 30 10 10 10 38 38 38 00 78 08 08 78 40 40 78 00 78 08 08 7c 0c 0c 7c 00 60 60 60 6c 7c 0c 0c 00 78 40 40 78\n08 08 78 00 78 48 40 40 7e 42 7e 00 7c 44 04 1c 10 10 10 00 38 28 28 7c 6c 6c 7c 00 7c 44 44 7c 0c 0c 0c 00 00 00 00 00 00 00 00 38 38\n38 00 00 38 38 38 80 80 80 80 80 80 80 ff 00 3c 20 20 78 60 60 7c 00 66 99 99 99 66 00 00 00 00 00 7e 00 00 00 00 00 18 18 18 7e 18 18\n18 00 18 7e db 99 db 7e 18 66 66 66 66 66 2c 38 30 00 7c 44 44 7c 68 6c 6c 00 1c 3e 63 5d 63 3e 1c 00 46 46 44 7c 64 66 66 fe 92 10 18\n18 18 18 18 fc 8c 8c 80 80 80 84 fc 00 00 00 00 00 00 00 ff 80 80 80 80 80 80 80 80 00 00 00 00 00 00 00 80 80 aa 9c be 9c aa 80 ff 80\n98 80 b6 80 8c 80 ff 80 8e 80 b8 80 9c 80 ff 80 b0 98 be 98 b0 80 ff 00 00 6c 6f 6e 67 00 72 61 6e 67 65 00 73 63 61 6e 00 00 00 00 00\n00 61 66 74 00 76 69 65 77 00 00 00 00 00 00 67 61 6c 61 63 74 69 63 00 63 68 61 72 74 00 00 00 60 46 1a a1 f0 47 35 0d 07 07 07 07 07\n07 07 07 80 46 1f 0d 46 71 09 06 06 41 80 02 a9 00 8d 0f d2 85 66 85 62 85 63 a9 03 8d 0f d2 a0 2f a9 ff 84 65 85 64 a9 00 aa 9d 00 d0\n9d 00 d4 e0 0f b0 03 9d 00 d2 9d 00 d3 9d 67 00 e8 d0 ea ca 9a d8 a9 02 20 0f ae a9 51 8d 16 02 a9 a7 8d 17 02 a9 d1 8d 22 02 a9 18 8d\n00 02 a9 a6 8d 23 02 a9 a7 8d 01 02 a9 04 8d 02 d3 a9 11 8d 1b d0 a9 03 8d 1d d0 20 ba b3 a2 0a 20 45 b0 a5 64 29 80 a8 a2 5f a9 08 20\nf1 ad a9 20 85 71 a9 80 8d 02 d4 a9 02 8d 03 d4 a9 3e 8d 00 d4 a9 00 8d 07 d4 a9 10 85 79 a6 62 bc 0c bf 20 23 b2 a9 40 8d 0e d2 58 a9\nc0 8d 0e d4 a5 67 f0 fc a9 00 85 67 a5 7a f0 20 a2 04 e8 bc 5b 0c b9 00 08 85 68 b9 64 08 85 69 bc 8c 0c bd bd 0c 91 68 e4 7a 90 e6 a9\n00 85 7a a5 c0 30 2d a6 79 86 7a bd f9 0b 9d 5b 0c a8 b9 00 08 85 68 b9 64 08 85 69 bd 2a 0c 4a 4a 9d 8c 0c a8 b1 68 9d bd 0c 1d ee 0c\n91 68 ca e0 04 d0 d7 a5 66 10 0e a9 00 8d e3 17 8d e4 17 8d bc 17 8d bb 17 a9 00 ac 5f 0c ae c1 0c 99 00 03 c8 ca 10 f9 ac 5e 0c ae c0\n0c 99 00 07 c8 ca 10 f9 ac 5d 0c ae bf 0c 99 00 06 c8 ca 10 f9 ac 5c 0c ae be 0c 99 00 05 c8 ca 10 f9 ac 5b 0c ae bd 0c 99 00 04 c8 ca\n10 f9 ad 90 0c c9 01 a4 e8 ae fd 0b 8e 5f 0c ad f2 0c 85 6a 8d c1 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 03 c8 e8 c6 6a 10 ef ad 8f 0c c9 01\na4 e7 ae fc 0b 8e 5e 0c ad f1 0c 85 6a 8d c0 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 07 e8 c8 c6 6a 10 ef ad 8e 0c c9 01 a4 e6 ae fb 0b 8e 5d\n0c ad f0 0c 85 6a 8d bf 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 06 e8 c8 c6 6a 10 ef a4 e5 ae fa 0b 8e 5c 0c ad ef 0c 85 6a 8d be 0c b9 b1 b9\n9d 00 05 e8 c8 c6 6a 10 f4 a4 e4 ae f9 0b 8e 5b 0c ad ee 0c 85 6a 8d bd 0c b9 b1 b9 9d 00 04 e8 c8 c6 6a 10 f4 ad 2a 0c 8d 00 d0 ad 2b\n0c 8d 01 d0 ad 2c 0c 8d 02 d0 ad 2d 0c 8d 03 d0 ad 2e 0c 8d 07 d0 18 69 02 8d 06 d0 69 02 8d 05 d0 69 02 8d 04 d0 24 d0 30 3a a5 c8 f0\n19 85 6d a4 79 84 6e 18 98 aa 69 31 a8 20 9b b6 98 aa a4 6e 20 9b b6 88 10 eb a5 c9 f0 19 85 6d a4 79 84 6e 18 98 aa 69 62 a8 20 9b b6\n98 aa a4 6e 20 9b b6 88 10 eb a6 79 e0 05 b0 05 bd 8c 0c f0 19 38 bd d3 0a e5 70 9d d3 0a bd 40 0a e5 c1 9d 40 0a bd ad 09 e9 00 9d ad\n09 ca 10 db a6 79 e0 10 d0 02 a2 04 8a a8 a9 00 85 6b b9 66 0b 10 09 49 7f 18 69 01 b0 02 c6 6b 18 79 d3 0a 99 d3 0a b9 40 0a 65 6b 99\n40 0a b9 ad 09 65 6b 99 ad 09 98 18 69 31 c9 90 90 ce ca 10 c4 a0 04 98 aa a9 02 85 6a bd ad 09 c9 02 90 10 0a a9 00 9d ad 09 b0 05 fe\nad 09 49 ff 9d 40 0a 8a 18 69 31 aa c6 6a 10 e0 88 10 d7 a5 d0 c9 02 b0 5c a6 79 a9 ff bc ad 09 c4 d0 f0 4b bd 0f 0a d0 12 38 a9 00 fd\n35 0b 85 6a a9 00 fd a2 0a 85 6b 4c 7d a4 bd 35 0b 85 6a bd a2 0a 85 6b 20 21 aa 20 1e b7 bd de 09 d0 12 38 a9 00 fd 04 0b 85 6a a9 00\nfd 71 0a 85 6b 4c a4 a4 bd 04 0b 85 6a bd 71 0a 85 6b 20 21 aa 20 fb b6 ca 10 a6 20 62 b1 24 d0 50 31 a2 31 20 6f a7 2c 96 09 70 27 a6\n79 bd 40 0a bc ad 09 d0 02 49 ff a8 b9 e9 0d 20 1e b7 bd 71 0a bc de 09 d0 02 49 ff a8 b9 e9 0d 20 fb b6 ca 10 db a2 05 ca 10 03 4c 79\na5 a9 00 95 e4 9d ee 0c 24 d0 10 0b e0 03 90 eb ad 0a d2 a0 f2 30 2b d5 e9 f0 e0 70 f3 bc 40 0a 24 7b 50 1e e0 02 b0 16 ad 2c 0c 18 7d\ndb be 9d 2a 0c ad fb 0b 18 69 04 9d f9 0b ac 42 0a a5 76 29 0f 85 6b 98 bc f9 0b c0 cc b0 af a4 d0 f0 02 49 ff c9 20 b0 a5 c9 10 90 02\na9 0f 85 6a 1d 8c 0c 4a a8 b9 2f be 95 e4 b9 7f be 9d ee 0c 98 4a 4a 4a a8 b9 d1 bf c0 08 d0 03 4d 0a d2 a4 6a 59 db bf 45 6b bc df b8\n99 ee 00 4c e7 a4 a0 af a6 81 a5 8b f0 0c c6 8b a0 4f 29 20 f0 04 a2 42 a0 60 84 f4 86 f6 a6 79 bd 40 0a a4 d0 c0 01 d0 09 c9 f0 b0 03\n20 64 b7 49 ff c9 10 90 02 a9 0f 0a 29 1c 05 72 a8 b9 90 ba 85 6a bd 2a 0c 29 03 a8 b9 b0 ba 25 6a 9d ee 0c ca e0 05 b0 ca 24 64 50 03\n4c 9b a6 20 fe af ad 00 d3 a8 29 03 aa bd f5 ba 85 c9 98 4a 4a 29 03 aa bd f5 ba 85 c8 20 3d af 20 29 ae 2c 95 09 70 40 a5 7e f0 3c a5\nd0 d0 03 20 bf a7 ae 5c 09 a5 bf 30 05 aa 09 80 85 bf b5 e9 d0 0b 8a 49 01 aa b5 e9 d0 03 ae 5c 09 8e 5c 09 a5 7c f0 13 a5 d0 c9 02 b0\n0d 49 01 dd ad 09 f0 06 aa bd cf be 85 ca 20 e6 ac 20 79 aa a5 7b d0 5c a5 eb f0 58 ac 42 0a c8 c0 02 b0 50 ac 73 0a c8 c0 02 b0 48 ac\na4 0a c8 c0 02 b0 40 20 e1 ae a0 02 20 6b ac a2 7f a5 81 d0 1e a2 0a 20 45 b0 a0 23 a2 08 20 0a b1 a2 5f a0 80 a9 08 20 f1 ad 20 0d ae\na2 40 86 e3 a2 ff 86 8a a9 00 85 eb a9 02 85 be a2 01 20 6f b8 a2 0a 20 a8 ae a4 63 ad 1f d0 49 ff 29 03 85 63 f0 1a 88 10 17 85 66 c9\n02 b0 06 a9 00 a8 4c 5e a1 e6 62 a5 62 29 03 85 62 4c 5a a1 20 04 b8 20 9b a8 20 16 b2 20 e4 b4 4c f3 a1 a9 ff 85 67 a9 e0 8d 09 d4 a6\nf6 ad 0a d2 24 8a 50 07 30 04 29 72 09 40 aa a5 d0 c9 03 90 02 a2 a0 86 f6 a2 08 b5 ee 9d 12 d0 ca 10 f8 8d 1e d0 20 ab b2 e6 77 d0 0d\na5 66 30 09 e6 66 10 05 a0 00 4c 5c a1 4c 4b a7 48 8a 48 98 48 a9 e0 ac 0b d4 c0 60 f0 02 a9 a0 8d 09 d4 a2 04 8d 0a d4 b5 f7 9d 16 d0\nca 10 f8 ad 08 d0 0d 09 d0 0d 0a d0 0d 0b d0 85 83 ad 0f d0 85 82 68 a8 68 aa 68 40 48 a9 00 8d 0e d2 a9 40 8d 0e d2 ad 09 d2 09 c0 85\nca 68 40 99 a4 00 e8 88 10 0e 20 82 a7 a9 05 85 a2 2c 95 09 70 09 a0 02 bd f9 ba c9 fe d0 e4 60 a9 55 85 6b a5 a4 85 6e 29 7f 85 a4 a4\na5 b9 00 08 85 68 b9 64 08 85 69 a5 a6 4a 4a 85 6a a5 a6 29 03 a8 b9 b0 ba 25 6b a4 6a 11 68 91 68 24 6e 10 04 e6 a5 d0 02 e6 a6 c6 a4\nd0 d0 60 ae 5c 09 a4 a2 c0 05 b0 24 a5 a0 85 a6 b9 6e bf 0a 85 6c 90 0d a9 81 85 a4 a5 a1 85 a5 a9 aa 20 84 a7 e6 a6 a5 6c d0 e8 e6 a1\ne6 a2 60 c0 0a 90 f9 b5 e9 f0 3c bd 71 0a bc de 09 f0 08 c9 0c 90 0a a9 0b 10 06 c9 f5 b0 02 a9 f5 18 69 83 85 a0 bd a2 0a 49 ff bc 0f\n0a d0 08 c9 05 90 0a a9 04 10 06 c9 fa b0 02 a9 fa 18 69 4d 85 a1 a9 00 85 a2 a9 36 85 68 a9 1b 85 69 a2 0e a0 06 b1 68 29 55 91 68 88\n10 f7 18 a5 68 69 28 85 68 90 02 e6 69 ca 10 e7 ae 5c 09 c8 a5 88 f0 04 c6 88 d0 39 a5 a0 c9 81 90 33 c9 85 b0 2f a9 aa 8d fe 1b 8d 04\n1c a5 a1 c9 4b 90 21 c9 4f b0 1d a9 aa 8d 9e 1c 8d a4 1c bd 40 0a c9 0c b0 0e a0 a0 8c 40 1d 8c 68 1d 8c 42 1d 8c 6a 1d 84 a3 60 a4 c0\nf0 61 a5 70 c9 fe b0 5c c9 80 90 03 20 b4 a9 a9 03 8d 5c 09 a9 90 8d 8f 0c 85 ec a9 1f 8d 43 0a 38 ad fc 0b e9 77 18 65 c5 29 7f 85 8e\n38 ad 2d 0c e9 7d 18 65 c4 29 7f 85 8f a5 62 f0 11 ad 0a d2 a4 d0 f0 06 8d 2d 0c 8d fc 0b c9 10 b0 14 ad 0a d2 09 10 25 c6 8d 9a 0b ad\n0a d2 09 10 25 c6 8d cb 0b 60 98 30 11 a9 ff 85 c0 a2 00 20 a6 b3 20 a7 b1 a0 1b 4c 8d a9 c6 91 f0 05 a2 02 4c 6f b8 a0 19 20 87 a9 a5\n8f 85 8d a5 8e 85 8c 4a 29 07 aa bd b3 bf 85 c7 a4 92 84 90 a9 00 85 7b be c9 08 10 2e a9 ff 85 7b a0 00 a9 00 99 68 0b a9 01 99 af 09\nad 0a d2 25 c7 99 42 0a 98 18 69 31 a8 c9 93 90 e5 ad 42 0a 09 71 8d 42 0a a2 02 4c be b7 f0 0e a9 ff 85 8b a2 06 20 a6 b3 a0 75 20 23\nb2 60 a2 01 20 6f b8 a0 17 a9 00 85 71 85 c0 a9 10 85 79 a9 00 85 c1 85 73 85 8a 8d 8f 0c 85 80 c0 17 f0 04 85 e9 85 ea 85 eb 85 ec 85\ned 85 75 8d 5c 09 4c 23 b2 c6 c2 10 68 a9 01 85 c1 a9 30 85 79 a9 03 85 c2 a6 c3 a9 12 85 69 ad 0a d2 29 03 a8 b9 3a bb 9d 71 0a b9 3e\nbb 9d a2 0a 20 be b7 8a a8 a9 05 85 6e 18 a5 68 69 50 85 68 9d d3 0a a5 69 69 00 85 69 9d 40 0a a9 00 9d 66 0b 9d 97 0b 9d c8 0b a9 01\n9d ad 09 a9 63 9d f9 0b 9d 2a 0c 20 c1 ac ca e0 11 b0 02 a2 30 c6 6e 10 c7 86 c3 60 a9 00 85 6d a9 07 85 6e 46 6b 66 6a a5 d0 d0 0f bd\n40 0a 4a 85 69 bd d3 0a 6a 85 68 4c 52 aa 38 a9 00 fd d3 0a 85 68 a9 00 fd 40 0a 4a 85 69 66 68 06 6d 38 a5 6a e5 68 a8 a5 6b e5 69 90\n06 85 6b 84 6a e6 6d 06 6a 26 6b 90 03 a9 ff 60 c6 6e 10 df a4 6d b9 e9 0d 60 a5 c0 05 7b d0 f9 a5 86 f0 30 a6 89 38 bd f9 0b ed fc 0b\n90 02 a9 00 20 ca ae 8d cb 0b 8d cc 0b 38 ad 2d 0c fd 2a 0c 20 ca ae 8d 9a 0b 38 ad 2e 0c fd 2a 0c 20 ca ae 8d 9b 0b a2 03 d6 ba 10 27\n8a 4a a8 b9 c8 00 a4 d0 f0 05 49 ff 18 69 01 18 75 b4 10 02 a9 00 c9 10 90 02 a9 0f 95 b4 c9 08 90 02 49 0f 0a 95 ba ca 10 d2 ad 8e 0c\nd0 1b a4 62 b9 85 bf ae a4 0a 10 02 29 7f 8d ca 0b 09 80 ae 73 0a 10 02 29 7f 8d 99 0b a5 76 29 03 f0 2e a5 e6 f0 04 a5 eb d0 25 ad 0a\nd2 c9 04 b0 1e a9 60 8d 8e 0c a2 02 20 64 b7 a9 3c 85 eb a9 88 8d 68 0b a9 00 8d 2c 0c 8d 99 0b 8d ca 0b 60 a5 a7 49 01 85 a7 aa b5 e9\nd0 42 a5 e9 05 ea 29 01 a4 90 d9 c9 08 b0 ba a9 ff 95 e9 ad 0a d2 29 07 a8 b9 89 bf 9d 8c 0c a5 62 f0 03 b9 91 bf 95 a8 a9 01 95 aa 9d\nad 09 ad 0a d2 25 c7 9d a2 0a 69 13 9d 71 0a 09 71 9d 40 0a 20 be b7 bd 40 0a c9 20 b0 11 bd ad 09 f0 08 b5 e4 f0 08 c9 29 f0 04 a9 00\n95 a8 d6 aa 10 24 a9 78 95 aa a5 62 ac 0a d2 c0 30 90 01 4a 4a 95 b8 b5 a8 2c 0a d2 10 02 49 0f 95 ac e8 e8 e0 06 90 f1 a6 a7 b5 a8 d0\n32 a4 a7 c0 31 b0 13 b9 b8 00 4a b9 40 0a b0 06 c9 0a 90 0e b0 04 c9 f5 b0 04 b9 ad 09 4a a9 0f b0 02 a9 00 95 ac 18 98 69 31 a8 e8 e8\ne0 06 90 d2 a6 a7 a4 a7 b5 b2 d5 ac f0 08 b0 04 f6 b2 90 02 d6 b2 86 6a aa bd 99 bf a6 6a 99 66 0b 98 18 69 31 a8 e8 e8 e0 06 90 dc a6\na7 ad 8e 0c d0 0b a5 eb d0 06 a5 be f0 03 c6 be 60 18 bd a2 0a 69 02 c9 05 b0 f5 a0 d0 bd ad 09 4a bd 40 0a b0 08 49 ff a4 62 f0 e4 a0\n50 c9 20 b0 de 8c 68 0b a9 00 8d 8e 0c 8d 2c 0c a9 3e 85 eb a2 02 a4 a7 84 bf 4c af ac a9 80 85 73 a2 30 86 79 ad 0a d2 29 0f 79 2a 0c\ne9 30 9d 2a 0c ad 0a d2 29 0f 79 f9 0b 4a e9 10 9d f9 0b 20 af ac ad 0a d2 29 87 9d 66 0b ad 0a d2 29 87 9d 97 0b ad 0a d2 29 87 9d c8\n0b ca e0 10 d0 c5 60 b9 ad 09 9d ad 09 b9 40 0a 9d 40 0a b9 d3 0a 9d d3 0a b9 de 09 9d de 09 b9 71 0a 9d 71 0a b9 0f 0a 9d 0f 0a b9 a2\n0a 9d a2 0a b9 04 0b 9d 04 0b b9 35 0b 9d 35 0b 60 a5 7b f0 fb a5 d0 d0 05 a9 14 8d 1b d0 a9 02 8d 5c 09 a9 30 8d 8e 0c a9 20 8d 8d 0c\na9 40 8d 8c 0c a9 ff a6 90 bc c9 08 30 02 a9 00 85 e9 85 ea 85 eb 85 7b 30 0a a0 02 20 6b ac a2 0a 4c a8 ae ad 42 0a d0 0a ad d5 0a c9\n20 b0 03 ee d5 0a ad 2c 0c 38 e9 78 c9 10 b0 22 ad fb 0b 38 e9 68 c9 10 b0 18 ad 42 0a c9 02 b0 11 ad af 09 2d 11 0a 49 01 05 70 0d a4\n0a 05 71 f0 10 a5 75 c9 02 90 05 a0 1f 20 23 b2 a9 00 85 75 60 24 75 70 0d 30 42 a5 75 d0 f5 c6 75 a0 1c 4c 23 b2 a2 00 86 65 a4 d1 d0\ne6 a9 50 8d 90 0c a9 01 8d b1 09 8d e2 09 8d 13 0a 8d a6 0a 8d 9b 0b a9 10 8d 44 0a a9 00 8d 75 0a a9 87 8d 6a 0b a9 81 85 75 8d cc 0b\n85 ed 60 ad b1 09 d0 fa a2 0c 20 a6 b3 a0 21 20 23 b2 a2 05 bd 8b bb 9d 92 09 ca 10 f7 a9 89 a2 03 9d 55 09 ca 10 fa a9 07 8d 6a 0b a9\n81 8d 9b 0b a9 01 8d cc 0b 85 75 4c 7b b0 78 85 6a ad 0b d4 c9 7c 90 f9 b9 62 ba c8 10 02 a9 0d 9d 80 02 e8 c6 6a d0 f0 58 60 a9 10 85\n69 a9 00 a8 85 68 85 a3 85 7a 91 68 c8 d0 fb e6 69 a4 69 c0 20 a8 90 f2 60 a5 84 ac 10 d0 84 84 d0 0e 84 66 a6 c0 d0 08 a6 87 c9 01 f0\n03 b0 18 60 b5 ec c9 e8 b0 f9 ac 5c 09 84 89 a9 0c a4 a3 84 86 f0 02 a9 00 85 88 84 84 2c 92 09 70 e1 30 05 8a 49 01 85 87 8a 9d e1 09\nbd 73 bf 9d 74 0a a9 ff 95 ec 9d a5 0a a9 00 9d 8f 0c 9d 43 0a 9d 07 0b 9d 12 0a 9d 38 0b a9 01 9d b0 09 9d d6 0a a5 d0 4a 6a 09 66 9d\n69 0b a9 00 9d 9a 0b 9d cb 0b a2 02 20 6f b8 a2 00 8a d0 06 a5 e1 c9 18 b0 18 a0 07 bd 20 bf 99 da 00 e8 88 10 f6 bd 20 bf 8d 08 d2 bd\n21 bf 8d 04 d2 60 a0 80 b0 04 49 ff a0 00 84 6a c9 08 90 02 a9 07 a8 a5 6a 19 c9 bf 60 24 64 30 57 a6 62 ad 0a d2 dd 10 bf b0 4d 29 07\nc9 06 b0 47 aa bd 92 09 0a 30 eb a5 eb c9 1e a9 80 bc 14 bf 90 17 e0 03 d0 05 2c 96 09 70 0e e0 04 d0 05 2c 95 09 70 05 a9 c0 bc 1a bf\n1d 92 09 9d 92 09 84 65 2c 95 09 50 07 a9 00 85 7e 20 0d ae a0 52 20 23 b2 a2 12 20 a6 b3 60 a2 02 ca 10 01 60 bd 8f 0c d0 f7 b5 ec f0\nf3 b5 82 29 07 f0 ed 4a c9 03 d0 01 4a a8 b9 e9 00 f0 e1 a5 d0 f0 02 a9 ff 85 6c 59 40 0a c9 10 90 02 a9 0f 4a 84 6b a8 a5 6c 5d 43 0a\nd9 75 bf b0 c2 d9 7d bf 90 bd a4 6b 38 a9 ff f5 ec 85 e2 c9 0f 90 05 b9 8c 0c c9 80 a9 00 85 88 95 ec b0 4b 99 e9 00 b9 8c 0c f0 43 c9\n60 f0 3f a9 00 85 86 a6 90 de c9 08 10 13 a9 00 9d c9 08 38 a5 cb e9 03 85 cb a5 cc e9 00 85 cc 60 18 a5 cb 69 06 85 cb a5 cc 69 00 85\n\n00 7f 47 47 47 47 47 7f 00 30 10 10 10 38 38 38 00 78 08 08 78 40 40 78 00 78 08 08 7c 0c 0c 7c 00 60 60 60 6c 7c 0c 0c 00 78 40 40 78\n08 08 78 00 78 48 40 40 7e 42 7e 00 7c 44 04 1c 10 10 10 00 38 28 28 7c 6c 6c 7c 00 7c 44 44 7c 0c 0c 0c 00 00 00 00 00 00 00 00 38 38\n38 00 00 38 38 38 80 80 80 80 80 80 80 ff 00 3c 20 20 78 60 60 7c 00 66 99 99 99 66 00 00 00 00 00 7e 00 00 00 00 00 18 18 18 7e 18 18\n18 00 18 7e db 99 db 7e 18 66 66 66 66 66 2c 38 30 00 7c 44 44 7c 68 6c 6c 00 1c 3e 63 5d 63 3e 1c 00 46 46 44 7c 64 66 66 fe 92 10 18\n18 18 18 18 fc 8c 8c 80 80 80 84 fc 00 00 00 00 00 00 00 ff 80 80 80 80 80 80 80 80 00 00 00 00 00 00 00 80 80 aa 9c be 9c aa 80 ff 80\n98 80 b6 80 8c 80 ff 80 8e 80 b8 80 9c 80 ff 80 b0 98 be 98 b0 80 ff 00 00 6c 6f 6e 67 00 72 61 6e 67 65 00 73 63 61 6e 00 00 00 00 00\n00 61 66 74 00 76 69 65 77 00 00 00 00 00 00 67 61 6c 61 63 74 69 63 00 63 68 61 72 74 00 00 00 60 46 1a a1 f0 47 35 0d 07 07 07 07 07\n07 07 07 80 46 1f 0d 46 71 09 06 06 41 80 02 a9 00 8d 0f d2 85 66 85 62 85 63 a9 03 8d 0f d2 a0 2f a9 ff 84 65 85 64 a9 00 aa 9d 00 d0\n9d 00 d4 e0 0f b0 03 9d 00 d2 9d 00 d3 9d 67 00 e8 d0 ea ca 9a d8 a9 02 20 0f ae a9 51 8d 16 02 a9 a7 8d 17 02 a9 d1 8d 22 02 a9 18 8d\n00 02 a9 a6 8d 23 02 a9 a7 8d 01 02 a9 04 8d 02 d3 a9 11 8d 1b d0 a9 03 8d 1d d0 20 ba b3 a2 0a 20 45 b0 a5 64 29 80 a8 a2 5f a9 08 20\nf1 ad a9 20 85 71 a9 80 8d 02 d4 a9 02 8d 03 d4 a9 3e 8d 00 d4 a9 00 8d 07 d4 a9 10 85 79 a6 62 bc 0c bf 20 23 b2 a9 40 8d 0e d2 58 a9\nc0 8d 0e d4 a5 67 f0 fc a9 00 85 67 a5 7a f0 20 a2 04 e8 bc 5b 0c b9 00 08 85 68 b9 64 08 85 69 bc 8c 0c bd bd 0c 91 68 e4 7a 90 e6 a9\n00 85 7a a5 c0 30 2d a6 79 86 7a bd f9 0b 9d 5b 0c a8 b9 00 08 85 68 b9 64 08 85 69 bd 2a 0c 4a 4a 9d 8c 0c a8 b1 68 9d bd 0c 1d ee 0c\n91 68 ca e0 04 d0 d7 a5 66 10 0e a9 00 8d e3 17 8d e4 17 8d bc 17 8d bb 17 a9 00 ac 5f 0c ae c1 0c 99 00 03 c8 ca 10 f9 ac 5e 0c ae c0\n0c 99 00 07 c8 ca 10 f9 ac 5d 0c ae bf 0c 99 00 06 c8 ca 10 f9 ac 5c 0c ae be 0c 99 00 05 c8 ca 10 f9 ac 5b 0c ae bd 0c 99 00 04 c8 ca\n10 f9 ad 90 0c c9 01 a4 e8 ae fd 0b 8e 5f 0c ad f2 0c 85 6a 8d c1 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 03 c8 e8 c6 6a 10 ef ad 8f 0c c9 01\na4 e7 ae fc 0b 8e 5e 0c ad f1 0c 85 6a 8d c0 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 07 e8 c8 c6 6a 10 ef ad 8e 0c c9 01 a4 e6 ae fb 0b 8e 5d\n0c ad f0 0c 85 6a 8d bf 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 06 e8 c8 c6 6a 10 ef a4 e5 ae fa 0b 8e 5c 0c ad ef 0c 85 6a 8d be 0c b9 b1 b9\n9d 00 05 e8 c8 c6 6a 10 f4 a4 e4 ae f9 0b 8e 5b 0c ad ee 0c 85 6a 8d bd 0c b9 b1 b9 9d 00 04 e8 c8 c6 6a 10 f4 ad 2a 0c 8d 00 d0 ad 2b\n0c 8d 01 d0 ad 2c 0c 8d 02 d0 ad 2d 0c 8d 03 d0 ad 2e 0c 8d 07 d0 18 69 02 8d 06 d0 69 02 8d 05 d0 69 02 8d 04 d0 24 d0 30 3a a5 c8 f0\n19 85 6d a4 79 84 6e 18 98 aa 69 31 a8 20 9b b6 98 aa a4 6e 20 9b b6 88 10 eb a5 c9 f0 19 85 6d a4 79 84 6e 18 98 aa 69 62 a8 20 9b b6\n98 aa a4 6e 20 9b b6 88 10 eb a6 79 e0 05 b0 05 bd 8c 0c f0 19 38 bd d3 0a e5 70 9d d3 0a bd 40 0a e5 c1 9d 40 0a bd ad 09 e9 00 9d ad\n09 ca 10 db a6 79 e0 10 d0 02 a2 04 8a a8 a9 00 85 6b b9 66 0b 10 09 49 7f 18 69 01 b0 02 c6 6b 18 79 d3 0a 99 d3 0a b9 40 0a 65 6b 99\n40 0a b9 ad 09 65 6b 99 ad 09 98 18 69 31 c9 90 90 ce ca 10 c4 a0 04 98 aa a9 02 85 6a bd ad 09 c9 02 90 10 0a a9 00 9d ad 09 b0 05 fe\nad 09 49 ff 9d 40 0a 8a 18 69 31 aa c6 6a 10 e0 88 10 d7 a5 d0 c9 02 b0 5c a6 79 a9 ff bc ad 09 c4 d0 f0 4b bd 0f 0a d0 12 38 a9 00 fd\n35 0b 85 6a a9 00 fd a2 0a 85 6b 4c 7d a4 bd 35 0b 85 6a bd a2 0a 85 6b 20 21 aa 20 1e b7 bd de 09 d0 12 38 a9 00 fd 04 0b 85 6a a9 00\nfd 71 0a 85 6b 4c a4 a4 bd 04 0b 85 6a bd 71 0a 85 6b 20 21 aa 20 fb b6 ca 10 a6 20 62 b1 24 d0 50 31 a2 31 20 6f a7 2c 96 09 70 27 a6\n79 bd 40 0a bc ad 09 d0 02 49 ff a8 b9 e9 0d 20 1e b7 bd 71 0a bc de 09 d0 02 49 ff a8 b9 e9 0d 20 fb b6 ca 10 db a2 05 ca 10 03 4c 79\na5 a9 00 95 e4 9d ee 0c 24 d0 10 0b e0 03 90 eb ad 0a d2 a0 f2 30 2b d5 e9 f0 e0 70 f3 bc 40 0a 24 7b 50 1e e0 02 b0 16 ad 2c 0c 18 7d\ndb be 9d 2a 0c ad fb 0b 18 69 04 9d f9 0b ac 42 0a a5 76 29 0f 85 6b 98 bc f9 0b c0 cc b0 af a4 d0 f0 02 49 ff c9 20 b0 a5 c9 10 90 02\na9 0f 85 6a 1d 8c 0c 4a a8 b9 2f be 95 e4 b9 7f be 9d ee 0c 98 4a 4a 4a a8 b9 d1 bf c0 08 d0 03 4d 0a d2 a4 6a 59 db bf 45 6b bc df b8\n99 ee 00 4c e7 a4 a0 af a6 81 a5 8b f0 0c c6 8b a0 4f 29 20 f0 04 a2 42 a0 60 84 f4 86 f6 a6 79 bd 40 0a a4 d0 c0 01 d0 09 c9 f0 b0 03\n20 64 b7 49 ff c9 10 90 02 a9 0f 0a 29 1c 05 72 a8 b9 90 ba 85 6a bd 2a 0c 29 03 a8 b9 b0 ba 25 6a 9d ee 0c ca e0 05 b0 ca 24 64 50 03\n4c 9b a6 20 fe af ad 00 d3 a8 29 03 aa bd f5 ba 85 c9 98 4a 4a 29 03 aa bd f5 ba 85 c8 20 3d af 20 29 ae 2c 95 09 70 40 a5 7e f0 3c a5\nd0 d0 03 20 bf a7 ae 5c 09 a5 bf 30 05 aa 09 80 85 bf b5 e9 d0 0b 8a 49 01 aa b5 e9 d0 03 ae 5c 09 8e 5c 09 a5 7c f0 13 a5 d0 c9 02 b0\n0d 49 01 dd ad 09 f0 06 aa bd cf be 85 ca 20 e6 ac 20 79 aa a5 7b d0 5c a5 eb f0 58 ac 42 0a c8 c0 02 b0 50 ac 73 0a c8 c0 02 b0 48 ac\na4 0a c8 c0 02 b0 40 20 e1 ae a0 02 20 6b ac a2 7f a5 81 d0 1e a2 0a 20 45 b0 a0 23 a2 08 20 0a b1 a2 5f a0 80 a9 08 20 f1 ad 20 0d ae\na2 40 86 e3 a2 ff 86 8a a9 00 85 eb a9 02 85 be a2 01 20 6f b8 a2 0a 20 a8 ae a4 63 ad 1f d0 49 ff 29 03 85 63 f0 1a 88 10 17 85 66 c9\n02 b0 06 a9 00 a8 4c 5e a1 e6 62 a5 62 29 03 85 62 4c 5a a1 20 04 b8 20 9b a8 20 16 b2 20 e4 b4 4c f3 a1 a9 ff 85 67 a9 e0 8d 09 d4 a6\nf6 ad 0a d2 24 8a 50 07 30 04 29 72 09 40 aa a5 d0 c9 03 90 02 a2 a0 86 f6 a2 08 b5 ee 9d 12 d0 ca 10 f8 8d 1e d0 20 ab b2 e6 77 d0 0d\na5 66 30 09 e6 66 10 05 a0 00 4c 5c a1 4c 4b a7 48 8a 48 98 48 a9 e0 ac 0b d4 c0 60 f0 02 a9 a0 8d 09 d4 a2 04 8d 0a d4 b5 f7 9d 16 d0\nca 10 f8 ad 08 d0 0d 09 d0 0d 0a d0 0d 0b d0 85 83 ad 0f d0 85 82 68 a8 68 aa 68 40 48 a9 00 8d 0e d2 a9 40 8d 0e d2 ad 09 d2 09 c0 85\nca 68 40 99 a4 00 e8 88 10 0e 20 82 a7 a9 05 85 a2 2c 95 09 70 09 a0 02 bd f9 ba c9 fe d0 e4 60 a9 55 85 6b a5 a4 85 6e 29 7f 85 a4 a4\na5 b9 00 08 85 68 b9 64 08 85 69 a5 a6 4a 4a 85 6a a5 a6 29 03 a8 b9 b0 ba 25 6b a4 6a 11 68 91 68 24 6e 10 04 e6 a5 d0 02 e6 a6 c6 a4\nd0 d0 60 ae 5c 09 a4 a2 c0 05 b0 24 a5 a0 85 a6 b9 6e bf 0a 85 6c 90 0d a9 81 85 a4 a5 a1 85 a5 a9 aa 20 84 a7 e6 a6 a5 6c d0 e8 e6 a1\ne6 a2 60 c0 0a 90 f9 b5 e9 f0 3c bd 71 0a bc de 09 f0 08 c9 0c 90 0a a9 0b 10 06 c9 f5 b0 02 a9 f5 18 69 83 85 a0 bd a2 0a 49 ff bc 0f\n0a d0 08 c9 05 90 0a a9 04 10 06 c9 fa b0 02 a9 fa 18 69 4d 85 a1 a9 00 85 a2 a9 36 85 68 a9 1b 85 69 a2 0e a0 06 b1 68 29 55 91 68 88\n10 f7 18 a5 68 69 28 85 68 90 02 e6 69 ca 10 e7 ae 5c 09 c8 a5 88 f0 04 c6 88 d0 39 a5 a0 c9 81 90 33 c9 85 b0 2f a9 aa 8d fe 1b 8d 04\n1c a5 a1 c9 4b 90 21 c9 4f b0 1d a9 aa 8d 9e 1c 8d a4 1c bd 40 0a c9 0c b0 0e a0 a0 8c 40 1d 8c 68 1d 8c 42 1d 8c 6a 1d 84 a3 60 a4 c0\nf0 61 a5 70 c9 fe b0 5c c9 80 90 03 20 b4 a9 a9 03 8d 5c 09 a9 90 8d 8f 0c 85 ec a9 1f 8d 43 0a 38 ad fc 0b e9 77 18 65 c5 29 7f 85 8e\n38 ad 2d 0c e9 7d 18 65 c4 29 7f 85 8f a5 62 f0 11 ad 0a d2 a4 d0 f0 06 8d 2d 0c 8d fc 0b c9 10 b0 14 ad 0a d2 09 10 25 c6 8d 9a 0b ad\n0a d2 09 10 25 c6 8d cb 0b 60 98 30 11 a9 ff 85 c0 a2 00 20 a6 b3 20 a7 b1 a0 1b 4c 8d a9 c6 91 f0 05 a2 02 4c 6f b8 a0 19 20 87 a9 a5\n8f 85 8d a5 8e 85 8c 4a 29 07 aa bd b3 bf 85 c7 a4 92 84 90 a9 00 85 7b be c9 08 10 2e a9 ff 85 7b a0 00 a9 00 99 68 0b a9 01 99 af 09\nad 0a d2 25 c7 99 42 0a 98 18 69 31 a8 c9 93 90 e5 ad 42 0a 09 71 8d 42 0a a2 02 4c be b7 f0 0e a9 ff 85 8b a2 06 20 a6 b3 a0 75 20 23\nb2 60 a2 01 20 6f b8 a0 17 a9 00 85 71 85 c0 a9 10 85 79 a9 00 85 c1 85 73 85 8a 8d 8f 0c 85 80 c0 17 f0 04 85 e9 85 ea 85 eb 85 ec 85\ned 85 75 8d 5c 09 4c 23 b2 c6 c2 10 68 a9 01 85 c1 a9 30 85 79 a9 03 85 c2 a6 c3 a9 12 85 69 ad 0a d2 29 03 a8 b9 3a bb 9d 71 0a b9 3e\nbb 9d a2 0a 20 be b7 8a a8 a9 05 85 6e 18 a5 68 69 50 85 68 9d d3 0a a5 69 69 00 85 69 9d 40 0a a9 00 9d 66 0b 9d 97 0b 9d c8 0b a9 01\n9d ad 09 a9 63 9d f9 0b 9d 2a 0c 20 c1 ac ca e0 11 b0 02 a2 30 c6 6e 10 c7 86 c3 60 a9 00 85 6d a9 07 85 6e 46 6b 66 6a a5 d0 d0 0f bd\n40 0a 4a 85 69 bd d3 0a 6a 85 68 4c 52 aa 38 a9 00 fd d3 0a 85 68 a9 00 fd 40 0a 4a 85 69 66 68 06 6d 38 a5 6a e5 68 a8 a5 6b e5 69 90\n06 85 6b 84 6a e6 6d 06 6a 26 6b 90 03 a9 ff 60 c6 6e 10 df a4 6d b9 e9 0d 60 a5 c0 05 7b d0 f9 a5 86 f0 30 a6 89 38 bd f9 0b ed fc 0b\n90 02 a9 00 20 ca ae 8d cb 0b 8d cc 0b 38 ad 2d 0c fd 2a 0c 20 ca ae 8d 9a 0b 38 ad 2e 0c fd 2a 0c 20 ca ae 8d 9b 0b a2 03 d6 ba 10 27\n8a 4a a8 b9 c8 00 a4 d0 f0 05 49 ff 18 69 01 18 75 b4 10 02 a9 00 c9 10 90 02 a9 0f 95 b4 c9 08 90 02 49 0f 0a 95 ba ca 10 d2 ad 8e 0c\nd0 1b a4 62 b9 85 bf ae a4 0a 10 02 29 7f 8d ca 0b 09 80 ae 73 0a 10 02 29 7f 8d 99 0b a5 76 29 03 f0 2e a5 e6 f0 04 a5 eb d0 25 ad 0a\nd2 c9 04 b0 1e a9 60 8d 8e 0c a2 02 20 64 b7 a9 3c 85 eb a9 88 8d 68 0b a9 00 8d 2c 0c 8d 99 0b 8d ca 0b 60 a5 a7 49 01 85 a7 aa b5 e9\nd0 42 a5 e9 05 ea 29 01 a4 90 d9 c9 08 b0 ba a9 ff 95 e9 ad 0a d2 29 07 a8 b9 89 bf 9d 8c 0c a5 62 f0 03 b9 91 bf 95 a8 a9 01 95 aa 9d\nad 09 ad 0a d2 25 c7 9d a2 0a 69 13 9d 71 0a 09 71 9d 40 0a 20 be b7 bd 40 0a c9 20 b0 11 bd ad 09 f0 08 b5 e4 f0 08 c9 29 f0 04 a9 00\n95 a8 d6 aa 10 24 a9 78 95 aa a5 62 ac 0a d2 c0 30 90 01 4a 4a 95 b8 b5 a8 2c 0a d2 10 02 49 0f 95 ac e8 e8 e0 06 90 f1 a6 a7 b5 a8 d0\n32 a4 a7 c0 31 b0 13 b9 b8 00 4a b9 40 0a b0 06 c9 0a 90 0e b0 04 c9 f5 b0 04 b9 ad 09 4a a9 0f b0 02 a9 00 95 ac 18 98 69 31 a8 e8 e8\ne0 06 90 d2 a6 a7 a4 a7 b5 b2 d5 ac f0 08 b0 04 f6 b2 90 02 d6 b2 86 6a aa bd 99 bf a6 6a 99 66 0b 98 18 69 31 a8 e8 e8 e0 06 90 dc a6\na7 ad 8e 0c d0 0b a5 eb d0 06 a5 be f0 03 c6 be 60 18 bd a2 0a 69 02 c9 05 b0 f5 a0 d0 bd ad 09 4a bd 40 0a b0 08 49 ff a4 62 f0 e4 a0\n50 c9 20 b0 de 8c 68 0b a9 00 8d 8e 0c 8d 2c 0c a9 3e 85 eb a2 02 a4 a7 84 bf 4c af ac a9 80 85 73 a2 30 86 79 ad 0a d2 29 0f 79 2a 0c\ne9 30 9d 2a 0c ad 0a d2 29 0f 79 f9 0b 4a e9 10 9d f9 0b 20 af ac ad 0a d2 29 87 9d 66 0b ad 0a d2 29 87 9d 97 0b ad 0a d2 29 87 9d c8\n0b ca e0 10 d0 c5 60 b9 ad 09 9d ad 09 b9 40 0a 9d 40 0a b9 d3 0a 9d d3 0a b9 de 09 9d de 09 b9 71 0a 9d 71 0a b9 0f 0a 9d 0f 0a b9 a2\n0a 9d a2 0a b9 04 0b 9d 04 0b b9 35 0b 9d 35 0b 60 a5 7b f0 fb a5 d0 d0 05 a9 14 8d 1b d0 a9 02 8d 5c 09 a9 30 8d 8e 0c a9 20 8d 8d 0c\na9 40 8d 8c 0c a9 ff a6 90 bc c9 08 30 02 a9 00 85 e9 85 ea 85 eb 85 7b 30 0a a0 02 20 6b ac a2 0a 4c a8 ae ad 42 0a d0 0a ad d5 0a c9\n20 b0 03 ee d5 0a ad 2c 0c 38 e9 78 c9 10 b0 22 ad fb 0b 38 e9 68 c9 10 b0 18 ad 42 0a c9 02 b0 11 ad af 09 2d 11 0a 49 01 05 70 0d a4\n0a 05 71 f0 10 a5 75 c9 02 90 05 a0 1f 20 23 b2 a9 00 85 75 60 24 75 70 0d 30 42 a5 75 d0 f5 c6 75 a0 1c 4c 23 b2 a2 00 86 65 a4 d1 d0\ne6 a9 50 8d 90 0c a9 01 8d b1 09 8d e2 09 8d 13 0a 8d a6 0a 8d 9b 0b a9 10 8d 44 0a a9 00 8d 75 0a a9 87 8d 6a 0b a9 81 85 75 8d cc 0b\n85 ed 60 ad b1 09 d0 fa a2 0c 20 a6 b3 a0 21 20 23 b2 a2 05 bd 8b bb 9d 92 09 ca 10 f7 a9 89 a2 03 9d 55 09 ca 10 fa a9 07 8d 6a 0b a9\n81 8d 9b 0b a9 01 8d cc 0b 85 75 4c 7b b0 78 85 6a ad 0b d4 c9 7c 90 f9 b9 62 ba c8 10 02 a9 0d 9d 80 02 e8 c6 6a d0 f0 58 60 a9 10 85\n69 a9 00 a8 85 68 85 a3 85 7a 91 68 c8 d0 fb e6 69 a4 69 c0 20 a8 90 f2 60 a5 84 ac 10 d0 84 84 d0 0e 84 66 a6 c0 d0 08 a6 87 c9 01 f0\n03 b0 18 60 b5 ec c9 e8 b0 f9 ac 5c 09 84 89 a9 0c a4 a3 84 86 f0 02 a9 00 85 88 84 84 2c 92 09 70 e1 30 05 8a 49 01 85 87 8a 9d e1 09\nbd 73 bf 9d 74 0a a9 ff 95 ec 9d a5 0a a9 00 9d 8f 0c 9d 43 0a 9d 07 0b 9d 12 0a 9d 38 0b a9 01 9d b0 09 9d d6 0a a5 d0 4a 6a 09 66 9d\n69 0b a9 00 9d 9a 0b 9d cb 0b a2 02 20 6f b8 a2 00 8a d0 06 a5 e1 c9 18 b0 18 a0 07 bd 20 bf 99 da 00 e8 88 10 f6 bd 20 bf 8d 08 d2 bd\n21 bf 8d 04 d2 60 a0 80 b0 04 49 ff a0 00 84 6a c9 08 90 02 a9 07 a8 a5 6a 19 c9 bf 60 24 64 30 57 a6 62 ad 0a d2 dd 10 bf b0 4d 29 07\nc9 06 b0 47 aa bd 92 09 0a 30 eb a5 eb c9 1e a9 80 bc 14 bf 90 17 e0 03 d0 05 2c 96 09 70 0e e0 04 d0 05 2c 95 09 70 05 a9 c0 bc 1a bf\n1d 92 09 9d 92 09 84 65 2c 95 09 50 07 a9 00 85 7e 20 0d ae a0 52 20 23 b2 a2 12 20 a6 b3 60 a2 02 ca 10 01 60 bd 8f 0c d0 f7 b5 ec f0\nf3 b5 82 29 07 f0 ed 4a c9 03 d0 01 4a a8 b9 e9 00 f0 e1 a5 d0 f0 02 a9 ff 85 6c 59 40 0a c9 10 90 02 a9 0f 4a 84 6b a8 a5 6c 5d 43 0a\nd9 75 bf b0 c2 d9 7d bf 90 bd a4 6b 38 a9 ff f5 ec 85 e2 c9 0f 90 05 b9 8c 0c c9 80 a9 00 85 88 95 ec b0 4b 99 e9 00 b9 8c 0c f0 43 c9\n60 f0 3f a9 00 85 86 a6 90 de c9 08 10 13 a9 00 9d c9 08 38 a5 cb e9 03 85 cb a5 cc e9 00 85 cc 60 18 a5 cb 69 06 85 cb a5 cc 69 00 85\n\n3\n\nPoC GTFO\n\nСамиздат\n\na b\n\nc\n\n# #\nCut Here if Printing on A4 Cut Here if Printing on A4\n\n\n\n9 6\n\ncc\na2\n\n01\nfe\n\n50\n09\n\nbd\n50\n\n09\nc9\n\n4a\n90\n\n08\na9\n\n40\n9d\n\n50\n09\n\nca\n10\n\nee\n20\n\n6b\nac\n\na2\n7f\n\nbd\nc9\n\n08\n30\n\n02\nd0\n\n0a\nca\n\n10\nf6\n\na0\n3f\n\na2\n00\n\n20\n21\n\nb1\n60\n\na5\nca\n\nf0\n3e\n\na2\n14\n\n85\n6a\n\na9\n00\n\n85\n66\n\n85\nca\n\na9\n11\n\n8d\n1b\n\nd0\nbd\n\nbe\nba\n\nc5\n6a\n\nf0\n08\n\nca\n10\n\nf6\na0\n\n10\n4c\n\n23\nb2\n\ne0\n0a\n\nb0\n1d\n\na5\nc0\n\nf0\n03\n\n4c\n80\n\na9\n2c\n\n93\n09\n\n50\n06\n\ne0\n06\n\n90\n02\n\na2\n05\n\nbd\nd3\n\nba\n85\n\n80\nbd\n\nb4\nba\n\n85\n71\n\n60\ne0\n\n0e\nb0\n\n1b\nbd\n\n18\nbe\n\n85\nd0\n\nbc\n82\n\nba\na2\n\n02\na9\n\n08\n20\n\nf1\nad\n\na2\n10\n\n20\n64\n\nb7\nca\n\ne0\n05\n\nb0\nf8\n\n90\n1b\n\ne0\n11\n\nb0\n35\n\nbc\n18\n\nbe\nb5\n\n6e\n5d\n\n1b\nbe\n\n95\n6e\n\nf0\n03\n\nbc\n1e\n\nbe\n20\n\n23\nb2\n\na2\n0c\n\n20\na6\n\nb3\na2\n\n16\na4\n\n7c\nf0\n\n01\ne8\n\n8e\n5a\n\n09\n20\n\n0d\nae\n\na5\n7e\n\nf0\nb4\n\na6\nd0\n\nf0\n06\n\ne0\n01\n\nd0\nac\n\na2\n2a\n\n4c\n6f\n\na7\ne0\n\n11\nd0\n\n50\na5\n\nc0\nd0\n\n5a\na9\n\n7f\n85\n\nc0\na9\n\nff\n85\n\n71\na9\n\n1e\n85\n\n80\na9\n\n30\n85\n\nc3\na9\n\n00\n85\n\nc2\n8d\n\n74\n0a\n\n8d\n07\n\n0b\n8d\n\n38\n0b\n\n8d\n69\n\n0b\na9\n\n01\n8d\n\nb0\n09\n\n8d\ne1\n\n09\n8d\n\n12\n0a\n\n8d\na5\n\n0a\na5\n\n8f\n85\n\nc4\na5\n\n8e\n85\n\nc5\na5\n\n62\nf0\n\n0b\na5\n\n91\n2a\n\n2a\n2a\n\n29\n03\n\na8\nb9\n\nd7\nbe\n\n85\nc6\n\na0\n11\n\n4c\n23\n\nb2\ne0\n\n13\nb0\n\n0b\nad\n\n5c\n09\n\n49\n01\n\n29\n01\n\n8d\n5c\n\n09\n60\n\nd0\n08\n\nad\n00\n\nd3\nc9\n\nff\nf0\n\nf7\n60\n\na0\n76\n\na2\n04\n\na9\n00\n\n85\nec\n\n85\nd6\n\n85\nd1\n\n85\n8b\n\n8d\n07\n\nd2\n85\n\n71\n85\n\n81\n85\n\n7d\n85\n\nc0\n85\n\nc1\na9\n\nff\n85\n\n64\n84\n\n65\n8a\n\n05\n62\n\naa\nbd\n\ndd\nbe\n\n18\n65\n\ncb\naa\n\na9\n00\n\n85\nc9\n\n85\nc8\n\n65\ncc\n\n30\n25\n\n4a\n8a\n\n6a\n4a\n\n4a\n4a\n\nc9\n13\n\n90\n04\n\na9\n12\n\na2\n0f\n\n85\ncd\n\na8\n8a\n\nc0\n00\n\nf0\n0b\n\nc0\n0b\n\n90\n04\n\nc0\n0f\n\n90\n03\n\n4a\n49\n\n08\n29\n\n0f\n85\n\nce\n60\n\na5\nc0\n\nd0\n04\n\na5\nd0\n\n30\n01\n\n60\n2c\n\n97\n09\n\n30\n03\n\n20\nb9\n\nb4\na5\n\n72\n29\n\n01\nd0\n\n2e\n18\n\na5\n8f\n\n65\nc8\n\n29\n7f\n\n85\n8f\n\n18\n69\n\n3d\n8d\n\n2e\n0c\n\n18\na5\n\n8e\n65\n\nc9\n29\n\n7f\n85\n\n8e\n18\n\n69\n3f\n\n8d\nfd\n\n0b\na5\n\n8c\n18\n\n69\n3f\n\n8d\nfc\n\n0b\na5\n\n8d\n18\n\n69\n3d\n\n8d\n2d\n\n0c\na5\n\n8f\n4a\n\n4a\n4a\n\n85\n6a\n\na5\n8e\n\n29\n70\n\n05\n6a\n\n85\n92\n\naa\nbd\n\nc9\n08\n\n10\n02\n\na9\n00\n\n09\n90\n\n2c\n97\n\n09\n70\n\n03\n8d\n\n8d\n09\n\n38\na5\n\n8f\ne5\n\n8d\nb0\n\n04\n49\n\nff\n69\n\n01\n85\n\n6a\n38\n\na5\n8e\n\ne5\n8c\n\nb0\n04\n\n49\nff\n\n69\n01\n\n4a\n18\n\n65\n6a\n\na8\n4a\n\n4a\n4a\n\naa\n98\n\n29\n03\n\n18\n7d\n\ndd\nba\n\n85\n91\n\na8\na9\n\n10\n8d\n\n7d\n09\n\n8d\n7e\n\n09\n8d\n\n7f\n09\n\na2\n02\n\nfe\n7d\n\n09\nbd\n\n7d\n09\n\nc9\n1a\n\n90\n08\n\na9\n10\n\n9d\n7d\n\n09\nca\n\n10\nee\n\n88\nd0\n\ne9\n60\n\na5\nd1\n\nf0\n05\n\nc6\ncf\n\nf0\n10\n\n60\na4\n\n65\nf0\n\nfb\n84\n\nd1\na0\n\n23\na2\n\n0f\na9\n\n07\n20\n\nf1\nad\n\na2\n13\n\na9\n00\n\n85\n6b\n\n9d\n1f\n\n0d\nca\n\n10\nfa\n\na6\nd1\n\ne6\nd1\n\nd0\n09\n\na2\n0f\n\na0\n80\n\na9\n07\n\n4c\nf1\n\nad\nbd\n\naa\nbb\n\nc9\nfc\n\nd0\n0f\n\na4\nce\n\nb9\nfc\n\nbe\na6\n\n6b\n9d\n\n1f\n0d\n\na9\n3c\n\n85\ncf\n\n60\nc9\n\nfd\nd0\n\n05\na4\n\ncd\nb9\n\ne9\nbe\n\n85\n6c\n\n29\n3f\n\n85\n6a\n\na9\n2a\n\n85\n68\n\na9\nbc\n\n85\n69\n\ne6\n68\n\nd0\n02\n\ne6\n69\n\na0\n00\n\nb1\n68\n\n10\nf4\n\nc6\n6a\n\nd0\nf0\n\n29\n3f\n\n49\na0\n\na6\n6b\n\ne6\n6b\n\n9d\n1f\n\n0d\nc8\n\nb1\n68\n\n10\nf0\n\ne6\n6b\n\na9\n3c\n\n24\n6c\n\n10\n04\n\n50\n08\n\na9\nfe\n\n50\n96\n\na0\nff\n\n84\nd1\n\n85\ncf\n\n60\na5\n\nd6\nf0\n\n37\nc6\n\nd8\n10\n\n33\na5\n\nd9\nf0\n\n0a\na5\n\nd5\n30\n\n06\n85\n\nd8\na0\n\n00\nf0\n\n20\na5\n\nd4\n85\n\nd8\na6\n\nd2\ne6\n\nd2\nbd\n\n5c\nbf\n\n8d\n06\n\nd2\na0\n\na8\nc9\n\nff\nd0\n\n0c\na5\n\nd7\n85\n\nd2\nc6\n\nd3\n10\n\ne4\na0\n\n00\n84\n\nd6\n8c\n\n07\nd2\n\n84\nd9\n\na5\ne2\n\nf0\n09\n\nc6\ne2\n\nd0\n05\n\na2\n14\n\n20\na8\n\nae\na6\n\n70\n8a\n\n4a\n4a\n\n4a\n4a\n\n4a\nc5\n\ne1\n90\n\n2c\na9\n\n00\n85\n\ne1\ne8\n\n8a\n49\n\nff\n8d\n\n04\nd2\n\naa\n0a\n\n0a\n0a\n\n0a\n0a\n\n8d\n00\n\nd2\n8a\n\n4a\n4a\n\n4a\n8d\n\n02\nd2\n\n4a\n49\n\n8f\n8d\n\n03\nd2\n\n29\n87\n\n8d\n05\n\nd2\na9\n\n70\n8d\n\n08\nd2\n\n60\na5\n\ndb\nf0\n\n08\nc6\n\ndb\nd0\n\n04\na9\n\n8f\n85\n\ndc\na6\n\nda\nf0\n\n1c\nc6\n\nda\nd0\n\n0a\na9\n\naf\n85\n\ndc\na9\n\n02\n85\n\nde\n85\n\ndf\nbd\n\nea\nbf\n\n85\ndd\n\nbd\nf2\n\nbf\n8d\n\n04\nd2\n\n8d\n09\n\nd2\na5\n\ne3\nf0\n\n0e\nc6\n\ne3\nad\n\n0a\nd2\n\n8d\n04\n\nd2\n29\n\n20\n45\n\ndd\n85\n\ndd\n18\n\na5\nde\n\n65\ne0\n\n85\nde\n\n8d\n00\n\nd2\na5\n\ndf\n69\n\n00\n85\n\ndf\n8d\n\n02\nd2\n\na6\ndc\n\na4\ndd\n\na5\n72\n\n4a\n90\n\n1a\na5\n\ne1\nf0\n\n16\nc6\n\ne1\nc9\n\n11\nb0\n\n10\n8a\n\n29\n0f\n\nf0\n03\n\nca\n86\n\ndc\n98\n\n29\n0f\n\nf0\n03\n\n88\n84\n\ndd\n8e\n\n03\nd2\n\n8c\n05\n\nd2\n60\n\nbd\n3e\n\nbf\nc5\n\nd6\n90\n\n0c\na0\n\n05\nbd\n\n3e\nbf\n\n99\nd2\n\n00\ne8\n\n88\n10\n\nf6\n60\n\na2\n59\n\na9\n0d\n\n9d\n85\n\n02\ne0\n\n0a\nb0\n\n05\nbd\n\na9\nbf\n\n95\nf2\n\nca\n10\n\nef\na9\n\n70\n8d\n\n80\n02\n\n8d\n81\n\n02\na9\n\n41\n8d\n\ne7\n02\n\na9\n80\n\n8d\ne8\n\n02\na9\n\n02\n8d\n\ne9\n02\n\na2\n00\n\n86\n68\n\n86\n69\n\n86\n6a\n\n86\n6b\n\n18\na5\n\n68\n69\n\n51\n85\n\n68\na5\n\n69\n9d\n\ne9\n0d\n\n69\n00\n\n85\n69\n\n18\na5\n\n6a\n69\n\n64\n85\n\n6a\na5\n\n6b\n9d\n\ne9\n0e\n\nf8\n69\n\n00\nd8\n\n85\n6b\n\ne8\nd0\n\ndb\na2\n\n00\n86\n\n68\na9\n\n10\n85\n\n69\n18\n\na5\n68\n\n9d\n00\n\n08\n69\n\n28\n85\n\n68\na5\n\n69\n9d\n\n64\n08\n\n69\n00\n\n85\n69\n\nbd\n42\n\nbb\n9d\n\n49\n09\n\ne8\ne0\n\n64\n90\n\ne2\nca\n\n86\n78\n\na2\n03\n\n8e\n11\n\n09\nbd\n\na6\nbb\n\n85\n6a\n\na4\n62\n\nc8\nc8\n\n84\n6b\n\nad\n0a\n\nd2\n29\n\n7f\na8\n\nb9\nc9\n\n08\nd0\n\nf5\na5\n\n6a\n10\n\n21\nc0\n\n10\n90\n\ned\nc0\n\n70\nb0\n\ne9\n98\n\n29\n0f\n\nf0\ne4\n\nc9\n0f\n\nf0\ne0\n\nb9\nc8\n\n08\n19\n\nca\n08\n\n19\nd9\n\n08\n19\n\nb9\n08\n\nd0\nd2\n\na5\n6a\n\n99\nc9\n\n08\nc6\n\n6b\n10\n\nc9\nca\n\n10\nbb\n\na2\nb4\n\na9\n0a\n\n9d\n34\n\n0d\nca\n\nd0\nf8\n\na2\n0f\n\na9\n18\n\n9d\n37\n\n0d\nca\n\n10\nf8\n\na9\n1a\n\n8d\n47\n\n0d\na9\n\n00\n8d\n\n11\n09\n\na9\n48\n\n85\n90\n\na9\n43\n\n85\n8d\n\n85\n8f\n\na9\n47\n\n85\n8e\n\n85\n8c\n\na9\nea\n\n8d\ne8\n\n0f\na0\n\n00\n84\n\n6a\na6\n\n6a\nbd\n\nc9\n08\n\n10\n02\n\na9\n05\n\naa\nbd\n\nd1\nbe\n\n99\n4b\n\n0d\nc8\n\ne6\n6a\n\na5\n6a\n\n29\n0f\n\nd0\ne7\n\na9\n19\n\n99\n4b\n\n0d\nc8\n\nc8\nc8\n\nc8\nc0\n\na0\n90\n\nda\n60\n\ne6\n76\n\na2\n90\n\na5\n76\n\n10\n09\n\nac\n55\n\n09\nc0\n\n80\nd0\n\n02\na2\n\n44\n29\n\n03\n85\n\n72\nd0\n\n1f\na4\n\n7d\nf0\n\n17\na0\n\na0\n2c\n\n94\n09\n\n10\n0b\n\n70\n07\n\nad\n0a\n\nd2\nc9\n\nc8\n90\n\n07\na0\n\n00\n98\n\nd0\n02\n\na2\n26\n\n84\n81\n\n86\nfb\n\na2\n02\n\nbd\n8e\n\n0c\nd0\n\n06\nb5\n\neb\nf0\n\n02\nd6\n\neb\nca\n\n10\nf2\n\na5\n73\n\nf0\n16\n\nc6\n73\n\nd0\n04\n\na2\n11\n\n86\n79\n\nc9\n70\n\nb0\n04\n\na2\n00\n\n86\n8a\n\nc9\n18\n\nb0\n02\n\nc6\n79\n\nc6\n74\n\n10\n21\n\na9\n28\n\n85\n74\n\na2\n04\n\nfe\na3\n\n09\nbd\n\na3\n09\n\nc9\nda\n\n90\n0d\n\na9\nd0\n\n9d\na3\n\n09\ne0\n\n03\nd0\n\n01\nca\n\nca\n10\n\ne9\nc6\n\n78\n30\n\n01\n60\n\na9\n31\n\n85\n78\n\na5\ncb\n\nd0\n02\n\nc6\ncc\n\nc6\ncb\n\na6\n64\n\nd0\nef\n\n86\n6a\n\nbd\nc9\n\n08\n10\n\n19\n20\n\nf1\nb7\n\nf0\n14\n\na9\n02\n\n9d\nc9\n\n08\n85\n\n6a\n38\n\na5\ncb\n\ne9\n12\n\n85\ncb\n\na5\ncc\n\ne9\n00\n\n85\ncc\n\ne8\n10\n\ndf\na5\n\n6a\nf0\n\n0f\n2c\n\n97\n09\n\n70\n0a\n\na0\n15\n\n20\n23\n\nb2\na2\n\n18\n20\n\na6\nb3\n\nc6\n9f\n\n30\n07\n\na6\n93\n\nbd\nc9\n\n08\n30\n\n1f\na9\n\n07\n85\n\n9f\na0\n\n7f\nad\n\n0a\nd2\n\n29\n7f\n\naa\nbd\n\nc9\n08\n\n30\n0e\n\n88\n10\n\nf2\na2\n\n7f\nbd\n\nc9\n08\n\n30\n04\n\nca\n10\n\nf8\n60\n\n86\n93\n\n8a\n29\n\n0f\n85\n\n94\n8a\n\n4a\n4a\n\n4a\n4a\n\n85\n95\n\na2\nff\n\ne8\n10\n\n30\na2\n\n00\nbd\n\nc9\n08\n\n29\ndf\n\n9d\nc9\n\n08\ne8\n\n10\nf5\n\n2c\n97\n\n09\n70\n\n1d\na2\n\n00\nbd\n\nc9\n08\n\n10\n13\n\n20\nf1\n\nb7\nf0\n\n0e\na9\n\n63\n85\n\n78\na0\n\n13\n20\n\n23\nb2\n\na2\n18\n\n4c\na6\n\nb3\ne8\n\n10\ne5\n\n60\nbc\n\nc9\n08\n\nc0\n0a\n\nb0\nc6\n\nad\n0a\n\nd2\nd9\n\nbb\nbf\n\nb0\nbe\n\ne4\n90\n\nf0\nba\n\na0\n08\n\n18\n8a\n\n79\nc0\n\nbf\n85\n\n6a\n29\n\n0f\n38\n\ne5\n94\n\nb0\n04\n\n49\nff\n\n69\n01\n\n85\n6b\n\na5\n6a\n\n4a\n4a\n\n4a\n4a\n\n38\ne5\n\n95\nb0\n\n04\n49\n\nff\n69\n\n01\n18\n\n65\n6b\n\n99\n96\n\n00\n88\n\n10\nd4\n\na9\n01\n\n85\n6b\n\na0\n07\n\nb9\n96\n\n00\nc5\n\n9e\nb0\n\n24\n18\n\n8a\n79\n\nc0\nbf\n\n30\n1d\n\n84\n6a\n\na8\nb9\n\nc9\n08\n\nd0\n13\n\nbd\nc9\n\n08\nc4\n\n90\nf0\n\n0c\n09\n\n20\n99\n\nc9\n08\n\na9\n00\n\n9d\nc9\n\n08\nf0\n\n0b\na4\n\n6a\n88\n\n10\nd2\n\ne6\n9e\n\nc6\n6b\n\n10\nca\n\n4c\nea\n\nb5\nbd\n\nad\n09\n\n49\n01\n\nf0\n02\n\na9\nff\n\n85\n6b\n\n85\n6c\n\nbd\n40\n\n0a\n85\n\n6a\nad\n\n0a\nd2\n\n09\nbf\n\n5d\nd3\n\n0a\n0a\n\n26\n6a\n\n26\n6b\n\n0a\n26\n\n6a\n26\n\n6b\na5\n\n6d\n49\n\nff\n85\n\n6d\n30\n\n1a\n18\n\nb9\nd3\n\n0a\n65\n\n6a\n99\n\nd3\n0a\n\nb9\n40\n\n0a\n65\n\n6b\n99\n\n40\n0a\n\nb9\nad\n\n09\n65\n\n6c\n99\n\nad\n09\n\n60\n38\n\nb9\nd3\n\n0a\ne5\n\n6a\n99\n\nd3\n0a\n\nb9\n40\n\n0a\ne5\n\n6b\n99\n\n40\n0a\n\nb9\nad\n\n09\ne5\n\n6c\n99\n\nad\n09\n\n60\nc9\n\n50\nb0\n\n5b\n85\n\n6d\na9\n\n50\ne0\n\n05\nb0\n\n02\na9\n\n7d\nbc\n\nde\n09\n\nd0\n09\n\n38\ne6\n\n6d\ne5\n\n6d\n9d\n\n2a\n0c\n\n60\n18\n\n65\n6d\n\n9d\n2a\n\n0c\n60\n\nc9\n32\n\nb0\n38\n\n85\n6d\n\na9\n32\n\ne0\n05\n\nb0\n04\n\n06\n6d\n\na9\n7a\n\n24\nd0\n\n50\n13\n\n2c\n96\n\n09\n10\n\n07\n2c\n\n0a\nd2\n\n50\n0e\n\n70\n15\n\nbc\nad\n\n09\nd0\n\n07\nf0\n\n0e\nbc\n\n0f\n0a\n\nf0\n09\n\n38\ne6\n\n6d\ne5\n\n6d\n9d\n\nf9\n0b\n\n60\n18\n\n65\n6d\n\n9d\nf9\n\n0b\n60\n\ne0\n05\n\nb0\n06\n\na9\nfb\n\n9d\nf9\n\n0b\n60\n\na9\n63\n\n9d\nf9\n\n0b\n9d\n\n2a\n0c\n\ne0\n11\n\nb0\nf3\n\nad\n0a\n\nd2\n29\n\n0f\n85\n\n6a\n9d\n\na2\n0a\n\nad\n0a\n\nd2\n29\n\n0f\nc5\n\n6a\n90\n\n02\n85\n\n6a\n9d\n\n71\n0a\n\na9\n0f\n\n9d\n40\n\n0a\na5\n\nd0\n49\n\n01\n29\n\n01\n9d\n\nad\n09\n\nd0\n11\n\n9d\n04\n\n0b\n9d\n\n35\n0b\n\n38\ne5\n\n6a\n9d\n\n40\n0a\n\na9\n80\n\n9d\nd3\n\n0a\n24\n\nd0\n50\n\n11\nad\n\n0a\nd2\n\n9d\n71\n\n0a\nad\n\n0a\nd2\n\n9d\n40\n\n0a\n29\n\n01\n9d\n\nad\n09\n\nad\n0a\n\nd2\n29\n\n01\n9d\n\n0f\n0a\n\nd0\n0f\n\n38\nfd\n\n35\n0b\n\n9d\n35\n\n0b\na9\n\n00\nfd\n\na2\n0a\n\n9d\na2\n\n0a\nad\n\n0a\nd2\n\n29\n01\n\n9d\nde\n\n09\nd0\n\n0f\n38\n\nfd\n04\n\n0b\n9d\n\n04\n0b\n\na9\n00\n\nfd\n71\n\n0a\n9d\n\n71\n0a\n\n60\nbd\n\nc8\n08\n\nf0\n0d\n\nbd\n\nca\n08\n\nf0\n08\n\nbd\nb9\n\n08\nf0\n\n03\nbd\n\nd9\n08\n\n60\na6\n\n70\ne4\n\n71\nf0\n\n08\n90\n\n04\nc6\n\n70\nb0\n\n12\ne6\n\n70\na5\n\nc0\nd0\n\n0c\n2c\n\n93\n09\n\n10\n07\n\na5\n71\n\n2d\n0a\n\nd2\n85\n\n70\na0\n\n01\n20\n\ncd\nb8\n\n2c\n95\n\n09\n30\n\n30\na9\n\n31\na0\n\n17\n20\n\na7\nb8\n\na9\n62\n\na0\n1d\n\n20\na7\n\nb8\na9\n\n00\na0\n\n23\n20\n\na7\nb8\n\nad\n6e\n\n09\n8d\n\n6f\n09\n\nc9\n0a\n\nb0\n11\n\nae\n5c\n\n09\nbd\n\nd3\n0a\n\n4a\n4a\n\n4a\n4a\n\naa\nbd\n\ne9\n0e\n\n8d\n6f\n\n09\n18\n\na5\n7f\n\n65\n7d\n\n65\n80\n\n65\n7e\n\n69\n01\n\nc5\n7f\n\n85\n7f\n\nb0\n39\n\na2\n03\n\n24\n64\n\n70\n33\n\nde\n55\n\n09\nbd\n\n55\n09\n\nc9\n80\n\nb0\n29\n\na9\n89\n\n9d\n55\n\n09\ne0\n\n02\nd0\n\n08\na5\n\ncb\nd0\n\n02\nc6\n\ncc\nc6\n\ncb\nca\n\n10\nde\n\na2\n0a\n\n8a\na0\n\n03\n99\n\n55\n09\n\n88\n10\n\nfa\n20\n\n45\nb0\n\na0\n31\n\na2\n04\n\n20\n0a\n\nb1\n60\n\n18\n6d\n\n5c\n09\n\naa\na9\n\n10\n85\n\n6a\nbd\n\nad\n09\n\n4a\nbd\n\n40\n0a\n\nb0\n04\n\n49\nff\n\nc6\n6a\n\naa\na5\n\n6a\n99\n\n49\n09\n\n98\n29\n\n10\nf0\n\n05\ne0\n\nff\nd0\n\n01\nca\n\nbd\ne9\n\n0e\naa\n\n29\n0f\n\n99\n4b\n\n09\n8a\n\n4a\n4a\n\n4a\n4a\n\n99\n4a\n\n09\n60\n\n00\n01\n\n02\n03\n\n07\n00\n\n18\n3c\n\n7e\n7e\n\n76\nf7\n\ndf\ndf\n\nff\nff\n\nf7\n76\n\n7e\n7e\n\n3c\n18\n\n10\n38\n\n7c\n7c\n\nfe\nde\n\nda\nfa\n\nee\nee\n\n7c\n7c\n\n38\n10\n\n18\n3c\n\n3c\n7e\n\n6e\n7a\n\n7e\n76\n\n7e\n3c\n\n3c\n18\n\n10\n38\n\n38\n7c\n\n74\n7c\n\n6c\n38\n\n38\n10\n\n10\n18\n\n3c\n2c\n\n3c\n3c\n\n18\n08\n\n10\n38\n\n38\n28\n\n38\n10\n\n3c\n3c\n\n24\n3c\n\n7e\n7e\n\n7e\n5a\n\nff\nff\n\n42\n42\n\n42\n42\n\n42\n42\n\n1c\n1c\n\n14\n3e\n\n3e\n3e\n\n2a\n7f\n\n7f\n22\n\n22\n22\n\n22\n22\n\n18\n18\n\n3c\n3c\n\n3c\n3c\n\n7e\n24\n\n24\n24\n\n24\n10\n\n10\n38\n\n38\n38\n\n7c\n28\n\n28\n28\n\n18\n18\n\n3c\n18\n\n18\n10\n\n10\n38\n\n10\n18\n\n7e\nff\n\nff\nff\n\nff\nff\n\ne7\ne7\n\nff\nff\n\nff\nff\n\nff\n7e\n\n7e\n00\n\n18\n3c\n\n7e\nff\n\nff\nff\n\ne7\n66\n\nff\nff\n\nff\nff\n\n7e\n7e\n\n00\n18\n\n3c\n7e\n\nff\nff\n\ne7\n66\n\nff\nff\n\nff\nff\n\n3c\n18\n\n3c\nff\n\nff\ne7\n\n66\nff\n\nff\n7e\n\n3c\n00\n\n18\n3c\n\nff\nff\n\nff\n3c\n\n18\n18\n\n3c\nff\n\n3c\n18\n\n28\n28\n\n28\n28\n\nee\n00\n\n00\nee\n\n28\n28\n\n28\n28\n\n00\n81\n\n81\n81\n\n81\nbd\n\nff\nff\n\nbd\n81\n\n81\n81\n\n81\n82\n\n82\nba\n\nfe\nfe\n\nba\n82\n\n82\n42\n\n5a\n7e\n\n7e\n5a\n\n42\n44\n\n54\n7c\n\n7c\n54\n\n44\n24\n\n3c\n3c\n\n24\n28\n\n38\n38\n\n28\n18\n\n18\n10\n\n10\ne0\n\nf8\nf8\n\nfe\n57\n\nfe\nf8\n\nf8\nc0\n\nc0\nf0\n\nc0\nf0\n\nf0\nfc\n\nbe\nfc\n\nf0\n80\n\n80\nc0\n\nc0\nf0\n\nbc\nf0\n\nc0\n07\n\n1f\n1f\n\n7f\nea\n\n7f\n1f\n\n1f\n03\n\n03\n0f\n\n03\n0f\n\n0f\n3f\n\n7d\n3f\n\n0f\n01\n\n01\n03\n\n03\n0f\n\n3d\n0f\n\n03\n18\n\n3c\n7e\n\n7e\ndb\n\nc3\n81\n\n81\n81\n\n10\n38\n\n7c\n7c\n\nd6\nc6\n\n82\n82\n\n18\n3c\n\n3c\n66\n\n66\n42\n\n42\n10\n\n38\n38\n\n6c\n44\n\n44\n18\n\n3c\n24\n\n24\n10\n\n38\n28\n\n18\n3c\n\n7e\nff\n\n18\n18\n\nff\n7e\n\n3c\n18\n\n10\n38\n\n7c\nfe\n\n38\n38\n\nfe\n7c\n\n38\n10\n\n18\n3c\n\n7e\n18\n\n7e\n3c\n\n18\n10\n\n38\n7c\n\n10\n7c\n\n38\n10\n\n18\n3c\n\n18\n3c\n\n18\n10\n\n38\n38\n\n10\n8d\n\n00\n46\n\n49\n09\n\n20\n06\n\n00\n01\n\n2e\na1\n\n00\n00\n\n46\nf8\n\na0\n4d\n\nc8\n10\n\n00\n00\n\n46\n09\n\na1\n4d\n\nc8\n10\n\n4d\n00\n\n10\n0d\n\n0d\n0d\n\n0d\n0d\n\n30\n46\n\n1f\n0d\n\n4d\na8\n\n12\n1b\n\n13\n0b\n\n08\nff\n\nff\nff\n\nff\naa\n\nff\naa\n\nff\naa\n\naa\naa\n\nff\naa\n\naa\naa\n\naa\naa\n\naa\naa\n\n55\n55\n\naa\n55\n\naa\n55\n\n55\n55\n\naa\n55\n\n55\n55\n\n55\nc0\n\n30\n0c\n\n03\n00\n\n01\n02\n\n04\n08\n\n10\n20\n\n40\n60\n\n70\nf2\n\ndf\nde\n\nda\nd8\n\ndd\ndb\n\nf3\nf5\n\nf0\nf8\n\nff\nc0\n\nfd\ned\n\nfe\nd2\n\nf9\ne5\n\nca\ne7\n\n00\n04\n\n06\n08\n\n0a\n0c\n\n0e\n1e\n\n2d\n3c\n\n0a\n0d\n\n10\n14\n\n17\n32\n\n46\n50\n\n5a\n78\n\n7d\n82\n\n87\n8c\n\n9b\naa\n\nb8\nc8\n\nd0\nd8\n\ndf\ne8\n\nf1\nfa\n\n00\n01\n\nff\n00\n\n50\n28\n\n87\n50\n\n36\n87\n\n77\n46\n\n1e\n77\n\n56\n1e\n\n77\n46\n\n91\n94\n\n46\n91\n\n78\n4e\n\n06\n7e\n\n4b\n0f\n\n7e\n51\n\n0f\n8d\n\n4e\n07\n\n85\n47\n\n84\n7e\n\n4c\n85\n\n8c\n4c\n\n85\n85\n\n52\n84\n\n3e\n32\n\n0f\n54\n\n32\n0f\n\nfe\n4e\n\n35\n82\n\n4f\n34\n\n82\n50\n\n32\n85\n\n51\n34\n\n82\n52\n\n35\n82\n\nfe\n04\n\n04\n03\n\n02\n02\n\n03\n04\n\n04\n12\n\n0b\n00\n\n00\n0a\n\n55\n4b\n\n40\n40\n\n0a\n8d\n\n8b\n89\n\n89\n89\n\n89\n0a\n\n16\n0b\n\n00\n0a\n\n14\n0b\n\n0f\n00\n\n00\n0a\n\n51\n4b\n\n0f\n00\n\n00\n0a\n\n93\n8b\n\n0f\n00\n\n00\n00\n\n0a\n37\n\n21\n32\n\n30\n00\n\n25\n2e\n\n25\n32\n\n27\n39\n\n1a\n00\n\n00\n00\n\n10\n00\n\n00\n00\n\n00\nb4\n\na1\nb2\n\na7\na5\n\nb4\nb3\n\n9a\n00\n\n00\n24\n\n23\n1a\n\n30\n25\n\n33\n23\n\n2c\n32\n\n00\nf3\n\nf4\ne1\n\nf2\n00\n\ne4\ne1\n\nf4\ne5\n\nda\nd0\n\nd0\nce\n\nd0\nd0\n\n00\n00\n\n00\n00\n\n00\ncf\n\n04\n03\n\n02\n00\n\n05\n06\n\n42\n05\n\n06\n43\n\n04\n42\n\n04\n43\n\n06\n07\n\n42\n07\n\n43\n48\n\n09\n4a\n\n0b\ncd\n\n0b\ncc\n\n09\n4e\n\n09\n4f\n\nd0\n11\n\n92\n56\n\n13\n4e\n\n15\n4f\n\nb8\n97\n\n99\n98\n\n8c\n9d\n\n1e\n9f\n\nfd\n25\n\nfc\n78\n\n9b\n60\n\nb8\n97\n\n98\n1a\n\n8e\n1c\n\n94\n24\n\n9f\nfd\n\n25\nfc\n\na7\n68\n\nb8\n97\n\n98\n1a\n\n8f\n24\n\n9f\nfd\n\n25\nfc\n\n66\n2c\n\n5a\n2e\n\n5a\n31\n\n5a\n33\n\n5a\nb8\n\n34\n76\n\n37\nb5\n\n78\n37\n\n8c\n78\n\n23\nb5\n\n78\n23\n\n8c\n78\n\n04\nb5\n\n78\n04\n\n8c\n78\n\n06\nb5\n\n78\n06\n\n8c\n78\n\na2\n75\n\na2\n4c\n\na1\n75\n\na1\n4c\n\nc1\nb8\n\n97\n98\n\n1a\n8e\n\n24\n9f\n\nfd\n25\n\nfc\n66\n\na0\n20\n\n20\n20\n\n20\n52\n\n45\n44\n\n20\n41\n\n4c\n45\n\n52\n54\n\ncf\n4e\n\ncf\n46\n\n46\nd3\n\n48\n49\n\n45\n4c\n\n44\n53\n\nc1\n54\n\n54\n41\n\n43\n4b\n\nc3\n4f\n\n4d\n50\n\n55\n54\n\n45\n52\n\nd4\n52\n\n41\n43\n\n4b\n49\n\n4e\n47\n\nd7\n48\n\n41\n54\n\n53\n20\n\n57\n52\n\n4f\n4e\n\n47\n3f\n\nc8\n59\n\n50\n45\n\n52\n57\n\n41\n52\n\n50\nc5\n\n4e\n47\n\n41\n47\n\n45\n44\n\nd3\n54\n\n41\n52\n\n42\n41\n\n53\n45\n\nc4\n45\n\n53\n54\n\n52\n4f\n\n59\n45\n\n44\nd3\n\n55\n52\n\n52\n4f\n\n55\n4e\n\n44\n45\n\n44\nc1\n\n42\n4f\n\n52\n54\n\n45\n44\n\nc3\n4f\n\n4d\n50\n\n4c\n45\n\n54\n45\n\nc8\n59\n\n50\n45\n\n52\n53\n\n50\n41\n\n43\n45\n\ncf\n52\n\n42\n49\n\n54\nc5\n\n53\n54\n\n41\n42\n\n4c\n49\n\n53\n48\n\n45\n44\n\nc4\n4f\n\n43\n4b\n\n49\n4e\n\n47\nc5\n\n4e\n45\n\n52\n47\n\n59\nd4\n\n52\n41\n\n4e\n53\n\n46\n45\n\n52\nd3\n\n54\n41\n\n4e\n44\n\n42\n59\n\nd3\n54\n\n41\n52\n\n20\n46\n\n4c\n45\n\n45\n54\n\n20\n54\n\n4f\nd3\n\n54\n41\n\n52\n20\n\n43\n52\n\n55\n49\n\n53\n45\n\n52\n20\n\n37\nc1\n\n4c\n4c\n\n20\n55\n\n4e\n49\n\n54\n53\n\ncd\n49\n\n53\n53\n\n49\n4f\n\n4e\na0\n\n20\n20\n\n20\n53\n\n54\n41\n\n52\n20\n\n52\n41\n\n49\n44\n\n45\n52\n\n53\nda\n\n45\n52\n\n4f\nc2\n\n59\n20\n\n5a\n59\n\n4c\n4f\n\n4e\n20\n\n46\n49\n\n52\n45\n\nd0\n4f\n\n53\n54\n\n48\n55\n\n4d\n4f\n\n55\n53\n\nd2\n41\n\n4e\n4b\n\n20\n49\n\n53\n3a\n\nc3\n4f\n\n50\n59\n\n52\n49\n\n47\n48\n\n54\n20\n\n41\n54\n\n41\n52\n\n49\n20\n\n31\n39\n\n37\n39\n\nd3\n55\n\n42\n2d\n\n53\n50\n\n41\n43\n\n45\n20\n\n52\n41\n\n44\n49\n\n4f\nd3\n\n45\n43\n\n54\n4f\n\n52\n20\n\n53\n43\n\n41\n4e\n\nc5\n4e\n\n47\n49\n\n4e\n45\n\n53\nce\n\n45\n57\n\nc3\n4c\n\n41\n53\n\n53\nc3\n\n4f\n4e\n\n47\n52\n\n41\n54\n\n55\n4c\n\n41\n54\n\n49\n4f\n\n4e\n53\n\nd2\n45\n\n50\n4f\n\n52\n54\n\n20\n54\n\n4f\n20\n\n42\n41\n\n53\n45\n\nc6\n4f\n\n52\n20\n\n54\n52\n\n41\n49\n\n4e\n49\n\n4e\n47\n\nc7\n41\n\n4c\n41\n\n43\n54\n\n49\n43\n\n20\n43\n\n4f\n4f\n\n4b\nc7\n\n41\n52\n\n42\n41\n\n47\n45\n\n20\n53\n\n43\n4f\n\n57\n20\n\n43\n41\n\n50\n54\n\n41\n49\n\n4e\nd2\n\n4f\n4f\n\n4b\n49\n\n45\nce\n\n4f\n56\n\n49\n43\n\n45\nc5\n\n4e\n53\n\n49\n47\n\n4e\nd0\n\n49\n4c\n\n4f\n54\n\nc1\n43\n\n45\ncc\n\n49\n45\n\n55\n54\n\n45\n4e\n\n41\n4e\n\n54\nd7\n\n41\n52\n\n52\n49\n\n4f\n52\n\nc3\n41\n\n50\n54\n\n41\n49\n\n4e\nc3\n\n4f\n4d\n\n4d\n41\n\n4e\n44\n\n45\n52\n\nc4\n41\n\n4d\n41\n\n47\n45\n\nc4\n41\n\n4d\n41\n\n47\n45\n\n44\nc3\n\n4f\n4e\n\n54\n52\n\n4f\n4c\n\nd0\n48\n\n4f\n54\n\n4f\n4e\n\n53\na0\n\nd3\n54\n\n41\n52\n\n20\n43\n\n4f\n4d\n\n4d\n41\n\n4e\n44\n\n45\n52\n\n80\n00\n\n01\n40\n\n80\n0e\n\n09\n04\n\nff\n08\n\n02\n0b\n\n07\n01\n\n01\n11\n\n1f\n2b\n\n35\n3d\n\n75\n7a\n\n01\n0d\n\n15\n1b\n\n21\n25\n\n29\n2b\n\n2d\n38\n\n41\n36\n\n36\n00\n\n00\n00\n\n7e\n8e\n\n9d\naa\n\nb4\nbc\n\n7b\n7a\n\n47\n52\n\n5b\n50\n\n50\n00\n\n00\n00\n\n43\n53\n\n61\n6c\n\n75\n7a\n\n75\n7a\n\n01\n11\n\n1f\n2b\n\n35\n3d\n\n75\n7a\n\n61\n6a\n\n72\n79\n\n7f\n83\n\n29\n2b\n\n86\n90\n\n9a\na1\n\na8\nad\n\n29\n2b\n\nc1\nc1\n\nc1\nc1\n\nc1\nc1\n\n75\nc1\n\n0f\n0d\n\n0b\n09\n\n07\n05\n\n01\n01\n\n0b\n07\n\n05\n05\n\n03\n03\n\n01\n01\n\n09\n08\n\n05\n02\n\n00\n00\n\n00\n00\n\n0f\n0e\n\n0c\n09\n\n07\n04\n\n02\n01\n\n09\n08\n\n05\n02\n\n00\n00\n\n00\n00\n\n0f\n0d\n\n0a\n08\n\n04\n03\n\n01\n01\n\n0f\n0d\n\n0b\n09\n\n07\n05\n\n01\n01\n\n08\n07\n\n06\n05\n\n03\n02\n\n01\n01\n\n09\n09\n\n06\n06\n\n04\n03\n\n01\n01\n\n0b\n0b\n\n0b\n0b\n\n0b\n0b\n\n01\n0b\n\nf8\nff\n\n0c\n1e\n\n1e\n1d\n\n1c\n1b\n\n9f\nbf\n\ndf\nff\n\nf8\n08\n\n50\n4c\n\n3c\n6f\n\n3c\n3c\n\n32\n64\n\n28\n32\n\n28\n5a\n\na9\naa\n\naa\nab\n\nab\nac\n\nac\nad\n\nad\nae\n\nae\naf\n\nb0\nb1\n\nb2\nb3\n\nb3\nb9\n\nb9\n95\n\n95\n95\n\n94\n94\n\n94\n94\n\n93\n93\n\n93\n92\n\n92\n92\n\n91\n91\n\n91\n4a\n\n4c\n4e\n\n50\n00\n\n50\nb4\n\nfe\n55\n\n5b\n61\n\n67\n6d\n\n71\n58\n\n5e\n64\n\n6a\n6f\n\n73\n18\n\nff\n02\n\n00\n8a\n\na0\n00\n\n08\n50\n\n00\n40\n\n40\n01\n\n03\n88\n\naf\n08\n\n00\n50\n\n04\n30\n\n40\n01\n\n03\n84\n\na8\n04\n\n00\n50\n\n04\n02\n\n02\n02\n\n03\n0c\n\n02\n04\n\n03\nff\n\n10\n07\n\n04\n07\n\n04\n02\n\n02\n00\n\n07\n0b\n\n05\nff\n\n20\n02\n\n0b\n0e\n\n06\n08\n\n20\n00\n\n0e\n10\n\nff\n18\n\nff\n40\n\n60\nff\n\n10\n10\n\n10\nff\n\n40\n20\n\nff\n48\n\n40\n51\n\nff\n84\n\nb4\nfc\n\nb4\n84\n\nff\n01\n\n0c\n0c\n\n0c\n0c\n\n0e\n0e\n\n0e\n20\n\n00\n00\n\n00\n02\n\n04\n06\n\n08\n0c\n\n81\n84\n\n88\n94\n\n80\n10\n\n10\n10\n\n70\n70\n\n70\n10\n\n04\n04\n\n00\n00\n\n00\n01\n\n00\n00\n\n3e\n1e\n\n10\n08\n\n04\n02\n\n01\n00\n\n00\n81\n\n82\n84\n\n88\n90\n\n9e\nbe\n\na6\naa\n\naf\n00\n\n00\nb8\n\n5a\nfc\n\n5e\n90\n\nff\nff\n\n3f\n0f\n\n3f\n7f\n\nff\nff\n\n00\nff\n\nff\nc0\n\n20\nf0\n\nef\nff\n\n0f\n10\n\n11\n01\n\nf1\n00\n\n00\n08\n\n10\n18\n\n28\n30\n\n38\n40\n\n50\n00\n\n20\n20\n\n20\n00\n\na0\n00\n\n00\n9f\n\n0e\n0e\n\n0e\n0c\n\n0c\n0c\n\n0a\n0a\n\n0a\n08\n\n08\n08\n\n06\n06\n\n04\n04\n\n8a\n8f\n\n8d\n8b\n\n89\n87\n\n85\n83\n\n00\n04\n\n01\n04\n\n01\n04\n\n01\n04\n\n07\n00\n\n80\n4a\n\na1\n\n!7 # 8\n\nGTFO\n\n!\n\n5\n\n#\n\n4PoC\n\n\n\n23\n\nManhattan Punch Line Theatre\n\nSteve Kaplan Mitch McGuire Richard Erickson Jerry Heymann\nProducing Directors\npresents\n\na new play\nby\nMike Eisenberg\n\nHACKERS\n\nDirected by Jerry Heymann\n\n} The Story of\na Boy\n\nand\nhis Machine\n\nManhattan Punch Line\nat the Lion Theatre\nYce West Yend Street\non theatre Row\n\n23\n\n\n\n\n3 How Slow Can You Go?\nby James Forshaw\n\nWhile doing my research into Windows, I tend to\nfind quite a few race condition vulnerabilities. Al-\nthough these vulnerabilities can be exploited, you\ntypically only get a tiny window of time in which\nto do it. A fairly typical sequence of actions looks\nsomething like this:\n\n1. Do some security check.\n\n2. Access some resource.\n\n3. Perform secure action.\n\nIn this case the race condition is between the\nsecurity check and the action. If we can modify\nthe state of the system in between those actions,\nit might be possible to elevate privileges or do un-\nexpected things. The time window is typically very\nsmall, but if the code is accessing some controllable\nresource in between the check and the action, we\nmight still be able to create a very reliable exploit.\n\nI wanted to find a way of increasing the time win-\ndow to win the race in cases where the code accesses\na resource we control. The following is an overview\nof the thought process I went through to come up\nwith a working solution.\n\n3.1 Investigating Object Manager\nLookup Performance\n\nHidden under the hood of Windows NT is the Ob-\nject Manager Namespace (OMN). You wouldn’t typ-\nically interact with it directly as the Win32 API for\nthe most part hides it away. The NT kernel defines a\nset of objects, such as Files, Events, Registry Keys,\nthat can all have a name associated with them. The\nOMN provides the means to lookup these named\nobjects. It acts like a file system; for example, you\ncan specify a path to an NT system call such as\n\\BaseNamedObjects\\MyEvent, and an event can be\nthus looked up.\n\nThere are two special object types for use in the\nOMN: Object Directories and Symbolic Links. Ob-\nject Directories act as named containers for other\nobjects, whereas Symbolic Links allow a name to be\nredirected to another OMN path. Symbolic Links\nare used quite a lot; for example, the Windows drive\nletters are really symbolic links to the real storage\ndevice. When we call an NT system call, the kernel\nmust lookup the entire path, following any symbolic\nlinks until it either reaches the named object or fails\nto find a match.\n\nIn this exploit we want to make the process of\nlooking up a resource we control as slow as possible.\nFor example, if we could make it take 1 or 2 seconds,\nthen we’ve got a massive window of opportunity to\nwin the race condition. Therefore I want to find\na way of manipulating the Object Manager lookup\nprocess in such a way that we achieve this goal. I\nam going to present my approach to achieving the\nrequired result.\n\nA note about my setup: for my testing I am go-\ning to open a named Event object. All testing is\ndone on my 2.8GHz Xeon Workstation. Although it\nhas 20 physical cores, the lookup process won’t be\nparallelized, and therefore that shouldn’t be an is-\nsue. Xeons tend to have more L2/L3 cache than con-\nsumer processors, but if anything this should only\nmake our timings faster. If I can get a long lookup\ntime on my Workstation, it should be possible on\npretty much anything else running Windows. Fi-\nnally, this is all tested on an up-to-date Windows 10;\nhowever, not much has changed since Windows 7\nthat might affect the results.\n\nFirst let’s just measure the time it takes to do\n\n24\n\n\n\na normal lookup. We’ll repeat the lookup a 1, 000\ntimes and take the average. The results are prob-\nably what we’d expect: the lookup process for a\nsimple named Event is roughly 3µs. That includes\nthe system call transition, lookup process, and the\naccess check on the Event object. Although in the-\nory you could win a race, it seems pretty unlikely,\neven on a multi-core processor. So let’s think about\na way of improving the lookup time (and when I say\n“improve”, I mean making the lookup time slower).\n\nAn Object Manager path is limited to the\nmaximum string size afforded by the UNI-\nCODE_STRING structure.\n\nstruct UNICODE_STRING {\n2 USHORT Length ;\n\nUSHORT MaximumLength ;\n4 PWSTR Buf f e r ;\n\n}\n\nWe can see that the Length member is an un-\nsigned 16 bit integer, limiting the maximum length\nto 216 − 1. This, however, is a byte count, so in\nfact this limits us to 215 − 1 or 32767 characters.\nFrom this result, there are two obvious possible ap-\nproaches we can take:\n\n1. Make a path that contains one very long name.\nThe lookup process would have to compare the\nentire name using a typical string comparison\noperation to verify it’s accessing the correct\nobject. This should take linear time relative\nto the length of the string.\n\n2. Make multiple small named directories and re-\npeat. E.g., \\A\\A\\A\\A\\...\\EventName. The\nassumption here is that each lookup takes a\nfixed amount of time to complete. The oper-\nation will again be linear time relative to the\ndepth of recursion of the directories.\n\nNow it would seem likely that the cost of the en-\ntire operation of a single lookup will be worse than\na string comparison, a primitive that is typically op-\ntimized quite heavily. At this point we have not had\nto look at any actual kernel code, and we won’t start\nquite yet, so instead empirical testing seems the way\nto go.\n\nLet’s start with the first approach, making a\nlong string and performing a lookup on it. Our\nname limit is around 32767, although we’ll need\nto be able to make the object in a writable direc-\ntory such as \\BaseNamedObject, which reduces the\n\nlength slightly, but not enough to make significant\nimpact. Therefore, we’ll perform the Event opening\non names between 1 character and 32,000 characters\nin length. The results are shown below:\n\n0 8000 16000 24000 32000\n0\n\n0.025\n\n0.05\n\n0.075\n\n0.1\n\nName Length in Characters\n\nL\noo\n\nku\np \n\nT\nim\n\ne \nA\nve\n\nra\nge\n\n (\nm\n\ns)\n\nAlthough this is a little noisy, our assumption\nof a linear lookup time seems correct. The longer\nthe string, the longer it takes to look it up. For a\n32,000 character long string, this seems to top out\nat roughly 90µs – still not enough in my opinion for\na useful primitive, but certainly a start.\n\nNow let’s instead look at the recursive directory\napproach. In this case the upper bound is around\n16,000 directories. This is because each path compo-\nnent must contain a backslash and a single charac-\nter name (i.e. \\A\\A\\A...). Therefore our maximum\npath limit is halved. Of course we’d make the as-\nsumption that the time to go through the lookup\nprocess is going to be greater than the time it takes\nto compare 4 Unicode characters, but let’s test to\nmake sure. The results are shown below:\n\n0 4000 8000 12000 16000\n0\n\n1\n\n2\n\n3\n\n4\n\nDirectory Count\n\nL\noo\n\nku\np \n\nT\nim\n\ne \nA\nve\n\nra\nge\n\n (\nm\n\ns)\n\nWell, I think that’s unequivocal. For 16,000 re-\ncursive depth, the average lookup time is around\n3700µs, or around 40 times larger than the long path\nname lookup result. Now, of course, this comes with\ndownsides. For a start, you need to create 16,000 or\nso directory objects in the kernel. At least on a mod-\n\n25\n\n\n\nern 64 bit Windows this isn’t likely to be too taxing,\nhowever it’s still worth bearing in mind. Also the\nprocess must maintain a handle to each of those di-\nrectories, because otherwise they’d be deleted (as a\nnormal user cannot make kernel objects permanent).\nFortunately our handle limit for a single process is\nof the order of 16 million, so we’re a couple of orders\nof magnitude below the limit of that.\n\nNow, is 3700µs going to be enough for us?\nMaybe, it’s certainly orders of magnitude greater\nthan 3µs. But can we do better? We’ve now run\nout of path space, we’ve filled the absolute maxi-\nmum allowed string length with recursive directory\nnames. What we could do with is a method of mul-\ntiplying that effect without requiring a longer path.\nWe can do this by using Object Manager symbolic\nlinks. By placing the symbolic link as the last com-\nponent of the long path we can force the kernel to\nreparse, and start the lookup all over again. On the\nfinal lookup we’ll just point the symbolic link to the\ntarget.\n\nUltimately though we can only do this 64 times.\nWhy, can’t we do this indefinitely? Well, no—for\na fairly obvious reason: each time a symbolic link\nis encountered the kernel restarts the parsing pro-\ncesses; if you pointed a symbolic link at itself, you’d\nend up in an infinite loop. The reparse limit of 64\nprevents that from becoming a problem. The re-\nsults are as we expected, the time taken to lookup\nour event is proportional to both the number of sym-\nbolic links and the number of recursive directories.\nFor 64 symbolic links and 16,000 directories it takes\napproximately 200ms (note I’ve had to change the\norder of the result now to milliseconds). At around\n1\n5 of a second that should be enough, right? Sure,\nbut I’m greedy; I want more. How can we make the\nlookup time even worse?\n\nAt this point it’s time to break out the disassem-\nbler and see how the lookup process works under the\nhood in the kernel. First off, let’s see what an object\ndirectory structure looks like. We can dump it from\na kernel debugging session using WinDBG with the\n\n26\n\n\n\ncommand dt nt!_OBJECT_DIRECTORY. Converted\nback to a C-style structure, it looks something like\nthe following:\n\n1 struct OBJECT_DIRECTORY\n{\n\n3 POBJECT_DIRECTORY_ENTRY HashBuckets [ 3 7 ] ;\nEX_PUSH_LOCK Lock ;\n\n5 PDEVICE_MAP DeviceMap ;\nULONG Ses s i on Id ;\n\n7 PVOID NamespaceEntry ;\nULONG Flags ;\n\n9 POBJECT_DIRECTORY ShadowDirectory ;\n}\n\nBased on the presence of the HashBucket field,\nit’s safe to assume that the kernel is using a hash\ntable to store directory entries. This makes some\nsense, because if the kernel just maintained a list\nof directory entries, this would be pretty poor for\nperformance. With a hash table the lookup time\nis much reduced as long as the hashing algorithm\ndoes a good job of reducing collisions. This is only\nthe case though if the algorithm isn’t being actively\nexploited. As we’re trying to increase the cost of\nlookups, we can intentionally add entries with col-\nlisions to make the lookup process take the worst\ncase time, which is linear relative to the number of\nentries in a directory. This again provides us with\nanother scaling factor, and in this case the number\nof entries is only going to be limited by available\nmemory, as we are never going to need to put the\nname into the path.\n\nSo what’s the algorithm for the hash? The\nmain function of interest is ObpLookupObject-\nName, which is referenced by functions such as Ob-\nReferenceObjectByName. The directory entry logic\nis buried somewhere in this large function; however,\nfortunately there’s a helper function ObpLookup-\nDirectoryEntryEx, which has the same logic (it\nisn’t actually called by ObpLookupObjectName, but\nit doesn’t matter) that is smaller and easier to re-\nverse (Figure 10).\n\nSo the hashing algorithm is pretty simple; it re-\npeatedly mixes the bits of the current hash value\nand then adds the uppercase Unicode character to\nthe hash. We could work out a clever way of getting\nhash collisions from this, but actually it’s pretty sim-\nple. The object manager allows us to specify names\ncontaining NULL characters, therefore if we take our\ntarget name, say ‘A’, and prefix it with increasing\nlength strings containing only NULL, we get both\nHash and Bucket collisions. This does limit us to\n\ncreating only 32,000 or so colliding entries before we\nrun out of strings to create them, but, as we’ll see\nin a minute, that’s not a problem. Let’s look at the\nresults of doing this for a single directory:\n\n0 4000 8000 12000 16000\n0\n\n0.15\n\n0.3\n\n0.45\n\n0.6\n\nCollisions\n\nL\noo\n\nku\np \n\nT\nim\n\ne \nA\nve\n\nra\nge\n\n (\nm\n\ns)\n\nYet again, a nice linear graph. For a given col-\nlision count it’s nowhere near as good as the recur-\nsive directory approach, but it is a multiplicative\nfactor in the lookup time, which we can abuse. So\nyou’d think we can now easily apply this to all our\n16,000 recursive directories, add in symbolic links,\nand probably get an insane lookup time. Yes, we\nwould, however there’s a problem, insertion time.\nEvery time we add a new entry to a directory, the\nkernel must do a lookup to check that the entry\ndoesn’t already exist. This means that, for every\nentry we add, we must do (n − 1)2 checks in the\nhash bucket just to find that we don’t have the en-\ntry before we insert it. This means that the time\nto add a new entry is approximately proportional to\nthe square of the number of entries. Sure it’s not\na cubic or exponential increase, but that’s hardly a\nconsolation. To prove that this is the case we can\njust measure the insertion time:\n\n0 4000 8000 12000 16000\n0\n\n1500\n\n3000\n\n4500\n\n6000\n\nDirectory Count\n\nIn\nse\n\nrt\nio\n\nn \nT\n\nim\ne \n\n(m\ns)\n\nThat graph shows a pretty clear n2 trend for the\ninsertion time. If, say, we wanted to create a direc-\ntory entry with 16,000 collisions, it takes close to 5.5\nseconds. If we wanted to then do that for all 16,000\n\n27\n\n\n\nPOBJECT_DIRECTORY ObpLookupDirectoryEntryEx (POBJECT_DIRECTORY Directory ,\n2 PUNICODE_STRING Name,\n\nULONG Attr ibuteF lags ) {\n4 BOOLEAN Case InSens i t i v e = ( Att r ibuteF lags & OBJ_CASE_INSENSITIVE) != 0 ;\n\nSIZE_T CharCount = Name−>Length / s izeof (WCHAR) ;\n6 WCHAR∗ Buf f e r = Name−>Buf f e r ;\n\nULONG Hash = 0 ;\n8 while (CharCount ) {\n\nHash = (Hash / 2) + 3 ∗ Hash ;\n10 Hash += RtlUpcaseUnicodeChar (∗ Buf f e r ) ;\n\nBu f f e r++;\n12 CharCount−−;\n\n}\n14\n\nOBJECT_DIRECTORY_ENTRY∗ Entry = Directory−>HashBuckets [ Hash % 3 7 ] ;\n16 while ( Entry ) {\n\ni f ( Entry−>HashValue == Hash ) {\n18 i f ( RtlEqualUnicodeStr ing (Name,\n\nObpGetObjectName (Entry−>Object ) , Case InSens i t i v e ) ) {\n20 ObReferenceObject ( Entry−>Object ) ;\n\nreturn Entry−>Object ;\n22 }\n\n}\n24 Entry = Entry−>ChainLink ;\n\n}\n26\n\nreturn NULL;\n28 }\n\nFigure 10. ObpLookupDirectoryEntryEx()\n\n28\n\n\n\nrecursive directory entries, it would take around 24\nhours! Now, I think we’re going a bit over the top\nhere, and by fiddling with the values we can get\nsomething that doesn’t take too long to set up and\ngives us a long lookup time. But I’m still greedy; I\nwant to see how far I can push the lookup time. Is\nthere any way we can get the best of all worlds?\n\nThe final piece of the puzzle is to bring in Shadow\ndirectories, which allow the Object Manager a fall-\nback path if it can’t find an entry in a directory.\nYou can use almost any other Object Manager direc-\ntory as a shadow, which will allow us to control the\nlookup behavior. A Shadow Directory has a crucial\ndifference from symbolic links, as it doesn’t cause a\nreparse to occur in the lookup process. This means\nthey’re not restricted to the 64 reparse limit. As\neach lookup consumes a path component, eventually\nthere will be no more paths to lookup. If we put to-\ngether two directories in the following arrangement,\nwe can pass a similar path to our recursive directory\nlookup, without actually creating all the directories.\n\nShadow Directory\nLookup\n\nPath: \\A\\A\\A\\A\\A ...\n\nLookup\n\nAA\n\nSo how does this actually work? If we open a\npath of the form \\A\\A\\A\\A\\A..., the kernel will first\nlookup the initial ‘A’ directory. This is the directory\non the left of the diagram. It will then try to open\nthe next ‘A’ directory, which is on the right, which\nagain it will find. Next the kernel again looks up\n‘A’, but in this case it doesn’t exist. As the direc-\ntory has a shadow link to its parent, it looks there\ninstead, finds the same ‘A’ directory, and repeats\nthe process. This will continue until we run out of\npath elements to lookup.\n\nSo let’s determine the performance of this ap-\nproach. We’d perhaps expect it to be less perfor-\n\nmant relative to actually creating all those directo-\nries if only because of the cache effects of the pro-\ncessor. But hopefully it won’t be too far behind.\n\n0 4000 8000 12000 160000\n\n1\n\n2\n\n3\n\n4\n\nDirectory Count\n\nL\noo\n\nku\np \n\nT\nim\n\ne \nA\nve\n\nra\nge\n\n (\nm\n\ns) Linear Sub\nDirectory\n\nLinear\nShadow\nDirectory\n\nLooks good. Yes, the performance is lower than\nactually creating the directories, but once we bring\ncollisions into the mix, that’s not really going to\nmatter much. So the final result is that instead of\ncreating 16,000 directories with 16,000 collisions we\ncan do it with just 2 directories, which is far more\nmanageable and only takes around 11 seconds on\nmy workstation. So, to sign off, let’s combine every-\nthing together.\n\n1. 16,000 path components using 2 object direc-\ntories in a shadow configuration\n\n2. 16,000 collisions per directory\n\n3. 64 symbolic link reparses\n\nAnd the resulting time for a single lookup on\nmy workstation is *drum roll please* 19 minutes! I\nthink we might just be able to win the race condition\nwith that.\n\nCode examples can be found attached to this\ndocument.10\n\n3.2 Conclusion\n\nSo after all that effort we can make the kernel take\naround 19 minutes to lookup a single controlled re-\nsource path. That’s pretty impressive. We have\nmany options to get the kernel to start the lookup\nprocess, allowing us to use not just files and registry\nkeys but almost any named event. It’s a typical tale\nof unexpected behavior when facing pathological in-\nput, and it’s not really surprising Microsoft wouldn’t\noptimize for this use case.\n\n10unzip pocorgtfo13.pdf object_manager_lookup_poc.cs\n\n29\n\n\n\n4 The FaceWhisperer for USB Glitching; or,\nReading RFID with ROP and a Wacom Tablet\n\nby Micah Elizabeth Scott\n\nGreetings, neighbors!\nToday, like most days, I would like to celebrate\n\nthe diversity of tiny machines around us. This time\nI’ve prepared a USB magic trick of sorts, incorpo-\nrating techniques from the analog and the digital\ndomains.\n\nRegular readers will be well aware that computer\nperipherals are typically general-purpose computers\nthemselves, and the operating system often trusts\nthem a little too much. Devices attached to Thun-\nderbolt (PCI Express) are trusted as much as the\nCPU. Devices attached to USB, at best, are as privi-\nleged as the user, who can typically do anything they\nwant albeit slowly and using interfaces designed for\nmeat.11 If that USB device can exploit a bug in lit-\nerally any available driver, the device could achieve\neven more direct levels of control.\n\nNot only are these peripherals small computers\nwith storage and vulnerabilities and secrets, they\ntypically have very direct access to their own hard-\nware. It’s often firmware’s responsibility to set up\nclocks, program power converters, and process ana-\nlog signals. Projects like BadUSB have focused on\nreprogramming a USB device to attack the com-\nputer they’re attached to. What about using the\navailable low-level peripherals in ways they weren’t\nintended?\n\nI recently made a video, a “Graphics Tablet\nPrimer for Hackers,” going into some detail on how a\npen tablet input device actually works. I compared\nthe electromagnetic power and data transfer to the\nlow-frequency RFID cards still used by many door\naccess control systems. At the time this was just a\nconvenient didactic tool, but it did start me won-\ndering just how hard it would be to use a graphics\ntablet to read 125 kHz RFID cards.\n\nI had somewhat arbitrarily chosen a Wacom\nCTE-450 (Bamboo Fun) tablet for this experiment.\nI had one handy, and I’d already done a little pre-\nliminary reversing on its protocol and circuit design.\nIt’s old enough that it didn’t seem to use any cus-\ntom Wacom silicon, recent enough to be both cheap\nand plentiful on the second-hand market.\n\n4.1 A Very Descriptive Descriptor\n\nTypically you need firmware to analyze a device.\nDocumented interfaces are the tip of the iceberg. To\nreally see what a device is capable of, you need to\nsee everything the firmware knows how to do. Some-\ntimes this is easy to get. Back in PoC‖GTFO 7:3\nwhen I was reversing an optical drive, the firmware\nwas plainly available from the manufacturer’s web\nsite. Usually you won’t be so lucky. Manufactur-\ners often encrypt firmware to hide their crimes or\nslow down clones, and some devices don’t appear to\nsupport firmware updates at all.\n\nThis device seemed to be the latter kind. No\nfirmware updates online. No hints of a firmware up-\ndating process hidden in their drivers. The CPU\nwas something I didn’t recognize at first. I posted\n\n11unzip pocorgtfo13.pdf meat.txt\n\n30\n\n\n\nXM\nEG\n\nA1\n28\n\nD\n4\n\nM\nAX\n\n34\n21\n\nES\nM\n\nD\n\nC\nLK\n\n1\n\nC\nLK\n\n2\n\nN\nC\n\n7W\nZ1\n\n4\nN\n\nC\n7W\n\nZ1\n4\n\n.1\nuF\n\n49\n\nVU\nSB\n\n IN\n\nG\nN\n\nD\n\nG\nN\n\nD\n\nC\nLK\n\n3\n\n3.\n3V\n\n3.\n3V\n\n3.\n3V\n\nR\nES\n\nET\n\nG\nN\n\nD\n\nG\nN\n\nD\n\nG\nN\n\nD\n\n10\n0n\n\n10\n0n\n\n10\n0n\n\n10\n0n\n\n1u\n\nG\nN\n\nD\nG\n\nN\nD\n\n3.\n3V\n\n3.\n3V\n\n10\n010\nk\n\n3.\n3V\n\nR\nes\n\net\n\n1k\n\n10\n0\n\nG\nN\n\nD\n\n3.\n3V\n\nG\nN\n\nD\n\nPo\nw\n\ner\nGND\n\n1k\n\n3.3V\n\nVBUS\n1k\n\n33 33\n\nPA\n5\n\nPA\n6\n\n1k 1k\n\n3.\n3V\n\nPT\nC\n\n 2\nA\n\nG\nN\n\nD\n\nG\nN\n\nD\n\nSY\nN\n\nC\nIN\n\nG\nN\n\nD\n\nIC\n1 PE\n\n0\n28\n\nPE\n1\n\n29\nPE\n\n2\n32\n\nPE\n3\n\n33\n\nPD\n7\n\n27\nPD\n\n6\n26\n\nPD\n5\n\n25\nPD\n\n4\n24\n\nPD\n3\n\n23\nPD\n\n2\n22\n\nPD\n1\n\n21\nPD\n\n0\n20\n\nPC\n7\n\n17\nPC\n\n6\n16\n\nPC\n5\n\n15\nPC\n\n4\n14\n\nPC\n3\n\n13\nPC\n\n2\n12\n\nPC\n1\n\n11\nPC\n\n0\n10\n\nPB\n3\n\n7\nPB\n\n2\n6\n\nPB\n1\n\n5\nPB\n\n0\n4\n\nPA\n6\n\n2\nPA\n\n7\n3\n\nPA\n5\n\n1\nPA\n\n4\n44\n\nPA\n3\n\n43\nPA\n\n2\n42\n\nPA\n1\n\n41\nPA\n\n0\n40\n\nAV\nC\n\nC\n39 3831\n\nPR\n0(\n\nXT\n2)\n\n36\n\nPR\n1(\n\nXT\n1)\n\n3719\nVC\n\nC\n9 18\n\nG\nN\n\nD\n8\n\nPD\nI_\n\nD\nAT\n\nA\n34 30\n\nR\nES\n\nET\n/P\n\nD\nI_\n\nC\nLK\n\n35\n\nU\n1 VC\n\nC\n23\n\nVL\n2\n\nD\n+\n\n21\nD\n\n-\n20\n\nVB\nC\n\nO\nM\n\nP\n22\n\nX0\n25\n\nX1\n24\n\nIN\nT\n\n18\nR\n\nES\n12\n\nG\nPX\n\n17\nM\n\nO\nSI\n\n16\nM\n\nIS\nO\n\n15\nSC\n\nK\n13\n\nSS\n14\n\nG\nN\n\nD\n3\n\nG\nN\n\nD\n19\n\nG\nO\n\nU\nT7\n\n11\nG\n\nO\nU\n\nT6\n10\n\nG\nO\n\nU\nT5\n\n9\nG\n\nO\nU\n\nT4\n8\n\nG\nO\n\nU\nT3\n\n7\nG\n\nO\nU\n\nT2\n6\n\nG\nO\n\nU\nT1\n\n5\nG\n\nO\nU\n\nT0\n4\n\nG\nPI\n\nN\n7\n\n1\nG\n\nPI\nN\n\n6\n32\n\nG\nPI\n\nN\n5\n\n31\nG\n\nPI\nN\n\n4\n30\n\nG\nPI\n\nN\n3\n\n29\nG\n\nPI\nN\n\n2\n28\n\nG\nPI\n\nN\n1\n\n27\nG\n\nPI\nN\n\n0\n26\n\nX1X2\n\nD\n+ D\n-\n\nVB\nU\n\nS\nG\n\nN\nD\n\nGND@1\nGND@2\n\nQ\n1\n\nU\n2A\n\n1\n6\n\nU\n2B\n\n3\n4\n\nC\n1\n\nR\n1\n\nU\n2P GNDVCC\n\n25\n\nJ2\n\nJ5\n\n123\n\nPR\nST\n\n5\n3V\n\n3\n3\n\n3V\n3\n\n18\n\n5V\n1\n\n5V\n20\n\nFH\nS1\n\n4\nFH\n\nS2\n6\n\nFI\nO\n\n1\n10\n\nFI\nO\n\n2\n12\n\nFI\nO\n\n3\n14\n\nFI\nO\n\n4\n16\n\nG\nN\n\nD\n17\n\nG\nN\n\nD\n19\n\nG\nN\n\nD\n2\n\nPD\nIC\n\n13\nPD\n\nID\n15\n\nPM\nIS\n\nO\n7\n\nPM\nO\n\nSI\n9\n\nPS\nC\n\nK\n11\n\nVR\nEF\n\n8\n\nJ4\n\n1 2 3 4\n\nJ6\n\n123\n\nC\n2\n\nC\n3\n\nC\n4\n\nC\n5\n\nC\n6\n\nR\n2R\n\n3\n\nLE\nD\n\n2\n\nR4\n\nR\n5\n\nLE\nD\n\n1\n\nR\n6\n\nLED3\n\nR7\n\nR\n8\n\nR\n9\n\nLE\nD\n\n4\n\nLE\nD\n\n5\n\nR\n10 R\n11\n\nF1\n\nJ7\n\n123\n\nD\n+\n\nD\n+\n\nD\n-\n\nD\n-\n\nC\nLK\n\n12\n\nC\nLK\n\n12\n\nC\nLK\n\n12\n\nC\nLK\n\n12\n\nR\nES\n\nET\n_G\n\nAT\nE\n\nR\nES\n\nET\n_G\n\nAT\nE\n\nTI\nO\n\n1\n\nTI\nO\n\n1\n\nTI\nO\n\n2\n\nTI\nO\n\n2\n\nTI\nO\n\n3\n\nTI\nO\n\n3\n\nTI\nO\n\n4\n\nTI\nO\n\n4\n\nPD\nI_\n\nC\nLK\n\nPD\nI_\n\nC\nLK\n\nPD\nI_\n\nD\nAT\n\nA\nPD\n\nI_\nD\n\nAT\nA\n\nU\nSB\n\n_I\nR\n\nQ\n\nU\nSB\n\n_I\nR\n\nQ\n\nU\nSB\n\n_R\nES\n\nET\n\nU\nSB\n\n_R\nES\n\nET\n\nU\nSB\n\n_G\nPX\n\nU\nSB\n\n_G\nPX\n\nU\nSB\n\n_M\nO\n\nSI\nU\n\nSB\n_M\n\nO\nSI\n\nU\nSB\n\n_M\nIS\n\nO\n\nU\nSB\n\n_M\nIS\n\nO\n\nU\nSB\n\n_S\nC\n\nK\n\nU\nSB\n\n_S\nC\n\nK\n\nU\nSB\n\n_S\nS\n\nU\nSB\n\n_S\nSSY\n\nN\nC\n\n_I\nN\n\nSY\nN\n\nC\n_I\n\nN\n\ns\nc\na\nn\nl\ni\nm\ne\n\ng\ni\nt\n\nUSB\n\nD\n\nG\n\nS\n\nR\nel\n\nea\nse\n\nd \nun\n\nde\nr t\n\nhe\n C\n\nre\nat\n\niv\ne \n\nC\nom\n\nm\non\n\ns\nAt\n\ntri\nbu\n\ntio\nn \n\nSh\nar\n\ne-\nAl\n\nik\ne \n\n4.\n0 \n\nLi\nce\n\nns\ne\n\n h\nttp\n\ns:\n//c\n\nre\nat\n\niv\nec\n\nom\nm\n\non\ns.\n\nor\ng/\n\nlic\nen\n\nse\ns/\n\nby\n-s\n\na/\n4.\n\n0/\n\nD\nes\n\nig\nn \n\nby\n:\n\n31\n\n\n\nthe photo to Twitter, and Ladyada recognized it as\na Sanyo/ONsemi LC87, an 8-bit micro that seems\nto be mostly used in Japanese consumer electron-\nics. It comes in both flash and ROM versions, both\nof which I would later find in these tablets. Test\npoints were available for an on-chip debugger, but I\ncouldn’t find the debug adapter for sale anywhere\nnor could I find any documentation for the pro-\ntocol. I even found the firmware for this myste-\nrious TCB87-TypeC debug adapter, and a way to\ndisassemble it, but the actual debug port was im-\nplemented by a custom peripheral on the adapter’s\nCPU. I tried various bit twiddling and pulse pushing\nin hopes of getting a response from the debug port,\nbut my best guess is that it’s been disabled.\n\nAt this point, the remaining options are more di-\nrect. A sufficiently funded and motivated researcher\ncould certainly break out the micropositioners and\nacid, reading the data directly from on-chip busses.\nBut this is needlessly complex and expensive. This\nis a USB device after all, and we have a perfectly\ngood off-chip bus that can already do many things.\nIn fact, when you attach a USB device to your PC,\nit typically hands very small pieces of its firmware\nback to the PC in order to identify itself. We think of\nthese USB Descriptors as data tables, not part of the\nfirmware at all, but where else would they be stored?\nOn an embedded device where RAM is so precious,\nthe descriptor chunks will be copied directly from\nFlash or Mask ROM into the USB endpoint buffer.\nIt’s a tiny engine designed to read parts of firmware\nout over USB, and nearly every USB device has code\nlike this.\n\nIf this code is functioning properly, it will read\nback only the USB descriptor tables, and nothing\nelse. If there’s a bug in the size calculation, you\nmay be able to request more data. If there isn’t\nalready a bug, you can introduce one via clock or\npower glitching.\n\nIntroducing a bug at just the right time can be\ntricky, so this is where it helped to build a new tool.\nWell, a tiny add-on for a masterful existing tool:\nthe ChipWhisperer-Lite by Colin O’Flynn. The\nChipWhisperer is an open source platform for side-\nchannel power analysis and glitching. The joy of\nhaving both power analysis and glitching in the same\nplatform is that they can be on the same reference\nclock. With one oscillator, you can deterministically\nstep your target device through its paces, measure\nits activity via the power consumption waveform,\nand deliver glitches to specific clock cycles. By re-\n\nmoving as many sources of jitter as possible, glitches\ncan be delivered more reliably to the intended oper-\nation within the target’s firmware.\n\nMy humble addon is the FaceWhisperer, a\nUSB host controller based on the MAX3421E\nchip, inspired of course by Travis Goodspeed’s\nFacedancer21 tool. Whereas the USB host controller\nin your PC will be subject to many influences far\noutside your control, the USB host in the FaceWhis-\nperer can be precisely synchronized with both the\ntarget device and the ChipWhisperer itself.\n\nPutting everything on the same clock is neces-\nsary but not sufficient for cycle-accurate timing re-\npeatability. The LC87, like many microcontrollers,\nwill boot from a free-running RC oscillator before\nswitching to the external clock under software con-\ntrol. This means it’s necessary to synchronize with\nthe running firmware somehow before starting up\nthe USB host. In this case, I’m using a comparator\ninput on the FaceWhisperer to precisely wait on a\ndebug signal that indicates the beginning of a tablet\nscanning cycle.\n\nThe GET_DESCRIPTOR request we’re interested in\ncomes in several parts: a SETUP token that describes\nwhat descriptor we’d like to read, some IN tokens\nthat each ask the device to send back one more\npacket, and finally an OUT for acknowledgment.\nThese phases each drive a forgetful state machine\nthat wakes up on each interrupt and leaves notes to\nitself for what needs to be done to the next packet.\nUnlike antique asynchronous serial ports, USB de-\nvices can never speak to the host unless they’re of-\nfered a timeslot with an IN token, so no matter how\nbadly we glitch the firmware we do need to follow\nthis flow in order to read back data from the device.\n\nThis firmware extraction glitch works by disrupt-\ning the calculation and/or storage of the descriptor\nlength, between that SETUP and the first IN. To ex-\ntract as much data as possible, the SETUP can have\na length limit of 0xFFFF and the FaceWhisperer can\ncontinue spamming IN tokens until something fails.\nWith this infrastructure in place, the ChipWhis-\nperer’s Glitch Explorer can hone in on timing off-\nsets and glitch parameters that give us longer than\nusual descriptor responses. By briefly interrupting\npower at slightly different timing offsets after the\nSETUP packet, a variety of glitched behavior can be\nobserved.\n\nThe descriptor we’ll be reading is the USB Con-\nfiguration Descriptor, typically one of the longest\ndescriptors a device will provide. This device has a\n\n32\n\n\n\n33\n\nCEEEEE CocceEe CEEEEE COEECECE CEOCECE COEEEe COCECE COOLED CLOEECE CoCCEe CoLECEE CoKGEE\n\ne°coe\n\naues +8 9.\nGOaarars ¢\n><)\n20x( ‘ 5\n\nBSu[seb,o\n0\n\n© cccoo o\n\n2\nLunes\n\necoce © cocee\n\n© eccce 0\n\neoccee cfoccce\n\n¢\necococe ccecce ceocece cococee cocece ccecoe CeCCoee CoCece Ceoecee cacceo cocecc occoo\n\n33\n\n\n\n\n34-byte descriptor that we’ll be trying to glitch into\nsomething much longer. Usually the whole thing\ncomes back in one packet:\n\nIN\n2 09022200010100801 E0904000001030102000921\n\n0001000122920007058103090004\n4 rcode 5 t o t a l 34\n\nSometimes our glitches occur while copying the\nIN data itself. These aren’t useful on their own, but\nthey can give some feedback on how well the glitch\nis working:\n\nIN\n2 09022200010100801 E0904000001030102000921\n\n21FFFFFFFF20D227FFFFFFFFFF20\n4 rcode 5 t o t a l 34\n\nWhen you’re getting close, you start to see non-\ncorrupted descriptors that have a longer than ex-\npected length:\n\nIN\n2 09022200010100801 E0904000001030102000921\n\n0001000122920007058103090004090222000101\n4 0080160904000001030102000921000100012292\n\n000705810309000409023B000201008016090400\n6 0001030102000921000100012292000705810309\n\n0004090401000103000000092100010001220F00\n8 07058203400004040309041E035700610063006F\n\n006D00200043006F002E002C004C00740064002E\n10 0010034300540045002D00340035003000100343\n\n00540045002D0036003500300010034D00540045\n12 002D0034003500300010034D00540045002D0036\n\n00350030006802680168026801680268006803F0\n14 00F001F003F00270017002700070037000700370\n\n00B801B800B801B8\n16 rcode 5 t o t a l 268\n\nOnly a little more of that, and we find a glitched\nconfiguration descriptor that’s 65,534 bytes long,\nmore than enough to reconstruct the entire 32 kB\nfirmware ROM. You only get the memory prior to\nthe descriptor if the address space wraps, but fortu-\nnately for us this was the case. All that’s left is to\ndetermine the address offset by looking for clues like\nan IVT at the beginning or unused memory near the\nend of the image, and correctly align the resulting\n32 kB image.\n\nIf you’d like to try this technique on your own\ndevices with the ChipWhisperer, you can grab the\n\nPCB design and source for FaceWhisperer and play\nalong.12\n\nThis sort of side-channel analysis still requires a\nbit of PCB surgery in order to set up the device’s\npower rails and clock for glitching and monitoring.\nIt also helps to have a reset signal and some sort\nof GPIO that can be used as a timing reference. It\nwould be interesting future work to see how far this\nsetup could be reduced. Could the glitching be per-\nformed solely via the USB port, even through what-\never power regulation and conditioning the device\nincludes?\n\n4.2 Coding in Disappearing Ink\n\nThe documentation for the LC87 architecture is\nsparse. I eventually found an instruction encoding\ntable buried in some product-line-specific appendix,\nbut for a while the only resource I could find was\na freeware toolchain, including a compiler and an\non-chip debugger. I had already taken a look at this\ndebugger in an attempt to awaken the debug port on\nmy tablet. It wouldn’t do much without this myste-\nrious TCB87-TypeC dongle, but I tried simulating\nthe TCB87 with a GreatFET that mostly just pre-\ntends things are okay and tells this RD87 debugger\nwhatever it wants to hear. When I get the debugger\nto start up, it begins populating the hex views with\nzeroes. After a quick look with the USB analyzer, I\neasily find the requests that are the same size as the\ndevice’s memory and begin answering those with my\nfirmware dump. Now I have a debugger that I can\nuse for static analysis!\n\nI was looking for some kind of update mech-\nanism. I would later discover that this tablet\n(firmware 1.16) used mask ROM whereas many ear-\nlier tablets (1.13) used flash memory. Those 1.13\ntablets do seem to have a bootloader of some kind\navailable, but I haven’t looked into it yet. With the\n1.16 tablet I had been analyzing, though, I became\nfairly certain there was no intended way to modify\nthe device’s program memory. This gave me a new\nconstraint, which turns out to be interesting any-\nway: Turn the tablet into an RFID reader without\nmodifying its firmware. We’ll do this entirely via\nRAM and return-oriented programming.\n\nThe next step was much easier than expected.\nThere was plenty of hidden functionality in the\nfirmware. These are things that aren’t part of any\n\n12git clone https://github.com/scanlime/facewhisperer\nunzip pocorgtfo13.pdf facewhisperer.tar.bz2\n\n34\n\n\n\nstandard and aren’t used by the official drivers, but\npresumably exist for factory test purposes. There’s\na mode you can put the tablet in which enables\nan additional USB endpoint that returns loads of\ntimers and internal debug info. Oh, and there’s a\nHID request that will just write exactly 16 bytes\ninto RAM anywhere you like!\n\nI think this was used in conjunction with another\nroutine that isn’t called anywhere, which tests the\ncustom silicon Sanyo added for Wacom. Oh, custom\nsilicon. I was hoping not to find that here. Newer\ntablets have chips that are obviously designed by\nWacom to be complete analog frontends. I wanted\nto start with an older tablet that would have fewer\ncustom parts. But perhaps the “W” in LC871W32\nstands for Wacom. The analog frontend is made\nfrom discrete components in this tablet; multiplex-\ners to select from an array of coils, op-amps to inte-\ngrate the received signals, a buffer to excite the coils\nwith a carrier wave. When I first looked at the cir-\ncuit, it seemed like the 750 kHz carrier wave itself as\nwell as the other timing signals would be generated\nusing general-purpose peripherals on the micro. But\nwhen I look for the corresponding GPIO pins, noth-\ning. More reverse engineering, and it was clear that\nI was facing custom hardware. I’ve been calling it\nFEB0h, after its I/O address. At first I thought it\nwas a serial engine of some sort that was being mis-\nused to run the tablet, but now it’s clear that this\nhardware is purpose-built. More on that later. For\nnow, it’s enough to know that the hardware or the\nmask ROM itself had enough engineering risk that\nthey thought it prudent to include such a powerful\ntest feature.\n\nThis is enough to start testing the waters and\nbuilding up more and more complex ROP code. The\nROM is only 32kB, and barely half full, but there are\nsome useful gadgets. We can make function calls, do\nmemcpy, RAM-to-RAM and ROM-to-RAM. Inter-\nrupts are tricky. I tried coexisting with them for a\nwhile, but had to give up on that due to USB packet\ncorruption issues I couldn’t track down. Write an\narbitrary byte? Look up where we’d find that in\nROM and do a memcpy. Loops are the slowest.\nThese ROP stack frames can only execute once be-\nfore they’re corrupted, so we must copy the code\neach time it’s run. It’s slow, but we’re doing arbi-\ntrary things to this peripheral that we haven’t even\nwritten any code to. We can even return it to nor-\nmal operation if we like, by jumping back to the\nmain loop and restoring a normal stack.\n\nThis is not typically the sort of operation your\nOS requires elevated privileges for. The underly-\ning Send Feature Report operation is typically as-\nsociated with harmless device-specific features like\ntoggling your keyboard LEDs, not with writing ar-\nbitrary instructions to a Turing-complete processor\nthat is trusted by the OS just as much as you are.\nApplications can typically reserve access to any HID\ndevice that doesn’t already have a driver loaded.\nIt’s easy to imagine some desktop malware that un-\nloads or subverts the default driver long enough to\nload some malware into a peripheral’s RAM with-\nout subsequent detection by either the user or the\ndriver.\n\n4.3 Amplitude Modulation Alchemy\n\nWacom pens and passive RFID cards are broadly\nsimilar, in that they both use a resonant LC circuit\nto pick up some energy from the reader’s chang-\ning magnetic field, then they send back data bits\nwith backscatter modulation, selectively shorting\nout the coil. The specific mechanism is a bit dif-\nferent though, and it will make our job harder. A\ntypical 125 kHz RFID reader is sending out either a\ncontinuous carrier, or perhaps sending long bursts a\nfew times a second to save energy. During this burst,\nthe reader is continuously listening for a modulated\nresponse, with hardware filters specifically tuned to\nthis job.\n\n35\n\n\n\nWacom tablets, by contrast, are all about se-\nquentially scanning an array of coils. This CTE-450\ntablet has 12 short and wide horizontal coils on the\nfront side (Y00 through Y11) and 17 tall and thin\nvertical coils on the back side (X00 to X16). When it\nhas no idea where the pen might be, it has to scan\neverywhere. After locating the pen, it can adjust\nthe scanning pattern to take differential measure-\nments from the tablet coils nearest the pen coil. In-\nstead of transmitting and receiving simultaneously,\nthe filtering can be simplified by toggling between\ntwo modes. When transmitting, a 74HC125 buffer\ndrives the coil with the tablet’s carrier wave. During\nthis time, the analog integrator is zeroed. Then the\ntablet switches modes, and begins integrating the\nreceived signal.\n\nThese resonant LC circuits are like electromag-\nnetic tuning forks. An RFID tag or a Wacom\npen have a tuning fork at a specific frequency, and\nsome circuitry that communicates each bit by either\ndamping the oscillations or letting them ring. The\nWacom tablet shouts at the tuning fork’s frequency,\nquickly and abruptly, and immediately listens for\nthe reverberation. The whole protocol is designed\naround this mode switch. Gaps in the carrier in-\ndicate the bit boundaries, and longer bursts divide\npackets.\n\nThe trick here is to use this mechanism to read\nsome common RFID access card. Between the slow\nreturn-oriented programming and the limited ana-\nlog frontend, I picked an easy target for the PoC.\nThe EM4100 is a common 125 kHz tag with a fixed\n40-bit ID. It’s no more secure than a pin tumbler\nlock for sure, but it isn’t too far from the tags used\nin many access control systems.\n\nThe EM4100 pads the 40-bit code out to a 64-bit\nrepeating pattern with the addition of a 9-bit header\nand a matrix of parity bits. Each bit is Manchester\nencoded; 0 becomes 10, 1 becomes 01. Each half-bit\nlasts 32 clock cycles, giving us a conveniently slow\ndata rate.\n\nThe pulsed carrier is a problem. The RFID card\ndoes have its little tuning fork, and it keeps ringing\na little bit, but not as much as you might think, es-\npecially when the EM4100 chip is trying to power\nitself from this stored energy and the external car-\nrier has disappeared. A clock cycle or two, but not\nnearly as long as the tablet’s A/D conversion takes.\nThis little bit of unpredictability, though, has so far\nfoiled every plan of mine to stay in sync with the\nsignal in order to sample it at or below the bit rate.\nMy workaround has been to use a short enough car-\nrier pulse in order to have multiple samples per bit,\nallowing me to occasionally use a pile of filters and\nheuristics to recover the correct bits with appropri-\nate deference to Nyquist. The problem with using\na shorter carrier pulse is that it lowers our carrier\nduty cycle, delivering less power to the RFID card.\nSo, there’s a delicate balance: long enough to power\nthe card, short enough for the resulting data to be\nintelligible through this intermittent sampling.\n\nThe returned signal is quite weak, since the\ntablet’s filters are looking for resonance at a very\ndifferent frequency. This is an area where I’ve seen\nmuch difference between individual RFID tags. Un-\nder unrealistic conditions, with the RFID tag placed\ndirectly on the tablet circuit board, many tags read\nsuccessfully without much trouble. With an unmod-\nified and fully assembled tablet, I’ve had very diffi-\ncult to reproduce results, occasionally reading only\none of the several tags I tried the setup with.\n\nIf you want to try this experiment or others, you\ncan find my simple ROP toolkit and signal process-\ning for the CTE-450 and try your luck with the\nreturn-oriented analog hacking.13\n\n4.4 More to do\n\nAlthough so far I’ve only managed to transform this\ntablet into an extremely bad RFID reader, I think\nthis shows that the overall approach may lead some-\nwhere. The main limitations here are in the reliance\non slow ROP, and the relatively low quality A/D\nconverter on the LC871. I’ve done my best to try\n\n13git clone https://github.com/scanlime/cte450-homebrew/\nunzip pocorgtfo13.pdf cte450-homebrew.tar.bz2\n\n36\n\n\n\nand separate the signal from the noise, but I’m no\nDSP guru. It’s possible that a signal processing ex-\npert could be snooping tags with a better success\nrate than I’ve been seeing. As a proof of concept,\nthis shows that the transformation from tablet to\nRFID reader is theoretically doable, though with-\nout a significant improvement in range it’s hard to\nimagine this approach succeeding at reading access\ncards casually left against a victim’s graphics tablet.\n\nIt could be interesting to examine newer tablets.\nThe custom silicon in FEB0h turned out to be one of\nthe best things about the CTE-450 tablet, making it\nrelatively easy to change the timing and carrier fre-\nquency. If newer tablets have a nicer A/D converter\nand a programmable filter on the receive path, they\ncould make a decent RFID reader indeed. A brief\nlook at my newer Intuos Pro tablet shows a Renesas\nprocessor that likely has reprogrammable flash.\n\nThere’s certainly more work to do in discov-\nering the scope of devices vulnerable to glitched\n\nGET_DESCRIPTOR requests. What other devices that\nwe usually think of as black-box peripherals might\nhave firmware that can be read out, or RAM that\nwe can temporarily hide code in?\n\nIt may be possible to mitigate these glitched\nGET_DESCRIPTOR firmware readouts by adding ad-\nditional verification steps in the device’s USB stack,\nwhich would each also need to be glitched. Reducing\nthe number of invalid states that eventually result\nin spilling data will make the glitching process much\nmore tedious.\n\nIn practice, though, I would argue that the best\nsecurity is not to rely on secret firmware at all. Al-\ngorithms shouldn’t need secrecy to keep them se-\ncure. Debug features that are too dangerous to\nleave should be disabled, not hidden. If any sensitive\ndata must be reachable from the CPU, it should be\nunmapped whenever possible, especially when some\nUSB controller asks for your life story.\n\n37\n\n\n\n5 Decoding AMBE+2 in MD380 Firmware in Linux\nby Travis Goodspeed KK4VCZ\n\nwith kind thanks to DD4CR, DF8AV, and AB3TL\n\nHowdy y’all,\nIn PoC‖GTFO 10:8, I shared with you fine folks\n\na method for extracting a cleartext firmware dump\nfrom the Tytera MD380. Since then, a rag-tag gang\nof neighbors has joined me in hacking this device,\nand hundreds of amateur radio operators around\nthe world are using our enhanced firmware for DMR\ncommunications.\n\nAMBE+2 is a fixed bit-rate audio compression\ncodec under some rather strict patents, for which\nthe anonymously-authored Digital Speech Decoder\n(DSD) project14 is the only open source decoder. It\ndoesn’t do encoding, so if for example you’d like to\nconvert your favorite Rick Astley tunes to AMBE\nframes, you’ll have to resort to expensive hardware\nconverters.\n\nIn this article, I’ll show you how I threw to-\ngether a quick and dirty AMBE audio decompressor\nfor Linux by wrapping the firmware into a 32-bit\nARM executable, then running that executable ei-\nther natively or through Qemu. The same tricks\ncould be used to make an AMBE encoder, or to\nconvert nifty libraries from other firmware images\ninto handy command-line tools.\n\nThis article will use an MD380 firmware image\nversion 2.032 for specific examples, but in the spirit\nof building our own bird feeders, the techniques\nought to apply just as well to your own firmware\nimages from other devices.\n\n– — — – — — — — – — –\nSuppose that you are reverse engineering a\n\nfirmware image, and you’ve begun to make good\nprogress. You know where plenty of useful func-\ntions are, and you’ve begun to hook them, but now\nyou are ready to start implementing unit tests and\ndebugging chunks of code. Wouldn’t it be nicer to\ndo that in Unix than inside of an embedded system?\n\nAs luck would have it, I’m writing this article\non an aarch64 Linux machine with eight cores and\na few gigs of RAM, but any old Raspberry Pi or\nAndroid phone has more than enough power to run\nthis code natively.\n\nBe sure to build statically, targeting\narm-linux-gnueabi. The resulting binary will run\non armel and aarch64 devices, as well as damned\n\nnear any Linux platform through Qemu’s userland\ncompatibility layer.\n\n5.1 Dynamic Firmware Loading\nFirst, we need to load the code into our process.\nWhile you can certainly link it into the executable,\nluck would have it that GCC puts its code sections\nvery low in the executable, and we can politely ask\nmmap(2) to load the unpacked firmware image to\nthe appropriate address. The first 48kB of Flash\nare used for a recovery bootloader, which we can\nconveniently skip without consequences, so the load\naddress will be 0x0800c000.\n\ns i ze_t l ength =994304;\n2 int fd=open ( \" experiment . img\" ,0 ) ;\n\nvoid ∗ f i rmware=mmap(\n4 (void ∗) 0x0800c000 , length ,\n\nPROT_EXEC|PROT_READ|PROT_WRITE,\n6 MAP_PRIVATE, // f l a g s\n\nfd , // f i l e\n8 0 // o f f s e t\n\n) ;\n\nAdditionally, we need the 128kB of RAM at\n0x20000000 and 64kB of TCRAM at 0x10000000\nthat the firmware expects on this platform. Since\nwe’d like to have initialized variables, it’s usually\nbetter go with dumps of live memory from a running\nsystem, but /dev/zero works for many functions if\nyou’re in a rush.\n\n14git clone https://github.com/szechyjs/dsd\n\n38\n\n\n\n1 //Load an SRAM image .\nint fdram=open ( \"ram . bin \" ,0 ) ;\n\n3 void ∗sram=mmap(\n(void ∗) 0x20000000 ,\n\n5 ( s i ze_t ) 0x20000 ,\nPROT_EXEC|PROT_READ|PROT_WRITE,\n\n7 MAP_PRIVATE, // f l a g s\nfdram , // f i l e\n\n9 0 // o f f s e t\n) ;\n\n11\n//Create an empty TCRAM region .\n\n13 int fdtcram=open ( \"/dev/ zero \" ,0 ) ;\nvoid ∗ tcram=mmap(\n\n15 (void ∗) 0x10000000 ,\n( s i z e_t ) 0x10000 ,\n\n17 PROT_READ|PROT_WRITE, // p ro t e c t i on s\nMAP_PRIVATE, // f l a g s\n\n19 fdtcram , // f i l e\n0 // o f f s e t\n\n21 ) ;\n\n5.2 Symbol Imports\n\nNow that we’ve got the code loaded, calling it is as\nsimple as calling any other function, except that our\nC program doesn’t yet know the symbol addresses.\nThere are two ways around this:\n\nThe quick but dirty solution is to simply cast a\ndata or function pointer. For a concrete example,\nthere is a null function at 0x08098e14 that sim-\nply returns without doing anything. Because it’s\na Thumb function and not an ARM function, we’ll\nhave to add one to that address before calling it at\n0x08098e15.\n\nvoid (∗ nu l l sub ) ( )=(void ∗) 0x08098e15 ;\n2\n\np r i n t f ( \"Trying to c a l l nu l l sub ( ) . \\ n\" ) ;\n4 nu l l sub ( ) ;\n\np r i n t f ( \" Success ! \\ n\" ) ;\n\nSimilarly, you can access data that’s in Flash or\nRAM.\n\n1 p r i n t f ( \"Manufacturer i s : ’%s ’\\n\" ,\n0 x080f9e4c ) ;\n\nCasting function pointers gets us part of the way,\nbut it’s rather tedious and wastes a bit of memory.\nInstead, it’s more efficient to pass a textfile of sym-\nbols to the linker. Because this is just a textfile, you\n\ncan easily export symbols by script from IDA Pro\nor Radare2.\n\nThe symbol file is just a collection of assignments\nof names to addresses in roughly C syntax.\n/∗ Populates the audio b u f f e r ∗/\n\n2 ambe_decode_wav = 0x08051249 ;\n/∗ Just re turns . ∗/\n\n4 nu l l sub = 0x08098e15 ;\n\nYou can include it in the executable by passing\nGCC parameters to the linker, or by calling ld di-\nrectly.\nCC=arm−l inux−gnueabi−gcc−6 −s t a t i c −g\n\n2 $ (CC) −o test test . c \\\n−Xl inker −−ju s t−symbols=symbols\n\nNow that we can load the firmware into process\nmemory and call its functions, let’s take a step back\nand see a second way to do the linking, by rewrit-\ning the firmware dump into an ELF object and then\nlinking it. After that, we’ll get along to decoding\nsome audio.\n\n5.3 Static Firmware Linking\nWhile it’s nice and easy to load firmware with\nmmap(2) at runtime, it would be nice and correct\nto convert the firmware dump into an object file for\nstatic linking, so that our resulting executable has\nno external dependencies at all. This requires both\na bit of objcopy wizardry and a custom script for\nld.\n\nFirst, let’s convert our firmware image dump to\nan ELF that loads at the proper address.\n\n1 arm−l inux−gnueabi−objcopy \\\n−I b inary experiment . img \\\n\n3 −−change−addre s s e s=0x0800C000 \\\n−−rename−s e c t i o n . data=. experiment \\\n\n5 −O e l f 32−l i t t l e a rm −B arm experiment . o\n\nSadly, ld will ignore our polite request\nto load this image at 0x08000C000, be-\ncause load addresses in Unix are just po-\nlite suggestions, to be thrown away by the\nlinker. We can fix this by passing -Xlinker\n–section-start=.experiment=0x0800C000 to gcc\nat compile time, so ld knows to place the section at\nthe right address.\n\nSimilarly, the SRAM image can be embedded at\nits own load address.\n\n39\n\n\n\n40\n\ncay\n\n|\n\nFor the past 35 years radio amateurs throughout the world have been purchasing equipment\nand supplies from me. Their friendship and loyalty have been the determining factors in\nour success. For this we are grateful and it is time that we made an effort to express our\nappreciation in a material way.\n\nMany amateur radio clubs need financial aid. Many others can use extra funds if these\nfunds can be obtained without assessing their members. We have a plan which will\ngreatly assist all amateur radio clubs.\nFor every order received until March 1, 1955, we will send our check for 15% of your\norder — to your radio club for deposit in their treasury. When you place your order, be\nsure to include the name and address of your club and treasurer.\nMy best wishes for a healthy, happy and prosperous New Year.\n\n73 — CUL\n\nUncledave, W2APF\n\nRADIO. DISTRIBUTING COMPANY\n904 BROADWAY, ALBANY, N. Y.\n“tou TELEPHONE ALBANY 5-1594\n\n40\n\n\n\n\n\n5.4 Decoding the Audio\nTo decode the audio, I decided to begin with the\nsame .amb format that DSD uses. This way, I could\nwork from their reference files and compare my de-\ncoding to theirs.\n\nThe .amb format consists of a four byte header\n(2e 61 6d 62) followed by eight-byte frames. Each\nframe begins with a zero byte and is followed by\n49 bits of data, stored most significant bit first with\nthe final bit in the least significant bit of its own\nbyte.\n\nTo have as few surprises as possible, I take the\neight packed bytes and extract them into an array of\n49 shorts located at 0x20011c8e, because this is the\naddress that the firmware uses to store its buffer.\nShorts are used for convenience in addressing dur-\ning computation, even if they are a bit more verbose\nthan they would be in a convenient calling conven-\ntion.\n\n1 //Re−use the firmware ’ s own AMBE bu f f e r .\nshort ∗ambe=(short ∗) 0 x20011c8e ;\n\n3\nint ambei=0;\n\n5 for ( int i =1; i <7; i++){// Skip f i r s t by te .\nfor ( int j =0; j <8; j++){\n\n7 //MSBit f i r s t\nambe [ ambei++]=(packed [ i ]>>(7− j ) )&1;\n\n9 }\n}\n\n11 //Final b i t in i t s own frame as LSBit .\nambe [ ambei++]=packed [ 7 ]&1 ;\n\nAdditionally, I re-use the output buffers to store\nthe resulting WAV audio. In the MD380, there are\ntwo buffers of audio produced from each frame of\nAMBE.\n\n//80 samples f o r each audio b u f f e r\n2 short ∗ outbuf0=(short ∗) 0x20011aa8 ;\n\nshort ∗ outbuf1=(short ∗) 0x20011b48 ;\n\nThe thread that does the decoding in firmware is\ntied into the MicroC/OS-II realtime operating sys-\ntem of the MD380. Since I don’t have the timers and\ninterrupts to call that thread, nor the I/O ports to\nsupport it, I’ll instead just call the decoding routines\nthat it calls.\n\n1 //Placed at 0x08051249\nint ambe_decode_wav(\n\n3 signed short ∗wavbuffer ,\nsigned int e ighty , // always 80\n\n5 short ∗ b i t bu f f e r , //0x20011c8e\nint a4 , //0\n\n7 short a5 , //0\nshort a6 , // t imes l o t , 0 or 1\n\n9 int a7 //0x20011224\n) ;\n\nFor any parameter that I don’t understand, I\njust copy the value that I’ve seen called through my\nhooks in the firmware running on real hardware. For\nexample, 0x20011224 is some structure used by the\nAMBE code, but I can simply re-use it thanks to\nmy handy RAM dump.\n\nSince everything is now in the right position, we\ncan decode a frame of AMBE to two audio frames\nin quick succession.\n\n//One AMBE frame becomes two audio frames .\n2 ambe_decode_wav(\n\noutbuf0 , 80 , ambe ,\n4 0 , 0 , 0 ,\n\n0x20011224\n6 ) ;\n\nambe_decode_wav(\n8 outbuf1 , 80 , ambe ,\n\n0 , 0 , 1 ,\n10 0x20011224\n\n) ;\n\nAfter dumping these to disk and converting to\na .wav file with sox -r 8000 -e signed-integer\n-L -b 16 -c 1 out.raw out.wav, a proper audio\nfile is produced that is easily played. We can now\ndecode AMBE in Linux!\n\n41\n\n\n\n5.5 Runtime Hooks\n\nSo now we’re able to decode audio frames, but this is\nfirmware, and damned near everything of value ex-\ncept the audio routines will eventually call a function\nthat deals with I/O—a function we’d better replace\nif we don’t want to implement all of the STM32’s\nI/O devices.\n\nLuckily, hooking a function is nice and easy. We\ncan simply scan through the entire image, replac-\ning all BX (Branch and eXchange) instructions to\nthe old functions with ones that direct to the new\nfunctions. False positives are a possibility, but we’ll\nignore them for now, as the alternative would be to\nlist every branch that must be hooked.\n\nThe BL instruction in Thumb is actually two ad-\njacent 16-bit instructions, which load a low and high\nhalf of the address difference into the link register,\nthen BX against that register. (This clobbers the\nlink register, but so does any BL, so the register use\nis effectively free.)\n\n1 /∗ Ca l cu l a t e s Thumb code to branch from\none address to another . ∗/\n\n3 int c a l c b l ( int adr , int t a r g e t ) {\n/∗ Begin with the d i f f e r e n c e o f the t a r g e t\n\n5 and the PC, which po in t s to j u s t a f t e r\nthe current i n s t r u c t i o n . ∗/\n\n7 int o f f s e t=target−adr−4;\n//LSBit doesn ’ t count .\n\n9 o f f s e t =( o f f s e t >>1) ;\n\n11 /∗ The BL in s t r u c t i on i s a c t u a l l y two\nThumb in s t r u c t i on s , wi th one s e t t i n g\n\n13 the h igh par t o f the LR and the other\ns e t t i n g the low part wh i l e swapping\n\n15 LR and PC. ∗/\nint hi=0xF000 | ( ( o f f s e t&0xFFF800)>>11) ;\n\n17 int l o=0xF800 | ( o f f s e t&0x7FF) ;\n\n19 //Return the pa i r as a s i n g l e 32− b i t word .\nreturn ( lo <<16) | h i ;\n\n21 }\n\nNow that we can calculate function call instruc-\ntions, a simple loop can patch all calls from one ad-\ndress into calls to a second address. You can use this\nto hook the I/O functions live, rather than trapping\nthem.\n\n5.6 I/O Traps\nWhat about those I/O functions that we’ve forgot-\nten to hook, or ones that have been inlined to a\ndozen places that we’d rather not hook? Wouldn’t\nit sometimes be easier to trap the access and fake\nthe result, rather than hooking the same function?\n\nYou’re in luck! Because this is Unix, we can sim-\nply create a handler for SIGSEGV, much as Jeffball\ndid in PoC‖GTFO 8:8. Your segfault handler can\nthen fake the action of the I/O device and return.\n\nAlternately, you might not bother with a proper\nhandler. Instead, you can use GDB to debug the\nprocess, printing a backtrace when the I/O region\nat 0x40000000 is accessed. While GDB in Qemu\ndoesn’t support ptrace(2), it has no trouble trap-\nping out the segmentation fault and letting you\nknow which function attempted to perform I/O.\n\n5.7 Conclusion\nThank you kindly for reading my ramblings about\nARM firmware. I hope that you will find them\nhandy in your own work, whenever you need to work\nwith reverse engineered firmware away from its own\nhardware.\n\nIf you’d like to similarly instrument Linux ap-\nplications, take a look at Jonathan Brossard’s\nWitchcraft Compiler Collection,15 an interactive\nELF shell that makes it nice and easy to turn an\nexecutable into a linkable library.\n\nThe emulator from this article has now been in-\ncorporated into my md380tools16 project, for use in\nLinux.\n\nCheers from Varaždin, Croatia,\n–Travis 6A/KK4VCZ\n\n15git clone https://github.com/endrazine/wcc\nunzip pocorgtfo13.pdf wcc.tar.bz2\n\n16git clone https://github.com/travisgoodspeed/md380tools\n\n42\n\n\n\n6 Password Weaknesses in Physical Security:\nSilliness in Three Acts\n\nby Evan Sultanik\n\nDramatis Personæ\nDisembodied Voice of Pastor Manul Laphroaig . . . . . . . . . . . . . . . . . . Bard\n\nAlice Feynman . . . . . . . . . . . . . Disciple of the Church of Weird Machines\n\nBob Schrute . . . . . . . . . . . . . . . . . Assistant to the Facility Security Officer\n\nHavva al-Kindi . . . . . . . . . . . . . . . . . . . . . . Alice’s Old and Wise Officemate\n\nThe Ghost of Paul Erdős . . . . . . . . . . . . . . . . . . . . . . . . Keeper of The Book\n\nAct I: Memorize, Don’t Compromise\n\nPastor: In the windowless bowels of a nonde-\nscript, Class A office building entrenched in-\nside the Washington, D.C. beltway, we meet\nour heroine, Alice Feynman, lost on her way\nto a meeting with the Facility Security Officer.\n\nAlice: Excuse me, which way is it to the secu-\nrity office?\n\nBob: You must be the new hire. Bob Schrute,\nassistant FSO. I can take you there right after\nI finish with this. . .\n\nAlice: Alice. Nice to meet you. What’re you\ndoing?\n\nBob: Kaba Mas X-09 high security spin-lock.\nIt’s DSS-approved for use in our SCIFs. I’m\nresetting this one’s passcode.\n\nAlice: [Blank Stare]\n\nBob: U.S. Department of Defense (DoD) De-\nfense Security Service (DSS). Sensitive Com-\npartmented Information Facilities (SCIFs).\nThe rooms where we are allowed to store and\nprocess classified information?\n\nAlice: I see. I noticed those things all over this\nbuilding.\n\nBob: They’re ubiquitous. You’ll see them any-\nwhere in the country there’s classified work go-\ning on. One on each door, and another on each\nsafe. Super secure, too. Security in this office\nis no joke.\n\nAlice: How do they work?\n\nBob: [Throwing Alice the lock’s manual.] They\nrun off of the electricity generated from spin-\nning them, so you need to spin them a bit to\nget started. You see? The LCD on top shows\nyou the current number. You enter three two-\ndigit numbers. First one clockwise, second\ncounter-clockwise, third clockwise, and then\na final spin counter-clockwise to open. That’s\nthe passcode.\n\nAlice: [Flipping through the manual.] Does\neach lock get a different passcode?\n\nBob: Yes. That’s why we have this [handing\nAlice a magnet stuck to the side of the door ].\n\nAlice: Ah I see. It’s a phone keypad. So you\nuse a mnemonic to remember each passcode?\n\nBob: Exactly. [Pointing to a poster on the wall\nwith his own mugshot and memetic letters em-\nblazoning “MEMORIZE, DON’T COMPRO-\nMISE”, he sternly repeats that slogan:] Mem-\norize, don’t compromise.\n\nAlice: [“Is this guy serious?” face.]\n\nBob: You think you could crack it? FALSE.\n[Flamboyantly produces a pocket calculator\nthat had been hidden somewhere on his per-\nson.] Three two-digit numbers. That’s 100\ntimes 100 times 100, so . . . there are a mil-\nlion possible codes. I’ve set this to have a\ntimeout of four minutes after each failed at-\ntempt. So, trying all possible combinations\n\n43\n\n\n\nwould take . . . [furiously punching at the calcu-\nlator ] . . . almost eight years! We change each\ncode once every couple months, so even if you\ncould continuously try codes for eight hours\na day, you’d have . . . [more furious punching ]\n. . . about seven tenths of one percent chance\nof getting the code right.\n\nAlice: [Handing the manual back.] I didn’t see\nanything in here about an automatic lockout\nafter too many failed attempts.\n\nBob: [Pointing to his minuscule biceps.] These\nprovide the lockout.\n\nAlice: Are you ready to take me to the security\noffice now?\n\nBob: Fine.\n\nAct II: Surely You’re Joking\n\nPastor: Two weeks later, Alice has settled into\nher office, which she shares with Havva al-\nKindi. She hasn’t had a chance to play with\nthose nifty locks at all yet; her clearance is still\nbeing processed. Most of her time is spent\nidling or doing busy-work while she waits to\nbe approved to work on a real project.\n\nAlice: [On her desk phone] Yes. Yes, no prob-\nlem. By close of business today. No problem.\nBye.\n\nPastor: As Alice hangs up the phone, she no-\ntices something odd about the keypad, and\nimmediately remembers the magnet Bob had\nshowed her.\n\nAlice: [Gets up and starts drawing on her\nwhiteboard.]\n\n0\n\n8\ntuv\n\n5\njkl\n\n2\nabc\n\n1 3\ndef\n\n4\nghi\n\n6\nmno\n\n7\npqrs\n\n9\nwxyz\n\nHavva: What are you doing?\n\nAlice: Did you ever notice that the numbers\nzero and one don’t have any letters on the\nphone?\n\nHavva: Sure! You’re probably too young to\nhave ever used a rotary phone, right? Back\nwhen phone numbers were only seven dig-\nits long, the first two numbers represented\nthe exchange, and a mnemonic was given\nto each exchange. [Singing and tapping on\nher desk ] Bum-dah-bum bah-duh-bum bahhh\ndummm! PEnnsylvania Six Five Thousand!\nNo? It was a big Glenn Miller hit! My par-\nents used to play it all the time when I was a\nkid. That song is referring to the phone num-\nber for the Hotel Pennsylvania in New York,\nwhich to this day is still (212) PE6-5000.\n\nAlice: Oh yeah! I went there once for HOPE.\n\nHavva: Hope? Anyhow, for various reasons,\nthe numbers zero and one were never used in\nexchanges, which meant they never occurred\nat the beginning of phone numbers, which\nmeant they couldn’t have letters associated\nwith them.\n\n44\n\n\n\nAlice: Interesting! [Continuing on the white-\nboard ] 86 = . . . [a pause to consult her com-\nputer ] 262144. 1 − 262144 ÷ 1000000 =\n. . . 0.738. Wow! So, if there are only eight\nbuttons with letters, that reduces the number\nof possible phone numbers associated with six-\nletter mnemonics by 74% compared to if all the\nbuttons had letters!\n\nHavva: I guess that’s true. There are also cer-\ntain phone numbers you’ll never be able to\nhave English mnemonics for, because the but-\ntons for 5, 7, and 9 don’t have any vowels. So\nyou can’t make a mnemonic for a phone num-\nber that only uses those three numbers.\n\nAlice: Wow, yeah, that’s another 36 = . . .\n[quickly doing some math in her head this\ntime] 729 codes that don’t have mnemonics.\n\nHavva: Codes?\n\nAlice: Er, I mean “phone numbers.”\n\nHavva: I’ll bet there are certain “codes” that\ndon’t have any English words associated with\nthem. Plus, letters in English words don’t all\noccur at the same frequency: It’s much more\nlikely that a word will have the letter “e” than\nit will have the letter “x.”\n\nAlice: [Opens up a terminal on her computer.]\n$ grep ’^.\\{6\\}$’ /usr/share/dict/words | wc -l\n\n17706\n$ echo `!!` / 1000000 | bc -l\n.01770600000000000000\n\nPastor: And thus, Alice had discovered that\nfewer than 2% of the million possible codes\nactually map to English words.\n\nAlice: [Once again at the whiteboard.]\n\nHA CK ER\n42 25 34\n\n[Back at the computer.]\n$ grep -i ’^.\\{4\\}er$’ /usr/share/dict/words \\\n| wc -l\n1562\n\nAbout 10% of six-letter English words end\nwith the letters “ER”!\n[Back at the board, with long pauses.]\n\nDO SA GE\n36 72 43\nEN RA GE\n36 72 43\nFO RA GE\n36 72 43\nFO RB ID\n36 72 43\n\nPastor: And many words share the same code.\nIn fact, Alice quickly wrote a script to count\nthe number of unique codes possible from six-\nletter English words17.\n\nAlice: There are only 14684 possible codes to\ncheck! That would take . . . only about 40 days\nto brute-force crack!\n\nAct III: The Book\n\nPastor: Later that day, Alice is at her favorite\ndive, decompressing with some of her side\nprojects.\n\nPaul: [Sits down next to Alice at the bar. Wheel\nof Fortune is playing on an ancient CRT.]\nTelevision is something the Russians invented\nto destroy American education.\n\nAlice: [Tippling a brown liquor, neat, while\nworking on her laptop. Paul’s comment draws\nher attention to the TV. Alice notices that\nsome letters are given away “for free” and re-\nmembers what Havva had said about letter fre-\nquency. She quickly grabs her notebook and\njots down the letters as a reminder.] R, S, T,\nL, N, E.\n\nPaul: [Noticing Alice’s notebook.] Yes, these\nare very common letters in English. My native\nlanguage does not use “r” as much. But what\ndo I know about English? I learned it from\nmy father, who taught it to himself by reading\nEnglish novels in one of Joe’s Gulags. [Awk-\nward pause while Alice struggles with how to\nrespond.] Have you discovered anything beau-\ntiful? [Pointing into her notebook.]\n\nAlice: Oh that? I’ve been thinking about\nmnemonics for passcodes.\n\n17$ grep ’^.\\{6\\}$’ /usr/share/dict/words | tr ’[:upper:]’ ’[:lower:]’ | sed ’s/[abc]/2/g; s/[def]/3/g;\ns/[ghi]/4/g; s/[jkl]/5/g; s/[mno]/6/g; s/[pqrs]/7/g; s/[tuv]/8/g; s/[wxyz]/9/g’ | sort | uniq | wc -l\n\n45\n\n\n\nPaul: [Pointing to the drink:] That poison will\nnot help you. [Produces a small pill bottle out\nof his shirt pocket, raises it to eye level, drops\nit, and then catches it with the same hand be-\nfore it hits the bar.]\n\nAlice: Haven’t you heard? The Ballmer Peak\nis real! Or at least that’s what I read on Stack\nExchange.\n\nPaul: Pál Erdős. My brain is open.\n\nPastor: Alice introduces herself and proceeds\nto explain all of her findings to Paul.\n\nAlice: . . .and I just finished sorting the 14684\ndistinct codes by the number of words associ-\nated with them. That way, if I try the codes\nin order of decreasing word associations, then\nit will maximize my chances of cracking the\ncode sooner than later.\n\nPaul: Yes, if codewords are chosen uniformly\nfrom all six-letter English words. Can I see\nthe distribution of word frequency? [Grabbing\na napkin, stealing Alice’s pen, and scribbling\nsome notes.] Using your method, after fewer\nthan 250 attempts, there is a 5% probability\nthat you will have cracked the code. After\nabout 5700 attempts, there will be a 50% prob-\nability of success.\n\nAlice: [Typing on her computer.] That’s only\nabout 16 days!\n\nPastor: An adversary with intermittent access\nto the lock—for example, after hours—could\nquite conceivably crack the code in less than a\nmonth.\n\nPaul: If there exists a method that allows the\ncode-breaker to detect whether each succes-\nsive two-digit subcode is correct before enter-\ning the next two-digit subcode,. . .\n\nPastor: . . .otherwise known as a “vulnerability” . . .\n\nPaul: . . .[annoyed about having been inter-\nrupted, even if by the disembodied voice of\na narrator ] then the expected value for the\nlength of time required to crack the code is on\nthe order of minutes. [Mumbling toward the\nfourth wall:] That Pastor is more annoying\nthan the SF.\n\nAlice: What?\n\nPaul: SF means “Supreme Fascist.” This would\nshow that God is bad. I do not claim that\nthis is correct, or that God exists. It is just a\nsort of half-joke. There is an anecdote I once\nheard. Suppose Israel Gelfand and his advisor,\nAndrei Kolmogorov, were to both arrive in a\ncountry with a lot of mountains. Kolmogorov\nwould immediately try and climb the highest\nmountain. Gelfand would immediately start\nbuilding roads. What would you do?\n\nAlice: I would learn to fly an airplane so I could\ndiscover new mountain ranges. What about\nyou?\n\nPaul: Some might say that is what I do. My\nfriends might add that they pay for the fuel.\nBut really, I just try to keep the SF’s score\nlow. How can we create mnemonics that are\nnot vulnerable to your attack?\n\nAlice: Well, I guess the first thing to do is cre-\nate a keypad layout that uses zero and one.\n\nPaul: Yes, but my academic sibling Pólya\nwould say that we first need to understand\nthe problem. Ideally, we want a keypad lay-\nout that produces an injective mapping from\nthe six-letter English words into the natural\nnumbers from zero to one million.\n\nAlice: Injective?\n\nPaul: Such that no two words produce the same\ncode number.\n\nAlice: Is that even possible?\n\nPaul: I do not know. I believe this is an in-\nstance of the multiple subset sum problem, re-\nlated to the knapsack problem.\n\nAlice: Ah yeah, I remember that from my al-\ngorithms class. It’s NP-Complete, right?\n\nPaul: Yes, and likely intractable for problems\neven as small as this one. The total number\nof possible keypad mappings is 100 million bil-\nlion billion. But it is easy for us to check the\npigeons.\n\nAlice: Huh?\n\nPaul: The pigeonhole principle. For any subset\nof m letters within a word, there can be at\nmost 106−m words that have that pattern of\n\n46\n\n\n\nletters. If there are more, then there must be\na collision, no matter the mapping we choose.\n\nAlice: Ah, I see. That’s easy enough to check!\n[Typing.]\n\n1 for m in range ( 2 , 6 ) :\nh i t s = {}\n\n3 for word in words :\nfor i ndexes in i t e r t o o l s .\n\ncombinat ions (range ( len (word ) ) , m) :\n5 key = tuple ( ( word [ i ] , i )\n\nfor i in i ndexes )\ni f key not in h i t s :\n\n7 h i t s [ key ] = 1\nelse :\n\n9 h i t s [ key ] += 1\nmax_hits = 10∗∗(6−m)\n\n11 for key , h in h i t s . i t e r i t em s ( ) :\ni f h <= max_hits :\n\n13 continue\nk = [ ’ . ’ for i in range (6 ) ]\n\n15 for c , i in key :\nk [ i ] = c\n\n17 print \"\" . j o i n (k ) , h − max_hits\n\nSo, there are fourteen five-letter suffixes like\n“inder”, “aggle”, and “ingle” that will all pro-\nduce at least one collision. I guess there’s no\nway to make a perfect mapping.\n\nPaul: Gelfand advised Endre Szemerédi. This\nproblem is reminiscent of Szemerédi’s use of\nexpander graphs in pseudo-random number\ngeneration. What we want to do is take a rel-\natively small set of inputs (being the six-letter\nEnglish words) and use an expander graph as\nan embedding into the natural numbers be-\ntween one and a million, such that the result-\ning distribution mimics uniformity.\n\nAlice: That sounds . . . difficult.\n\nPaul: Constructing expander graphs is ex-\ntremely difficult. But I think Szemerédi would\nagree that interesting things rarely happen in\nfewer than five dimensions.\n\nAlice: I am a pragmatist. How about we use\na genetic algorithm to evolve a near optimal\nmapping?\n\nPaul: Such a solution would not be from The\nBook, but it would provide you with a map-\nping.\n\nAlice: What book?\n\nPaul: The Book in which the SF keeps all of the\nmost beautiful solutions.\n\nAlice: Well, I think I’ll try my hand at a scruffy\ngenetic algorithm. I need a decent mapping if\nI ever want to publish this in PoC‖GTFO!\n\nPaul: What is PoC‖GTFO?\n\nAlice: It’s. . . I guess it’s a sort of bible.\n\nPaul: Then the only difference between your\nBook and mine are the fascists who created\nthem. Maybe we will continue tomorrow . . . if\nI live.\n\nAlice: [Looking up from her keyboard.] Can I\nbuy you a drink? [Paul has vanished.]\n\nPastor: The moral of the story, dear neighbors,\nis not that these locks are inherently vulnera-\nble; if used properly, they are in fact incredibly\nsecure. We must remember that these locks\nare only as secure as the codes humans choose\nto assign to them. Using a phone keypad map-\nping on six-letter English dictionary words is\nthe physical security equivalent of a website\narbitrarily limiting passwords to eight charac-\nters.\n\n0\not\n\n8\njmuy\n\n5\nfn\n\n2\nbex\n\n1\navwz\n\n3\ncl\n\n4\ndhq\n\n6\ngs\n\n7\nip\n\n9\nkr\n\n‖PoC GTFO\n!\n\n!\n\n!\n\n!\n\nDon’t\nMemorize,\n\nCompromise\nСамиздат\n\n47\n\n\n\n7 Reverse Engineering the LoRa PHY\nby Matt Knight\n\nIt’s 2016, and everyone’s favorite inescapable buz-\nzword is IoT, or the “Internet of Things.” The mere\nmention of this phrase draws myriad reactions, de-\npending on who you ask. A marketing manager\nmay wax philosophical about swarms of connected\ncars eradicating gridlock forever, or the inevitability\nof connected rat traps intelligently coordinating to\neradicate vermin from midtown Manhattan,18 while\na security researcher may just grin and relish in the\nplethora of low-power stacks and new attack surfaces\nbeing applied to cyber-physical applications.\n\nIoT is marketing speak for connected embedded\ndevices. That is, inexpensive, low power, resource\nconstrained computers that talk to each other, possi-\nbly on the capital-I Internet, to exchange data and\ncommand and control information. These devices\nare often installed in hard to reach places and can\nbe expected to operate for years. Thus, easy to con-\nfigure communication interfaces and extreme power\nefficiency are crucial design requirements. While 2G\ncellular has been a popular mechanism for connect-\ning devices in scenarios where a PAN or wired tech-\nnology will not cut it, AT&T’s plans to sunset 2G\non January 1, 2017 and LTE-M Rel 13’s distance\nto widespread adoption presents an opportunity for\nnew wireless specifications to seize market share.\n\nLoRa is one such nascent wireless technology\nthat is poised to capture this opportunity. It is a\nLow Power Wide Area Network (LPWAN), a class of\nwireless communication technology designed to con-\nnect low power embedded devices over long ranges.\nLoRa implements a proprietary PHY layer; there-\nfore the details of its modulation are not published.\n\nThis paper presents a comprehensive blind sig-\nnal analysis and resulting details of LoRa’s PHY,\nchronicles the process and pitfalls encountered along\nthe way, and aspires to offer insight that may assist\nsecurity researchers as they approach their future\nunknowns.\n\n7.1 Casing the Job\n\nI first heard of LoRa in December 2015, when it\nand other LPWANs came up in conversation among\nneighbors. Collectively we were intrigued by its ad-\nvertised performance and unusual modulation, thus\nI was motivated to track it down and learn more.\nIn the following weeks, I occasionally scanned the\n900 MHz ISM spectrum for signs of its distinctive\nwaveform (more on that soon), however searches in\nthe New York metropolitan area, Boston, and a col-\nleague’s search in San Francisco yielded no results.\n\nSometime later I found myself at an IoT security\nmeetup in Cambridge, MA that featured representa-\ntives from Senet and SIGFOX, two major LPWAN\nplayers. Senet’s foray into LoRa started when they\nsought to remotely monitor fluid levels in home heat-\ning oil tank measurement sensors to improve the ex-\nisting process of sending a guy in a truck to read it\nmanually. Senet soon realized that the value of this\ninfrastructure extended far beyond the heating oil\nmarket and has expanded their scope to becoming\na IoT cellular data carrier of sorts. While following\nup on the company I happened upon one of their\nmarketing videos online. A brief segment featured a\ngrainy shot of a coverage map, which revealed just\nenough to suggest the presence of active infrastruc-\nture in Portsmouth, NH. After quick drive with my\nEttus B210 Software Defined Radio, I had my first\nLoRa captures.\n\n7.2 First Observations and OSINT\n\nLoRa’s proprietary PHY uses a unique chirp spread\nspectrum (CSS) modulation scheme, which encodes\ninformation into RF features called chirps. A chirp\n\n18LoRaWan in the IoT Industrial Panel, presentation by Jun Wen of Cisco.\n\n48\n\n\n\nFigure 11. Spectrogram of a LoRa packet.\n\nis a signal whose frequency is increasing or decreas-\ning at a constant rate, and they are unmistakable\nwithin the waterfall. A chirp-based PHY is shown\nin Figure 11.\n\nContrasted with FSK or OFDM, two common\nPHYs, the differences are immediately apparent.\n\nModulation aside, visually inspecting a spectro-\ngram of LoRa’s distinct chirps reveals a PHY struc-\nture that is similar to essentially all other digital\nradio systems: the preamble, start of frame delim-\niter, and then the data or payload.\n\nSince LoRa’s PHY is proprietary, no PHY layer\nspecifications or reference materials were available.\nHowever, thorough analysis of open source and read-\nily available documentation can greatly abbreviate\nreverse engineering processes. When I conducted\nthis investigation, a number of useful documents\nwere available.\n\nFirst, the Layer 2+ LoRaWAN stack is pub-\nlished, containing clues about the PHY.\n\nSecond, several application notes were available\nfor Semtech’s commercial LoRa modules.19 These\nwere not specs, but they did reference some PHY-\nlayer components and definitions.\n\nThird, a European patent filing from Semtech\ndescribed a CSS modulation that could very well be\nLoRa.\n\nFinally, neighbors who came before me had\nproduced open-source prior art in the form of\na partial rtl-sdrangelove implementation and\na wiki page,20 however in my experience the\nrtl-sdrangelove attempt was piecemeal and ne-\nglected and the wiki contained only high level ob-\nservations. These were not enough to decode the\npackets that I had captured in New Hampshire.\n\n7.3 Demodulation\n\nOSINT gathering revealed a number of key defi-\nnitions that informed the reverse engineering pro-\ncess. A crucial notion is that of the spreading fac-\ntor (SF): the spreading factor represents the num-\nber of bits packed into each symbol. A symbol,\nfor the unordained, is a discrete RF energy state\nthat represents some quantity of modulated infor-\nmation (more on this later.) The LoRaWAN spec\nrevealed that the chirp bandwidth, that is the width\nof the channel that the chirps traverse, is 125 kHz,\n\n19Semtech AN1200.18, AN1200.22.\n20Decoding LoRa on the RevSpace Wiki\n\n49\n\n\n\n250 kHz, or 500 kHz within American deployments.\nThe chirp rate, which is intuitively the first deriva-\ntive of the signal’s frequency, is a function of the\nspreading factor and the bandwidth: it is defined as\nbandwidth/2(spreading_factor). Additionally, the\nabsolute value of the downchirp rate is the same as\nthe upchirp rate.21\n\nBack to the crucial concept of symbols. In LoRa,\nsymbols are modulated onto chirps by changing the\ninstantaneous frequency of the signal – the first\nderivative of the frequency, the chirp rate, remains\nconstant, while the signal itself “jumps” through-\nout its channel to represent data. The best way\nto intuitively think of this is that the modulation\nis frequency-modulating an underlying chirp. This\nis analogous to the signal alternating between two\nfrequencies in a 2FSK system, where one frequency\nrepresents a 0 and the other represents a 1. The\nunderlying signal in that case is a signal of constant\nfrequency, rather than a chirp, and the number of\nbits per symbol is 1. How many data bits are en-\ncoded into each frequency jump within LoRa? This\nis determined by the spreading factor.\n\nThe first step to extracting the symbols is to de-\nchirp the received signal. This is done by channeliz-\ning the received signal to the chirp’s bandwidth and\nmultiplying the result against a locally-generated\ncomplex conjugate of whichever chirp is being ex-\ntracted.\n\nA locally generated chirp might look like this.\n\nSince both upchirps and downchirps are present\nin the modulation, the signal should be multiplied\nagainst both a local upchirp and downchirp, which\nproduces two separate IQ streams. Why this works\ncan be reasoned intuitively, since waves obey su-\nperposition, multiplying a signal with frequency f0\nagainst a signal with frequency −f0 results in a sig-\nnal with frequency 0, or DC. If a chirp is multiplied\nagainst a copy of itself, it will result in a signal of\n2 ∗ f0, which will spread its energy throughout the\nband. Thus, generating a local chirp at the nega-\ntive chirp rate of whichever chirp is being processed\n\n21See Semtech AN1200.22.\n\n50\n\n\n\nresults in RF features with constant frequency that\ncan be handled nicely.\n\nIn following examples, the left image shows de-\nchirped upchirps while the right shows de-chirped\ndownchirps:\n\nThis de-chirped signal may be treated similarly\nto MFSK, where the number of possible frequen-\ncies is M = 2(spreading_factor). The Fast Fourier\nTransform (FFT) is the tool used to perform the\nactual symbol measurement. Fourier analysis shows\nthat a signal can be modeled as a summed series of\nbasic periodic functions (i.e., a sine wave) at various\nfrequencies. A FFT decomposes a signal into the fre-\nquency components that comprise it, returning the\npower and phase of each component present. Each\ncomponent to be extracted is colloquially called a\n“bin;” the number of bins is specified as the “FFT\nsize” or “FFT width.”\n\nThus, by taking an M -bin wide FFT of each IQ\nstream, the symbols may be resolved by finding the\nargmax, which is the bin with the most powerful\ncomponent of each FFT. This works out nicely be-\ncause a de-chirped CSS symbol turns into a signal\nwith constant frequency; all of the symbol’s energy\nshould fall into a single bin.22\n\nWith the signal de-chirped, the remainder of\nthe demodulation process can be described in three\nsteps. These steps mimic the process required for\nessentially all digital radio receivers.\n\nFirst, we’ll identify the start of the packet by\nfinding a preamble. Then, we’ll synchronize with\nthe start of the packet, so that we may conclude in\ndemodulating the payload by measuring its aligned\nsymbols.\n\n7.3.1 Finding the Preamble\n\nA preamble is a feature included in modulation\nschemes to announce that a packet is soon to fol-\nlow. By visual inspection, we can infer that LoRa’s\npreamble is represented by a series of continuous\nupchirps. Once de-chirped and passed through an\nFFT, all of the preamble’s symbols wind up resid-\ning within the same FFT bin. Thus, a preamble is\ndetected if enough consecutive FFTs have the same\nargmax.\n\n7.3.2 Synchronizing with the SFD\n\nWith our receiver aware that it’s about to receive\na packet, the next step is to accurately synchronize\nwith it so that symbols can be resolved accurately.\nTo facilitate this, modern radio systems often adver-\ntise the start of the packet’s data unit with a Start of\n\n22It may be possible to do this using FM demodulation rather than FFTs, however using FFTs preserves power information\nthat is useful for framing the packet without knowing its definitive length.\n\n51\n\n\n\nFrame Delimiter, or SFD, which is a known symbol\ndistinct from the preamble that receivers are pro-\ngrammed to look for. For LoRa, this is where the\ndownchirps come in.\n\nThe SFD is composed of two and one quarter\ndownchirps, while all the other symbols are repre-\nsented by upchirps. With preamble having been\nfound, our receiver should look for two consecutive\ndownchirps to synchronize against. It looks some-\nthing like the following:\n\nAccurate synchronization is crucial to properly\nresolving symbols. If synchronization is off by\nenough samples, when FFTs are taken each sym-\nbol’s energy will be divided between two adjacent\nFFTs. Until now, the FFT process used to resolve\nthe symbols processed 2(spreading_factor) samples\nper FFT with each sample being processed exactly\nonce, however after a few trial runs it became evi-\ndent that this coarse synchronization would not be\nsufficiently accurate to guarantee good fidelity.\n\nIncreasing the time-based FFT resolution was\nfound to be a reliable method for achieving an ac-\ncurate sync. This is done by shifting the stream of\nde-chirped samples through the FFT input buffer,\nprocessing each sample multiple times, to “overlap”\nadjacent FFTs. This increases the time-based res-\nolution of the FFT process at the expense of be-\ning more computationally intensive. Thus, overlap-\nping FFTs are only used to frame the SFD; non-\noverlapped FFTs with each sample being processed\nexactly once are taken otherwise to balance accuracy\nand computational requirements.\n\nTechnically there’s also a sync word that pre-\ncedes the SFD, but my demodulation process de-\nscribed in this article does not rely on it.\n\n7.3.3 Demodulating the Payload\n\nNow synchronized against the SFD, we are able\nto efficiently demodulate the symbols in the pay-\nload by using the original non-overlapping FFT\nmethod. However, since our receiver’s locally gen-\nerated chirps are likely out of phase with the chirp\nused by the transmitter, the symbols appear offset\nwithin the set range [0 : 2(spreading_factor)−1] by\nsome constant. It was surmised that the preamble\nwould be a reliable element to represent symbol 0,\nespecially given that the aforementioned sync word’s\nvalue is always referenced from the preamble. A sim-\nple modulo operation to normalize the symbol value\nrelative to the preamble’s zero-valued bin produces\nthe true value of the symbols, and the demodulation\nprocess is complete.\n\n7.4 Decoding, and its Pitfalls\n\nOverall, demodulation proved to not be too difficult,\nespecially when you have someone like Balint See-\nber feeding you advice and sagely wisdom. However,\ndecoding is where the fun (and uncertainty) really\nbegan.\n\nFirst, why encode data? In order to increase\nover the air resiliency, data is encoded before it is\nsent. Thus, the received symbols must be decoded\nin order to extract the data they represent.\n\nThe documentation I was able to gather on LoRa\ncertainly suggested that figuring out the decoding\nwould be a snap. The patent application describ-\ning a LoRa-like modulation described four decoding\nsteps that were likely present. Between the patent\nand some of Semtech’s reference designs, there were\ndocumented algorithms or detailed descriptions of\nevery step. However, these documents slowly proved\nto be lies, and my optimism proved to be misplaced.\n\n7.4.1 OSINT Revisited\n\nPerhaps the richest source of overall hints was\nSemtech’s European patent application.23 The\npatent describes a CSS-based modulation with an\nuncanny resemblance to LoRa, and goes so far as\nto walk step-by-step through the encoding elements\npresent in the PHY. From the encoder’s perspec-\ntive, the patent describes an encoding pipeline of\nforward error correction, a diagonal interleaver, data\nwhitening, and gray indexing, followed by the just-\ndescribed modulation process. The reverse process\n\n23European Patent #13154071.8/EP20130154071\n\n52\n\n\n\nFigure 12. The top is pre-sync and non-overlapped, middle is pre-sync overlapped, bottom is synchronized\nand non-overlapped.\n\n53\n\n\n\nwould be performed by the decoder. The patent\neven defines an interleaver algorithm, and Semtech\ndocumentation includes several candidate whitening\nalgorithms.\n\nThe first thing to try, of course, was to imple-\nment a decoder exactly as described in the docu-\nmentation. This involved, in order:\n\n1. Undoing gray coding applied to the symbols.\n\n2. Dewhitening using the algorithms defined in\nSemtech’s documentation.\n\n3. Deinterleaving using the algorithm defined in\nSemtech’s patent.\n\n4. Processing the Hamming forward error correc-\ntion hinted at in Semtech’s documentation.\n\nFirst, let’s review what we have learned about\neach step listed above based on open-source re-\nsearch, and what would be attempted as a result.\n\nGray Indexing Given the nomenclature ambigu-\nity in the Semtech patent, I also decided to test no\ngray coding and reverse gray coding in addition to\nforward gray coding. These were done using stan-\ndard algorithms.\n\nData Whitening Data whitening was a colossal\nquestion mark while looking at the system. An ideal\nwhitening algorithm is pseudorandom, thus an effec-\ntive obfuscator for all following components of the\nsystem. Luckily, Semtech appeared to have pub-\nlished the algorithm candidates in Application Note\nAN1200.18. Entitled “Implementing Data Whiten-\ning and CRC Calculation in Software on SX12xx\nDevices,” it describes three different whitening algo-\nrithms that were relevant to the Semtech SX12xx-\nseries wireless transceiver ICs, some of which sup-\nport LoRa. The whitening document provided one\nCCITT whitening sequences and two IBM methods\nin C++. As with the gray indexing uncertainty, all\nthree were implemented and permuted.\n\nInterleaver Interleaving refers to methods of de-\nterministically scrambling bits within a packet. It\nimproves the effectiveness of Forward Error Correc-\ntion, and will be elaborated on later in this text.\nThe Semtech patent application defined a diago-\nnal interleaver as LoRa’s probable interleaver. It is\na block-style non-additive diagonal interleaver that\n\nshuffles bits within a block of a fixed size. The in-\nterleaver is defined as: Symbol(j, (i + j)%PPM) =\nCodeword(i, j) where 0 <= i < PPM, 0 <= j <\n4 + RDD In this case, PPM is set to the spreading\nfactor (or spreading_factor−2 for the PHY header\nand when in low data rate modes), and RDD is set\nto the number of parity bits used by the Forward\nError Correction scheme (ranging [1 : 4]).\n\nThere was only one candidate illustrated here,\nso no iteration was necessary.\n\nForward Error Correction The Semtech patent\napplication suggests that Hamming FEC be used.\nOther documentation appeared to confirm this. A\ncustom FEC decoder was implemented that orig-\ninally just extracted the data bits from their stan-\ndard positions within Hamming(8,4) codewords, but\nearly results were negative, so this was extended to\napply the parity bits to repair errors.\n\nUsing a Microchip RN2903 LoRa Mote, a transmit-\nter that was understood to be able to produce raw\nframes, a known payload was sent and decoded us-\ning this process. However, the output that resulted\nbore no resemblance to the expected payload. The\nnext step was to inspect and validate each of the\nalgorithms derived from documentation.\n\nAfter validating each component, attempting ev-\nery permutation of supplied algorithms, and inspect-\ning the produced binary data, I concluded that\nsomething in LoRa’s described encoding sequence\nwas not as advertised.\n\n7.5 Taking Nothing for Granted\nThe nature of analyzing systems like this is that\nbeneath a certain point they become a black box.\nData goes in, some math gets done, RF happens,\nsaid math gets undone, and data comes out. Sim-\nple enough, but when encapsulated as a totality it\nbecomes difficult to isolate and chase down bugs in\neach component. Thus, the place to start was at the\ntop.\n\n54\n\n\n\n7.5.1 How to Bound a Problem\n\nThe Semtech patent describes the first stage of de-\ncoding as “gray indexing.” Gray coding is a process\nthat maps bits in such a way that makes it resilient\nto off-by-one errors. Thus, if a symbol were to be\nmeasured within ±1 index of the correct bin, the\ngray coding would naturally correct the error. “Gray\nindexing,” ambiguously referring to either gray cod-\ning or its inverse process, was initially understood\nto mean forward gray coding.\n\nThe whitening sequence was next in line. Data\nwhitening is a process applied to transmitted data\nto induce randomness into it. To whiten data, the\ndata is XORed against a pseudorandom string that\nis known to both the transmitter and the receiver.\nThis does good things from an RF perspective, since\nit induces lots of features and transitions for a re-\nceiver to perform clock recovery against. This is\nfunctionally analogous to line coding schemes such\nas Manchester encoding, but whitening offers one\npro and one con relative to line coding: data whiten-\ning does not impact the effective bit rate as Manch-\nester encoding does,24 but this comes at the expense\nof legibility due to the pseudorandom string.\n\nAt this point, it is important to address some of\nthe assumptions and inferences that were made to\nframe the following approach. While the four de-\ncoding stages were thrown into question by virtue\nof the fact that at least one of the well-described\nalgorithms was not correct, certain implied proper-\nties could be generalized for each class of algorithm,\neven if the implementation did not match exactly.\n\nI made a number of assumptions at this point,\nwhich I’ll describe in turn.\n\nFirst, the interleaver in use is non-additive. This\nmeans that while it will reorder the bits within each\ninterleaving block, it will not cause any additional\nbits to be set or unset. This was a reasonable\n\nassumption because many block-based interleavers\nare non-additive, and the interleaver defined in the\npatent is non-additive as well. Even if the interleaver\nused a different algorithm, such as a standard block\ninterleaver or a different type of diagonal interleaver,\nit could still fit within this model.\n\nSecond, the forward error correction in use is\nHamming FEC, with 4 data bits and 1-4 parity bits\nper codeword. FEC can be thought of as super-\ncharged parity bits. A single parity bit can indicate\nthe presence of an error, but if you use enough of\nthem they can collectively identify and correct er-\nrors in place, without re-transmission. Hamming is\nspecifically called out by the European patent, and\nthe code rate parameter referenced throughout ref-\nerence designs fits nicely within this model. The use\nof Hamming codes, as opposed to some other FEC\nor a cyclic coding scheme, was fortuitous because\nof a property of the Hamming code words. Ham-\nming codeword mapping is deterministic based on\nthe nybble that is being encoded. Four bits of data\nprovide 16 possible codewords. When looking at\nHamming(8,4) (which is the inferred FEC for LoRa\ncode rate 4/8), 14 of the 16 codewords contain four\nset bits (1s) and four unset bits (0s). However, the\ncode words for 0b0000 and 0b1111 are 0b00000000\nand 0b11111111, respectively.\n\nThus, following on these two assumptions, if a\npayload containing all 0x00s or 0xFFs were sent,\nthen the interleaving and forward error correction\nshould cancel out and not affect the output at all.\nThis reduces our unknown stages in the decoding\nchain from four to just two, with the unknowns be-\ning gray indexing and whitening, and once those are\nresolved then the remaining two can be solved for!\n\nSince “gray indexing” likely refers to gray cod-\ning, reverse gray coding, or no coding should it be\nomitted, this leaves only three permutations to try\nwhile solving for the data whitening sequence.\n\nThe first step was to take a critical look at\nthe data whitening algorithms provided by Semtech\nAN1200.18. Given the detail and granularity in\nwhich they are described, plus the relevance of\nhaving come straight from a LoRa transceiver\ndatasheet, it was almost a given that one of the three\nalgorithms would be the solution. With the inter-\nleaver and FEC effectively zeroed out, and “gray in-\ndexing” reduced to three possible states, it became\npossible to test each of the whitening algorithms.\n\nTesting each whitening algorithm was fairly\n24Manchester’s effective bit rate is 1/2 baud rate.\n\n55\n\n\n\nstraightforward. A known payload of all 0x00s or\n0xFFs (to cancel out interleaving and FEC) was\ntransmitted from the Microchip LoRa Technology\nMote and then decoded using each whitening al-\ngorithm and each of the possible “gray indexing”\nstates. This resulted in 9 total permutations. A\nvisual diff of the decoded data versus the expected\npayload resulted in no close matches. This was re-\nplaced with a diff script with a configurable toler-\nance for bits that did not match. This also resulted\nin no matches as well. One final thought was to\nforward compute the whitening algorithms in case\nthere was a static offset or seed warm-up, as can\nbe the case with other PRNG algorithms. Likewise,\nthis did not reveal any close matches. This meant\nthat either none of the given whitening algorithms\nin the documentation were utilized, or the assump-\ntions that I made about the interleaver and FEC\nwere not correct.\n\nAfter writing off the provided whitening algo-\nrithms as fiction, the next course of action was to\nattempt to derive the real whitening algorithm from\nthe LoRa transmitter itself. This approach was\nbased on the previous observations about the FEC\nand interleaver and a fundamental understanding of\nhow data whitening works. In essence, whitening is\nas simple as XORing a payload against a static pseu-\ndorandom string, with the same string used by both\nthe transmitter and receiver. Since anything XORed\nwith zero is itself, passing in a string of zeroes causes\nthe transmitter to reveal a “gray indexed” version of\nits whitening sequence.\n\nThis payload was received, then transformed into\nthree different versions of itself: one gray-coded, one\nunmodified, and one reverse gray-coded. All three\nwere then tested by transmitting a set of 0xF data\nnybbles and using each of the three “gray indexing”\ncandidates and received whitening sequence to de-\ncode the payload. The gray coded and unmodified\nversions proved to be incorrect, but the reverse gray\ncoding version successfully produced the transmit-\nted nybbles, and thus in one fell swoop, I was able\nto both derive the whitening sequence and discern\nthat “gray indexing” actually referred to the reverse\ngray coding operation. With “gray indexing” and\nwhitening solved, I could turn my attention to the\nbiggest challenge: the interleaver.\n\n7.5.2 The Interleaver\n\nAt this point we’ve resolved two of the four signal\nprocessing stages, disproving their documentation\n\nin the process. Following on this, the validity of the\ninterleaver definition provided in Semtech’s patent\nwas immediately called into question.\n\nA quick test was conducted against a local im-\nplementation of said interleaver: a payload com-\nprised of a repeated data byte that would produce\na Hamming(8,4) codeword with four set and four\nunset bits was transmitted and the de-interleaved\nframe was inspected for signs of the expected code-\nword. A few other iterations were attempted, in-\ncluding reversing the diagonal offset mapping pat-\ntern described by the patent and using the inverse\nof the algorithm (i.e., interleaving the received pay-\nload rather than de-interleaving it). Indeed, I was\nable to conclude that the interleaver implemented by\nthe protocol is not the one suggested by the patent.\nThe next logical step is to attempt to reverse it.\n\nWithin a transmitter, interleaving is often ap-\nplied after forward error correction in order to make\nthe packet more resilient to burst interference. In-\nterleaving scrambles the FEC-encoded bits through-\nout the packet so that if interference occurs it is\nmore likely to damage one bit from many codewords\nrather than several bits from a single codeword. The\nformer error scenario would be recoverable through\nFEC, the latter would result in unrecoverable data\ncorruption.\n\nBlock-based interleavers, like the one described\nin the patent, are functionally straightforward.\nThe interleaver itself can be thought of as a two-\ndimensional array, where each row is as wide as the\nnumber of bits in each FEC codeword and the num-\nber of columns corresponds to the number of FEC\ncodewords in each interleaver block. The data is\nthen written in row-wise and read out column-wise;\nthus the first output “codeword” is comprised of the\nLSB (or MSB) of each FEC codeword. A diagonal\ninterleaver, as suggested in the patent, offsets the\ncolumn of the bit being read out as rows are tra-\nversed.\n\nUnderstanding the aforementioned fundamentals\nof what the interleaver was likely doing was essen-\ntial to approaching this challenge. Ultimately, given\nthat a row-column or row-diagonal relationship de-\nfines most block-based interleavers, I anticipated\nthat patterns that could be revealed if approached\nappropriately. Payloads were therefore constructed\nto reveal the relationship of each row or codeword\nwith a corresponding diagonal or column. In order\nto reveal said mapping, the Hamming(8,4) codeword\nfor 0xF was leveraged, since it would fill each row\n\n56\n\n\n\n0x0000000F 0x000000F0 0x00000F00 0x0000F000 0x000F0000 0x00F00000 0x0F000000 0xF0000000\n00100011 11000000 00001001 11010000 00000011 01000100 01000001 00001000\n00010011 00100101 00000111 00001001 00000011 00000011 10000010 01000101\n00001001 00010001 00000011 00000101 01000001 00000000 00100001 10000011\n00000111 00001101 00000011 00000110 10000010 01000101 00010010 00100011\n00000000 00001100 01000010 00001000 00100010 10001001 00001010 00010011\n00000100 00000000 10000001 01000010 00010001 00100010 00000111 00001011\n01000011 00000001 00100001 10000000 00001001 00010000 00000011 00000111\n10000101 01000111 00010000 00100101 00000000 00001111 00000101 00000111\n\nFigure 13. Symbol Tests\n\nwith eight contiguous bits at a time. Payloads con-\nsisting of seven 0x0 codewords and one 0xF code-\nword were generated, with the nybble position of\n0xF iterating through the payload. See Figure 13.\n\nAs one can see, by visualizing the results as they\nwould be generated by the block, patterns associ-\nated with each codeword’s diagonal mapping can be\nidentified. The diagonals are arbitrarily offset from\nthe corresponding row/codeword position. One im-\nportant oddity to note is that the most significant\nbits of each diagonal are flipped.\n\nWhile we now know how FEC codewords map\ninto block diagonals, we do not know where each\ncodeword starts and ends within the diagonals, or\nhow its bits are mapped. The next step is to map\nthe bit positions of each interleaver diagonal. This\nis done by transmitting a known payload comprised\nof FEC codewords with 4 set and 4 unset bits and\nlooking for patterns within the expected diagonal.\n\n1 Payload : 0xDEADBEEF\nb i t 76543210\n\n3 00110011\n10111110\n\n5 11111010\n11011101\n\n7 10000010\n10000111\n\n9 11000000\n10000010\n\nReading out the mapped diagonals results in the\nfollowing table.\n\nT Bot\nD 1 0 1 0 0 0 0 1\nE 0 1 1 1 0 1 0 0\nA 0 1 0 1 1 0 0 0\nD 1 0 1 1 0 0 0 0\nB 1 1 0 0 0 0 1 0\nE 0 1 1 1 0 1 0 0\nE 0 1 1 1 0 1 0 0\nF 1 1 1 1 1 1 1 1\nWhile no matches immediately leap off the page,\n\nmanipulating and shuffling through the data begins\n\nto reveal patterns. First, reverse the bit order of the\nextracted codewords:\n\nB Top\nD 1 0 0 0 0 1 0 1\nE 0 0 1 0 1 1 1 0\nA 0 0 0 1 1 0 1 0\nD 0 0 0 0 1 1 0 1\nB 0 1 0 0 0 0 1 1\nE 0 0 1 0 1 1 1 0\nE 0 0 1 0 1 1 1 0\nF 1 1 1 1 1 1 1 1\nAnd then have a look at the last nybble for each\n\nof the highlighted codewords:\nB Top\n\nD 1 0 0 0 0 1 0 1\nE 0 0 1 0 1 1 1 0\nA 0 0 0 1 1 0 1 0\nD 0 0 0 0 1 1 0 1\nB 0 1 0 0 0 0 1 1\nE 0 0 1 0 1 1 1 0\nE 0 0 1 0 1 1 1 0\nF 1 1 1 1 1 1 1 1\nSix of the eight diagonals resemble the data em-\n\nbedded into each of the expected FEC encoded code-\nwords! As for the first and fifth codewords, it is\npossible they were damaged during transmission, or\nthat the derived whitening sequence used for those\npositions is not exact. That is where FEC proves its\nmettle – applying Hamming(8,4) FEC would repair\nany single bit errors that occurred in transmission.\nThe Hamming parity bits that are expected with\neach codeword are calculated using the Hamming\nFEC algorithm, or can be looked up for standard\nschemes like Hamming(7,4) or Hamming(8,4).\n\nData (8 , 4 ) Par i ty Bi t s\n2 0xD 1101 1000\n\n0xE 1110 0001\n4 0xA 1010 1010\n\n0xD 1101 1000\n6 0xB 1011 0100\n\n0xE 1110 0001\n8 0xE 1110 0001\n\n0xF 1111 1111\n\n57\n\n\n\nWhile the most standard Hamming(8,4) bit or-\nder is: p1, p2, d1, p3, d2, d3, d4, p4 (where p are\nparity bits and d are data bits), after recognizing the\nabove data values we can infer that the parity bits\nare in a nonstandard order. Looking at the diago-\nnal codeword table and the expected Hamming(8,4)\nencodings together, we can map the actual bit posi-\ntions:\n\nBot Top\np1 p2 p4 p3 d1 d2 d3 d4\n\nD 1 0 0 0 0 1 0 1\nE 0 0 1 0 1 1 1 0\nA 0 0 0 1 1 0 1 0\nD 0 0 0 0 1 1 0 1\nB 0 1 0 0 0 0 1 1\nE 0 0 1 0 1 1 1 0\nE 0 0 1 0 1 1 1 0\nF 1 1 1 1 1 1 1 1\nNote that parity bits three and four are swapped.\n\nWith that resolved, we can use the parity bits to de-\ncode the forward error correction, resulting in four\nbits being corrected, as shown in Figure 14.\n\nThat’s LoRa!\n– — — – — — — — – — –\n\nHaving reversed the protocol, it is important to\nlook back and reflect on how and why this worked.\nAs it turned out, being able to make assumptions\nand inferences about certain goings-on was crucial\nfor bounding the problem and iteratively verify-\ning components and solving for unknowns. Recall\nthat by effectively canceling out interleaving and\nforward error correction, I was able to effectively\nsplit the problem in two. This enabled me to solve\nfor whitening, even though “gray indexing” was un-\nknown there were only three permutations, and with\nthat in hand, I was able to solve for the interleaver,\nsince FEC was understood to some extent. Just like\nalgebra or any other scientific inquiry, it comes down\nto controlling your variables. By stepping through\nthe problem methodically and making the right in-\nferences, we were able to reduce 4 independent vari-\nables to 1, solve for it, and then plug that back in\nand solve for the rest.\n\n7.6 Remaining Work\nWhile the aforementioned process represents a com-\nprehensive description of the PHY, there are a few\npieces that will be filled in over time.\n\nThe LoRa PHY contains an optional header with\nits own checksum. I have not yet reversed the\n\nheader, and the Microchip LoRa module I’ve used\nto generate LoRa traffic does not expose the option\nof disabling the header. Thus I cannot zero those\nbits out to calculate the whitening sequence applied\nto it. It should be straightforward to fill in with the\ncorrect hardware in hand.\n\nThe PHY header and service data unit/payload\nCRCs have not been investigated for the same rea-\nson. This should be easy to resolve through the use\nof a tool like CRC RevEng once the header is known.\n\nIn my experience, for demodulation purposes\nclock recovery has not been necessary beyond get-\nting an accurate initial sync on the SFD. However\nshould clock drift pose a problem, for example if\ntransmitting longer messages or using higher spread-\ning factors which have slower data rates/longer over-\nthe-air transmission times, clock recovery may be\ndesirable.\n\n7.7 Shameless Plug\n\nI recently published an open source GNU Radio\nOOT module that implements a transceiver based\non this derived version of the LoRa PHY. It is pre-\nsented to empower RF and security researchers to\ninvestigate this nascent protocol.25\n\n25git clone https://github.com/BastilleResearch/gr-lora\nunzip pocorgtfo13.pdf gr-lora.tar.bz2\n\n58\n\n\n\nTop\np1 p2 p4 p3 d1 d2 d3 d4\n\nD 1 0 0 0 1 1 0 1 1101 = 0xD\nE 0 0 1 0 1 1 1 0 1110 = 0xE\nA 1 0 0 1 1 0 1 0 1010 = 0xA\nD 1 0 0 0 1 1 0 1 1101 = 0xD\nB 0 1 0 0 1 0 1 1 1011 = 0xB\nE 0 0 1 0 1 1 1 0 1110 = 0xE\nE 0 0 1 0 1 1 1 0 1110 = 0xE\nF 1 1 1 1 1 1 1 1 1111 = 0xF\n\nFigure 14. Forward Error Corrected bits shown in bold\n\n7.8 Conclusions and Key Takeaways\nPresented here is the process that resulted in a com-\nprehensive deconstruction of the LoRa PHY layer,\nand the details one would need to implement the\nprotocol. Beyond that, however, is a testament to\nthe challenges posed by red herrings (or three of\nthem, all at once) encountered throughout the re-\nverse engineering process. While open source in-\ntelligence and documentation can be a boon to re-\nsearchers – and make no mistake, it was enormously\nhelpful in debunking LoRa – one must remember\nthat even the most authentic sources may sometimes\nlie!\n\nAnother point to take away from this is the im-\nportance of bounding problems as you solve them,\nincluding through making informed inferences in the\nabsence of perfect information. This of course must\nbe balanced with the first point about OSINT, is\nknowing when to walk away from a source. How-\never as illustrated above, drawing appropriate con-\nclusions proved integral to reducing and solving for\neach of the decoding elements within a black-box\nmethodology.\n\nThe final thought I will leave you with is that\nwireless doesn’t just mean Wi-Fi anymore - it in-\ncludes cellular, PANs, LPWANs, and everything in\nbetween. Accordingly, a friendly reminder that se-\ncurity monitoring and test tools don’t exist until\nsomeone creates them. Monitor mode and Wire-\nshark weren’t always a thing, so don’t take them\nfor granted: it’s time to make the next generation\nof wireless networks visible to researchers, because\nknow it or not it is already here and is here to stay.\n\n59\n\n\n\n8 Plumbing, not Popper;\nor, the Problem with STEP\n\nby Pastor Manul Laphroaig\n\nGather round, neighbors. We are going to a mag-\nical place. One that we hardly ever notice in our\nbusy lives, but which has a way of taking over your\nentire day when you are forced to visit it. We are\ngoing on a trip to the plumbing closet!26\n\nLook at the miracle that is the clump of pipes,\nlooking right back at you. Its message is clear: do\nnot approach without skill, unless you like wet, gi-\ngantic messes. This message is universal: it speaks\nto a politician, a professor, an NYT columnist, a\nmovie actor, and a hedge fund manager alike. It\ntranscends languages and beliefs.\n\nEven though these worthies and civic leaders\nmight agree the country could use more plumbers,\nit has not yet occurred to them to approach the\nproblem by putting a big P into some popular slo-\ngan like “STEP” (Science, Technology, Engineering,\nPlumbing), by setting up a federal Department of\nPlumbing, or by lionizing a professional coveralls-\nwearer TV personality who goes by “A Plumbing\nGuy,” despite never having fixed a pipe in his life.\n\nThey somehow know that these things will do\ndiddly squat to address the shortage of plumbers.\nThey know deep down that to learn plumbing—and\neven to not sound ridiculous about it—one needs to\n\nstudy with a plumber, attach oneself to a plumber,\nand do what a plumber does for a while. This, neigh-\nbors, is how deep the plumbing magic goes.\n\nScience, alas, has not been so lucky.\n– — — – — — — — – — –\n\nIt is fashionable to talk about how we need more\nscientists, and how we can direct and improve sci-\nence, quoting grand theories that explain science,\nwhile similarly educated people nod approvingly.\nAfter all, they all know what science is, as befits\nall forward-thinking people these days. No one feels\nawkward; everyone feels good.\n\nPerhaps this happens because our social betters\nall experienced helplessness at the sight of broken\nplumbing, but would not recognize broken science,\nmuch less a hopelessly broken science textbook. You\nsee, science lab equipment is OK with a patroniz-\ning, self-satisfied gaze, whereas plumbing has a way\nof glaring back contemptuously, daring you to use\nyour general theoretical understanding.\n\nWith plumbing, it’s either practical skill or\na huge mess in your basement. Messing with\nhow plumbers learn and teach this skill guarantees\nmesses in thousands of basements. If you value your\nplumbing, it’s wise to leave plumbers alone even if\nyou believe every word of every newspaper column\nyou’ve ever read on plumbing economy.\n\nIt may be a surprise to the readers of Karl Pop-\nper and Imre Lakatos27 that actual scientists are\nhelped by philosophy of science in exactly the same\nway as plumbers are helped by the Zen of Plumb-\ning. Although these very same people are likely to\nbelieve they understand plumbing too, they usually\nhave the sense to leave the plumbing profession well\nalone, and not apply their philosophical understand-\nings to it—being empirically familiar with the fact\nthat when you need plumbing done, philosophy is\nuseless; only the skill stands between the water in\nyour pipes and your expensive library.\n\n– — — – — — — — – — –\n26For those of you fortunate to own a house, it’s probably in the corner of your basement, an equally magical place, whence\n\nall science and innovation springs forth—but let us not digress.\n27Lakatos the philosopher is considered to be a great intellectual authority. For what it’s worth, you might also want to read\n\nabout how he applied his philosophy in real life: unzip pocorgtfo13 freudenthal.pdf\n\n60\n\n\n\n61\n\nMceAVITY’S PLUMBER S’\n\nPLUMBERS’ TOOLS\n\nPlate 2213\nShave Hook.\nPrice, per Doz... .$6.00\n\nPlate 2211\nTap Borer. Price, per Doz.$6.00\n\nPlate 2212 Plate 2215\nPlate 2214 Bibb reseating Tool with Cutters Bench Mallet\nPlumbers’ Snips For $6''-19\"-26\"-34\" Bibbs. Price, per Doz : $6.00\nNo. 5 3 % ” Cut Each. .$3.50 Price, Each................-- $5.00 2 es\nNo. 3.00 Extra Cutters, per set......... 2.50\nNo. 10 2 y \"\n\nPlate 2217\nLead Pipe Bending Spring\nSizes 1” 14%\" 1144” 2”\nPlate 2216 Price, Each....... $1.25 $1.50 $1.75 $2.00\n\n. Burner Pliers\nSizes a rr LE ; a\n\nPrice, Each.$ .75 $1.00 $1.25\n\nPlate 22110\n. . . Steel Bend Iron\n\nPlate 2219— Combination Pliers Price, Each.... ......... $ .75\nSizes 6” 8” — 10”\nNickel Plated..$ 1.50 $1.75 $2.00\n\nPlate 2218 Polished Steel.. 1.25 1.50 1.75\n\nBoxwood Lead Dresser Blue finished\nPrice, per Doz..........$15.00 Steel..... 1.00\n\nPlate 21111\n‘* Rivetting Hammer ”’\nSizes 1” 2” 3”\nPrice...... $1.50 $1.25 $1.00\n\nCold Chisel................20000- Yr 5\"\nPrice, Each................02005. $ .50° $.75\n\nPlate 22113—Capé Chisel\nPrice, Each, 34”...........0..0005 $ .50\n\nPlate 22114 Plate 22115 Plate 22116\nStraight Caulking Chisel Picking Chisel Regular Caulking Chisel\nPrice, Each............ $ .75 Price, Each........ $ .75 Size, 34’’ Price, Each. ...$ .75\n\nreo —r\nPlate 22118\nPlate 22117 Rand L Hand Caulking Chisel Plate 22119\nLong Packing Iron Price, Each........... 1.00 Round nose Pliers,\nSize, 18”. Price, Each.... $ .75 rey aE $ Stocked from 4” to 8”\n\n61\n\n\n\n\nBy far the worst hit to a profession is delivered\nwhen a part of the professionals actually welcomes\nphilosophers lauding it, politicians bearing gifts and\ngrants, and governments setting up departments to\npromote it. Forms to fill, ever-growing grant appli-\ncation paperwork, pervasive “performance metrics,”\nand having to explain basic fallacies to the well-\nmeaning but fundamentally ignorant and hugely\npowerful committees come later—and accumulate.\nIn the context of metrics, charlatans always win, be-\ncause they don’t get distracted by trying for actual\nresults.\n\nNot to mention that the money that goes to char-\nlatans is not net-neutral for actual plumbing (or sci-\nence); it is net-negative, because charlatans have a\nway of making the lives of professionals hard where\nit hurts the most. When Tim “the Tool Man” Tay-\nlor waves power tools around with a swagger, the\n\nresults are immediate and obvious. When learned\ncommittees do the professional equivalent thereof to\nmath textbooks and call it nice names like “Discov-\nery Math,” “Common Core,” or “Critical Thinking”\nit takes a generation to notice, and then we wonder—\nhow on earth did school math become unteachable\nand unlearnable?28\n\nPlumbers have wisely avoided it, perhaps due to\nsome secret wisdom passed from master to appren-\ntice through the ages. Scientists, I am sorry to say,\nwalked right into it around the middle of the twen-\ntieth century.\n\nSure enough, national agencies got us to the\nmoon—but it seems that all the good science school-\nbooks have been put on the rockets going there,\nnever to return. Have you met many scientists who\nare happy with what schools do to their sciences\nafter half a century of being improved by various\ngovernment offices?\n\nFunny how it worked out for scientists. Now hear\nthem complain about “publish or perish,” the rapidly\nrising age at which one finally succeeds in getting\none’s first grant, and the relentless race to rebrand\nand follow the current big-ticket grant programs.29\n\nBut don’t blame them, neighbors; it was their\nadvisors or their advisors’ advisors who fell for it.\nBetter to buy them a drink, and remember their\nlesson.\n\nBetter yet, find some plumbers, and buy them\ndrinks. Perhaps they’ll share with you some of their\nsecrets of how to keep the philosophers and their\neducated and benevolent readers interested in the\nresult, but at a safe distance from the actual plumb-\ning.\n\n28We sort of know the answer, neighbors: a roller coaster of reforms and unintelligible standards created a generation of math\nteachers for whom math did not have to make sense. unzip pocorgtfo13.pdf wu-preparing-teachers.pdf and read it. It may\napply to whatever else you hold dear.\n\n29According to Ronald J. Daniels, President of Baltimore’s Johns Hopkins University, no less than the whole generation\nis at risk: “A generation at risk: Young investigators and the future of the biomedical workforce.” (unzip pocorgtfo13.pdf\natrisk.pdf.) For more of this, read “Science in the Age of Selfies” by Donald Geman, Stuart Geman. (selfies.pdf.) It’s hard\nto make these things up, neighbors.\n\n62\n\n\n\n9 Where is ShimDBC.exe?\nby Geoff Chappell\n\nMicrosoft’s Shim Database Compiler might be a\nlegend . . . except that nobody seems ever to have\nmade any story of it. It might be mythical . . . ex-\ncept that it actually does exist. Indeed, it has been\naround for 15 years in more or less plain sight. Yet\nif you ask Google to search the Internet for occur-\nrences of shimdbc, and especially of “shimdbc.exe”\nin quotes, you get either remarkably little or a tan-\ntalising hint, depending on your perspective.\n\nMostly, you get those scam sites that have pre-\npared a page for seemingly every executable that\nhas ever existed and can fix it for you if only you\nwill please download their repair tool. But amongst\nthis dross is a page from Microsoft’s TechNet site.\nGoogle excerpts that “QFixApp uses the support\nutility ShimDBC.exe to test the group of selected\nfixes.” Follow the link and you get to one of those\nrelatively extensive pages that Microsoft sometimes\nwrites to sketch a new feature for system adminis-\ntrators and advanced users (if not also to pat them-\nselves on the back for the great new work). This\npage is from 2001 and is titled Windows XP Appli-\ncation Compatibility Technologies.30\n\n9.1 Application Compatibility?\n\nThere can’t be anything more boring in the whole\nof Windows, you may think. I certainly used to,\nand might still for applications if I cared enough,\nbut Windows 8 brought Application Compatibility\nto kernel mode in a whole new way, and this I do\ncare about.\n\nThe integrity of any kernel-mode driver that you\nor I write nowadays depends on what anyone else,\nwell-meaning or not, can get into the DRVMAIN.SDB\nfile in the AppPatch subdirectory of the Windows\ninstallation. This particular Shim Database file ex-\nists in earlier Windows versions too, but only to list\ndrivers that the kernel is not to load. If you’re the\nwriter of a driver, there’s nothing you can do at run-\ntime about your driver being blocked from loading,\nand in some sense you’re not even affected: you’re\nnot loaded and that’s that. Starting with Win-\ndows 8, however, the DRVMAIN.SDB file defines the\ninstalled shim providers and either the registry or\nthe file can associate your driver with one or more of\nthese defined shim providers. When your driver gets\nloaded, the applicable shim providers get loaded too,\nif they are not already, and before long your driver’s\nimage in memory has been patched, both for how it\ncalls out through its Import Address Table and how\nit gets called, e.g., to handle I/O requests.\n\nIn this brave new world, is your driver really\nyour driver? You might hope that Microsoft would\nat least give you the tools to find out, if only so\nthat you can establish that a reported problem with\nyour driver really is with your driver. After all,\nfor the analogous shimming, patching, and what-\never of applications, Microsoft has long provided an\nApplication Compatibility Toolkit (ACT), recently\nre-branded as the Windows Assessment and Deploy-\nment Kit (ADK). The plausible thoroughness of this\nkit’s Compatibility Administrator in presenting a\ntree view of the details is much of the reason that\nI, for one, regarded the topic as offering, at best,\nslim pickings for research. For the driver database,\nhowever, this kit does nothing—well, except to leave\nme thinking that the SDB file format and the API\nsupport through which SDB files get interpreted,\ncreated, and might be edited, are now questions I\nshould want to answer for myself rather than imag-\n\n30https://technet.microsoft.com/library/bb457032.aspx\n\n63\n\n\n\nine they’ve already been answered well by whoever\nmanaged somehow to care about Application Com-\npatibility all along.\n\n9.2 The SDB File Format\n\nRelax! I’m not taking you to the depths of Applica-\ntion Compatibility, not even just for what’s specific\nto driver shims. Our topic here is reverse engineer-\ning. Now that you know what these SDB files are\nand why we might care to know what’s in them,\nI expect that if you have no interest at all in Ap-\nplication Compatibility, you can treat this part of\nthis article as using SDB files just as an example\nfor some general concerns about how we present\nreverse-engineered file formats. (And please don’t\nskip ahead, but I promise that the final part is pretty\nmuch nothing but ugly hackery.)\n\nLet’s work even more specifically with just one\nexample of an SDB file, shown in Figure 15. It’s a\nlittle long, despite being nearly minimal. It defines\none driver shim but no drivers to which this shim is\nto be applied.\n\nAlthough Microsoft has not documented the\nSDB file format, Microsoft has documented a se-\nlection of API functions that work with SDB files,\nwhich is in some ways preferable. Perhaps by look-\ning at these functions researchers and reverse engi-\nneers have come to know at least something of the\nfile format, as evidenced by various tools they have\npublished which interpret SDB files one way or an-\nother, typically as XML.\n\nAs a rough summary, an SDB file has a 3-dword\nheader, for a major version, minor version, and sig-\nnature, and the rest of the file is a list of variable-size\ntags which each have three parts:\n\n1. a 16-bit TAG, whose numerical value tells of the\ntag’s type and purpose;\n\n2. a size in bytes, which can be given explicitly as\na dword or may be implied by the high 4 bits\nof the TAG;\n\n3. and then that many bytes of data, whose in-\nterpretation depends on the TAG.\n\nImportantly for the power of the file format, the\ndata for some tags (the ones whose high 4 bits are\n7) is itself a list of tags. From this summary and a\nfew details about the recognised TAG values, the im-\nplied sizes and the general interpretation of the data,\n\ne.g., as word, dword, binary, or Unicode string—\nall of which can be gleaned from Microsoft’s admit-\ntedly terse documentation of those API functions—\nyou might think to reorganise the raw dump so that\nit retains every byte but more conveniently shows\nthe hierarchy of tags, each with their TAG, size (if\nexplicit) and data (if present). A decoding of Fig-\nure 15 is shown in Figure 16.\n\nTo manually verify that everything in the file is\nexactly as it should be, there is perhaps no better\nrepresentation to work from than one that retains\nevery byte. In practice, though, you’ll want some\ninterpretation. Indeed, the dump above does this\nalready for the tags whose high 4 bits are 6. The\ndata for any such tag is a string reference, specifi-\ncally the offset of a 0x8801 tag within the 0x7801\ntag (at offset 0x0142 in this example), and an auto-\nmated dump can save you a little trouble by show-\ning the offset’s conversion to the string. Since those\nnumbers for tags soon become tedious, you may pre-\nfer to name them. The names that Microsoft uses\nin its programming are documented for the roughly\n100 tags that were defined ten years ago (for Win-\ndows Vista). All tags, documented or not (and now\nrunning to 260), have friendly names that can be ob-\ntained from the API function SdbTagToString. If\nyou haven’t suspected all along that Microsoft pre-\npares SDB files from XML input, then you’ll likely\ntake “tag” as a hint to represent an SDB file’s tags\nas XML tags. And this, give or take, is where some\nof the dumping tools you can find on the Internet\nleave things, such as in Figure 17.\n\nNotice already that choices are made about what\nto show and how. If you don’t show the offset in\nbytes that each XML tag has as an SDB tag in the\noriginal SDB file, then you risk complicating your\npresentation of data, as with the string references,\nwhose interpretation depends on those file offsets.\nBut show the offsets and your XML quickly looks\nmessy. Once your editorial choices go so far that you\ndon’t reproduce every byte but instead build more\nand more interpretation into the XML, why show\nevery tag? Notably, the string table that’s the data\nfor tag 0x7801 (TAG_STRINGTABLE) and the indexes\nthat are the data for tag 0x7802 (TAG_INDEXES)\nmust be generated automatically from the data for\ntag 0x7001 (TAG_DATABASE) such that the last may\nbe all you want to bother with. Observe that for any\ntag that has children, the subtags that don’t have\nchildren come first, and perhaps you’ll plumb for a\ndifferent style of XML in which each tag that has no\n\n64\n\n\n\n00000000: 02 00 00 00 01 00 00 00-73 64 62 66 02 78 CA 00 ........sdbf.x..\n00000010: 00 00 03 78 14 00 00 00-02 38 07 70 03 38 01 60 ...x.....8.p.8.‘\n00000020: 16 40 01 00 00 00 01 98-00 00 00 00 03 78 0E 00 .@...........x..\n00000030: 00 00 02 38 17 70 03 38-01 60 01 98 00 00 00 00 ...8.p.8.‘......\n00000040: 03 78 0E 00 00 00 02 38-07 70 03 38 04 90 01 98 .x.....8.p.8....\n00000050: 00 00 00 00 03 78 14 00-00 00 02 38 1C 70 03 38 .....x.....8.p.8\n00000060: 01 60 16 40 02 00 00 00-01 98 00 00 00 00 03 78 .‘.@...........x\n00000070: 14 00 00 00 02 38 1C 70-03 38 0B 60 16 40 02 00 .....8.p.8.‘.@..\n00000080: 00 00 01 98 00 00 00 00-03 78 14 00 00 00 02 38 .........x.....8\n00000090: 1A 70 03 38 01 60 16 40-02 00 00 00 01 98 00 00 .p.8.‘.@........\n000000A0: 00 00 03 78 14 00 00 00-02 38 1A 70 03 38 0B 60 ...x.....8.p.8.‘\n000000B0: 16 40 02 00 00 00 01 98-00 00 00 00 03 78 1A 00 .@...........x..\n000000C0: 00 00 02 38 25 70 03 38-01 60 01 98 0C 00 00 00 ...8%p.8.‘......\n000000D0: 00 00 52 45 4B 43 41 48-14 01 00 00 01 70 60 00 ..REKCAH.....p‘.\n000000E0: 00 00 01 50 D8 C1 31 3C-70 10 D2 01 22 60 06 00 ...P..1<p...\"‘..\n000000F0: 00 00 01 60 1C 00 00 00-23 40 01 00 00 00 07 90 ...‘....#@......\n00000100: 10 00 00 00 28 22 AB F9-12 33 73 4A B6 F9 93 6D ....(\"...3sJ...m\n00000110: 70 E1 12 EF 25 70 28 00-00 00 01 60 50 00 00 00 p...%p(....‘P...\n00000120: 10 90 10 00 00 00 C8 E4-9C 91 69 D0 21 45 A5 45 ..........i.!E.E\n00000130: 01 32 B0 63 94 ED 17 40-03 00 00 00 03 60 64 00 .2.c...@.....‘d.\n00000140: 00 00 01 78 7A 00 00 00-01 88 10 00 00 00 32 00 ...xz.........2.\n00000150: 2E 00 31 00 2E 00 30 00-2E 00 33 00 00 00 01 88 ..1...0...3.....\n00000160: 2E 00 00 00 48 00 61 00-63 00 6B 00 65 00 64 00 ....H.a.c.k.e.d.\n00000170: 20 00 44 00 72 00 69 00-76 00 65 00 72 00 20 00 .D.r.i.v.e.r. .\n00000180: 44 00 61 00 74 00 61 00-62 00 61 00 73 00 65 00 D.a.t.a.b.a.s.e.\n00000190: 00 00 01 88 0E 00 00 00-48 00 61 00 63 00 6B 00 ........H.a.c.k.\n000001A0: 65 00 72 00 00 00 01 88-16 00 00 00 68 00 61 00 e.r.........h.a.\n000001B0: 63 00 6B 00 65 00 72 00-2E 00 73 00 79 00 73 00 c.k.e.r...s.y.s.\n000001C0: 00 00 ..\n\nFigure 15. ShimDB File\n\nchild tags is represented as an attribute and value,\ne.g.,\n\n<DATABASE\n2 TIME=\"0x01D210703C31C1D8\"\n\nCOMPILER_VERSION=\" 2 . 1 . 0 . 3 \"\n4 NAME=\"Hacked Driver Database\"\n\nOS_PLATFORM=\"0x00000001\"\n6 DATABASE_ID=\"0x28 0x22 0xAB 0xF9 0x12 0x33\n\n0x73 0x4A 0xB6 0xF9 0x93 0x6D 0x70 0xE1 0\nx12 0xEF\">\n<KSHIM\n\n8 NAME=\"Hacker\"\nFIX_ID=\"0xC8 0xE4 0x9C 0x91 0x69 0xD0 0\n\nx21 0x45 0xA5 0x45 0x01 0x32 0xB0 0x63 0\nx94 0xED\"\n\n10 FLAGS=\"0x00000003\"\nMODULE=\"hacker . sys \" />\n\n12 </DATABASE>\n\nWhether you choose XML in this style or to have\nevery tag’s data between opening and closing tags,\nthere are any number of ways to represent the data\nfor each tag. For instance, once you know that\nthe binary data for tag 0x9007 (TAG_DATABASE_ID)\nor tag 0x9010 (TAG_FIX_ID) is always a GUID, you\nmight more conveniently represent it in the usual\nstring form. Instead of showing the data for tag\n0x5001 (TAG_TIME) as a raw qword, why not show\n\nthat you know it’s a Windows FILETIME and present\nit as 16/09/2016 23:15:37.944? Or, on the grounds\nthat it too must be generated automatically, you\nmight decide not to show it at all!\n\nIf I labour the presentation, it’s to make the\npoint that what’s produced by any number of dump-\ning tools inevitably varies according to purpose and\ntaste. Let’s say a hundred researchers want a tool\nfor the easy reading of SDB files. Yes, that’s doubt-\nful, but 100 is a good round number. Then ninety\nwill try to crib code from someone else—because,\nyou know, who wants to reinvent the wheel—and\nwhat you get from the others will each be different,\npossibly very different, not just for its output but\nespecially for what the source code shows of the file\nformat. Worse, because nine out of ten program-\nmers don’t bother much with commenting, even for\na tool they may intend as showing off their cod-\ning skills, you may have to pick through the source\ncode to extract the file format. That may be easier\nthan reverse-engineering Microsoft’s binaries that\nwork with the file, but not necessarily by much—and\nnot necessarily leaving you with the same confidence\nthat what you’ve learnt about the file format is cor-\n\n65\n\n\n\n00000000: Header: MajorVersion=0x00000002 MinorVersion=0x00000001 Magic=0x66626473\n0000000C: Tag=0x7802 Size=0x000000CA Data=\n00000012: Tag=0x7803 Size=0x00000014 Data=\n00000018: Tag=0x3802 Data=0x7007\n0000001C: Tag=0x3803 Data=0x6001\n00000020: Tag=0x4016 Data=0x00000001\n00000026: Tag=0x9801 Size=0x00000000\n0000002C: Tag=0x7803 Size=0x0000000E Data=\n00000032: Tag=0x3802 Data=0x7017\n00000036: Tag=0x3803 Data=0x6001\n0000003A: Tag=0x9801 Size=0x00000000\n00000040: Tag=0x7803 Size=0x0000000E Data=\n\n...\n\n000000BC: Tag=0x7803 Size=0x0000001A Data=\n000000C2: Tag=0x3802 Data=0x7025\n000000C6: Tag=0x3803 Data=0x6001\n000000CA: Tag=0x9801 Size=0x0000000C Data=0x00 0x00 0x52 0x45 0x4B 0x43 0x41 0x48 0x14 0x01 0x00 0x00\n000000DC: Tag=0x7001 Size=0x00000060\n000000E2: Tag=0x5001 Data=0x01D210703C31C1D8\n000000EC: Tag=0x6022 Data=0x00000006 => L\"2.1.0.3\"\n000000F2: Tag=0x6001 Data=0x0000001C => L\"Hacked Driver Database\"\n000000F8: Tag=0x4023 Data=0x00000001\n000000FE: Tag=0x9007 Size=0x00000010 Data=0x28 0x22 0xAB 0xF9 0x12 0x33 0x73 0x4A 0xB6 0xF9 0x93 0x6D\n\n0x70 0xE1 0x12 0xEF\n00000114: Tag=0x7025 Size=0x00000028\n0000011A: Tag=0x6001 Data=0x00000050 => L\"Hacker\"\n00000120: Tag=0x9010 Size=0x00000010 Data=0xC8 0xE4 0x9C 0x91 0x69 0xD0 0x21 0x45 0xA5 0x45 0x01 0x32\n\n0xB0 0x63 0x94 0xED\n00000136: Tag=0x4017 Data=0x00000003\n0000013A: Tag=0x6003 Data=0x00000064 => L\"hacker.sys\"\n00000142: Tag=0x7801 Size=0x0000007A Data=\n00000148: Tag=0x8801 Size=0x00000010 Data=L\"2.1.0.3\"\n0000015E: Tag=0x8801 Size=0x0000002E Data=L\"Hacked Driver Database\"\n00000192: Tag=0x8801 Size=0x0000000E Data=L\"Hacker\"\n000001A6: Tag=0x8801 Size=0x00000016 Data=L\"hacker.sys\"\n\nFigure 16. ShimDB File (Decoded from Figure 15)\n\n66\n\n\n\n1 <INDEXES>\n<INDEX>\n\n3 <INDEX_TAG>0x7007</INDEX_TAG>\n<INDEX_KEY>0x6001</INDEX_KEY>\n\n5 <INDEX_FLAGS>0x00000001</INDEX_FLAGS>\n<INDEX_BITS></INDEX_BITS>\n\n7 </INDEX>\n<INDEX>\n\n9 <INDEX_TAG>0x7017</INDEX_TAG>\n<INDEX_KEY>0x6001</INDEX_KEY>\n\n11 <INDEX_BITS></INDEX_BITS>\n</INDEX>\n\n13 . . .\n<INDEX>\n\n15 <INDEX_TAG>0x7025</INDEX_TAG>\n<INDEX_KEY>0x6001</INDEX_KEY>\n\n17 <INDEX_BITS>0x00 0x00 0x52 0x45 0x4B 0x43 0x41 0x48 0x14 0x01 0x00 0x00</INDEX_BITS>\n</INDEX>\n\n19 </INDEXES>\n<DATABASE>\n\n21 <TIME>0x01D210703C31C1D8</TIME>\n<COMPILER_VERSION>0x00000006</COMPILER_VERSION>\n\n23 <NAME>0x0000001C</NAME>\n<OS_PLATFORM>0x00000001</OS_PLATFORM>\n\n25 <DATABASE_ID>0x28 0x22 0xAB 0xF9 0x12 0x33 0x73 0x4A 0xB6 0xF9 0x93 0x6D 0x70 0xE1 0x12 0xEF</\nDATABASE_ID>\n\n<KSHIM>\n27 <NAME>0x00000050</NAME>\n\n<FIX_ID>0xC8 0xE4 0x9C 0x91 0x69 0xD0 0x21 0x45 0xA5 0x45 0x01 0x32 0xB0 0x63 0x94 0xED</\nFIX_ID>\n\n29 <FLAGS>0x00000003</FLAGS>\n<MODULE>0x00000064</MODULE>\n\n31 </KSHIM>\n</DATABASE>\n\n33 <STRINGTABLE>\n<STRINGTABLE_ITEM>2 . 1 . 0 . 3</STRINGTABLE_ITEM>\n\n35 <STRINGTABLE_ITEM>Hacked Driver Database</STRINGTABLE_ITEM>\n<STRINGTABLE_ITEM>Hacker</STRINGTABLE_ITEM>\n\n37 <STRINGTABLE_ITEM>hacker . sys</STRINGTABLE_ITEM>\n</STRINGTABLE>\n\nFigure 17. Illegible XML From a ShimDB Dumping Tool\n\n67\n\n\n\nrect and comprehensive. Writing a tool that dumps\nan undocumented file format may be more reward-\ning for you as a programmer but it is not nearly the\nsame as documenting the file format.\n\n9.3 Reversing XML to SDB\nBut is there really no definitive XML for repre-\nsenting SDB files? Of all the purposes that moti-\nvate anyone to work with SDB files closely enough\nto need to know the file format, one has special\nstanding: Microsoft’s creation of SDB files from\nXML input. If we had Microsoft’s tool for that,\nthen wouldn’t most researchers plumb for revers-\ning its work to recover the XML source? After\nall, most reverse engineers and certainly the popular\nreverse-engineering tools don’t take binary code and\nunassemble it just to what you see in the debugger.\nNo, they disassemble it into assembly language that\ncan be edited and re-assembled. Many go further\nand try to decompile it into C or C++ that can be\nedited and re-compiled (even if it doesn’t look re-\nmotely like anything you’d be pleased to have from\na human programmer). In this context, the SDB to\nXML conversion to want is something you could feed\nto Microsoft’s Shim Database Compiler for compila-\ntion back to SDB. Anything else is pseudo-code. It\nmay be fine in its way for understanding the content,\nand some may prefer it to a raw dump interpreted\nwith reference to documentation of the file format,\nbut however widely it gets accepted it is nonetheless\npseudo-code.\n\nThe existence of something that someone at\nMicrosoft refers to as a Shim Database Com-\npiler has been known for at least a decade be-\ncause Microsoft’s documentation of tag 0x6022\n(TAG_COMPILER_VERSION), apparently contempora-\nneous with Windows Vista, describes this tag’s data\nas the “Shim Database Compiler version.” And\nwhat, then, is the ShimDBC.exe from the even older\nTechNet article if it’s not this Shim Database Com-\npiler?\n\nBut has anyone outside Microsoft ever seen this\ncompiler? Dig out an installation disc for Win-\ndows XP from 2001, look in the Support Tools di-\nrectory, install the ACT version 2.0 from its self-\nextracting executable, and perhaps install the Sup-\nport Tools too in case that’s what the TechNet ar-\nticle means by “support utility.” For your troubles,\nwhich may include having to install Windows XP,\nyou’ll get the article’s QFixApp.exe, and the Com-\npatibility Administrator, as CompatAdmin.exe, and\n\nsome other possibly useful or at least instructive\ntools such as GrabMI.exe, but you don’t get any\nfile named ShimDBC.exe. I suspect that Shim-\nDBC.exe never has existed in public as any sort of\nself-standing utility or even as its own file. Even if\nit did once upon a time, we should want a modern\nversion that knows the modern tags such as 0x7025\n(TAG_KSHIM) for defining driver shims.\n\nFor some good news, look into either QFix-\nApp.exe or CompatAdmin.exe using whatever is\nyour tool of choice for inspecting executables. In-\nside each, not as resources but intermingled with the\ncode and data, are several instances of ShimDBC as\ntext. We’ve had Microsoft’s Shim Database Com-\npiler for 15 years since the release of Windows XP.\nAll along, the code and data for the console program\nShimDBC.exe, from its wmain function inwards, has\nbeen linked into the GUI programs QFixApp.exe\nand CompatAdmin.exe (of which only the latter sur-\nvives to modern versions of the ACT). Each of the\nGUI programs has a WinMain function that’s first to\nexecute after the C Run-Time (CRT) initialisation.\nWhenever either of the GUI programs wants to cre-\nate an SDB file, it composes the Unicode text of a\ncommand line for the fake ShimDBC.exe and calls a\nroutine that first parses this into the argc and argv\nthat are expected for a wmain function and which\nthen simply calls the wmain function. Where the\nTechNet article says QFixApp uses ShimDBC.exe,\nit is correct, but it doesn’t mean that QFixApp ex-\necutes ShimDBC.exe as a separate program, more\nthat QFixApp simulates such execution from the\nShimDBC code and data that’s built in.\n\nUnfortunately, CompatAdmin does not provide,\neven in secret, for passing a command line of our\nchoice through WinMain to wmain. But, c’mon, we’re\nhackers. You’ll already be ahead of me: we can\npatch the file. Make a copy of CompatAdmin.exe as\nShimDBC.exe, and use your favourite debugger or\ndisassembler to find three things:\n\n• the program’s WinMain function;\n\n• the routine the program passes the fake com-\nmand line to for parsing and for calling wmain;\n\n• the address of the Import Address Table entry\nfor calling the GetCommandLineW function.\n\n68\n\n\n\nIdeally, you might then assemble something like\nc a l l dword ptr [__imp__GetCommandLineW@0]\n\n2 mov ecx , eax\nc a l l SimulateShimDBCExecution\n\n4 r e t 10h\n\nover the very start of WinMain. In practice, you\nhave to allow for relocations. Our indirect call to\nGetCommandLineW will need a fixup if the program\ndoesn’t get loaded at its preferred address. Worse,\nif we overwrite any fixup sites in WinMain, then our\ncode will get corrupted if fixups get applied. But\nthese are small chores that are bread and butter for\npractised reverse engineers. For concreteness, I give\nthe patch details for the 32-bit CompatAdmin.exe\nfrom the ACT version 6.1 for Windows 8.1 in Ta-\nble 2.\n\nFor hardly any trouble, we get an executable\nthat still contains all its GUI material (except for\nthe 17 bytes we’ve changed) but never executes\nit and instead runs the console-application code\nwith the command line that we give when running\nthe patched program. Microsoft surely has Shim-\nDBC.exe as a self-standing console application, but\nwhat we get from patching CompatAdmin.exe must\nbe close to the next best thing, certainly for so little\neffort. It’s still a GUI program, however, so to see\nwhat it writes to standard output we must explicitly\ngive it a standard output. At a Command Prompt\nwith administrative privilege, enter\n\nshimdbc -? >help.txt\n\nto get the built-in ShimDBC program’s mostly accu-\nrate description of its command-line syntax, includ-\ning most of the recognised command-line options.\n\nTo produce the SDB file that is this article’s ex-\nample, write the following as a Unicode text file\nnamed test.xml:\n<?xml version=\" 1 .0 \" encoding=\"UTF−16\" ?>\n\n2 <DATABASE NAME=\"Hacked Driver Database\"\nID=\"{F9AB2228−3312−4A73−B6F9−936D70E112EF}\">\n\n4 <LIBRARY>\n<KSHIM NAME=\"Hacker\" FILE=\"hacker . sys \"\n\n6 ID=\"{919CE4C8−D069−4521−A545−0132B06394ED}\n\"\nLOGO=\"YES\" ONDEMAND=\"YES\" />\n\n8 </LIBRARY>\n</DATABASE>\n\nand feed it to the compiler via the command line\n1 shimdbc Driver t e s t . xml t e s t . sdb >t e s t . txt\n\nI may be alone in this, but if you’re going to\ntell me that I should know that you know the SDB\nfile format when all you have to show is a tool that\nconverts SDB to XML, then this would better be\nthe XML that your tool produces from this article’s\nexample of an SDB file. Otherwise, as far as I’m\nconcerned for studying any SDB file, I’m better off\nwith a raw dump in combination with actual docu-\nmentation of the file format.\n\nDo not let it go unnoticed, though, that the\nXML that works for Microsoft’s ShimDBC needs at-\ntributes that differ from the programmatic names\nthat Microsoft has documented for the tags or the\nfriendly names that can be obtained from the Sdb-\nTagToString function. For instance, the 0x6003 tag\n(TAG_MODULE) is compiled from an attribute named\nnot MODULE but FILE. The 0x4017 tag (TAG_FLAGS)\nis synthesised from two attributes. Even harder to\nhave guessed is that a LIBRARY tag is needed in the\nXML but does not show at all in the SDB file, i.e.,\nas a tag 0x7002 (TAG_LIBRARY). So, to know what\nXML is acceptable to Microsoft’s compiler for creat-\ning an SDB file, you’ll have to reverse-engineer the\ncompiler or do a lot of inspired guesswork.\n\nHappy hunting!\n\n69\n\n\n\nFile Offset Original Patched Remarks\n0x0002FB54 8B FF EB 08 jump to instruction that will use existing fixup site\n0x0002FB56 55\n0x0002FB57 8B EC\n0x0002FB59 81 EC 88 05 00 00\n0x0002FB5E FF 15 D0 30 49 00 incorporate existing fixup site at file offset 0x0002FB60\n0x0002FB5F A1 00 60 48 00\n0x0002FB64 33 C5 8B C8\n0x0002FB66 89 45 FC E8 55 87 01 00 no fixup required for this direct call within .text section\n0x0002FB69 8B 45 08\n0x0002FB6B C2 10 00\n0x0002FB6C 53\n0x0002FB6D 56\n\nTable 2. Patch details for the 32-bit CompatAdmin.exe from the ACT version 6.1 for Windows 8.1.\n\nba\nse\n\nd \non\n\n h\nttp\n\ns:/\n/d\n\niv\nisb\n\nyz\ner\n\no.c\nom\n\n/2\n01\n\n6/\n07\n\n/0\n6/\n\nm\nak\n\ne-a\n-su\n\ngih\nar\n\na-\ncir\n\ncle\nsq\n\nua\nre\n\n-o\npt\n\nica\nl-i\nllu\n\nsio\nn-\n\nou\nt-o\n\nf-p\nap\n\ner\n/\n\nAmbiguous Cylinder by Kokichi Sugihara\n\nresult\n\n杉原 厚吉 の 多義柱体\n\n70\n\n\n\n10 Post Scriptum: A Schizophrenic Ghost\nby Evan Sultanik and Philippe Teuwen\n\nA while back, we asked ourselves,\n\nWhat if PoC‖GTFO had completely dif-\nferent content depending on whether the\nfile was rendered by a PDF viewer versus\nbeing sent to a printer?\n\nA PostScript/PDF polyglot seemed inevitable. We\nhad already done MBR, ISO, TrueCrypt, HTML,\nRuby, . . . Surely PostScript would be simple, right?\nAs it turns out, it’s actually quite tricky.\n\n$ gv pocorgtfo13.pdf\n\nThere were two new challenges in getting this\npolyglot to work:\n\n1. The PDF format is a subset of the PostScript\nlanguage, meaning that we needed to devise\na way to get a PDF interpreter to ignore the\nPostScript code, and vice versa; and\n\n2. It’s almost impossible to find a PostScript\ninterpreter that doesn’t also support PDF.\nGhostscript is nearly ubiquitous in its use as a\nbackend library for desktop PostScript view-\ners (e.g., Ghostview), and it has PDF sup-\nport, too. Furthermore, it doesn’t have any\nconfiguration parameters to force it to use a\nspecific format, so we needed a way to force\nGhostscript to always interpret the polyglot\nas if it were PostScript.\n\nTo overcome the first challenge, we used a sim-\nilar technique to the Ruby polyglot from pocor-\ngtfo11.pdf, in which the PDF header is embed-\nded into a multi-line string (delimited by parenthesis\nin PostScript), so that it doesn’t get interpreted as\nPostScript commands. We halt the PostScript inter-\npreter at the end of the PostScript content by using\nthe handy stop command following the standard\n%%EOF “Document Structuring Conventions” (DSC)\ndirective.\n\nThis works, in that it produces a file that is\nboth a completely valid PDF as well as a completely\nvalid PostScript program. The trouble is that Adobe\nseems to have blacklisted any PDF that starts with\nan opening parenthesis. We resolved this by wrap-\nping the multi-line string containing the PDF header\ninto a PostScript function we called /pdfheader:\n\n/pdfheader\n{\n(\n%!PS-Adobe\n%PDF-1.5\n%<D0><D4><C5><D8>\n\n9999 0 obj\n<<\n/Length # bytes between “stream”\n\nand “endstream”\n>>\nstream\n)\n}\nPostScript Content\nstop\nendstream\nendobj\n\nRemainder of PDF Content\n\nMulti-Line PostScript String\n\nPostScript Function\n\nPDF Object\n\nTerminates\n\nPostScript\n\nInterpretation\n\nThe trick of starting the file with a PostScript\nfunction worked, and the PDF could be viewed\nin Adobe. That still leaves the second challenge,\nthough: We needed a way to trick Ghostscript into\nbeing “schizophrenic” (cf. PoC‖GTFO 7:6), vi&., to\ninsert a parser-specific inconsistency into the poly-\nglot that would force Ghostscript into thinking it is\nPostScript.\n\nGhostscript’s logic for auto-detecting file types\nseems to be in the dsc_scan_type function in-\nside /psi/dscparse.c. It is quite complex, since\nthis single function must differentiate between seven\ndifferent filetypes, including DSC/PostScript and\nPDF. It classifies a file as a PDF if it contains a\nline starting with “%PDF-”, and PostScript if it con-\ntains a line starting with “%!PS-Adobe”. Therefore,\nif we put %!PS-Adobe anywhere before %PDF-1.5,\nthen Ghostscript should be tricked into thinking it is\nPostScript! The only caveat is that Adobe blacklists\nany PDF that starts with “%!PS-Adobe”, so it can’t\nbe at the beginning of the file (which is typically\nwhere it occurs in DSC files). But that’s okay, be-\ncause Ghostscript only needs it to occur before the\n%PDF-1.5, regardless of where.\n\nThis article continues in the PostScript!\n\n71\n\n\n\n11 Tithe us your Alms of 0day!\nfrom the desk of Pastor Manul Laphroaig,\n\nInternational Church of the Weird Machines\n\nDearest neighbor,\nDo you remember what it was like when you first\n\nlearned to program a computer? Not when you first\nrealized that you could do it well, but when you first\nrealized that you could do it at all? How did it feel?\n\nAnd do you remember what it was like when you\nfirst learned how to use calculus? Not when you\nfirst learned how complicated differential equations\ncould become, but when you first realized that with\na handful of rules, you could bounce back and forth\nbetween position, velocity, acceleration, and jerk as\nif they were all the same thing? How did that feel?\n\nAnd do you remember what it was like when\nyou first learned how to use a screwdriver? Not\nwhen you first learned what to do after removing\nthe screw, but when you first realized that with a\nscrewdriver—with the right screwdriver—you could\ntake apart anything? How did that feel?\n\nWhen I was sixteen, I was a bit of an asshole,\nand I asked my automechanics teacher a question\nabout a distributor’s angular momentum. I don’t\nrecall my exact question, but I do recall that it was\nthe sort of thing no one could be expected to know,\nand that, being a jerk, I asked it in the vocabulary\nof calculus.\n\nCoach Crigger could’ve called me out for be-\ning rude, or he could’ve dodged the question. He\ncould’ve done any number of things that you might\nexpect. Instead, he walked out of the classroom\nwhile two and half dozen hooligans started a racket\naudible from the other side of the campus.\n\nTen minutes later, he returned to the classroom.\nHe walked right up to my desk and slammed a\n’72 Ford’s distributor onto my desk along with the\nscrewdriver to open it. It felt good!\n\nDo this: write an email telling our editors how\nto reproduce ONE clever, technical trick from your\nresearch. If you are uncertain of your English, we’ll\nhappily translate from French, Russian, Southern\nAppalachian, and German. If you don’t speak those\nlanguages, we’ll draft a translator from those poor\nsods who owe us favors.\n\nLike an email, keep it short. Like an email, you\nshould assume that we already know more than a\nbit about hacking, and that we’ll be insulted or—\nWORSE!—that we’ll be bored if you include a long\ntutorial where a quick reminder would do.\n\nJust use 7-bit ASCII if your language doesn’t\nrequire funny letters, as whenever we receive some-\nthing typeset in OpenOffice, we briefly mistake it\nfor a ransom note. Don’t try to make it thorough\nor broad. Don’t use bullet-points, as this isn’t a\ndamned Powerpoint deck. Keep your code samples\nshort and sweet; we can leave the long-form code as\nan attachment. Do not send us LATEX; it’s our job\nto do the typesetting!\n\nDon’t tell us that it’s possible; rather, teach us\nhow to do it ourselves with the absolute minimum\nof formality and bullshit.\n\nLike an email, we expect informal (or faux-\nbiblical) language and hand-sketched diagrams.\nWrite it in a single sitting, and leave any editing\nfor your poor preacherman to do over a bottle of\nfine scotch. Send this to pastor@phrack org and\nhope that the neighborly Phrack folks—praise be to\nthem!—aren’t man-in-the-middling our submission\nprocess.\n\nYours in PoC and Pwnage,\nPastor Manul Laphroaig, D D\n\n72\n\n\n\t0.0: \n\t0.1: \n\t0.2: \n\t0.3: \n\t0.4: \n\t0.5: \n\t0.6: \n\t0.7: \n\t0.8: \n\t0.9: \n\t0.10: \n\t0.11: \n\t0.12: \n\t0.13: \n\t0.14: \n\t0.15: \n\t0.16: \n\t0.17: \n\t0.18: \n\t0.19: \n\t0.20: \n\t0.21: \n\t0.22: \n\t0.23: \n\t0.24: \n\t0.25: \n\t0.26: \n\t0.27: \n\t0.28: \n\t0.29: \n\t0.30: \n\t0.31: \n\t0.32: \n\t0.33: \n\t0.34: \n\t0.35: \n\t0.36: \n\t0.37: \n\t0.38: \n\t0.39: \n\t0.40: \n\t0.41: \n\t0.42: \n\t0.43: \n\t0.44: \n\t0.45: \n\t0.46: \n\t0.47: \n\t0.48: \n\t0.49: \n\t0.50: \n\t0.51: \n\t0.52: \n\t0.53: \n\t0.54: \n\t0.55: \n\tanm0: \n\t1.0: \n\t1.1: \n\t1.2: \n\t1.3: \n\t1.4: \n\t1.5: \n\t1.6: \n\t1.7: \n\t1.8: \n\t1.9: \n\t1.10: \n\t1.11: \n\t1.12: \n\t1.13: \n\t1.14: \n\t1.15: \n\t1.16: \n\t1.17: \n\t1.18: \n\t1.19: \n\t1.20: \n\t1.21: \n\t1.22: \n\t1.23: \n\t1.24: \n\t1.25: \n\t1.26: \n\t1.27: \n\t1.28: \n\t1.29: \n\t1.30: \n\t1.31: \n\t1.32: \n\t1.33: \n\t1.34: \n\t1.35: \n\t1.36: \n\t1.37: \n\t1.38: \n\t1.39: \n\t1.40: \n\t1.41: \n\t1.42: \n\t1.43: \n\t1.44: \n\t1.45: \n\t1.46: \n\t1.47: \n\t1.48: \n\t1.49: \n\t1.50: \n\t1.51: \n\t1.52: \n\t1.53: \n\t1.54: \n\t1.55: \n\t1.56: \n\t1.57: \n\t1.58: \n\t1.59: \n\t1.60: \n\t1.61: \n\t1.62: \n\t1.63: \n\t1.64: \n\t1.65: \n\t1.66: \n\t1.67: \n\t1.68: \n\t1.69: \n\t1.70: \n\t1.71: \n\t1.72: \n\t1.73: \n\t1.74: \n\t1.75: \n\t1.76: \n\t1.77: \n\t1.78: \n\t1.79: \n\t1.80: \n\t1.81: \n\t1.82: \n\t1.83: \n\t1.84: \n\t1.85: \n\t1.86: \n\t1.87: \n\t1.88: \n\t1.89: \n\t1.90: \n\t1.91: \n\t1.92: \n\t1.93: \n\t1.94: \n\t1.95: \n\t1.96: \n\t1.97: \n\t1.98: \n\t1.99: \n\t1.100: \n\t1.101: \n\t1.102: \n\t1.103: \n\t1.104: \n\t1.105: \n\t1.106: \n\t1.107: \n\t1.108: \n\t1.109: \n\t1.110: \n\t1.111: \n\t1.112: \n\t1.113: \n\t1.114: \n\t1.115: \n\t1.116: \n\t1.117: \n\t1.118: \n\t1.119: \n\t1.120: \n\t1.121: \n\t1.122: \n\t1.123: \n\t1.124: \n\t1.125: \n\t1.126: \n\t1.127: \n\t1.128: \n\t1.129: \n\t1.130: \n\t1.131: \n\t1.132: \n\t1.133: \n\t1.134: \n\t1.135: \n\t1.136: \n\t1.137: \n\t1.138: \n\t1.139: \n\t1.140: \n\t1.141: \n\t1.142: \n\t1.143: \n\t1.144: \n\t1.145: \n\t1.146: \n\t1.147: \n\t1.148: \n\t1.149: \n\t1.150: \n\t1.151: \n\t1.152: \n\t1.153: \n\t1.154: \n\t1.155: \n\t1.156: \n\t1.157: \n\t1.158: \n\t1.159: \n\t1.160: \n\t1.161: \n\t1.162: \n\t1.163: \n\t1.164: \n\t1.165: \n\t1.166: \n\t1.167: \n\t1.168: \n\t1.169: \n\t1.170: \n\t1.171: \n\t1.172: \n\t1.173: \n\t1.174: \n\t1.175: \n\t1.176: \n\t1.177: \n\t1.178: \n\t1.179: \n\t1.180: \n\t1.181: \n\t1.182: \n\t1.183: \n\t1.184: \n\t1.185: \n\t1.186: \n\t1.187: \n\t1.188: \n\t1.189: \n\t1.190: \n\t1.191: \n\t1.192: \n\t1.193: \n\t1.194: \n\t1.195: \n\t1.196: \n\t1.197: \n\t1.198: \n\t1.199: \n\t1.200: \n\t1.201: \n\t1.202: \n\t1.203: \n\t1.204: \n\t1.205: \n\t1.206: \n\t1.207: \n\t1.208: \n\t1.209: \n\t1.210: \n\t1.211: \n\t1.212: \n\t1.213: \n\t1.214: \n\t1.215: \n\t1.216: \n\t1.217: \n\t1.218: \n\t1.219: \n\t1.220: \n\t1.221: \n\t1.222: \n\t1.223: \n\t1.224: \n\t1.225: \n\t1.226: \n\t1.227: \n\t1.228: \n\t1.229: \n\t1.230: \n\t1.231: \n\t1.232: \n\t1.233: \n\t1.234: \n\t1.235: \n\t1.236: \n\t1.237: \n\t1.238: \n\t1.239: \n\t1.240: \n\t1.241: \n\t1.242: \n\t1.243: \n\t1.244: \n\t1.245: \n\t1.246: \n\t1.247: \n\t1.248: \n\t1.249: \n\t1.250: \n\t1.251: \n\t1.252: \n\t1.253: \n\t1.254: \n\t1.255: \n\t1.256: \n\t1.257: \n\t1.258: \n\t1.259: \n\t1.260: \n\t1.261: \n\t1.262: \n\t1.263: \n\t1.264: \n\t1.265: \n\t1.266: \n\t1.267: \n\t1.268: \n\t1.269: \n\t1.270: \n\t1.271: \n\t1.272: \n\t1.273: \n\t1.274: \n\t1.275: \n\t1.276: \n\t1.277: \n\t1.278: \n\t1.279: \n\t1.280: \n\t1.281: \n\t1.282: \n\t1.283: \n\t1.284: \n\t1.285: \n\t1.286: \n\t1.287: \n\t1.288: \n\t1.289: \n\t1.290: \n\t1.291: \n\t1.292: \n\t1.293: \n\t1.294: \n\t1.295: \n\t1.296: \n\t1.297: \n\t1.298: \n\t1.299: \n\t1.300: \n\t1.301: \n\t1.302: \n\t1.303: \n\t1.304: \n\t1.305: \n\t1.306: \n\t1.307: \n\t1.308: \n\t1.309: \n\t1.310: \n\t1.311: \n\t1.312: \n\t1.313: \n\t1.314: \n\t1.315: \n\t1.316: \n\t1.317: \n\t1.318: \n\t1.319: \n\t1.320: \n\t1.321: \n\t1.322: \n\t1.323: \n\t1.324: \n\t1.325: \n\t1.326: \n\t1.327: \n\t1.328: \n\t1.329: \n\t1.330: \n\t1.331: \n\t1.332: \n\t1.333: \n\t1.334: \n\t1.335: \n\t1.336: \n\t1.337: \n\t1.338: \n\t1.339: \n\t1.340: \n\t1.341: \n\t1.342: \n\t1.343: \n\t1.344: \n\t1.345: \n\t1.346: \n\t1.347: \n\t1.348: \n\t1.349: \n\t1.350: \n\t1.351: \n\t1.352: \n\t1.353: \n\t1.354: \n\t1.355: \n\t1.356: \n\t1.357: \n\t1.358: \n\t1.359: \n\t1.360: \n\t1.361: \n\t1.362: \n\t1.363: \n\t1.364: \n\t1.365: \n\t1.366: \n\t1.367: \n\t1.368: \n\t1.369: \n\t1.370: \n\t1.371: \n\t1.372: \n\t1.373: \n\t1.374: \n\t1.375: \n\t1.376: \n\t1.377: \n\t1.378: \n\t1.379: \n\t1.380: \n\t1.381: \n\t1.382: \n\t1.383: \n\t1.384: \n\t1.385: \n\t1.386: \n\tanm1: \n\n\n","extracted_metadata":{"pdf:docinfo:trapped":["False"],"dcterms:modified":["2016-10-18T20:43:26Z"],"pdf:PDFVersion":["1.5"],"dcterms:created":["2016-06-23T02:46:00Z"],"pdf:docinfo:custom:PTEX.Fullbanner":["This is pdfTeX, Version 3.14159265-2.6-1.40.15 (TeX Live 2014) kpathsea version 6.2.0"],"access_permission:can_print_degraded":["true"],"pdf:hasMarkedContent":["false"],"access_permission:extract_content":["true"],"Content-Type":["application/pdf"],"resourceName":["Proof of Concept or GTFO - v13 (October 18th, 2016).pdf"],"access_permission:extract_for_accessibility":["true"],"access_permission:modify_annotations":["true"],"pdf:overallPercentageUnmappedUnicodeChars":["2.1356227807700634E-4"],"PTEX.Fullbanner":["This is pdfTeX, Version 3.14159265-2.6-1.40.15 (TeX Live 2014) kpathsea version 6.2.0"],"dc:subject":["pocorgtfo,poc,gtfo"],"access_permission:fill_in_form":["true"],"pdf:hasXMP":["false"],"access_permission:can_print":["true"],"dc:creator":["Pastor Manul Laphroaig"],"X-TIKA:Parsed-By":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"pdf:annotationSubtypes":["Widget"],"pdf:docinfo:title":["PoC||GTFO 13"],"dc:title":["PoC||GTFO 13"],"pdf:hasAcroFormFields":["true"],"access_permission:assemble_document":["true"],"access_permission:can_modify":["true"],"xmp:CreatorTool":["ace02468bdf13579"],"pdf:hasXFA":["false"],"pdf:unmappedUnicodeCharsPerPage":["0","2","0","1","0","0","0","0","0","8","0","11","0","0","0","0","0","0","0","0","2","4","0","0","0","0","0","0","0","1","0","0","0","0","0","0","0","1","0","0","0","1","0","0","0","0","7","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","2","0"],"dc:format":["application/pdf; version=1.5"],"pdf:num3DAnnotations":["0"],"pdf:docinfo:creator_tool":["ace02468bdf13579"],"Content-Length":["62061798"],"pdf:producer":["pdfTeX-1.40.15"],"pdf:docinfo:creator":["Pastor Manul Laphroaig"],"pdf:totalUnmappedUnicodeChars":["40"],"xmpTPg:NPages":["72"],"pdf:containsNonEmbeddedFont":["false"],"pdf:docinfo:modified":["2016-10-18T20:43:26Z"],"pdf:charsPerPage":["894","1751","2239","2749","1246","5465","1630","2550","2390","2652","2815","2432","2347","3409","2526","2568","2258","899","3024","1419","16265","8301","2","2639","2908","1692","3068","686","2771","2438","1230","4119","2","3459","3159","3391","1588","2632","2584","2","2164","2728","2318","1797","2624","2922","2095","3045","1827","1737","2047","3251","110","3183","3650","4119","2578","2570","1493","2959","2","2582","2917","3787","3393","1520","1118","3757","2622","621","2879","2685"],"pdf:docinfo:producer":["pdfTeX-1.40.15"],"pdf:containsDamagedFont":["false"],"pdf:docinfo:created":["2016-06-23T02:46:00Z"],"pdf:hasCollection":["false"],"pdf:docinfo:keywords":["pocorgtfo,poc,gtfo"],"pdf:annotationTypes":["null"],"X-TIKA:Parsed-By-Full-Set":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser","org.apache.tika.parser.ocr.TesseractOCRParser"],"pdf:encrypted":["false"]},"metadata_field_count":48,"attempts":1,"timestamp":1754064901.062621,"platform":"Linux","python_version":"3.13.5"},{"file_path":"test_documents/pdfs/Intel 64 and IA-32 Architectures Software Developer's Manual - Combined Volumes 1-4 - June 2021 (325462-sdm-vol-1-2abcd-3abcd).pdf","file_size":52916900,"file_type":"pdf","category":"huge","framework":"extractous","iteration":1,"extraction_time":7.198139429092407,"startup_time":null,"peak_memory_mb":719.33203125,"avg_memory_mb":682.39375,"peak_cpu_percent":99.9,"avg_cpu_percent":19.98,"total_io_mb":null,"status":"success","character_count":500000,"word_count":125052,"error_type":null,"error_message":null,"quality_metrics":{"char_count":500000,"word_count":125052,"sentence_count":6292,"paragraph_count":2207,"avg_word_length":2.9588731087867446,"avg_sentence_length":8.662746344564527,"extraction_completeness":1.0,"text_coherence":0.04993781568060103,"noise_ratio":0.37750000000000006,"gibberish_ratio":0.038461538461538464,"flesch_reading_ease":42.27549675631161,"gunning_fog_index":14.564634416928994,"has_proper_formatting":true,"maintains_line_breaks":true,"preserves_whitespace":true,"table_structure_preserved":true,"format_specific_score":0.8,"expected_content_preserved":false,"has_encoding_issues":false,"has_ocr_artifacts":true,"preserves_pdf_formatting":true},"overall_quality_score":0.45001632486553983,"extracted_text":"\nIntel® 64 and IA-32 Architectures\nSoftware Developer’s Manual\n\nCombined Volumes:\n1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D and 4\n\nNOTE: This document contains all four volumes of the Intel 64 and IA-32 Architectures Software\nDeveloper's Manual: Basic Architecture, Order Number 253665; Instruction Set Reference A-Z, Order\nNumber 325383; System Programming Guide, Order Number 325384; Model-Specific Registers, Order\nNumber 335592. Refer to all four volumes when evaluating your design needs.\n\nOrder Number:  325462-075US\nJune 2021\n\n\n\nIntel technologies features and benefits depend on system configuration and may require enabled hardware, software, or service activation. Learn\nmore at intel.com, or from the OEM or retailer.\n\nNo computer system can be absolutely secure. Intel does not assume any liability for lost or stolen data or systems or any damages resulting\nfrom such losses.\n\nYou may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products\ndescribed herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject\nmatter disclosed herein.\n\nNo license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document.\n\nThe products described may contain design defects or errors known as errata which may cause the product to deviate from published specifica-\ntions. Current characterized errata are available on request.\n\nThis document contains information on products, services and/or processes in development. All information provided here is subject to change\nwithout notice. Contact your Intel representative to obtain the latest Intel product specifications and roadmaps \n\nCopies of documents which have an order number and are referenced in this document, or other Intel literature, may be obtained by calling 1-\n800-548-4725, or by visiting http://www.intel.com/design/literature.htm.\n\nIntel, the Intel logo, Intel Atom, Intel Core, Intel SpeedStep, MMX, Pentium, VTune, and Xeon are trademarks of Intel Corporation in the U.S.\nand/or other countries.\n\n*Other names and brands may be claimed as the property of others.\n\nCopyright © 1997-2021, Intel Corporation. All Rights Reserved.\n\nhttp://www.intel.com/design/literature.htm\nhttp://www.intel.com/design/literature.htm\n\n\nIntel® 64 and IA-32 Architectures\nSoftware Developer’s Manual\n\nVolume 1:\nBasic Architecture\n\nNOTE: The Intel 64 and IA-32 Architectures Software Developer's Manual consists of four volumes:\nBasic Architecture, Order Number 253665; Instruction Set Reference A-Z, Order Number 325383;\nSystem Programming Guide, Order Number 325384; Model-Specific Registers, Order Number\n335592. Refer to all four volumes when evaluating your design needs.\n\nOrder Number:  253665-075US\nJune 2021\n\n\n\nIntel technologies features and benefits depend on system configuration and may require enabled hardware, software, or service activation. Learn\nmore at intel.com, or from the OEM or retailer.\n\nNo computer system can be absolutely secure. Intel does not assume any liability for lost or stolen data or systems or any damages resulting\nfrom such losses.\n\nYou may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products\ndescribed herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject\nmatter disclosed herein.\n\nNo license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document.\n\nThe products described may contain design defects or errors known as errata which may cause the product to deviate from published specifica-\ntions. Current characterized errata are available on request.\n\nThis document contains information on products, services and/or processes in development. All information provided here is subject to change\nwithout notice. Contact your Intel representative to obtain the latest Intel product specifications and roadmaps \n\nCopies of documents which have an order number and are referenced in this document, or other Intel literature, may be obtained by calling 1-\n800-548-4725, or by visiting http://www.intel.com/design/literature.htm.\n\nIntel, the Intel logo, Intel Atom, Intel Core, Intel SpeedStep, MMX, Pentium, VTune, and Xeon are trademarks of Intel Corporation in the U.S.\nand/or other countries.\n\n*Other names and brands may be claimed as the property of others.\n\nCopyright © 1997-2021, Intel Corporation. All Rights Reserved.\n\nhttp://www.intel.com/design/literature.htm\nhttp://www.intel.com/design/literature.htm\n\n\nCONTENTS\nPAGE\nCHAPTER 1\nABOUT THIS MANUAL\n1.1 INTEL® 64 AND IA-32 PROCESSORS COVERED IN THIS MANUAL  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1-1\n1.2 OVERVIEW OF VOLUME 1: BASIC ARCHITECTURE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1-4\n1.3 NOTATIONAL CONVENTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1-5\n1.3.1 Bit and Byte Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-5\n1.3.2 Reserved Bits and Software Compatibility  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-6\n1.3.2.1 Instruction Operands. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-6\n1.3.3 Hexadecimal and Binary Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-7\n1.3.4 Segmented Addressing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-7\n1.3.5 A New Syntax for CPUID, CR, and MSR Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-7\n1.3.6 Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-8\n1.4 RELATED LITERATURE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1-9\n\nCHAPTER 2\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.1 BRIEF HISTORY OF INTEL® 64 AND IA-32 ARCHITECTURE  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2-1\n2.1.1 16-bit Processors and Segmentation (1978) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-1\n2.1.2 The Intel® 286 Processor (1982) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-1\n2.1.3 The Intel386™ Processor (1985) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-1\n2.1.4 The Intel486™ Processor (1989) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-1\n2.1.5 The Intel® Pentium® Processor (1993). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-2\n2.1.6 The P6 Family of Processors (1995-1999) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-2\n2.1.7 The Intel® Pentium® 4 Processor Family (2000-2006). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-3\n2.1.8 The Intel® Xeon® Processor (2001- 2007) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-3\n2.1.9 The Intel® Pentium® M Processor (2003-2006) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-3\n2.1.10 The Intel® Pentium® Processor Extreme Edition (2005)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-4\n2.1.11 The Intel® Core™ Duo and Intel® Core™ Solo Processors (2006-2007)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-4\n2.1.12 The Intel® Xeon® Processor 5100, 5300 Series and Intel® Core™2 Processor Family (2006) . . . . . . . . . . . . . . . . . . . . . . . .2-4\n2.1.13 The Intel® Xeon® Processor 5200, 5400, 7400 Series and Intel® Core™2 Processor Family (2007) . . . . . . . . . . . . . . . . . .2-4\n2.1.14 The Intel® Atom™ Processor Family (2008) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\n2.1.15 The Intel® Atom™ Processor Family Based on Silvermont Microarchitecture (2013) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\n2.1.16 The Intel® Core™i7 Processor Family (2008) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\n2.1.17 The Intel® Xeon® Processor 7500 Series (2010) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\n2.1.18 2010 Intel® Core™ Processor Family (2010) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\n2.1.19 The Intel® Xeon® Processor 5600 Series (2010) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\n2.1.20 The Second Generation Intel® Core™ Processor Family (2011) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\n2.1.21 The Third Generation Intel® Core™ Processor Family (2012) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\n2.1.22 The Fourth Generation Intel® Core™ Processor Family (2013)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-7\n2.2 MORE ON SPECIFIC ADVANCES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2-7\n2.2.1 P6 Family Microarchitecture. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-7\n2.2.2 Intel NetBurst® Microarchitecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-8\n2.2.2.1 The Front End Pipeline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-9\n2.2.2.2 Out-Of-Order Execution Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\n2.2.2.3 Retirement Unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\n2.2.3 Intel® Core™ Microarchitecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\n2.2.3.1 The Front End . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\n2.2.3.2 Execution Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12\n2.2.4 Intel® Atom™ Microarchitecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12\n2.2.5 Intel® Microarchitecture Code Name Nehalem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-13\n2.2.6 Intel® Microarchitecture Code Name Sandy Bridge. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-13\n2.2.7 SIMD Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-14\n2.2.8 Intel® Hyper-Threading Technology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-16\nVol. 1 iii\n\n\n\nCONTENTS\n\nPAGE\n2.2.8.1 Some Implementation Notes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-17\n2.2.9 Multi-Core Technology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-18\n2.2.10 Intel® 64 Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-20\n2.2.11 Intel® Virtualization Technology (Intel® VT) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-20\n2.3 INTEL® 64 AND IA-32 PROCESSOR GENERATIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2-20\n2.4 PROPOSED REMOVAL OF INTEL INSTRUCTION SET ARCHITECTURE AND FEATURES FROM UPCOMING PRODUCTS . . . . .  2-28\n2.5 INTEL INSTRUCTION SET ARCHITECTURE AND FEATURES REMOVED . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2-28\n\nCHAPTER 3\nBASIC EXECUTION ENVIRONMENT\n3.1 MODES OF OPERATION. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-1\n3.1.1 Intel® 64 Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-1\n3.2 OVERVIEW OF THE BASIC EXECUTION ENVIRONMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-2\n3.2.1 64-Bit Mode Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-5\n3.3 MEMORY ORGANIZATION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-6\n3.3.1 IA-32 Memory Models. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-7\n3.3.2 Paging and Virtual Memory. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-8\n3.3.3 Memory Organization in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-8\n3.3.4 Modes of Operation vs. Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-9\n3.3.5 32-Bit and 16-Bit Address and Operand Sizes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-9\n3.3.6 Extended Physical Addressing in Protected Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-9\n3.3.7 Address Calculations in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-10\n3.3.7.1 Canonical Addressing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-10\n3.4 BASIC PROGRAM EXECUTION REGISTERS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-10\n3.4.1 General-Purpose Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-11\n3.4.1.1 General-Purpose Registers in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-12\n3.4.2 Segment Registers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-13\n3.4.2.1 Segment Registers in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-15\n3.4.3 EFLAGS Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-15\n3.4.3.1 Status Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-16\n3.4.3.2 DF Flag. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-17\n3.4.3.3 System Flags and IOPL Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-17\n3.4.3.4 RFLAGS Register in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-18\n3.5 INSTRUCTION POINTER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-18\n3.5.1 Instruction Pointer in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-18\n3.6 OPERAND-SIZE AND ADDRESS-SIZE ATTRIBUTES  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-18\n3.6.1 Operand Size and Address Size in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19\n3.7 OPERAND ADDRESSING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-19\n3.7.1 Immediate Operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-20\n3.7.2 Register Operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-20\n3.7.2.1 Register Operands in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\n3.7.3 Memory Operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\n3.7.3.1 Memory Operands in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\n3.7.4 Specifying a Segment Selector  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\n3.7.4.1 Segmentation in 64-Bit Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-22\n3.7.5 Specifying an Offset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-22\n3.7.5.1 Specifying an Offset in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-24\n3.7.6 Assembler and Compiler Addressing Modes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-24\n3.7.7 I/O Port Addressing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-24\n\nCHAPTER 4\nDATA TYPES\n4.1 FUNDAMENTAL DATA TYPES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-1\n4.1.1 Alignment of Words, Doublewords, Quadwords, and Double Quadwords  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-2\n4.2 NUMERIC DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-2\n4.2.1 Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-3\n4.2.1.1 Unsigned Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-3\n4.2.1.2 Signed Integers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-4\n4.2.2 Floating-Point Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-4\niv Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n4.3 POINTER DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-6\n4.3.1 Pointer Data Types in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\n4.4 BIT FIELD DATA TYPE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-7\n4.5 STRING DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-8\n4.6 PACKED SIMD DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-8\n4.6.1 64-Bit SIMD Packed Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\n4.6.2 128-Bit Packed SIMD Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\n4.7 BCD AND PACKED BCD INTEGERS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-9\n4.8 REAL NUMBERS AND FLOATING-POINT FORMATS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-11\n4.8.1 Real Number System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-11\n4.8.2 Floating-Point Format  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-11\n4.8.2.1 Normalized Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\n4.8.2.2 Biased Exponent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\n4.8.3 Real Number and Non-number Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\n4.8.3.1 Signed Zeros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14\n4.8.3.2 Normalized and Denormalized Finite Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14\n4.8.3.3 Signed Infinities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\n4.8.3.4 NaNs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\n4.8.3.5 Operating on SNaNs and QNaNs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\n4.8.3.6 Using SNaNs and QNaNs in Applications  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\n4.8.3.7 QNaN Floating-Point Indefinite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-17\n4.8.3.8 Half-Precision Floating-Point Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-17\n4.8.4 Rounding  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-17\n4.8.4.1 Rounding Control (RC) Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\n4.8.4.2 Truncation with SSE and SSE2 Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\n4.9 OVERVIEW OF FLOATING-POINT EXCEPTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-18\n4.9.1 Floating-Point Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\n4.9.1.1 Invalid Operation Exception (#I) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\n4.9.1.2 Denormal Operand Exception (#D). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\n4.9.1.3 Divide-By-Zero Exception (#Z) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\n4.9.1.4 Numeric Overflow Exception (#O) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\n4.9.1.5 Numeric Underflow Exception (#U) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\n4.9.1.6 Inexact-Result (Precision) Exception (#P) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-22\n4.9.2 Floating-Point Exception Priority . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-23\n4.9.3 Typical Actions of a Floating-Point Exception Handler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-23\n\nCHAPTER 5\nINSTRUCTION SET SUMMARY\n5.1 GENERAL-PURPOSE INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-4\n5.1.1 Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-4\n5.1.2 Binary Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-5\n5.1.3 Decimal Arithmetic Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\n5.1.4 Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\n5.1.5 Shift and Rotate Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\n5.1.6 Bit and Byte Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\n5.1.7 Control Transfer Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-7\n5.1.8 String Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-8\n5.1.9 I/O Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-8\n5.1.10 Enter and Leave Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9\n5.1.11 Flag Control (EFLAG) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9\n5.1.12 Segment Register Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9\n5.1.13 Miscellaneous Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9\n5.1.14 User Mode Extended Sate Save/Restore Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10\n5.1.15 Random Number Generator Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10\n5.1.16 BMI1, BMI2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10\n5.1.16.1 Detection of VEX-encoded GPR Instructions, LZCNT and TZCNT, PREFETCHW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10\n5.2 X87 FPU INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-11\n5.2.1 x87 FPU Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-11\n5.2.2 x87 FPU Basic Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-11\nVol. 1 v\n\n\n\nCONTENTS\n\nPAGE\n5.2.3 x87 FPU Comparison Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-12\n5.2.4 x87 FPU Transcendental Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-12\n5.2.5 x87 FPU Load Constants Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-12\n5.2.6 x87 FPU Control Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-13\n5.3 X87 FPU AND SIMD STATE MANAGEMENT INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-13\n5.4 MMX™ INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-13\n5.4.1 MMX Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-14\n5.4.2 MMX Conversion Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-14\n5.4.3 MMX Packed Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-14\n5.4.4 MMX Comparison Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\n5.4.5 MMX Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\n5.4.6 MMX Shift and Rotate Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\n5.4.7 MMX State Management Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\n5.5 SSE INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-15\n5.5.1 SSE SIMD Single-Precision Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-16\n5.5.1.1 SSE Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-16\n5.5.1.2 SSE Packed Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-16\n5.5.1.3 SSE Comparison Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\n5.5.1.4 SSE Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\n5.5.1.5 SSE Shuffle and Unpack Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\n5.5.1.6 SSE Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\n5.5.2 SSE MXCSR State Management Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-18\n5.5.3 SSE 64-Bit SIMD Integer Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-18\n5.5.4 SSE Cacheability Control, Prefetch, and Instruction Ordering Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-18\n5.6 SSE2 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-18\n5.6.1 SSE2 Packed and Scalar Double-Precision Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-19\n5.6.1.1 SSE2 Data Movement Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-19\n5.6.1.2 SSE2 Packed Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-19\n5.6.1.3 SSE2 Logical Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\n5.6.1.4 SSE2 Compare Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\n5.6.1.5 SSE2 Shuffle and Unpack Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\n5.6.1.6 SSE2 Conversion Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\n5.6.2 SSE2 Packed Single-Precision Floating-Point Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-21\n5.6.3 SSE2 128-Bit SIMD Integer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-21\n5.6.4 SSE2 Cacheability Control and Ordering Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-21\n5.7 SSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-22\n5.7.1 SSE3 x87-FP Integer Conversion Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\n5.7.2 SSE3 Specialized 128-bit Unaligned Data Load Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\n5.7.3 SSE3 SIMD Floating-Point Packed ADD/SUB Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\n5.7.4 SSE3 SIMD Floating-Point Horizontal ADD/SUB Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\n5.7.5 SSE3 SIMD Floating-Point LOAD/MOVE/DUPLICATE Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-23\n5.7.6 SSE3 Agent Synchronization Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-23\n5.8 SUPPLEMENTAL STREAMING SIMD EXTENSIONS 3 (SSSE3) INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-23\n5.8.1 Horizontal Addition/Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-23\n5.8.2 Packed Absolute Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.3 Multiply and Add Packed Signed and Unsigned Bytes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.4 Packed Multiply High with Round and Scale  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.5 Packed Shuffle Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.6 Packed Sign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.7 Packed Align Right . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.9 SSE4 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-25\n5.10 SSE4.1 INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-25\n5.10.1 Dword Multiply Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-25\n5.10.2 Floating-Point Dot Product Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-25\n5.10.3 Streaming Load Hint Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-25\n5.10.4 Packed Blending Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-26\n5.10.5 Packed Integer MIN/MAX Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-26\n5.10.6 Floating-Point Round Instructions with Selectable Rounding Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-26\n5.10.7 Insertion and Extractions from XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-26\nvi Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n5.10.8 Packed Integer Format Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-27\n5.10.9 Improved Sums of Absolute Differences (SAD) for 4-Byte Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-27\n5.10.10 Horizontal Search  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-27\n5.10.11 Packed Test. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.10.12 Packed Qword Equality Comparisons  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.10.13 Dword Packing With Unsigned Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.11 SSE4.2 INSTRUCTION SET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-28\n5.11.1 String and Text Processing Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.11.2 Packed Comparison SIMD integer Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.12 INTEL® AES-NI AND PCLMULQDQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-28\n5.13 INTEL® ADVANCED VECTOR EXTENSIONS (INTEL® AVX). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-29\n5.14 16-BIT FLOATING-POINT CONVERSION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-29\n5.15 FUSED-MULTIPLY-ADD (FMA)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-29\n5.16 INTEL® ADVANCED VECTOR EXTENSIONS 2 (INTEL® AVX2)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-29\n5.17 INTEL® TRANSACTIONAL SYNCHRONIZATION EXTENSIONS (INTEL® TSX) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-30\n5.18 INTEL® SHA EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-30\n5.19 INTEL® ADVANCED VECTOR EXTENSIONS 512 (INTEL® AVX-512)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-30\n5.20 SYSTEM INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-34\n5.21 64-BIT MODE INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-35\n5.22 VIRTUAL-MACHINE EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-35\n5.23 SAFER MODE EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-36\n5.24 INTEL® MEMORY PROTECTION EXTENSIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-36\n5.25 INTEL® SOFTWARE GUARD EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-37\n5.26 SHADOW STACK MANAGEMENT INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-37\n5.27 CONTROL TRANSFER TERMINATING INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-37\n\nCHAPTER 6\nPROCEDURE CALLS, INTERRUPTS, AND EXCEPTIONS\n6.1 PROCEDURE CALL TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-1\n6.2 STACKS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-1\n6.2.1 Setting Up a Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-2\n6.2.2 Stack Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-2\n6.2.3 Address-Size Attributes for Stack Accesses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3\n6.2.4 Procedure Linking Information  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3\n6.2.4.1 Stack-Frame Base Pointer  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3\n6.2.4.2 Return Instruction Pointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3\n6.2.5 Stack Behavior in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-4\n6.3 SHADOW STACKS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-4\n6.4 CALLING PROCEDURES USING CALL AND RET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-4\n6.4.1 Near CALL and RET Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-4\n6.4.2 Far CALL and RET Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-5\n6.4.3 Parameter Passing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.3.1 Passing Parameters Through the General-Purpose Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.3.2 Passing Parameters on the Stack. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.3.3 Passing Parameters in an Argument List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.4 Saving Procedure State Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.5 Calls to Other Privilege Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.6 CALL and RET Operation Between Privilege Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-8\n6.4.7 Branch Functions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-12\n6.5 INTERRUPTS AND EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-12\n6.5.1 Call and Return Operation for Interrupt or Exception Handling Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-13\n6.5.2 Calls to Interrupt or Exception Handler Tasks  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-18\n6.5.3 Interrupt and Exception Handling in Real-Address Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-18\n6.5.4 INT n, INTO, INT3, INT1, and BOUND Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-18\n6.5.5 Handling Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-19\n6.5.6 Interrupt and Exception Behavior in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-19\n6.6 PROCEDURE CALLS FOR BLOCK-STRUCTURED LANGUAGES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-20\n6.6.1 ENTER Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-20\n6.6.2 LEAVE Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-24\nVol. 1 vii\n\n\n\nCONTENTS\n\nPAGE\nCHAPTER 7\nPROGRAMMING WITH GENERAL-PURPOSE INSTRUCTIONS\n7.1 PROGRAMMING ENVIRONMENT FOR GP INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  7-1\n7.2 PROGRAMMING ENVIRONMENT FOR GP INSTRUCTIONS IN 64-BIT MODE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  7-1\n7.3 SUMMARY OF GP INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  7-2\n7.3.1 Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-2\n7.3.1.1 General Data Movement Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-3\n7.3.1.2 Exchange Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-4\n7.3.1.3 Exchange Instructions in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-5\n7.3.1.4 Stack Manipulation Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-5\n7.3.1.5 Stack Manipulation Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-7\n7.3.1.6 Type Conversion Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-7\n7.3.1.7 Type Conversion Instructions in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2 Binary Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.1 Addition and Subtraction Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.2 Increment and Decrement Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.3 Increment and Decrement Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.4 Comparison and Sign Change Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.5 Multiplication and Division Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-9\n7.3.3 Decimal Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-9\n7.3.3.1 Packed BCD Adjustment Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-9\n7.3.3.2 Unpacked BCD Adjustment Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-9\n7.3.4 Decimal Arithmetic Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-10\n7.3.5 Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-10\n7.3.6 Shift and Rotate Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-10\n7.3.6.1 Shift Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-10\n7.3.6.2 Double-Shift Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-12\n7.3.6.3 Rotate Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-13\n7.3.7 Bit and Byte Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-13\n7.3.7.1 Bit Test and Modify Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.7.2 Bit Scan Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.7.3 Byte Set on Condition Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.7.4 Test Instruction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.8 Control Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.8.1 Unconditional Transfer Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.8.2 Conditional Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-15\n7.3.8.3 Control Transfer Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-17\n7.3.8.4 Software Interrupt Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-17\n7.3.8.5 Software Interrupt Instructions in 64-bit Mode and Compatibility Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-18\n7.3.9 String Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-18\n7.3.9.1 String Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-18\n7.3.9.2 Repeated String Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-19\n7.3.9.3 Fast-String Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-19\n7.3.9.4 String Operations in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-20\n7.3.10 I/O Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-20\n7.3.11 I/O Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-20\n7.3.12 Enter and Leave Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\n7.3.13 Flag Control (EFLAG) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\n7.3.13.1 Carry and Direction Flag Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\n7.3.13.2 EFLAGS Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\n7.3.13.3 Interrupt Flag Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.14 Flag Control (RFLAG) Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.15 Segment Register Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.15.1 Segment-Register Load and Store Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.15.2 Far Control Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.15.3 Software Interrupt Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.15.4 Load Far Pointer Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.16 Miscellaneous Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.16.1 Address Computation Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\nviii Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n7.3.16.2 Table Lookup Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.16.3 Processor Identification Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.16.4 No-Operation and Undefined Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.17 Random Number Generator Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-24\n7.3.17.1 RDRAND . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-24\n7.3.17.2 RDSEED. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-24\n\nCHAPTER 8\nPROGRAMMING WITH THE X87 FPU \n8.1 X87 FPU EXECUTION ENVIRONMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-1\n8.1.1 x87 FPU in 64-Bit Mode and Compatibility Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-1\n8.1.2 x87 FPU Data Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-1\n8.1.2.1 Parameter Passing With the x87 FPU Register Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-3\n8.1.3 x87 FPU Status Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-4\n8.1.3.1 Top of Stack (TOP) Pointer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-4\n8.1.3.2 Condition Code Flags  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-4\n8.1.3.3 x87 FPU Floating-Point Exception Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-5\n8.1.3.4 Stack Fault Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-6\n8.1.4 Branching and Conditional Moves on Condition Codes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-6\n8.1.5 x87 FPU Control Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-7\n8.1.5.1 x87 FPU Floating-Point Exception Mask Bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-7\n8.1.5.2 Precision Control Field . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-7\n8.1.5.3 Rounding Control Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\n8.1.6 Infinity Control Flag. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\n8.1.7 x87 FPU Tag Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\n8.1.8 x87 FPU Instruction and Data (Operand) Pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-9\n8.1.9 Last Instruction Opcode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-10\n8.1.9.1 Fopcode Compatibility Sub-mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-10\n8.1.10 Saving the x87 FPU’s State with FSTENV/FNSTENV and FSAVE/FNSAVE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-11\n8.1.11 Saving the x87 FPU’s State with FXSAVE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12\n8.2 X87 FPU DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-13\n8.2.1 Indefinites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-14\n8.2.2 Unsupported Double Extended-Precision Floating-Point Encodings and Pseudo-Denormals . . . . . . . . . . . . . . . . . . . . . . . . 8-14\n8.3 X87 FPU INSTRUCTION SET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-15\n8.3.1 Escape (ESC) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-15\n8.3.2 x87 FPU Instruction Operands  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-15\n8.3.3 Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-16\n8.3.4 Load Constant Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-17\n8.3.5 Basic Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-17\n8.3.6 Comparison and Classification Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-18\n8.3.6.1 Branching on the x87 FPU Condition Codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-20\n8.3.7 Trigonometric Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-20\n8.3.8 Approximation of Pi  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-21\n8.3.9 Logarithmic, Exponential, and Scale. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-21\n8.3.10 Transcendental Instruction Accuracy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-22\n8.3.11 x87 FPU Control Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-23\n8.3.12 Waiting vs. Non-waiting Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-24\n8.3.13 Unsupported x87 FPU Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-24\n8.4 X87 FPU FLOATING-POINT EXCEPTION HANDLING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-24\n8.4.1 Arithmetic vs. Non-arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-25\n8.5 X87 FPU FLOATING-POINT EXCEPTION CONDITIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-26\n8.5.1 Invalid Operation Exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-26\n8.5.1.1 Stack Overflow or Underflow Exception (#IS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-26\n8.5.1.2 Invalid Arithmetic Operand Exception (#IA)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-27\n8.5.2 Denormal Operand Exception (#D). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-28\n8.5.3 Divide-By-Zero Exception (#Z) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-28\n8.5.4 Numeric Overflow Exception (#O) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-28\n8.5.5 Numeric Underflow Exception (#U) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-29\n8.5.6 Inexact-Result (Precision) Exception (#P) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-30\nVol. 1 ix\n\n\n\nCONTENTS\n\nPAGE\n8.6 X87 FPU EXCEPTION SYNCHRONIZATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-31\n8.7 HANDLING X87 FPU EXCEPTIONS IN SOFTWARE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-32\n8.7.1 Native Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-32\n8.7.2 MS-DOS* Compatibility Sub-mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-32\n8.7.3 Handling x87 FPU Exceptions in Software  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-33\n\nCHAPTER 9 \nPROGRAMMING WITH INTEL® MMX™ TECHNOLOGY\n9.1 OVERVIEW OF MMX TECHNOLOGY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-1\n9.2 THE MMX TECHNOLOGY PROGRAMMING ENVIRONMENT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-1\n9.2.1 MMX Technology in 64-Bit Mode and Compatibility Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-2\n9.2.2 MMX Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-2\n9.2.3 MMX Data Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-3\n9.2.4 Memory Data Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-3\n9.2.5 Single Instruction, Multiple Data (SIMD) Execution Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-4\n9.3 SATURATION AND WRAPAROUND MODES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-4\n9.4 MMX INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-5\n9.4.1 Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-6\n9.4.2 Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-6\n9.4.3 Comparison Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-7\n9.4.4 Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-7\n9.4.5 Unpack Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-7\n9.4.6 Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-7\n9.4.7 Shift Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-8\n9.4.8 EMMS Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-8\n9.5 COMPATIBILITY WITH X87 FPU ARCHITECTURE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-8\n9.5.1 MMX Instructions and the x87 FPU Tag Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-8\n9.6 WRITING APPLICATIONS WITH MMX CODE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-8\n9.6.1 Checking for MMX Technology Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-8\n9.6.2 Transitions Between x87 FPU and MMX Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-9\n9.6.3 Using the EMMS Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-9\n9.6.4 Mixing MMX and x87 FPU Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-10\n9.6.5 Interfacing with MMX Code. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-10\n9.6.6 Using MMX Code in a Multitasking Operating System Environment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-10\n9.6.7 Exception Handling in MMX Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-11\n9.6.8 Register Mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-11\n9.6.9 Effect of Instruction Prefixes on MMX Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-11\n\nCHAPTER 10\nPROGRAMMING WITH INTEL® STREAMING SIMD EXTENSIONS (INTEL® SSE)\n10.1 OVERVIEW OF SSE EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10-1\n10.2 SSE PROGRAMMING ENVIRONMENT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10-2\n10.2.1 SSE in 64-Bit Mode and Compatibility Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-3\n10.2.2 XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-3\n10.2.3 MXCSR Control and Status Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-3\n10.2.3.1 SIMD Floating-Point Mask and Flag Bits  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-4\n10.2.3.2 SIMD Floating-Point Rounding Control Field  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-4\n10.2.3.3 Flush-To-Zero . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-4\n10.2.3.4 Denormals-Are-Zeros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-5\n10.2.4 Compatibility of SSE Extensions with SSE2/SSE3/MMX and the x87 FPU. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-5\n10.3 SSE DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10-5\n10.4 SSE INSTRUCTION SET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10-6\n10.4.1 SSE Packed and Scalar Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-6\n10.4.1.1 SSE Data Movement Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-7\n10.4.1.2 SSE Arithmetic Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-8\n10.4.2 SSE Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-9\n10.4.2.1 SSE Comparison Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-9\n10.4.2.2 SSE Shuffle and Unpack Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-9\n10.4.3 SSE Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-11\nx Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n10.4.4 SSE 64-Bit SIMD Integer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-11\n10.4.5 MXCSR State Management Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-12\n10.4.6 Cacheability Control, Prefetch, and Memory Ordering Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-12\n10.4.6.1 Cacheability Control Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-12\n10.4.6.2 Caching of Temporal vs. Non-Temporal Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-12\n10.4.6.3 PREFETCHh Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-13\n10.4.6.4 SFENCE Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-14\n10.5 FXSAVE AND FXRSTOR INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-14\n10.5.1 FXSAVE Area  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-14\n10.5.1.1 x87 State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-15\n10.5.1.2 SSE State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-16\n10.5.2 Operation of FXSAVE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-16\n10.5.3 Operation of FXRSTOR  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-17\n10.6 HANDLING SSE INSTRUCTION EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-17\n10.7 WRITING APPLICATIONS WITH THE SSE EXTENSIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-17\n\nCHAPTER 11\nPROGRAMMING WITH INTEL® STREAMING SIMD EXTENSIONS 2 (INTEL® SSE2)\n11.1 OVERVIEW OF SSE2 EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11-1\n11.2 SSE2 PROGRAMMING ENVIRONMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11-2\n11.2.1 SSE2 in 64-Bit Mode and Compatibility Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-3\n11.2.2 Compatibility of SSE2 Extensions with SSE, MMX Technology and x87 FPU Programming Environment  . . . . . . . . . . . . 11-3\n11.2.3 Denormals-Are-Zeros Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-3\n11.3 SSE2 DATA TYPES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11-3\n11.4 SSE2 INSTRUCTIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11-4\n11.4.1 Packed and Scalar Double-Precision Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-4\n11.4.1.1 Data Movement Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-5\n11.4.1.2 SSE2 Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-6\n11.4.1.3 SSE2 Logical Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-7\n11.4.1.4 SSE2 Comparison Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-7\n11.4.1.5 SSE2 Shuffle and Unpack Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-7\n11.4.1.6 SSE2 Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-9\n11.4.2 SSE2 64-Bit and 128-Bit SIMD Integer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-10\n11.4.3 128-Bit SIMD Integer Instruction Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-11\n11.4.4 Cacheability Control and Memory Ordering Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.4.1 FLUSH Cache Line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.4.2 Cacheability Control Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.4.3 Memory Ordering Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.4.4 Pause. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.5 Branch Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-13\n11.5 SSE, SSE2, AND SSE3 EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-13\n11.5.1 SIMD Floating-Point Exceptions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-13\n11.5.2 SIMD Floating-Point Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-14\n11.5.2.1 Invalid Operation Exception (#I) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-14\n11.5.2.2 Denormal-Operand Exception (#D)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-15\n11.5.2.3 Divide-By-Zero Exception (#Z) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-15\n11.5.2.4 Numeric Overflow Exception (#O) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-15\n11.5.2.5 Numeric Underflow Exception (#U) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-16\n11.5.2.6 Inexact-Result (Precision) Exception (#P) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-16\n11.5.3 Generating SIMD Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-16\n11.5.3.1 Handling Masked Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-16\n11.5.3.2 Handling Unmasked Exceptions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-17\n11.5.3.3 Handling Combinations of Masked and Unmasked Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-18\n11.5.4 Handling SIMD Floating-Point Exceptions in Software. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-18\n11.5.5 Interaction of SIMD and x87 FPU Floating-Point Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-18\n11.6 WRITING APPLICATIONS WITH SSE/SSE2 EXTENSIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-19\n11.6.1 General Guidelines for Using SSE/SSE2 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-19\n11.6.2 Checking for SSE/SSE2 Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-19\n11.6.3 Checking for the DAZ Flag in the MXCSR Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-20\nVol. 1 xi\n\n\n\nCONTENTS\n\nPAGE\n11.6.4 Initialization of SSE/SSE2 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-20\n11.6.5 Saving and Restoring the SSE/SSE2 State. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-20\n11.6.6 Guidelines for Writing to the MXCSR Register  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-21\n11.6.7 Interaction of SSE/SSE2 Instructions with x87 FPU and MMX Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-21\n11.6.8 Compatibility of SIMD and x87 FPU Floating-Point Data Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-22\n11.6.9 Mixing Packed and Scalar Floating-Point and 128-Bit SIMD Integer Instructions and Data . . . . . . . . . . . . . . . . . . . . . . . . . 11-22\n11.6.10 Interfacing with SSE/SSE2 Procedures and Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-23\n11.6.10.1 Passing Parameters in XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-23\n11.6.10.2 Saving XMM Register State on a Procedure or Function Call . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-23\n11.6.10.3 Caller-Save Recommendation for Procedure and Function Calls. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-24\n11.6.11 Updating Existing MMX Technology Routines Using 128-Bit SIMD Integer Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-24\n11.6.12 Branching on Arithmetic Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-24\n11.6.13 Cacheability Hint Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-25\n11.6.14 Effect of Instruction Prefixes on the SSE/SSE2 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-25\n\nCHAPTER 12\nPROGRAMMING WITH INTEL® SSE3, SSSE3, INTEL® SSE4 AND INTEL® AESNI\n12.1 PROGRAMMING ENVIRONMENT AND DATA TYPES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-1\n12.1.1 SSE3, SSSE3, SSE4 in 64-Bit Mode and Compatibility Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-1\n12.1.2 Compatibility of SSE3/SSSE3 with MMX Technology, the x87 FPU Environment, and SSE/SSE2 Extensions . . . . . . . . . 12-1\n12.1.3 Horizontal and Asymmetric Processing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-1\n12.2 OVERVIEW OF SSE3 INSTRUCTIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-2\n12.3 SSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-2\n12.3.1 x87 FPU Instruction for Integer Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-3\n12.3.2 SIMD Integer Instruction for Specialized 128-bit Unaligned Data Load  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-3\n12.3.3 SIMD Floating-Point Instructions That Enhance LOAD/MOVE/DUPLICATE Performance. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-3\n12.3.4 SIMD Floating-Point Instructions Provide Packed Addition/Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-4\n12.3.5 SIMD Floating-Point Instructions Provide Horizontal Addition/Subtraction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-4\n12.3.6 Two Thread Synchronization Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-5\n12.4 WRITING APPLICATIONS WITH SSE3 EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-5\n12.4.1 Guidelines for Using SSE3 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-5\n12.4.2 Checking for SSE3 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-5\n12.4.3 Enable FTZ and DAZ for SIMD Floating-Point Computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-6\n12.4.4 Programming SSE3 with SSE/SSE2 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-6\n12.5 OVERVIEW OF SSSE3 INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-6\n12.6 SSSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-6\n12.6.1 Horizontal Addition/Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-7\n12.6.2 Packed Absolute Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-7\n12.6.3 Multiply and Add Packed Signed and Unsigned Bytes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.6.4 Packed Multiply High with Round and Scale  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.6.5 Packed Shuffle Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.6.6 Packed Sign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.6.7 Packed Align Right . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.7 WRITING APPLICATIONS WITH SSSE3 EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-9\n12.7.1 Guidelines for Using SSSE3 Extensions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-9\n12.7.2 Checking for SSSE3 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-9\n12.8 SSE3/SSSE3 AND SSE4 EXCEPTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-9\n12.8.1 Device Not Available (DNA) Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-9\n12.8.2 Numeric Error flag and IGNNE# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-9\n12.8.3 Emulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-10\n12.8.4 IEEE 754 Compliance of SSE4.1 Floating-Point Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-10\n12.9 SSE4 OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-10\n12.10 SSE4.1 INSTRUCTION SET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-11\n12.10.1 Dword Multiply Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-11\n12.10.2 Floating-Point Dot Product Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-11\n12.10.3 Streaming Load Hint Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-12\n12.10.4 Packed Blending Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\n12.10.5 Packed Integer MIN/MAX Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\n12.10.6 Floating-Point Round Instructions with Selectable Rounding Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\nxii Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n12.10.7 Insertion and Extractions from XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-15\n12.10.8 Packed Integer Format Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-15\n12.10.9 Improved Sums of Absolute Differences (SAD) for 4-Byte Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-16\n12.10.10 Horizontal Search  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-16\n12.10.11 Packed Test. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.10.12 Packed Qword Equality Comparisons  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.10.13 Dword Packing With Unsigned Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.11 SSE4.2 INSTRUCTION SET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.11.1 String and Text Processing Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.11.1.1 Memory Operand Alignment  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-18\n12.11.2 Packed Comparison SIMD Integer Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-18\n12.12 WRITING APPLICATIONS WITH SSE4 EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-18\n12.12.1 Guidelines for Using SSE4 Extensions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-18\n12.12.2 Checking for SSE4.1 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-19\n12.12.3 Checking for SSE4.2 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-19\n12.13 AESNI OVERVIEW. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-19\n12.13.1 Little-Endian Architecture and Big-Endian Specification (FIPS 197) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-19\n12.13.1.1 AES Data Structure in Intel 64 Architecture. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-20\n12.13.2 AES Transformations and Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-21\n12.13.3 PCLMULQDQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-24\n12.13.4 Checking for AESNI Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-24\n\nCHAPTER 13\nMANAGING STATE USING THE XSAVE FEATURE SET\n13.1 XSAVE-SUPPORTED FEATURES AND STATE-COMPONENT BITMAPS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13-1\n13.2 ENUMERATION OF CPU SUPPORT FOR XSAVE INSTRUCTIONS AND XSAVE-SUPPORTED FEATURES  . . . . . . . . . . . . . . . . . .  13-3\n13.3 ENABLING THE XSAVE FEATURE SET AND XSAVE-ENABLED FEATURES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13-4\n13.4 XSAVE AREA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13-6\n13.4.1 Legacy Region of an XSAVE Area  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-7\n13.4.2 XSAVE Header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-8\n13.4.3 Extended Region of an XSAVE Area . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-8\n13.5 XSAVE-MANAGED STATE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13-9\n13.5.1 x87 State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-9\n13.5.2 SSE State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-10\n13.5.3 AVX State  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-10\n13.5.4 MPX State  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-11\n13.5.5 AVX-512 State. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-11\n13.5.6 PT State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-12\n13.5.7 PKRU State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-13\n13.5.8 CET State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-13\n13.5.9 HDC State. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-13\n13.5.10 HWP State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-14\n13.6 PROCESSOR TRACKING OF XSAVE-MANAGED STATE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-14\n13.7 OPERATION OF XSAVE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-15\n13.8 OPERATION OF XRSTOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-16\n13.8.1 Standard Form of XRSTOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-16\n13.8.2 Compacted Form of XRSTOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-17\n13.8.3 XRSTOR and the Init and Modified Optimizations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-17\n13.9 OPERATION OF XSAVEOPT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-18\n13.10 OPERATION OF XSAVEC  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-19\n13.11 OPERATION OF XSAVES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-20\n13.12 OPERATION OF XRSTORS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-21\n13.13 MEMORY ACCESSES BY THE XSAVE FEATURE SET  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-23\n\nCHAPTER 14\nPROGRAMMING WITH AVX, FMA AND AVX2\n14.1 INTEL AVX OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-1\n14.1.1 256-Bit Wide SIMD Register Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-1\n14.1.2 Instruction Syntax Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-2\nVol. 1 xiii\n\n\n\nCONTENTS\n\nPAGE\n14.1.3 VEX Prefix Instruction Encoding Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-2\n14.2 FUNCTIONAL OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-3\n14.2.1 256-bit Floating-Point Arithmetic Processing Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-9\n14.2.2 256-bit Non-Arithmetic Instruction Enhancements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-9\n14.2.3 Arithmetic Primitives for 128-bit Vector and Scalar processing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-11\n14.2.4 Non-Arithmetic Primitives for 128-bit Vector and Scalar Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-13\n14.3 DETECTION OF AVX INSTRUCTIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-15\n14.3.1 Detection of VEX-Encoded AES and VPCLMULQDQ  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-17\n14.4 HALF-PRECISION FLOATING-POINT CONVERSION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-18\n14.4.1 Detection of F16C Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-20\n14.5 FUSED-MULTIPLY-ADD (FMA) EXTENSIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-21\n14.5.1 FMA Instruction Operand Order and Arithmetic Behavior. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-22\n14.5.2 Fused-Multiply-ADD (FMA) Numeric Behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-22\n14.5.3 Detection of FMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-24\n14.6 OVERVIEW OF INTEL® ADVANCED VECTOR EXTENSIONS 2 (INTEL® AVX2)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-25\n14.6.1 AVX2 and 256-bit Vector Integer Processing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-25\n14.7 PROMOTED VECTOR INTEGER INSTRUCTIONS IN AVX2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-26\n14.7.1 Detection of AVX2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-31\n14.8 ACCESSING YMM REGISTERS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-32\n14.9 MEMORY ALIGNMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-32\n14.10 SIMD FLOATING-POINT EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-34\n14.11 EMULATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-34\n14.12 WRITING AVX FLOATING-POINT EXCEPTION HANDLERS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-34\n14.13 GENERAL PURPOSE INSTRUCTION SET ENHANCEMENTS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-35\n\nCHAPTER 15\nPROGRAMMING WITH INTEL® AVX-512\n15.1 OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-1\n15.1.1 512-Bit Wide SIMD Register Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-1\n15.1.2 32 SIMD Register Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-1\n15.1.3 Eight Opmask Register Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-1\n15.1.4 Instruction Syntax Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-2\n15.1.5 EVEX Instruction Encoding Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-3\n15.2 DETECTION OF AVX-512 FOUNDATION INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-3\n15.2.1 Additional 512-bit Instruction Extensions of the Intel AVX-512 Family . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-4\n15.3 DETECTION OF 512-BIT INSTRUCTION GROUPS OF INTEL® AVX-512 FAMILY. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-5\n15.4 DETECTION OF INTEL AVX-512 INSTRUCTION GROUPS OPERATING AT 256 AND 128-BIT VECTOR LENGTHS  . . . . . . . . .  15-6\n15.5 ACCESSING XMM, YMM AND ZMM REGISTERS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-8\n15.6 ENHANCED VECTOR PROGRAMMING ENVIRONMENT USING EVEX ENCODING  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-8\n15.6.1 OPMASK Register to Predicate Vector Data Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-9\n15.6.1.1 Opmask Register K0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-9\n15.6.1.2 Example of Opmask Usages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-10\n15.6.2 OpMask Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-11\n15.6.3 Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-11\n15.6.4 Static Rounding Mode and Suppress All Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-12\n15.6.5 Compressed Disp8*N Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-13\n15.7 MEMORY ALIGNMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-13\n15.8 SIMD FLOATING-POINT EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-14\n15.9 INSTRUCTION EXCEPTION SPECIFICATION. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-15\n15.10 EMULATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-15\n15.11 WRITING FLOATING-POINT EXCEPTION HANDLERS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-15\n\nCHAPTER 16\nPROGRAMMING WITH INTEL® TRANSACTIONAL SYNCHRONIZATION EXTENSIONS\n16.1 OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  16-1\n16.2 INTEL® TRANSACTIONAL SYNCHRONIZATION EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  16-1\n16.2.1 HLE Software Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-2\n16.2.2 RTM Software Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3 INTEL® TSX APPLICATION PROGRAMMING MODEL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  16-3\nxiv Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n16.3.1 Detection of Transactional Synchronization Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3.1.1 Detection of HLE Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3.1.2 Detection of RTM Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3.1.3 Detection of XTEST Instruction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3.2 Querying Transactional Execution Status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-4\n16.3.3 Requirements for HLE Locks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-4\n16.3.4 Transactional Nesting  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-4\n16.3.4.1 HLE Nesting and Elision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-4\n16.3.4.2 RTM Nesting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\n16.3.4.3 Nesting HLE and RTM. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\n16.3.5 RTM Abort Status Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\n16.3.6 RTM Memory Ordering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\n16.3.7 RTM-Enabled Debugger Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-6\n16.3.8 Programming Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-6\n16.3.8.1 Instruction Based Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-6\n16.3.8.2 Runtime Considerations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-7\n\nCHAPTER 17\nINTEL® MEMORY PROTECTION EXTENSIONS\n17.1 INTEL® MEMORY PROTECTION EXTENSIONS (INTEL® MPX) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-1\n17.2 INTRODUCTION. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-1\n17.3 INTEL MPX PROGRAMMING ENVIRONMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-2\n17.3.1 Detection and Enumeration of Intel MPX Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-2\n17.3.2 Bounds Registers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-2\n17.3.3 Configuration and Status Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-3\n17.3.4 Read and Write of IA32_BNDCFGS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-4\n17.4 INTEL MPX INSTRUCTION SUMMARY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-4\n17.4.1 Instruction Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-5\n17.4.2 Usage and Examples. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-5\n17.4.3 Loading and Storing Bounds in Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-6\n17.4.3.1 BNDLDX and BNDSTX in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-7\n17.4.3.2 BNDLDX and BNDSTX Outside 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-8\n17.5 INTERACTIONS WITH INTEL MPX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-9\n17.5.1 Intel MPX and Operating Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-9\n17.5.2 Intel MPX Support for Pointer Operations with Branching. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-10\n17.5.3 CALL, RET, JMP and All Jcc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-10\n17.5.4 BOUND Instruction and Intel MPX  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\n17.5.5 Programming Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\n17.5.6 Intel MPX and System Management Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\n17.5.7 Support of Intel MPX in VMCS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\n17.5.8 Support of Intel MPX in Intel TSX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-12\n\nCHAPTER 18\nCONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET)\n18.1 INTRODUCTION. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18-1\n18.1.1 Shadow Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-1\n18.1.2 Indirect Branch Tracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-1\n18.1.3 Speculative Behavior when CET is Enabled. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-2\n18.2 SHADOW STACKS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18-2\n18.2.1 Shadow Stack Pointer and its Operand and Address Size Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-2\n18.2.2 Terminology  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-2\n18.2.3 Supervisor Shadow Stack Token  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-3\n18.2.4 Shadow Stack Usage on Task Switch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-5\n18.2.5 Switching Shadow Stacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-5\n18.2.6 Constraining Execution at Targets of RET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-7\n18.3 INDIRECT BRANCH TRACKING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18-7\n18.3.1 No-track Prefix for Near Indirect CALL/JMP  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-8\n18.3.2 Terminology  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-9\n18.3.3 Indirect Branch Tracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-10\nVol. 1 xv\n\n\n\nCONTENTS\n\nPAGE\n18.3.3.1 Control Transfers between CPL 3 and CPL < 3  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-10\n18.3.3.2 Control Transfers within CPL 3 or CPL < 3  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-10\n18.3.4 Indirect Branch Tracking State Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-11\n18.3.5 INT3 Treatment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-12\n18.3.6 Legacy Compatibility Treatment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-12\n18.3.6.1 Legacy Code Page Bitmap Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.7 Other Considerations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.7.1 Intel® Transactional Synchronization Extensions (Intel® TSX) Interactions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.7.2 #CP(ENDBRANCH) Priority w.r.t #NM and #UD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.7.3 #CP(ENDBRANCH) Priority w.r.t #BP and #DB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.8 Constraining Speculation after Missing ENDBRANCH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-14\n18.4 INTEL® TRUSTED EXECUTION TECHNOLOGY (INTEL® TXT) INTERACTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18-14\n\nCHAPTER 19\nINPUT/OUTPUT\n19.1 I/O PORT ADDRESSING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-1\n19.2 I/O PORT HARDWARE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-1\n19.3 I/O ADDRESS SPACE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-1\n19.3.1 Memory-Mapped I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-2\n19.4 I/O INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-3\n19.5 PROTECTED-MODE I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-3\n19.5.1 I/O Privilege Level  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-3\n19.5.2 I/O Permission Bit Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-4\n19.6 ORDERING I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-5\n\nCHAPTER 20 \nPROCESSOR IDENTIFICATION AND FEATURE DETERMINATION\n20.1 USING THE CPUID INSTRUCTION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  20-1\n20.1.1 Notes on Where to Start . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20-1\n20.1.2 Identification of Earlier IA-32 Processors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20-1\n\nAPPENDIX A\nEFLAGS CROSS-REFERENCE\nA.1 EFLAGS AND INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  A-1\n\nAPPENDIX B\nEFLAGS CONDITION CODES\nB.1 CONDITION CODES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  B-1\n\nAPPENDIX C\nFLOATING-POINT EXCEPTIONS SUMMARY\nC.1 OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-1\nC.2 X87 FPU INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-1\nC.3 SSE INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-3\nC.4 SSE2 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-5\nC.5 SSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-7\nC.6 SSSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-7\nC.7 SSE4 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-7\n\nAPPENDIX D\nGUIDELINES FOR WRITING SIMD FLOATING-POINT EXCEPTION HANDLERS\nD.1 TWO OPTIONS FOR HANDLING FLOATING-POINT EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-1\nD.2 SOFTWARE EXCEPTION HANDLING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-1\nD.3 EXCEPTION SYNCHRONIZATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-3\nD.4 SIMD FLOATING-POINT EXCEPTIONS AND THE IEEE STANDARD 754  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-3\nD.4.1 Floating-Point Emulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-3\nD.4.2 SSE/SSE2/SSE3 Response To Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-4\nD.4.2.1 Numeric Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-5\nxvi Vol. 1\n\n\n\nCONTENTS\n\nPAGE\nD.4.2.2 Results of Operations with NaN Operands or a NaN Result for SSE/SSE2/SSE3 Numeric Instructions. . . . . . . . . . . . . .D-5\nD.4.2.3 Condition Codes, Exception Flags, and Response for Masked and Unmasked Numeric Exceptions. . . . . . . . . . . . . . . . . .D-9\nD.4.3 Example SIMD Floating-Point Emulation Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-15\nVol. 1 xvii\n\n\n\nCONTENTS\n\nPAGE\nFIGURES\n\nFigure 1-1. Bit and Byte Order. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\nFigure 1-2. Syntax for CPUID, CR, and MSR Data Presentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-8\nFigure 2-1. The P6 Processor Microarchitecture with Advanced Transfer Cache Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-7\nFigure 2-2. The Intel NetBurst Microarchitecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-9\nFigure 2-3. The Intel Core Microarchitecture Pipeline Functionality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\nFigure 2-4. SIMD Extensions, Register Layouts, and Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-16\nFigure 2-5. Comparison of an IA-32 Processor Supporting Hyper-Threading Technology and a Traditional Dual Processor \n\nSystem  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-17\nFigure 2-6. Intel 64 and IA-32 Processors that Support Dual-Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-18\nFigure 2-7. Intel 64 Processors that Support Quad-Core  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-19\nFigure 2-8. Intel Core i7 Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-19\nFigure 3-1. IA-32 Basic Execution Environment for Non-64-bit Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-3\nFigure 3-2. 64-Bit Mode Execution Environment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-6\nFigure 3-3. Three Memory Management Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-8\nFigure 3-4. General System and Application Programming Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-11\nFigure 3-5. Alternate General-Purpose Register Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-12\nFigure 3-6. Use of Segment Registers for Flat Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-14\nFigure 3-7. Use of Segment Registers in Segmented Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-14\nFigure 3-8. EFLAGS Register  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-16\nFigure 3-9. Memory Operand Address. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\nFigure 3-10. Memory Operand Address in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\nFigure 3-11. Offset (or Effective Address) Computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-23\nFigure 4-1. Fundamental Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\nFigure 4-2. Bytes, Words, Doublewords, Quadwords, and Double Quadwords in Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\nFigure 4-3. Numeric Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-3\nFigure 4-4. Pointer Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\nFigure 4-5. Pointers in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\nFigure 4-6. Bit Field Data Type  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\nFigure 4-7. 64-Bit Packed SIMD Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\nFigure 4-8. 128-Bit Packed SIMD Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-9\nFigure 4-9. BCD Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10\nFigure 4-10. Binary Real Number System. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-12\nFigure 4-11. Binary Floating-Point Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-12\nFigure 4-12. Real Numbers and NaNs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14\nFigure 6-1. Stack Structure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-2\nFigure 6-2. Stack on Near and Far Calls  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-6\nFigure 6-3. Shadow Stack on Near and Far Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-6\nFigure 6-4. Protection Rings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-8\nFigure 6-5. Stack Switch on a Call to a Different Privilege Level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-9\nFigure 6-6. Shadow Stack Switch on a Call to a Different Privilege Level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-10\nFigure 6-7. Stack Usage on Transfers to Interrupt and Exception Handling Routines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-15\nFigure 6-8. Shadow Stack Usage on Transfers to Interrupt and Exception Handling Routines  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-16\nFigure 6-9. Nested Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-21\nFigure 6-10. Stack Frame After Entering the MAIN Procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-22\nFigure 6-11. Stack Frame After Entering Procedure A. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-22\nFigure 6-12. Stack Frame After Entering Procedure B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-23\nFigure 6-13. Stack Frame After Entering Procedure C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-24\nFigure 7-1. Operation of the PUSH Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-5\nFigure 7-2. Operation of the PUSHA Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-6\nFigure 7-3. Operation of the POP Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-6\nFigure 7-4. Operation of the POPA Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-7\nFigure 7-5. Sign Extension  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-7\nFigure 7-6. SHL/SAL Instruction Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-11\nFigure 7-7. SHR Instruction Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-11\nFigure 7-8. SAR Instruction Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-12\nFigure 7-9. SHLD and SHRD Instruction Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-12\nFigure 7-10. ROL, ROR, RCL, and RCR Instruction Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-13\nxviii Vol. 1\n\n\n\nCONTENTS\n\nPAGE\nFigure 7-11. Flags Affected by the PUSHF, POPF, PUSHFD, and POPFD Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\nFigure 8-1. x87 FPU Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-2\nFigure 8-2. x87 FPU Data Register Stack  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-2\nFigure 8-3. Example x87 FPU Dot Product Computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-3\nFigure 8-4. x87 FPU Status Word. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-4\nFigure 8-5. Moving the Condition Codes to the EFLAGS Register  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-6\nFigure 8-6. x87 FPU Control Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-7\nFigure 8-7. x87 FPU Tag Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\nFigure 8-8. Contents of x87 FPU Opcode Registers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-11\nFigure 8-9. Protected Mode x87 FPU State Image in Memory, 32-Bit Format  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-11\nFigure 8-10. Real Mode x87 FPU State Image in Memory, 32-Bit Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12\nFigure 8-11. Protected Mode x87 FPU State Image in Memory, 16-Bit Format  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12\nFigure 8-12. Real Mode x87 FPU State Image in Memory, 16-Bit Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12\nFigure 8-13. x87 FPU Data Type Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-13\nFigure 9-1. MMX Technology Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-2\nFigure 9-2. MMX Register Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-3\nFigure 9-3. Data Types Introduced with the MMX Technology. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-3\nFigure 9-4. SIMD Execution Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-4\nFigure 10-1. SSE Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-2\nFigure 10-2. XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-3\nFigure 10-3. MXCSR Control/Status Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-4\nFigure 10-4. 128-Bit Packed Single-Precision Floating-Point Data Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-6\nFigure 10-5. Packed Single-Precision Floating-Point Operation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-7\nFigure 10-6. Scalar Single-Precision Floating-Point Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-7\nFigure 10-7. SHUFPS Instruction, Packed Shuffle Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10-10\nFigure 10-8. UNPCKHPS Instruction, High Unpack and Interleave Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10-10\nFigure 10-9. UNPCKLPS Instruction, Low Unpack and Interleave Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10-10\nFigure 11-1. Steaming SIMD Extensions 2 Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-2\nFigure 11-2. Data Types Introduced with the SSE2 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-4\nFigure 11-3. Packed Double-Precision Floating-Point Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-5\nFigure 11-4. Scalar Double-Precision Floating-Point Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-5\nFigure 11-5. SHUFPD Instruction, Packed Shuffle Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-8\nFigure 11-6. UNPCKHPD Instruction, High Unpack and Interleave Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-8\nFigure 11-7. UNPCKLPD Instruction, Low Unpack and Interleave Operation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-8\nFigure 11-8. SSE and SSE2 Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-9\nFigure 11-9. Example Masked Response for Packed Operations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .11-17\nFigure 12-1. Asymmetric Processing in ADDSUBPD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-2\nFigure 12-2. Horizontal Data Movement in HADDPD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-2\nFigure 12-3. Horizontal Data Movement in PHADDD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-7\nFigure 12-4. MPSADBW Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .12-16\nFigure 12-5. AES State Flow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .12-19\nFigure 14-1. 256-Bit Wide SIMD Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-2\nFigure 14-2. General Procedural Flow of Application Detection of AVX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .14-15\nFigure 14-3. General Procedural Flow of Application Detection of Float-16. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .14-20\nFigure 15-1. 512-Bit Wide Vectors and SIMD Register Set. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-2\nFigure 15-2. Procedural Flow for Application Detection of AVX-512 Foundation Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-4\nFigure 15-3. Procedural Flow for Application Detection of 512-bit Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-5\nFigure 15-4. Procedural Flow for Application Detection of 512-bit Instruction Groups  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-6\nFigure 15-5. Procedural Flow for Detection of Intel AVX-512 Instructions Operating at Vector Lengths < 512. . . . . . . . . . . . . . . 15-7\nFigure 17-1. Layout of the Bounds Registers BND0-BND3  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-3\nFigure 17-2. Common Layout of the Bound Configuration Registers BNDCFGU and BNDCFGS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-3\nFigure 17-3. Layout of the Bound Status Registers BNDSTATUS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-4\nFigure 17-4. Bound Paging Structure and Address Translation in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-7\nFigure 17-5. Bound Paging Structure and Address Translation Outside 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-9\nFigure 18-1. Supervisor Shadow Stack with a Supervisor Shadow Stack Token. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-4\nFigure 18-2. RSTORSSP to Switch to New Shadow Stack. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-6\nFigure 18-3. SAVEPREVSSP to Save a Restore Point. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-6\nFigure 18-4. Priority of Control Protection Exception on Missing ENDBRANCH. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-8\nFigure 19-1. Memory-Mapped I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-2\nVol. 1 xix\n\n\n\nCONTENTS\n\nPAGE\nFigure 19-2. I/O Permission Bit Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-4\nFigure D-1. Control Flow for Handling Unmasked Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-4\nxx Vol. 1\n\n\n\nCONTENTS\n\nPAGE\nTABLES\n\nTable 2-1. Key Features of Most Recent IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21\nTable 2-2. Key Features of Most Recent Intel 64 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21\nTable 2-3. Key Features of Previous Generations of IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-27\nTable 2-4. Proposed Intel ISA and Features Removal List  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-28\nTable 2-5. Intel ISA and Features Removal List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-28\nTable 3-1. Instruction Pointer Sizes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-10\nTable 3-2. Addressable General Purpose Registers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-13\nTable 3-3. Effective Operand- and Address-Size Attributes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19\nTable 3-4. Effective Operand- and Address-Size Attributes in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19\nTable 3-5. Default Segment Selection Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-22\nTable 4-1. Signed Integer Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\nTable 4-2. Length, Precision, and Range of Floating-Point Data Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\nTable 4-3. Floating-Point Number and NaN Encodings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\nTable 4-4. Packed Decimal Integer Encodings  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10\nTable 4-5. Real and Floating-Point Number Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-12\nTable 4-6. Denormalization Process. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\nTable 4-7. Rules for Handling NaNs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\nTable 4-8. Rounding Modes and Encoding of Rounding Control (RC) Field . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\nTable 4-9. Numeric Overflow Thresholds. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\nTable 4-10. Masked Responses to Numeric Overflow  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\nTable 4-11. Numeric Underflow (Normalized) Thresholds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-22\nTable 5-1. Instruction Groups in Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\nTable 5-2. Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2\nTable 5-3. Supervisor and User Mode Enclave Instruction Leaf Functions in Long-Form of SGX1  . . . . . . . . . . . . . . . . . . . . . . . . . . 5-37\nTable 6-1. Exceptions and Interrupts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-13\nTable 7-1. Move Instruction Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-3\nTable 7-2. Conditional Move Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-4\nTable 7-3. Bit Test and Modify Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\nTable 7-4. Conditional Jump Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-16\nTable 8-1. Condition Code Interpretation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-5\nTable 8-2. Precision Control Field (PC). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\nTable 8-3. Unsupported Double Extended-Precision Floating-Point Encodings and Pseudo-Denormals . . . . . . . . . . . . . . . . . . . . . 8-14\nTable 8-4. Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-16\nTable 8-5. Floating-Point Conditional Move Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-16\nTable 8-6. Setting of x87 FPU Condition Code Flags for Floating-Point Number Comparisons. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-19\nTable 8-7. Setting of EFLAGS Status Flags for Floating-Point Number Comparisons. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-19\nTable 8-8. TEST Instruction Constants for Conditional Branching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-20\nTable 8-9. Arithmetic and Non-arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-25\nTable 8-10. Invalid Arithmetic Operations and the Masked Responses to Them  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-27\nTable 8-11. Divide-By-Zero Conditions and the Masked Responses to Them . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-28\nTable 9-1. Data Range Limits for Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-5\nTable 9-2. MMX Instruction Set Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-6\nTable 9-3. Effect of Prefixes on MMX Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-11\nTable 10-1. PREFETCHh Instructions Caching Hints  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-13\nTable 10-2. Format of an FXSAVE Area  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-15\nTable 11-1. Masked Responses of SSE/SSE2/SSE3 Instructions to Invalid Arithmetic Operations . . . . . . . . . . . . . . . . . . . . . . . . . . 11-14\nTable 11-2. SSE and SSE2 State Following a Power-up/Reset or INIT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-20\nTable 11-3. Effect of Prefixes on SSE, SSE2, and SSE3 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-26\nTable 12-1. SIMD numeric exceptions signaled by SSE4.1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-10\nTable 12-2. Enhanced 32-bit SIMD Multiply Supported by SSE4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-11\nTable 12-3. Blend Field Size and Control Modes Supported by SSE4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\nTable 12-4. Enhanced SIMD Integer MIN/MAX Instructions Supported by SSE4.1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\nTable 12-5. New SIMD Integer conversions supported by SSE4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-15\nTable 12-6. New SIMD Integer Conversions Supported by SSE4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-16\nTable 12-7. Enhanced SIMD Pack support by SSE4.1  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\nTable 12-8. Byte and 32-bit Word Representation of a 128-bit State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-20\nTable 12-9. Matrix Representation of a 128-bit State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-20\nVol. 1 xxi\n\n\n\nCONTENTS\n\nPAGE\nTable 12-10. Little Endian Representation of a 128-bit State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-21\nTable 12-11. Little Endian Representation of a 4x4 Byte Matrix  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-21\nTable 12-12. The ShiftRows Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-22\nTable 12-13. Look-up Table Associated with S-Box Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-22\nTable 12-14. The InvShiftRows Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-23\nTable 12-15. Look-up Table Associated with InvS-Box Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-24\nTable 13-1. Format of the Legacy Region of an XSAVE Area. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-7\nTable 14-1. Promoted SSE/SSE2/SSE3/SSSE3/SSE4 Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-3\nTable 14-2. Promoted 256-Bit and 128-bit Arithmetic AVX Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-9\nTable 14-3. Promoted 256-bit and 128-bit Data Movement AVX Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-9\nTable 14-4. 256-bit AVX Instruction Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-10\nTable 14-5. Promotion of Legacy SIMD ISA to 128-bit Arithmetic AVX instruction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-11\nTable 14-6. 128-bit AVX Instruction Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-13\nTable 14-7. Promotion of Legacy SIMD ISA to 128-bit Non-Arithmetic AVX instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-14\nTable 14-8. Immediate Byte Encoding for 16-bit Floating-Point Conversion Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-18\nTable 14-9. Non-Numerical Behavior for VCVTPH2PS, VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-18\nTable 14-10. Invalid Operation for VCVTPH2PS, VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-18\nTable 14-12. Underflow Condition for VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19\nTable 14-13. Overflow Condition for VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19\nTable 14-14. Inexact Condition for VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19\nTable 14-11. Denormal Condition Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19\nTable 14-15. FMA Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-21\nTable 14-16. Rounding Behavior of Zero Result in FMA Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-23\nTable 14-17. FMA Numeric Behavior. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-23\nTable 14-18. Promoted Vector Integer SIMD Instructions in AVX2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-26\nTable 14-19.  VEX-Only SIMD Instructions in AVX and AVX2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-29\nTable 14-20. New Primitive in AVX2 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-30\nTable 14-21. Alignment Faulting Conditions when Memory Access is Not Aligned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-33\nTable 14-22. Instructions Requiring Explicitly Aligned Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-33\nTable 14-23. Instructions Not Requiring Explicit Memory Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-34\nTable 15-1. 512-bit Instruction Groups in the Intel AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-6\nTable 15-2. Feature flag Collection Required of 256/128 Bit Vector Lengths for Each Instruction Group . . . . . . . . . . . . . . . . . . . . 15-7\nTable 15-3. Instruction Mnemonics That Do Not Support EVEX.128 Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-8\nTable 15-4. Characteristics of Three Rounding Control Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-12\nTable 15-5. Static Rounding Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-12\nTable 15-6.  SIMD Instructions Requiring Explicitly Aligned Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-14\nTable 15-7. Instructions Not Requiring Explicit Memory Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-14\nTable 16-1. RTM Abort Status Definition  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\nTable 17-1.  Error Code Definition of BNDSTATUS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-4\nTable 17-2.  Intel MPX Instruction Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-5\nTable 17-3.  Effective Address Size of Intel MPX Instructions with 67H Prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-10\nTable 17-4.  Bounds Register INIT Behavior Due to BND Prefix with Branch Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\nTable 18-1. Indirect Branch Tracking State Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-11\nTable 19-1. I/O Instruction Serialization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-6\nTable A-1. Codes Describing Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .A-1\nTable A-2. EFLAGS Cross-Reference. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .A-1\nTable B-1. EFLAGS Condition Codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .B-1\nTable C-1. x87 FPU and SIMD Floating-Point Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-1\nTable C-2. Exceptions Generated with x87 FPU Floating-Point Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-1\nTable C-3. Exceptions Generated with SSE Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-3\nTable C-4. Exceptions Generated with SSE2 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-5\nTable C-5. Exceptions Generated with SSE3 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-7\nTable C-6. Exceptions Generated with SSE4 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-8\nTable D-1. ADDPS, ADDSS, SUBPS, SUBSS, MULPS, MULSS, DIVPS, DIVSS, ADDPD, ADDSD, SUBPD, SUBSD, MULPD, MULSD, \n\nDIVPD, DIVSD, ADDSUBPS, ADDSUBPD, HADDPS, HADDPD, HSUBPS, HSUBPD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-5\nTable D-2. CMPPS.EQ, CMPSS.EQ, CMPPS.ORD, CMPSS.ORD, CMPPD.EQ, CMPSD.EQ, CMPPD.ORD, CMPSD.ORD  . . . . . . . . . . . . . . . . .D-6\nTable D-3. CMPPS.NEQ, CMPSS.NEQ, CMPPS.UNORD, CMPSS.UNORD, CMPPD.NEQ, CMPSD.NEQ, CMPPD.UNORD, CMPSD.\n\nUNORD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-6\nTable D-4. CMPPS.LT, CMPSS.LT, CMPPS.LE, CMPSS.LE, CMPPD.LT, CMPSD.LT, CMPPD.LE, CMPSD.LE . . . . . . . . . . . . . . . . . . . . . . . . . .D-6\nxxii Vol. 1\n\n\n\nCONTENTS\n\nPAGE\nTable D-5. CMPPS.NLT, CMPSS.NLT, CMPPS.NLE, CMPSS.NLE, CMPPD.NLT, CMPSD.NLT, CMPPD.NLE, CMPSD.NLE . . . . . . . . . . . . . .D-7\nTable D-6. COMISS, COMISD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-7\nTable D-7. UCOMISS, UCOMISD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-7\nTable D-8. CVTPS2PI, CVTSS2SI, CVTTPS2PI, CVTTSS2SI, CVTPD2PI, CVTSD2SI, CVTTPD2PI, CVTTSD2SI, CVTPS2DQ, \n\nCVTTPS2DQ, CVTPD2DQ, CVTTPD2DQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-7\nTable D-9. MAXPS, MAXSS, MINPS, MINSS, MAXPD, MAXSD, MINPD, MINSD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-8\nTable D-10. SQRTPS, SQRTSS, SQRTPD, SQRTSD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-8\nTable D-11. CVTPS2PD, CVTSS2SD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-8\nTable D-12. CVTPD2PS, CVTSD2SS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-8\nTable D-13. #I - Invalid Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-9\nTable D-14. #Z - Divide-by-Zero. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-11\nTable D-15. #D - Denormal Operand . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-12\nTable D-16. #O - Numeric Overflow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-13\nTable D-17. #U - Numeric Underflow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-14\nTable D-18. #P - Inexact Result (Precision)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-15\nVol. 1 xxiii\n\n\n\nCONTENTS\n\nPAGE\nxxiv Vol. 1\n\n\n\nCHAPTER 1\nABOUT THIS MANUAL\n\nThe Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1: Basic Architecture (order number \n253665) is part of a set that describes the architecture and programming environment of Intel® 64 and IA-32 \narchitecture processors. Other volumes in this set are:\n• The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 2A, 2B, 2C & 2D: Instruction Set \n\nReference (order numbers 253666, 253667, 326018 and 334569).\n• The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 3A, 3B, 3C & 3D: System \n\nProgramming Guide (order numbers 253668, 253669, 326019 and 332831).\n• The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 4: Model-Specific Registers \n\n(order number 335592).\n\nThe Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, describes the basic architecture \nand programming environment of Intel 64 and IA-32 processors. The Intel® 64 and IA-32 Architectures Software \nDeveloper’s Manual, Volumes 2A, 2B, 2C & 2D, describe the instruction set of the processor and the opcode struc-\nture. These volumes apply to application programmers and to programmers who write operating systems or exec-\nutives. The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 3A, 3B, 3C & 3D, describe \nthe operating-system support environment of Intel 64 and IA-32 processors. These volumes target operating-\nsystem and BIOS designers. In addition, the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 3B, addresses the programming environment for classes of software that host operating systems. The \nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 4, describes the model-specific registers \nof Intel 64 and IA-32 processors.\n\n1.1 INTEL® 64 AND IA-32 PROCESSORS COVERED IN THIS MANUAL\nThis manual set includes information pertaining primarily to the most recent Intel 64 and IA-32 processors, which \ninclude: \n• Pentium® processors\n• P6 family processors\n• Pentium® 4 processors\n• Pentium® M processors\n• Intel® Xeon® processors\n• Pentium® D processors\n• Pentium® processor Extreme Editions\n• 64-bit Intel® Xeon® processors\n• Intel® Core™ Duo processor\n• Intel® Core™ Solo processor\n• Dual-Core Intel® Xeon® processor LV\n• Intel® Core™2 Duo processor\n• Intel® Core™2 Quad processor Q6000 series\n• Intel® Xeon® processor 3000, 3200 series\n• Intel® Xeon® processor 5000 series\n• Intel® Xeon® processor 5100, 5300 series\n• Intel® Core™2 Extreme processor X7000 and X6800 series\n• Intel® Core™2 Extreme processor QX6000 series\n• Intel® Xeon® processor 7100 series\nVol. 1 1-1\n\n\n\nABOUT THIS MANUAL\n• Intel® Pentium® Dual-Core processor\n• Intel® Xeon® processor 7200, 7300 series\n• Intel® Xeon® processor 5200, 5400, 7400 series\n• Intel® Core™2 Extreme processor QX9000 and X9000 series\n• Intel® Core™2 Quad processor Q9000 series\n• Intel® Core™2 Duo processor E8000, T9000 series\n• Intel® Atom™ processor family\n• Intel® Atom™ processors 200, 300, D400, D500, D2000, N200, N400, N2000, E2000, Z500, Z600, Z2000, \n\nC1000 series are built from 45 nm and 32 nm processes\n• Intel® Core™ i7 processor\n• Intel® Core™ i5 processor\n• Intel® Xeon® processor E7-8800/4800/2800 product families \n• Intel® Core™ i7-3930K processor\n• 2nd generation Intel® Core™ i7-2xxx, Intel® Core™ i5-2xxx, Intel® Core™ i3-2xxx processor series\n• Intel® Xeon® processor E3-1200 product family\n• Intel® Xeon® processor E5-2400/1400 product family\n• Intel® Xeon® processor E5-4600/2600/1600 product family\n• 3rd generation Intel® Core™ processors\n• Intel® Xeon® processor E3-1200 v2 product family\n• Intel® Xeon® processor E5-2400/1400 v2 product families\n• Intel® Xeon® processor E5-4600/2600/1600 v2 product families\n• Intel® Xeon® processor E7-8800/4800/2800 v2 product families\n• 4th generation Intel® Core™ processors\n• The Intel® Core™ M processor family \n• Intel® Core™ i7-59xx Processor Extreme Edition\n• Intel® Core™ i7-49xx Processor Extreme Edition\n• Intel® Xeon® processor E3-1200 v3 product family\n• Intel® Xeon® processor E5-2600/1600 v3 product families\n• 5th generation Intel® Core™ processors\n• Intel® Xeon® processor D-1500 product family\n• Intel® Xeon® processor E5 v4 family\n• Intel® Atom™ processor X7-Z8000 and X5-Z8000 series\n• Intel® Atom™ processor Z3400 series\n• Intel® Atom™ processor Z3500 series\n• 6th generation Intel® Core™ processors\n• Intel® Xeon® processor E3-1500m v5 product family\n• 7th generation Intel® Core™ processors\n• Intel® Xeon Phi™ Processor 3200, 5200, 7200 Series \n• Intel® Xeon® Processor Scalable Family \n• 8th generation Intel® Core™ processors\n• Intel® Xeon Phi™ Processor 7215, 7285, 7295 Series\n• Intel® Xeon® E processors\n• 9th generation Intel® Core™ processors\n• 2nd generation Intel® Xeon® Processor Scalable Family \n1-2 Vol. 1\n\n\n\nABOUT THIS MANUAL\n• 10th generation Intel® Core™ processors\n• 11th generation Intel® Core™ processors\n• 3rd generation Intel® Xeon® Processor Scalable Family\n\nP6 family processors are IA-32 processors based on the P6 family microarchitecture. This includes the Pentium® \nPro, Pentium® II, Pentium® III, and Pentium® III Xeon® processors.\n\nThe Pentium® 4, Pentium® D, and Pentium® processor Extreme Editions are based on the Intel NetBurst® micro-\narchitecture. Most early Intel® Xeon® processors are based on the Intel NetBurst® microarchitecture. Intel Xeon \nprocessor 5000, 7100 series are based on the Intel NetBurst® microarchitecture.\n\nThe Intel® Core™ Duo, Intel® Core™ Solo and dual-core Intel® Xeon® processor LV are based on an improved \nPentium® M processor microarchitecture. \n\nThe Intel® Xeon® processor 3000, 3200, 5100, 5300, 7200, and 7300 series, Intel® Pentium® dual-core, Intel® \nCore™2 Duo, Intel® Core™2 Quad, and Intel® Core™2 Extreme processors are based on Intel® Core™ microarchi-\ntecture.\n\nThe Intel® Xeon® processor 5200, 5400, 7400 series, Intel® Core™2 Quad processor Q9000 series, and Intel® \nCore™2 Extreme processors QX9000, X9000 series, Intel® Core™2 processor E8000 series are based on Enhanced \nIntel® Core™ microarchitecture.\n\nThe Intel® Atom™ processors 200, 300, D400, D500, D2000, N200, N400, N2000, E2000, Z500, Z600, Z2000, \nC1000 series are based on the Intel® Atom™ microarchitecture and supports Intel 64 architecture.\n\nP6 family, Pentium® M, Intel® Core™ Solo, Intel® Core™ Duo processors, dual-core Intel® Xeon® processor LV, \nand early generations of Pentium 4 and Intel Xeon processors support IA-32 architecture. The Intel® AtomTM \nprocessor Z5xx series support IA-32 architecture.\n\nThe Intel® Xeon® processor 3000, 3200, 5000, 5100, 5200, 5300, 5400, 7100, 7200, 7300, 7400 series, Intel® \nCore™2 Duo, Intel® Core™2 Extreme, Intel® Core™2 Quad processors, Pentium® D processors, Pentium® Dual-\nCore processor, newer generations of Pentium 4 and Intel Xeon processor family support Intel® 64 architecture.\n\nThe Intel® Core™ i7 processor and Intel® Xeon® processor 3400, 5500, 7500 series are based on 45 nm Nehalem \nmicroarchitecture. Westmere microarchitecture is a 32 nm version of the Nehalem microarchitecture. Intel® \nXeon® processor 5600 series, Intel Xeon processor E7 and various Intel Core i7, i5, i3 processors are based on the \nWestmere microarchitecture. These processors support Intel 64 architecture.\n\nThe Intel® Xeon® processor E5 family, Intel® Xeon® processor E3-1200 family, Intel® Xeon® processor E7-\n8800/4800/2800 product families, Intel® Core™ i7-3930K processor, and 2nd generation Intel® Core™ i7-2xxx, \nIntel® CoreTM i5-2xxx, Intel® Core™ i3-2xxx processor series are based on the Sandy Bridge microarchitecture and \nsupport Intel 64 architecture.\n\nThe Intel® Xeon® processor E7-8800/4800/2800 v2 product families, Intel® Xeon® processor E3-1200 v2 product \nfamily and 3rd generation Intel® Core™ processors are based on the Ivy Bridge microarchitecture and support \nIntel 64 architecture.\n\nThe Intel® Xeon® processor E5-4600/2600/1600 v2 product families, Intel® Xeon® processor E5-2400/1400 v2 \nproduct families and Intel® Core™ i7-49xx Processor Extreme Edition are based on the Ivy Bridge-E microarchitec-\nture and support Intel 64 architecture.\n\nThe Intel® Xeon® processor E3-1200 v3 product family and 4th Generation Intel® Core™ processors are based on \nthe Haswell microarchitecture and support Intel 64 architecture.\n\nThe Intel® Xeon® processor E5-2600/1600 v3 product families and the Intel® Core™ i7-59xx Processor Extreme \nEdition are based on the Haswell-E microarchitecture and support Intel 64 architecture.\n\nThe Intel® Atom™ processor Z8000 series is based on the Airmont microarchitecture.\n\nThe Intel® Atom™ processor Z3400 series and the Intel® Atom™ processor Z3500 series are based on the Silver-\nmont microarchitecture.\n\nThe Intel® Core™ M processor family, 5th generation Intel® Core™ processors, Intel® Xeon® processor D-1500 \nproduct family and the Intel® Xeon® processor E5 v4 family are based on the Broadwell microarchitecture and \nsupport Intel 64 architecture. \n\nThe Intel® Xeon® Processor Scalable Family, Intel® Xeon® processor E3-1500m v5 product family and 6th gener-\nation Intel® Core™ processors are based on the Skylake microarchitecture and support Intel 64 architecture.\nVol. 1 1-3\n\n\n\nABOUT THIS MANUAL\nThe 7th generation Intel® Core™ processors are based on the Kaby Lake microarchitecture and support Intel 64 \narchitecture.\n\nThe Intel® Atom™ processor C series, the Intel® Atom™ processor X series, the Intel® Pentium® processor J \nseries, the Intel® Celeron® processor J series, and the Intel® Celeron® processor N series are based on the Gold-\nmont microarchitecture.\n\nThe Intel® Xeon Phi™ Processor 3200, 5200, 7200 Series is based on the Knights Landing microarchitecture and \nsupports Intel 64 architecture.\n\nThe Intel® Pentium® Silver processor series, the Intel® Celeron® processor J series, and the Intel® Celeron® \nprocessor N series are based on the Goldmont Plus microarchitecture.\n\nThe 8th generation Intel® Core™ processors, 9th generation Intel® Core™ processors, and Intel® Xeon® E proces-\nsors are based on the Coffee Lake microarchitecture and support Intel 64 architecture.\n\nThe Intel® Xeon Phi™ Processor 7215, 7285, 7295 Series is based on the Knights Mill microarchitecture and \nsupports Intel 64 architecture.\n\nThe 2nd generation Intel® Xeon® Processor Scalable Family is based on the Cascade Lake product and supports \nIntel 64 architecture.\n\nSome 10th generation Intel® Core™ processors are based on the Ice Lake microarchitecture, and some are based \non the Comet Lake microarchitecture; both support Intel 64 architecture.\n\nSome 11th generation Intel® Core™ processors are based on the Tiger Lake microarchitecture, and some are \nbased on the Rocket Lake microarchitecture; both support Intel 64 architecture.\n\nSome 3rd generation Intel® Xeon® Processor Scalable Family processors are based on the Cooper Lake product, \nand some are based on the Ice Lake microarchitecture; both support Intel 64 architecture.\n\nIA-32 architecture is the instruction set architecture and programming environment for Intel's 32-bit microproces-\nsors. Intel® 64 architecture is the instruction set architecture and programming environment which is the superset \nof Intel’s 32-bit and 64-bit architectures. It is compatible with the IA-32 architecture.\n\n1.2 OVERVIEW OF VOLUME 1: BASIC ARCHITECTURE\nA description of this manual’s content follows:\n\nChapter 1 — About This Manual. Gives an overview of all five volumes of the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual. It also describes the notational conventions in these manuals and lists related Intel \nmanuals and documentation of interest to programmers and hardware designers.\n\nChapter 2 — Intel® 64 and IA-32 Architectures. Introduces the Intel 64 and IA-32 architectures along with the \nfamilies of Intel processors that are based on these architectures. It also gives an overview of the common features \nfound in these processors and brief history of the Intel 64 and IA-32 architectures.\n\nChapter 3 — Basic Execution Environment. Introduces the models of memory organization and describes the \nregister set used by applications.\n\nChapter 4 — Data Types. Describes the data types and addressing modes recognized by the processor; provides \nan overview of real numbers and floating-point formats and of floating-point exceptions.\n\nChapter 5 — Instruction Set Summary. Lists all Intel 64 and IA-32 instructions, divided into technology groups.\n\nChapter 6 — Procedure Calls, Interrupts, and Exceptions. Describes the procedure stack and mechanisms \nprovided for making procedure calls and for servicing interrupts and exceptions.\n\nChapter 7 — Programming with General-Purpose Instructions. Describes basic load and store, program \ncontrol, arithmetic, and string instructions that operate on basic data types, general-purpose and segment regis-\nters; also describes system instructions that are executed in protected mode.\n\nChapter 8 — Programming with the x87 FPU. Describes the x87 floating-point unit (FPU), including floating-\npoint registers and data types; gives an overview of the floating-point instruction set and describes the processor's \nfloating-point exception conditions.\n\nChapter 9 — Programming with Intel® MMX™ Technology. Describes Intel MMX technology, including MMX \nregisters and data types; also provides an overview of the MMX instruction set. \n1-4 Vol. 1\n\n\n\nABOUT THIS MANUAL\nChapter 10 — Programming with Intel® Streaming SIMD Extensions (Intel® SSE). Describes SSE exten-\nsions, including XMM registers, the MXCSR register, and packed single-precision floating-point data types; provides \nan overview of the SSE instruction set and gives guidelines for writing code that accesses the SSE extensions. \n\nChapter 11 — Programming with Intel® Streaming SIMD Extensions 2 (Intel® SSE2). Describes SSE2 \nextensions, including XMM registers and packed double-precision floating-point data types; provides an overview \nof the SSE2 instruction set and gives guidelines for writing code that accesses SSE2 extensions. This chapter also \ndescribes SIMD floating-point exceptions that can be generated with SSE and SSE2 instructions. It also provides \ngeneral guidelines for incorporating support for SSE and SSE2 extensions into operating system and applications \ncode.\n\nChapter 12 — Programming with Intel® Streaming SIMD Extensions 3 (Intel® SSE3), Supplemental \nStreaming SIMD Extensions 3 (SSSE3), Intel® Streaming SIMD Extensions 4 (Intel® SSE4) and Intel® \nAES New Instructions (Intel® AES-NI). Provides an overview of the SSE3 instruction set, Supplemental SSE3, \nSSE4, AESNI instructions, and guidelines for writing code that access these extensions.\n\nChapter 13 — Managing State Using the XSAVE Feature Set. Describes the XSAVE feature set instructions \nand explains how software can enable the XSAVE feature set and XSAVE-enabled features.\n\nChapter 14 — Programming with AVX, FMA and AVX2. Provides an overview of the Intel® AVX instruction set, \nFMA and Intel AVX2 extensions and gives guidelines for writing code that access these extensions.\n\nChapter 15 — Programming with Intel® AVX-512. Provides an overview of the Intel® AVX-512 instruction set \nextensions and gives guidelines for writing code that access these extensions.\n\nChapter 16 — Programming with Intel Transactional Synchronization Extensions. Describes the instruc-\ntion extensions that support lock elision techniques to improve the performance of multi-threaded software with \ncontended locks.\n\nChapter 17 — Intel® Memory Protection Extensions. Provides an overview of the Intel® Memory Protection \nExtensions and gives guidelines for writing code that access these extensions.\n\nChapter 18 — Control-flow Enforcement Technology. Provides an overview of the Control-flow Enforcement \nTechnology (CET) and gives guidelines for writing code that access these extensions.\n\nChapter 19 — Input/Output. Describes the processor’s I/O mechanism, including I/O port addressing, I/O \ninstructions, and I/O protection mechanisms.\n\nChapter 20 — Processor Identification and Feature Determination. Describes how to determine the CPU \ntype and features available in the processor.\n\nAppendix A — EFLAGS Cross-Reference. Summarizes how the IA-32 instructions affect the flags in the EFLAGS \nregister.\n\nAppendix B — EFLAGS Condition Codes. Summarizes how conditional jump, move, and ‘byte set on condition \ncode’ instructions use condition code flags (OF, CF, ZF, SF, and PF) in the EFLAGS register.\n\nAppendix C — Floating-Point Exceptions Summary. Summarizes exceptions raised by the x87 FPU floating-\npoint and SSE/SSE2/SSE3 floating-point instructions.\n\nAppendix D — Guidelines for Writing SIMD Floating-Point Exception Handlers. Gives guidelines for writing \nexception handlers for exceptions generated by SSE/SSE2/SSE3 floating-point instructions.\n\n1.3 NOTATIONAL CONVENTIONS\nThis manual uses specific notation for data-structure formats, for symbolic representation of instructions, and for \nhexadecimal and binary numbers. This notation is described below.\n\n1.3.1 Bit and Byte Order\nIn illustrations of data structures in memory, smaller addresses appear toward the bottom of the figure; addresses \nincrease toward the top. Bit positions are numbered from right to left. The numerical value of a set bit is equal to \ntwo raised to the power of the bit position. Intel 64 and IA-32 processors are “little endian” machines; this means \nthe bytes of a word are numbered starting from the least significant byte. See Figure 1-1.\nVol. 1 1-5\n\n\n\nABOUT THIS MANUAL\n1.3.2 Reserved Bits and Software Compatibility\nIn many register and memory layout descriptions, certain bits are marked as reserved. When bits are marked as \nreserved, it is essential for compatibility with future processors that software treat these bits as having a future, \nthough unknown, effect. The behavior of reserved bits should be regarded as not only undefined, but unpredict-\nable. \n\nSoftware should follow these guidelines in dealing with reserved bits:\n• Do not depend on the states of any reserved bits when testing the values of registers that contain such bits. \n\nMask out the reserved bits before testing.\n• Do not depend on the states of any reserved bits when storing to memory or to a register.\n• Do not depend on the ability to retain information written into any reserved bits.\n• When loading a register, always load the reserved bits with the values indicated in the documentation, if any, or \n\nreload them with values previously read from the same register.\n\nNOTE\nAvoid any software dependence upon the state of reserved bits in Intel 64 and IA-32 registers. \nDepending upon the values of reserved register bits will make software dependent upon the \nunspecified manner in which the processor handles these bits. Programs that depend upon \nreserved values risk incompatibility with future processors.\n\n1.3.2.1  Instruction Operands\nWhen instructions are represented symbolically, a subset of the IA-32 assembly language is used. In this subset, \nan instruction has the following format:\n\nlabel: mnemonic argument1, argument2, argument3\n\nwhere:\n• A label is an identifier which is followed by a colon.\n• A mnemonic is a reserved name for a class of instruction opcodes which have the same function.\n• The operands argument1, argument2, and argument3 are optional. There may be from zero to three \n\noperands, depending on the opcode. When present, they take the form of either literals or identifiers for data \nitems. Operand identifiers are either reserved names of registers or are assumed to be assigned to data items \ndeclared in another part of the program (which may not be shown in the example).\n\nWhen two operands are present in an arithmetic or logical instruction, the right operand is the source and the left \noperand is the destination. \n\nFigure 1-1.  Bit and Byte Order\n\nByte 3\n\nData Structure \n\nByte 1Byte 2 Byte 0\nLowest\n\nBit offset\n\n28\n24\n20\n16\n12\n8\n4\n0\n\nAddress\n\nByte Offset\n\nHighest\nAddress 32 24 23 16 15 8 7 0\n1-6 Vol. 1\n\n\n\nABOUT THIS MANUAL\nFor example:\n\nLOADREG: MOV EAX, SUBTOTAL\n\nIn this example, LOADREG is a label, MOV is the mnemonic identifier of an opcode, EAX is the destination operand, \nand SUBTOTAL is the source operand. Some assembly languages put the source and destination in reverse order.\n\n1.3.3 Hexadecimal and Binary Numbers\nBase 16 (hexadecimal) numbers are represented by a string of hexadecimal digits followed by the character H (for \nexample, 0F82EH). A hexadecimal digit is a character from the following set: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, \nE, and F.\n\nBase 2 (binary) numbers are represented by a string of 1s and 0s, sometimes followed by the character B (for \nexample, 1010B). The “B” designation is only used in situations where confusion as to the type of number might \narise.\n\n1.3.4 Segmented Addressing\nThe processor uses byte addressing. This means memory is organized and accessed as a sequence of bytes. \nWhether one or more bytes are being accessed, a byte address is used to locate the byte or bytes memory. The \nrange of memory that can be addressed is called an address space.\n\nThe processor also supports segmented addressing. This is a form of addressing where a program may have many \nindependent address spaces, called segments. For example, a program can keep its code (instructions) and stack \nin separate segments. Code addresses would always refer to the code space, and stack addresses would always \nrefer to the stack space. The following notation is used to specify a byte address within a segment: \n\nSegment-register:Byte-address\n\nFor example, the following segment address identifies the byte at address FF79H in the segment pointed by the DS \nregister:\n\nDS:FF79H\n\nThe following segment address identifies an instruction address in the code segment. The CS register points to the \ncode segment and the EIP register contains the address of the instruction.\n\nCS:EIP\n\n1.3.5 A New Syntax for CPUID, CR, and MSR Values\nObtain feature flags, status, and system information by using the CPUID instruction, by checking control register \nbits, and by reading model-specific registers. We are moving toward a new syntax to represent this information. \nSee Figure 1-2.\nVol. 1 1-7\n\n\n\nABOUT THIS MANUAL\n1.3.6 Exceptions\nAn exception is an event that typically occurs when an instruction causes an error. For example, an attempt to \ndivide by zero generates an exception. However, some exceptions, such as breakpoints, occur under other condi-\ntions. Some types of exceptions may provide error codes. An error code reports additional information about the \nerror. An example of the notation used to show an exception and error code is shown below:\n\n#PF(fault code)\n\nThis example refers to a page-fault exception under conditions where an error code naming a type of fault is \nreported. Under some conditions, exceptions that produce error codes may not be able to report an accurate code. \nIn this case, the error code is zero, as shown below for a general-protection exception:\n\n#GP(0)\n\nFigure 1-2.  Syntax for CPUID, CR, and MSR Data Presentation\n\nInput value for EAX register\n\nOutput register and feature flag or field \nname with bit position(s)\n\nValue (or range) of output\n\nCPUID.01H:EDX.SSE[bit 25] = 1\n\nCR4.OSFXSR[bit 9] = 1\n\nIA32_MISC_ENABLE.ENABLEFOPCODE[bit 2] = 1\n\nCPUID Input and Output\n\nControl Register Values\n\nModel-Specific Register Values\n\nExample CR name\n\nFeature flag or field name \nwith bit position(s)\n\nValue (or range) of output\n\nExample MSR name\n\nFeature flag or field name with bit position(s)\n\nValue (or range) of output\n\nSDM29002\n1-8 Vol. 1\n\n\n\nABOUT THIS MANUAL\n1.4 RELATED LITERATURE\nLiterature related to Intel 64 and IA-32 processors is listed and viewable on-line at: \nhttps://software.intel.com/en-us/articles/intel-sdm\n\nSee also: \n• The latest security information on Intel® products:\n\nhttps://www.intel.com/content/www/us/en/security-center/default.html\n• Software developer resources, guidance and insights for security advisories:\n\nhttps://software.intel.com/security-software-guidance/\n• The data sheet for a particular Intel 64 or IA-32 processor\n• The specification update for a particular Intel 64 or IA-32 processor\n• Intel® C++ Compiler documentation and online help:\n\nhttp://software.intel.com/en-us/articles/intel-compilers/\n• Intel® Fortran Compiler documentation and online help:\n\nhttp://software.intel.com/en-us/articles/intel-compilers/\n• Intel® Software Development Tools:\n\nhttps://software.intel.com/en-us/intel-sdp-home\n• Intel® 64 and IA-32 Architectures Software Developer’s Manual (in one, four or ten volumes):\n\nhttps://software.intel.com/en-us/articles/intel-sdm\n• Intel® 64 and IA-32 Architectures Optimization Reference Manual: \n\nhttps://software.intel.com/en-us/articles/intel-sdm#optimization\n• Intel® Trusted Execution Technology Measured Launched Environment Programming Guide:\n\nhttp://www.intel.com/content/www/us/en/software-developers/intel-txt-software-development-guide.html\n• Intel® Software Guard Extensions (Intel® SGX) Information\n\nhttps://software.intel.com/en-us/isa-extensions/intel-sgx\n• Developing Multi-threaded Applications: A Platform Consistent Approach:\n\nhttps://software.intel.com/sites/default/files/article/147714/51534-developing-multithreaded-applica-\ntions.pdf\n\n• Using Spin-Loops on Intel® Pentium® 4 Processor and Intel® Xeon® Processor:\nhttps://software.intel.com/sites/default/files/22/30/25602\n\n• Performance Monitoring Unit Sharing Guide\nhttp://software.intel.com/file/30388\n\nLiterature related to select features in future Intel processors are available at:\n• Intel® Architecture Instruction Set Extensions Programming Reference\n\nhttps://software.intel.com/en-us/isa-extensions\n\nMore relevant links are:\n• Intel® Developer Zone:\n\nhttps://software.intel.com/en-us\n• Developer centers:\n\nhttp://www.intel.com/content/www/us/en/hardware-developers/developer-centers.html\n• Processor support general link:\n\nhttp://www.intel.com/support/processors/\n• Intel® Hyper-Threading Technology (Intel® HT Technology):\n\nhttp://www.intel.com/technology/platform-technology/hyper-threading/index.htm\nVol. 1 1-9\n\nhttp://www.intel.com/cd/software/products/asmo-na/eng/index.htm\nhttps://software.intel.com/en-us/isa-extensions/intel-sgx\nhttp://www.intel.com/cd/software/products/asmo-na/eng/index.htm\nhttp://www.intel.com/cd/software/products/asmo-na/eng/index.htm\nhttp://developer.intel.com/products/processor/manuals/index.htm\nhttp://developer.intel.com/products/processor/manuals/index.htm\nhttp://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html\n\nhttp://developer.intel.com/products/processor/manuals/index.htm\nhttp://www.intel.com/support/processors/sb/cs-009861.htm\nhttp://www.intel.com/content/www/us/en/software-developers/intel-txt-software-development-guide.html\nhttp://www3.intel.com/cd/ids/developer/asmo-na/eng/dc/threading/knowledgebase/19083.htm\nhttps://software.intel.com/en-us\nhttp://www.intel.com/cd/ids/developer/asmo-na/eng/dc/index.htm\nhttp://www.intel.com/content/www/us/en/hardware-developers/developer-centers.html\nhttp://www.intel.com/support/processors/\nhttp://www.intel.com/technology/platform-technology/hyper-threading/index.htm\nhttp://developer.intel.com/technology/hyperthread/\nhttps://software.intel.com/en-us\nhttps://software.intel.com/en-us/articles/resource-center/\nhttp://software.intel.com/en-us/articles/intel-compilers/\nhttp://software.intel.com/en-us/articles/intel-compilers/\nhttps://software.intel.com/en-us/isa-extensions\nhttps://software.intel.com/sites/default/files/article/147714/51534-developing-multithreaded-applications.pdf\nhttps://software.intel.com/en-us/intel-sdp-home\nhttps://software.intel.com/en-us/articles/intel-sdm\nhttps://software.intel.com/en-us/articles/intel-sdm#optimization\nhttps://www.intel.com/content/www/us/en/security-center/default.html\nhttps://software.intel.com/sites/default/files/22/30/25602\nhttps://software.intel.com/security-software-guidance/\n\n\nABOUT THIS MANUAL\n1-10 Vol. 1\n\n\n\nCHAPTER 2\nINTEL® 64 AND IA-32 ARCHITECTURES\n\n2.1 BRIEF HISTORY OF INTEL® 64 AND IA-32 ARCHITECTURE\nThe following sections provide a summary of the major technical evolutions from IA-32 to Intel 64 architecture: \nstarting from the Intel 8086 processor to the latest Intel® Core® 2 Duo, Core 2 Quad and Intel Xeon processor \n5300 and 7300 series. Object code created for processors released as early as 1978 still executes on the latest \nprocessors in the Intel 64 and IA-32 architecture families.\n\n2.1.1 16-bit Processors and Segmentation (1978)\nThe IA-32 architecture family was preceded by 16-bit processors, the 8086 and 8088. The 8086 has 16-bit regis-\nters and a 16-bit external data bus, with 20-bit addressing giving a 1-MByte address space. The 8088 is similar to \nthe 8086 except it has an 8-bit external data bus. \n\nThe 8086/8088 introduced segmentation to the IA-32 architecture. With segmentation, a 16-bit segment register \ncontains a pointer to a memory segment of up to 64 KBytes. Using four segment registers at a time, 8086/8088 \nprocessors are able to address up to 256 KBytes without switching between segments. The 20-bit addresses that \ncan be formed using a segment register and an additional 16-bit pointer provide a total address range of 1 MByte.\n\n2.1.2 The Intel® 286 Processor (1982)\nThe Intel 286 processor introduced protected mode operation into the IA-32 architecture. Protected mode uses the \nsegment register content as selectors or pointers into descriptor tables. Descriptors provide 24-bit base addresses \nwith a physical memory size of up to 16 MBytes, support for virtual memory management on a segment swapping \nbasis, and a number of protection mechanisms. These mechanisms include: \n• Segment limit checking\n• Read-only and execute-only segment options\n• Four privilege levels \n\n2.1.3 The Intel386™ Processor (1985)\nThe Intel386 processor was the first 32-bit processor in the IA-32 architecture family. It introduced 32-bit registers \nfor use both to hold operands and for addressing. The lower half of each 32-bit Intel386 register retains the prop-\nerties of the 16-bit registers of earlier generations, permitting backward compatibility. The processor also provides \na virtual-8086 mode that allows for even greater efficiency when executing programs created for 8086/8088 \nprocessors. \n\nIn addition, the Intel386 processor has support for:\n• A 32-bit address bus that supports up to 4-GBytes of physical memory\n• A segmented-memory model and a flat memory model\n• Paging, with a fixed 4-KByte page size providing a method for virtual memory management\n• Support for parallel stages\n\n2.1.4 The Intel486™ Processor (1989)\nThe Intel486™ processor added more parallel execution capability by expanding the Intel386 processor’s instruc-\ntion decode and execution units into five pipelined stages. Each stage operates in parallel with the others on up to \nfive instructions in different stages of execution. \nVol. 1 2-1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIn addition, the processor added:\n• An 8-KByte on-chip first-level cache that increased the percent of instructions that could execute at the scalar \n\nrate of one per clock\n• An integrated x87 FPU\n• Power saving and system management capabilities\n\n2.1.5 The Intel® Pentium® Processor (1993)\nThe introduction of the Intel Pentium processor added a second execution pipeline to achieve superscalar perfor-\nmance (two pipelines, known as u and v, together can execute two instructions per clock). The on-chip first-level \ncache doubled, with 8 KBytes devoted to code and another 8 KBytes devoted to data. The data cache uses the MESI \nprotocol to support more efficient write-back cache in addition to the write-through cache previously used by the \nIntel486 processor. Branch prediction with an on-chip branch table was added to increase performance in looping \nconstructs. \n\nIn addition, the processor added:\n• Extensions to make the virtual-8086 mode more efficient and allow for 4-MByte as well as 4-KByte pages\n• Internal data paths of 128 and 256 bits add speed to internal data transfers\n• Burstable external data bus was increased to 64 bits\n• An APIC to support systems with multiple processors\n• A dual processor mode to support glueless two processor systems\n\nA subsequent stepping of the Pentium family introduced Intel MMX technology (the Pentium Processor with MMX \ntechnology). Intel MMX technology uses the single-instruction, multiple-data (SIMD) execution model to perform \nparallel computations on packed integer data contained in 64-bit registers. \n\nSee Section 2.2.7, “SIMD Instructions.”\n\n2.1.6 The P6 Family of Processors (1995-1999)\nThe P6 family of processors was based on a superscalar microarchitecture that set new performance standards; see \nalso Section 2.2.1, “P6 Family Microarchitecture.” One of the goals in the design of the P6 family microarchitecture \nwas to exceed the performance of the Pentium processor significantly while using the same 0.6-micrometer, four-\nlayer, metal BICMOS manufacturing process. Members of this family include the following: \n• The Intel Pentium Pro processor is three-way superscalar. Using parallel processing techniques, the \n\nprocessor is able on average to decode, dispatch, and complete execution of (retire) three instructions per \nclock cycle. The Pentium Pro introduced the dynamic execution (micro-data flow analysis, out-of-order \nexecution, superior branch prediction, and speculative execution) in a superscalar implementation. The \nprocessor was further enhanced by its caches. It has the same two on-chip 8-KByte 1st-Level caches as the \nPentium processor and an additional 256-KByte Level 2 cache in the same package as the processor.\n\n• The Intel Pentium II processor added Intel MMX technology to the P6 family processors along with new \npackaging and several hardware enhancements. The processor core is packaged in the single edge contact \ncartridge (SECC). The Level l data and instruction caches were enlarged to 16 KBytes each, and Level 2 cache \nsizes of 256 KBytes, 512 KBytes, and 1 MByte are supported. A half-frequency backside bus connects the Level \n2 cache to the processor. Multiple low-power states such as AutoHALT, Stop-Grant, Sleep, and Deep Sleep are \nsupported to conserve power when idling.\n\n• The Pentium II Xeon processor combined the premium characteristics of previous generations of Intel \nprocessors. This includes: 4-way, 8-way (and up) scalability and a 2 MByte 2nd-Level cache running on a full-\nfrequency backside bus.\n\n• The Intel Celeron processor family focused on the value PC market segment. Its introduction offers an \nintegrated 128 KBytes of Level 2 cache and a plastic pin grid array (P.P.G.A.) form factor to lower system design \ncost.\n\n• The Intel Pentium III processor introduced the Streaming SIMD Extensions (SSE) to the IA-32 architecture. \nSSE extensions expand the SIMD execution model introduced with the Intel MMX technology by providing a \n2-2 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nnew set of 128-bit registers and the ability to perform SIMD operations on packed single-precision floating-\npoint values. See Section 2.2.7, “SIMD Instructions.”\n\n• The Pentium III Xeon processor extended the performance levels of the IA-32 processors with the \nenhancement of a full-speed, on-die, and Advanced Transfer Cache.\n\n2.1.7 The Intel® Pentium® 4 Processor Family (2000-2006) \nThe Intel Pentium 4 processor family is based on Intel NetBurst microarchitecture; see Section 2.2.2, “Intel \nNetBurst® Microarchitecture.”\n\nThe Intel Pentium 4 processor introduced Streaming SIMD Extensions 2 (SSE2); see Section 2.2.7, “SIMD Instruc-\ntions.” The Intel Pentium 4 processor 3.40 GHz, supporting Hyper-Threading Technology introduced Streaming \nSIMD Extensions 3 (SSE3); see Section 2.2.7, “SIMD Instructions.”\n\nIntel 64 architecture was introduced in the Intel Pentium 4 Processor Extreme Edition supporting Hyper-Threading \nTechnology and in the Intel Pentium 4 Processor 6xx and 5xx sequences.\n\nIntel® Virtualization Technology (Intel® VT) was introduced in the Intel Pentium 4 processor 672 and 662.\n\n2.1.8 The Intel® Xeon® Processor (2001- 2007)\nIntel Xeon processors (with exception for dual-core Intel Xeon processor LV, Intel Xeon processor 5100 series) are \nbased on the Intel NetBurst microarchitecture; see Section 2.2.2, “Intel NetBurst® Microarchitecture.” As a family, \nthis group of IA-32 processors (more recently Intel 64 processors) is designed for use in multi-processor server \nsystems and high-performance workstations. \n\nThe Intel Xeon processor MP introduced support for Intel® Hyper-Threading Technology; see Section 2.2.8, “Intel® \nHyper-Threading Technology.”\n\nThe 64-bit Intel Xeon processor 3.60 GHz (with an 800 MHz System Bus) was used to introduce Intel 64 architec-\nture. The Dual-Core Intel Xeon processor includes dual core technology. The Intel Xeon processor 70xx series \nincludes Intel Virtualization Technology.\n\nThe Intel Xeon processor 5100 series introduces power-efficient, high performance Intel Core microarchitecture. \nThis processor is based on Intel 64 architecture; it includes Intel Virtualization Technology and dual-core tech-\nnology. The Intel Xeon processor 3000 series are also based on Intel Core microarchitecture. The Intel Xeon \nprocessor 5300 series introduces four processor cores in a physical package, they are also based on Intel Core \nmicroarchitecture. \n\n2.1.9 The Intel® Pentium® M Processor (2003-2006)\nThe Intel Pentium M processor family is a high performance, low power mobile processor family with microarchitec-\ntural enhancements over previous generations of IA-32 Intel mobile processors. This family is designed for \nextending battery life and seamless integration with platform innovations that enable new usage models (such as \nextended mobility, ultra thin form-factors, and integrated wireless networking).\n\nIts enhanced microarchitecture includes:\n• Support for Intel Architecture with Dynamic Execution\n• A high performance, low-power core manufactured using Intel’s advanced process technology with copper \n\ninterconnect\n• On-die, primary 32-KByte instruction cache and 32-KByte write-back data cache\n• On-die, second-level cache (up to 2 MByte) with Advanced Transfer Cache Architecture\n• Advanced Branch Prediction and Data Prefetch Logic\n• Support for MMX technology, Streaming SIMD instructions, and the SSE2 instruction set\n• A 400 or 533 MHz, Source-Synchronous Processor System Bus\n• Advanced power management using Enhanced Intel SpeedStep® technology\nVol. 1 2-3\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.1.10 The Intel® Pentium® Processor Extreme Edition (2005) \nThe Intel Pentium processor Extreme Edition introduced dual-core technology. This technology provides advanced \nhardware multi-threading support. The processor is based on Intel NetBurst microarchitecture and supports SSE, \nSSE2, SSE3, Hyper-Threading Technology, and Intel 64 architecture.\n\nSee also:\n• Section 2.2.2, “Intel NetBurst® Microarchitecture”\n• Section 2.2.3, “Intel® Core™ Microarchitecture”\n• Section 2.2.7, “SIMD Instructions”\n• Section 2.2.8, “Intel® Hyper-Threading Technology”\n• Section 2.2.9, “Multi-Core Technology”\n• Section 2.2.10, “Intel® 64 Architecture”\n\n2.1.11 The Intel® Core™ Duo and Intel® Core™ Solo Processors (2006-2007)\nThe Intel Core Duo processor offers power-efficient, dual-core performance with a low-power design that extends \nbattery life. This family and the single-core Intel Core Solo processor offer microarchitectural enhancements over \nPentium M processor family.\n\nIts enhanced microarchitecture includes:\n• Intel® Smart Cache which allows for efficient data sharing between two processor cores\n• Improved decoding and SIMD execution\n• Intel® Dynamic Power Coordination and Enhanced Intel® Deeper Sleep to reduce power consumption\n• Intel® Advanced Thermal Manager which features digital thermal sensor interfaces\n• Support for power-optimized 667 MHz bus\n\nThe dual-core Intel Xeon processor LV is based on the same microarchitecture as Intel Core Duo processor, and \nsupports IA-32 architecture.\n\n2.1.12 The Intel® Xeon® Processor 5100, 5300 Series and Intel® Core™2 Processor Family \n(2006)\n\nThe Intel Xeon processor 3000, 3200, 5100, 5300, and 7300 series, Intel Pentium Dual-Core, Intel Core 2 Extreme, \nIntel Core 2 Quad processors, and Intel Core 2 Duo processor family support Intel 64 architecture; they are based \non the high-performance, power-efficient Intel® Core microarchitecture built on 65 nm process technology. The \nIntel Core microarchitecture includes the following innovative features:\n• Intel® Wide Dynamic Execution to increase performance and execution throughput\n• Intel® Intelligent Power Capability to reduce power consumption\n• Intel® Advanced Smart Cache which allows for efficient data sharing between two processor cores\n• Intel® Smart Memory Access to increase data bandwidth and hide latency of memory accesses\n• Intel® Advanced Digital Media Boost which improves application performance using multiple generations of \n\nStreaming SIMD extensions \n\nThe Intel Xeon processor 5300 series, Intel Core 2 Extreme processor QX6800 series, and Intel Core 2 Quad \nprocessors support Intel quad-core technology.\n\n2.1.13 The Intel® Xeon® Processor 5200, 5400, 7400 Series and Intel® Core™2 Processor \nFamily (2007)\n\nThe Intel Xeon processor 5200, 5400, and 7400 series, Intel Core 2 Quad processor Q9000 Series, Intel Core 2 Duo \nprocessor E8000 series support Intel 64 architecture; they are based on the Enhanced Intel® Core microarchitec-\n2-4 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nture using 45 nm process technology. The Enhanced Intel Core microarchitecture provides the following improved \nfeatures:\n• A radix-16 divider, faster OS primitives further increases the performance of Intel® Wide Dynamic Execution. \n• Improves Intel® Advanced Smart Cache with Up to 50% larger level-two cache and up to 50% increase in way-\n\nset associativity. \n• A 128-bit shuffler engine significantly improves the performance of Intel® Advanced Digital Media Boost and \n\nSSE4.\n\nIntel Xeon processor 5400 series and Intel Core 2 Quad processor Q9000 Series support Intel quad-core tech-\nnology. Intel Xeon processor 7400 series offers up to six processor cores and an L3 cache up to 16 MBytes.\n\n2.1.14 The Intel® Atom™ Processor Family (2008)\nThe first generation of Intel® AtomTM processors are built on 45 nm process technology. They are based on a new \nmicroarchitecture, Intel® AtomTM microarchitecture, which is optimized for ultra low power devices. The Intel® \nAtomTM microarchitecture features two in-order execution pipelines that minimize power consumption, increase \nbattery life, and enable ultra-small form factors. The initial Intel Atom Processor family and subsequent generations including \nIntel Atom processor D2000, N2000, E2000, Z2000, C1000 series provide the following features:\n• Enhanced Intel® SpeedStep® Technology\n• Intel® Hyper-Threading Technology\n• Deep Power Down Technology with Dynamic Cache Sizing\n• Support for instruction set extensions up to and including Supplemental Streaming SIMD Extensions 3 \n\n(SSSE3).\n• Support for Intel® Virtualization Technology\n• Support for Intel® 64 Architecture (excluding Intel Atom processor Z5xx Series)\n\n2.1.15 The Intel® Atom™ Processor Family Based on Silvermont Microarchitecture (2013)\nIntel Atom Processor C2xxx, E3xxx, S1xxx series are based on the Silvermont microarchitecture. Processors based on the Silvermont \nmicroarchitecture supports instruction set extensions up to and including SSE4.2, AESNI, and PCLMULQDQ.\n\n2.1.16 The Intel® Core™i7 Processor Family (2008)\nThe Intel Core i7 processor 900 series support Intel 64 architecture; they are based on Intel® microarchitecture \ncode name Nehalem using 45 nm process technology. The Intel Core i7 processor and Intel Xeon processor 5500 \nseries include the following innovative features:\n• Intel® Turbo Boost Technology converts thermal headroom into higher performance. \n• Intel® HyperThreading Technology in conjunction with Quadcore to provide four cores and eight threads. \n• Dedicated power control unit to reduce active and idle power consumption.\n• Integrated memory controller on the processor supporting three channel of DDR3 memory.\n• 8 MB inclusive Intel® Smart Cache.\n• Intel® QuickPath interconnect (QPI) providing point-to-point link to chipset.\n• Support for SSE4.2 and SSE4.1 instruction sets.\n• Second generation Intel Virtualization Technology.\n\n2.1.17 The Intel® Xeon® Processor 7500 Series (2010)\nThe Intel Xeon processor 7500 and 6500 series are based on Intel microarchitecture code name Nehalem using 45 \nnm process technology. They support the same features described in Section 2.1.16, plus the following innovative \nfeatures:\nVol. 1 2-5\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n• Up to eight cores per physical processor package.\n• Up to 24 MB inclusive Intel® Smart Cache.\n• Provides Intel® Scalable Memory Interconnect (Intel® SMI) channels with Intel® 7500 Scalable Memory Buffer \n\nto connect to system memory. \n• Advanced RAS supporting software recoverable machine check architecture.\n\n2.1.18 2010 Intel® Core™ Processor Family (2010)\n2010 Intel Core processor family spans Intel Core i7, i5 and i3 processors. They are based on Intel® microarchitec-\nture code name Westmere using 32 nm process technology. The innovative features can include:\n• Deliver smart performance using Intel Hyper-Threading Technology plus Intel Turbo Boost Technology. \n• Enhanced Intel Smart Cache and integrated memory controller.\n• Intelligent power gating.\n• Repartitioned platform with on-die integration of 45 nm integrated graphics.\n• Range of instruction set support up to AESNI, PCLMULQDQ, SSE4.2 and SSE4.1.\n\n2.1.19 The Intel® Xeon® Processor 5600 Series (2010)\nThe Intel Xeon processor 5600 series are based on Intel microarchitecture code name Westmere using 32 nm \nprocess technology. They support the same features described in Section 2.1.16, plus the following innovative \nfeatures:\n• Up to six cores per physical processor package.\n• Up to 12 MB enhanced Intel® Smart Cache.\n• Support for AESNI, PCLMULQDQ, SSE4.2 and SSE4.1 instruction sets.\n• Flexible Intel Virtualization Technologies across processor and I/O.\n\n2.1.20 The Second Generation Intel® Core™ Processor Family (2011)\nThe Second Generation Intel Core processor family spans Intel Core i7, i5 and i3 processors based on the Sandy \nBridge microarchitecture. They are built from 32 nm process technology and have innovative features including:\n• Intel Turbo Boost Technology for Intel Core i5 and i7 processors\n• Intel Hyper-Threading Technology. \n• Enhanced Intel Smart Cache and integrated memory controller.\n• Processor graphics and built-in visual features like Intel® Quick Sync Video, Intel® InsiderTM etc.\n• Range of instruction set support up to AVX, AESNI, PCLMULQDQ, SSE4.2 and SSE4.1.\n\nIntel Xeon processor E3-1200 product family is also based on the Sandy Bridge microarchitecture.\n\nIntel Xeon processor E5-2400/1400 product families are based on the Sandy Bridge-EP microarchitecture.\n\nIntel Xeon processor E5-4600/2600/1600 product families are based on the Sandy Bridge-EP microarchitecture \nand provide support for multiple sockets.\n\n2.1.21 The Third Generation Intel® Core™ Processor Family (2012)\nThe Third Generation Intel Core processor family spans Intel Core i7, i5 and i3 processors based on the Ivy Bridge \nmicroarchitecture. The Intel Xeon processor E7-8800/4800/2800 v2 product families and Intel Xeon processor E3-\n1200 v2 product family are also based on the Ivy Bridge microarchitecture.\n\nThe Intel Xeon processor E5-2400/1400 v2 product families are based on the Ivy Bridge-EP microarchitecture.\n2-6 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nThe Intel Xeon processor E5-4600/2600/1600 v2 product families are based on the Ivy Bridge-EP microarchitec-\nture and provide support for multiple sockets.\n\n2.1.22 The Fourth Generation Intel® Core™ Processor Family (2013)\nThe Fourth Generation Intel Core processor family spans Intel Core i7, i5 and i3 processors based on the Haswell \nmicroarchitecture. Intel Xeon processor E3-1200 v3 product family is also based on the Haswell microarchitecture.\n\n2.2 MORE ON SPECIFIC ADVANCES\nThe following sections provide more information on major innovations.\n\n2.2.1 P6 Family Microarchitecture\nThe Pentium Pro processor introduced a new microarchitecture commonly referred to as P6 processor microarchi-\ntecture. The P6 processor microarchitecture was later enhanced with an on-die, Level 2 cache, called Advanced \nTransfer Cache.\n\nThe microarchitecture is a three-way superscalar, pipelined architecture. Three-way superscalar means that by \nusing parallel processing techniques, the processor is able on average to decode, dispatch, and complete execution \nof (retire) three instructions per clock cycle. To handle this level of instruction throughput, the P6 processor family \nuses a decoupled, 12-stage superpipeline that supports out-of-order instruction execution. \n\nFigure 2-1 shows a conceptual view of the P6 processor microarchitecture pipeline with the Advanced Transfer \nCache enhancement. \n\nTo ensure a steady supply of instructions and data for the instruction execution pipeline, the P6 processor microar-\nchitecture incorporates two cache levels. The Level 1 cache provides an 8-KByte instruction cache and an 8-KByte \n\nFigure 2-1.  The P6 Processor Microarchitecture with Advanced Transfer Cache Enhancement\n\nBus Unit\n\n2nd Level Cache\nOn-die, 8-way\n\n1st  Level  Cache\n4-way, low latency\n\nFetch/\nDecode\n\nExecution\nInstruction\n\nCache\nMicrocode\n\nROM\n\nExecution\nOut-of-Order\n\nCore\nRetirement\n\nBTSs/Branch Prediction\n\nSystem Bus\n\nBranch  History  Update\n\nFrequently  used\n\nLess  frequently  used\n\nFront End\n\nOM16520\nVol. 1 2-7\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\ndata cache, both closely coupled to the pipeline. The Level 2 cache provides 256-KByte, 512-KByte, or 1-MByte \nstatic RAM that is coupled to the core processor through a full clock-speed 64-bit cache bus.\n\nThe centerpiece of the P6 processor microarchitecture is an out-of-order execution mechanism called dynamic \nexecution. Dynamic execution incorporates three data-processing concepts:\n• Deep branch prediction allows the processor to decode instructions beyond branches to keep the instruction \n\npipeline full. The P6 processor family implements highly optimized branch prediction algorithms to predict the \ndirection of the instruction.\n\n• Dynamic data flow analysis requires real-time analysis of the flow of data through the processor to \ndetermine dependencies and to detect opportunities for out-of-order instruction execution. The out-of-order \nexecution core can monitor many instructions and execute these instructions in the order that best optimizes \nthe use of the processor’s multiple execution units, while maintaining the data integrity.\n\n• Speculative execution refers to the processor’s ability to execute instructions that lie beyond a conditional \nbranch that has not yet been resolved, and ultimately to commit the results in the order of the original \ninstruction stream. To make speculative execution possible, the P6 processor microarchitecture decouples the \ndispatch and execution of instructions from the commitment of results. The processor’s out-of-order execution \ncore uses data-flow analysis to execute all available instructions in the instruction pool and store the results in \ntemporary registers. The retirement unit then linearly searches the instruction pool for completed instructions \nthat no longer have data dependencies with other instructions or unresolved branch predictions. When \ncompleted instructions are found, the retirement unit commits the results of these instructions to memory \nand/or the IA-32 registers (the processor’s eight general-purpose registers and eight x87 FPU data registers) \nin the order they were originally issued and retires the instructions from the instruction pool.\n\n2.2.2 Intel NetBurst® Microarchitecture\nThe Intel NetBurst microarchitecture provides:\n• The Rapid Execution Engine\n\n— Arithmetic Logic Units (ALUs) run at twice the processor frequency \n\n— Basic integer operations can dispatch in 1/2 processor clock tick\n• Hyper-Pipelined Technology\n\n— Deep pipeline to enable industry-leading clock rates for desktop PCs and servers\n\n— Frequency headroom and scalability to continue leadership into the future\n• Advanced Dynamic Execution\n\n— Deep, out-of-order, speculative execution engine\n\n• Up to 126 instructions in flight\n\n• Up to 48 loads and 24 stores in pipeline1\n\n— Enhanced branch prediction capability\n\n• Reduces the misprediction penalty associated with deeper pipelines \n\n• Advanced branch prediction algorithm\n\n• 4K-entry branch target array\n• New cache subsystem\n\n— First level caches\n\n• Advanced Execution Trace Cache stores decoded instructions\n\n• Execution Trace Cache removes decoder latency from main execution loops\n\n• Execution Trace Cache integrates path of program execution flow into a single line\n\n1. Intel 64 and IA-32 processors based on the Intel NetBurst microarchitecture at 90 nm process can handle more than 24 stores in \nflight.\n2-8 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n• Low latency data cache\n\n— Second level cache\n\n• Full-speed, unified 8-way Level 2 on-die Advance Transfer Cache\n\n• Bandwidth and performance increases with processor frequency\n• High-performance, quad-pumped bus interface to the Intel NetBurst microarchitecture system bus\n\n— Supports quad-pumped, scalable bus clock to achieve up to 4X effective speed\n\n— Capable of delivering up to 8.5 GBytes of bandwidth per second\n• Superscalar issue to enable parallelism\n• Expanded hardware registers with renaming to avoid register name space limitations\n• 64-byte cache line size (transfers data up to two lines per sector)\n\nFigure 2-2 is an overview of the Intel NetBurst microarchitecture. This microarchitecture pipeline is made up of \nthree sections: (1) the front end pipeline, (2) the out-of-order execution core, and (3) the retirement unit. \n\n2.2.2.1  The Front End Pipeline\nThe front end supplies instructions in program order to the out-of-order execution core. It performs a number of \nfunctions:\n• Prefetches instructions that are likely to be executed\n• Fetches instructions that have not already been prefetched\n• Decodes instructions into micro-operations\n• Generates microcode for complex instructions and special-purpose code\n• Delivers decoded instructions from the execution trace cache\n\nFigure 2-2.  The Intel NetBurst Microarchitecture\n\nFetch/Decode Trace Cache\nMicrocode ROM\n\nExecution\nOut-Of-Order\n\nCore\nRetirement\n\n1st Level Cache\n4-way\n\n2nd Level Cache\n 8-Way\n\nBTBs/Branch Prediction\n\nBus Unit\n\nSystem Bus\nFrequently used paths\n\nLess frequently used\npaths\n\nFront End\n\n3rd Level  Cache\nOptional\n\nBranch History Update\n\nOM16521\nVol. 1 2-9\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n• Predicts branches using highly advanced algorithm\n\nThe pipeline is designed to address common problems in high-speed, pipelined microprocessors. Two of these \nproblems contribute to major sources of delays:\n• time to decode instructions fetched from the target\n• wasted decode bandwidth due to branches or branch target in the middle of cache lines\n\nThe operation of the pipeline’s trace cache addresses these issues. Instructions are constantly being fetched and \ndecoded by the translation engine (part of the fetch/decode logic) and built into sequences of micro-ops called \ntraces. At any time, multiple traces (representing prefetched branches) are being stored in the trace cache. The \ntrace cache is searched for the instruction that follows the active branch. If the instruction also appears as the first \ninstruction in a pre-fetched branch, the fetch and decode of instructions from the memory hierarchy ceases and the \npre-fetched branch becomes the new source of instructions (see Figure 2-2).\n\nThe trace cache and the translation engine have cooperating branch prediction hardware. Branch targets are \npredicted based on their linear addresses using branch target buffers (BTBs) and fetched as soon as possible.\n\n2.2.2.2  Out-Of-Order Execution Core\nThe out-of-order execution core’s ability to execute instructions out of order is a key factor in enabling parallelism. \nThis feature enables the processor to reorder instructions so that if one micro-op is delayed, other micro-ops may \nproceed around it. The processor employs several buffers to smooth the flow of micro-ops.\n\nThe core is designed to facilitate parallel execution. It can dispatch up to six micro-ops per cycle (this exceeds trace \ncache and retirement micro-op bandwidth). Most pipelines can start executing a new micro-op every cycle, so \nseveral instructions can be in flight at a time for each pipeline. A number of arithmetic logical unit (ALU) instruc-\ntions can start at two per cycle; many floating-point instructions can start once every two cycles. \n\n2.2.2.3  Retirement Unit\nThe retirement unit receives the results of the executed micro-ops from the out-of-order execution core and \nprocesses the results so that the architectural state updates according to the original program order. \n\nWhen a micro-op completes and writes its result, it is retired. Up to three micro-ops may be retired per cycle. The \nReorder Buffer (ROB) is the unit in the processor which buffers completed micro-ops, updates the architectural \nstate in order, and manages the ordering of exceptions. The retirement section also keeps track of branches and \nsends updated branch target information to the BTB. The BTB then purges pre-fetched traces that are no longer \nneeded.\n\n2.2.3 Intel® Core™ Microarchitecture\nIntel Core microarchitecture introduces the following features that enable high performance and power-efficient \nperformance for single-threaded as well as multi-threaded workloads:\n• Intel® Wide Dynamic Execution enable each processor core to fetch, dispatch, execute in high bandwidths \n\nto support retirement of up to four instructions per cycle.\n\n— Fourteen-stage efficient pipeline\n\n— Three arithmetic logical units\n\n— Four decoders to decode up to five instruction per cycle \n\n— Macro-fusion and micro-fusion to improve front-end throughput\n\n— Peak issue rate of dispatching up to six micro-ops per cycle\n\n— Peak retirement bandwidth of up to 4 micro-ops per cycle\n\n— Advanced branch prediction\n\n— Stack pointer tracker to improve efficiency of executing function/procedure entries and exits\n• Intel® Advanced Smart Cache delivers higher bandwidth from the second level cache to the core, and \n\noptimal performance and flexibility for single-threaded and multi-threaded applications.\n2-10 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n— Large second level cache up to 4 MB and 16-way associativity\n\n— Optimized for multicore and single-threaded execution environments\n\n— 256 bit internal data path to improve bandwidth from L2 to first-level data cache\n• Intel® Smart Memory Access prefetches data from memory in response to data access patterns and reduces \n\ncache-miss exposure of out-of-order execution.\n\n— Hardware prefetchers to reduce effective latency of second-level cache misses\n\n— Hardware prefetchers to reduce effective latency of first-level data cache misses\n\n— Memory disambiguation to improve efficiency of speculative execution execution engine\n• Intel® Advanced Digital Media Boost improves most 128-bit SIMD instruction with single-cycle throughput \n\nand floating-point operations.\n\n— Single-cycle throughput of most 128-bit SIMD instructions\n\n— Up to eight floating-point operation per cycle\n\n— Three issue ports available to dispatching SIMD instructions for execution\n\nIntel Core 2 Extreme, Intel Core 2 Duo processors and Intel Xeon processor 5100 series implement two processor \ncores based on the Intel Core microarchitecture, the functionality of the subsystems in each core are depicted in \nFigure 2-3. \n\n2.2.3.1  The Front End\nThe front end of Intel Core microarchitecture provides several enhancements to feed the Intel Wide Dynamic \nExecution engine:\n• Instruction fetch unit prefetches instructions into an instruction queue to maintain steady supply of instruction \n\nto the decode units.\n• Four-wide decode unit can decode 4 instructions per cycle or 5 instructions per cycle with Macrofusion.\n\nFigure 2-3.  The Intel Core Microarchitecture Pipeline Functionality\n\nDecode\n\nALU\nBranch\n\nMMX/SSE/FP\nMove\n\nLoad\n\nShared L2 Cache\nUp to 10.7 GB/s \n\nFSB\n\nRetirement Unit \n(Re-Order Buffer)\n\nL1D Cache and DTLB\n\nInstruction Fetch and PreDecode\n\nInstruction Queue\n\nRename/Alloc\n\nALU\nFAdd\n\nMMX/SSE\n\nALU\nFMul\n\nMMX/SSE\n\nScheduler\n\nMicro-\ncode \nROM\n\nStore\nVol. 1 2-11\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n• Macrofusion fuses common sequence of two instructions as one decoded instruction (micro-ops) to increase \ndecoding throughput.\n\n• Microfusion fuses common sequence of two micro-ops as one micro-ops to improve retirement throughput.\n• Instruction queue provides caching of short loops to improve efficiency.\n• Stack pointer tracker improves efficiency of executing procedure/function entries and exits.\n• Branch prediction unit employs dedicated hardware to handle different types of branches for improved branch \n\nprediction.\n• Advanced branch prediction algorithm directs instruction fetch unit to fetch instructions likely in the architec-\n\ntural code path for decoding.\n\n2.2.3.2  Execution Core \nThe execution core of the Intel Core microarchitecture is superscalar and can process instructions out of order to \nincrease the overall rate of instructions executed per cycle (IPC). The execution core employs the following feature \nto improve execution throughput and efficiency:\n• Up to six micro-ops can be dispatched to execute per cycle\n• Up to four instructions can be retired per cycle\n• Three full arithmetic logical units\n• SIMD instructions can be dispatched through three issue ports\n• Most SIMD instructions have 1-cycle throughput (including 128-bit SIMD instructions)\n• Up to eight floating-point operation per cycle\n• Many long-latency computation operation are pipelined in hardware to increase overall throughput\n• Reduced exposure to data access delays using Intel Smart Memory Access\n\n2.2.4 Intel® Atom™ Microarchitecture\nIntel Atom microarchitecture maximizes power-efficient performance for single-threaded and multi-threaded \nworkloads by providing:\n• Advanced Micro-Ops Execution \n\n— Single-micro-op instruction execution from decode to retirement, including instructions with register-only, \nload, and store semantics.\n\n— Sixteen-stage, in-order pipeline optimized for throughput and reduced power consumption.\n\n— Dual pipelines to enable decode, issue, execution and retirement of two instructions per cycle.\n\n— Advanced stack pointer to improve efficiency of executing function entry/returns.\n• Intel® Smart Cache\n\n— Second level cache is 512 KB and 8-way associativity.\n\n— Optimized for multi-threaded and single-threaded execution environments\n\n— 256 bit internal data path between L2 and L1 data cache improves high bandwidth.\n• Efficient Memory Access\n\n— Efficient hardware prefetchers to L1 and L2, speculatively loading data likely to be requested by processor \nto reduce cache miss impact.\n\n• Intel® Digital Media Boost\n\n— Two issue ports for dispatching SIMD instructions to execution units.\n\n— Single-cycle throughput for most 128-bit integer SIMD instructions\n\n— Up to six floating-point operations per cycle\n\n— Up to two 128-bit SIMD integer operations per cycle\n2-12 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n— Safe Instruction Recognition (SIR) to allow long-latency floating-point operations to retire out of order with \nrespect to integer instructions.\n\n2.2.5 Intel® Microarchitecture Code Name Nehalem\nIntel microarchitecture code name Nehalem provides the foundation for many innovative features of Intel Core i7 \nprocessors. It builds on the success of 45 nm Intel Core microarchitecture and provides the following feature \nenhancements:\n• Enhanced processor core\n\n— Improved branch prediction and recovery from misprediction.\n\n— Enhanced loop streaming to improve front end performance and reduce power consumption.\n\n— Deeper buffering in out-of-order engine to extract parallelism.\n\n— Enhanced execution units to provide acceleration in CRC, string/text processing and data shuffling.\n• Smart Memory Access\n\n— Integrated memory controller provides low-latency access to system memory and scalable memory \nbandwidth\n\n— New cache hierarchy organization with shared, inclusive L3 to reduce snoop traffic\n\n— Two level TLBs and increased TLB size.\n\n— Fast unaligned memory access.\n• HyperThreading Technology\n\n— Provides two hardware threads (logical processors) per core.\n\n— Takes advantage of 4-wide execution engine, large L3, and massive memory bandwidth.\n• Dedicated Power management Innovations\n\n— Integrated microcontroller with optimized embedded firmware to manage power consumption.\n\n— Embedded real-time sensors for temperature, current, and power.\n\n— Integrated power gate to turn off/on per-core power consumption\n\n— Versatility to reduce power consumption of memory, link subsystems.\n\n2.2.6 Intel® Microarchitecture Code Name Sandy Bridge\nIntel® microarchitecture code name Sandy Bridge builds on the successes of Intel® Core™ microarchitecture and \nIntel microarchitecture code name Nehalem. It offers the following innovative features:\n• Intel Advanced Vector Extensions (Intel AVX)\n\n— 256-bit floating-point instruction set extensions to the 128-bit Intel Streaming SIMD Extensions, providing \nup to 2X performance benefits relative to 128-bit code.\n\n— Non-destructive destination encoding offers more flexible coding techniques.\n\n— Supports flexible migration and co-existence between 256-bit AVX code, 128-bit AVX code and legacy 128-\nbit SSE code.\n\n• Enhanced front-end and execution engine\n\n— New decoded Icache component that improves front-end bandwidth and reduces branch misprediction \npenalty.\n\n— Advanced branch prediction.\n\n— Additional macro-fusion support.\n\n— Larger dynamic execution window.\n\n— Multi-precision integer arithmetic enhancements (ADC/SBB, MUL/IMUL).\nVol. 1 2-13\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n— LEA bandwidth improvement.\n\n— Reduction of general execution stalls (read ports, writeback conflicts, bypass latency, partial stalls).\n\n— Fast floating-point exception handling.\n\n— XSAVE/XRSTORE performance improvements and XSAVEOPT new instruction.\n• Cache hierarchy improvements for wider data path\n\n— Doubling of bandwidth enabled by two symmetric ports for memory operation.\n\n— Simultaneous handling of more in-flight loads and stores enabled by increased buffers.\n\n— Internal bandwidth of two loads and one store each cycle.\n\n— Improved prefetching.\n\n— High bandwidth low latency LLC architecture.\n\n— High bandwidth ring architecture of on-die interconnect.\n\nFor additional information on Intel® Advanced Vector Extensions (AVX), see Section 5.13, “Intel® Advanced Vector \nExtensions (Intel® AVX)” and Chapter 14, “Programming with AVX, FMA and AVX2” in Intel® 64 and IA-32 Archi-\ntectures Software Developer’s Manual, Volume 1.\n\n2.2.7 SIMD Instructions\nBeginning with the Pentium II and Pentium with Intel MMX technology processor families, six extensions have been \nintroduced into the Intel 64 and IA-32 architectures to perform single-instruction multiple-data (SIMD) operations. \nThese extensions include the MMX technology, SSE extensions, SSE2 extensions, SSE3 extensions, Supplemental \nStreaming SIMD Extensions 3, and SSE4. Each of these extensions provides a group of instructions that perform \nSIMD operations on packed integer and/or packed floating-point data elements. \n\nSIMD integer operations can use the 64-bit MMX or the 128-bit XMM registers. SIMD floating-point operations use \n128-bit XMM registers. Figure 2-4 shows a summary of the various SIMD extensions (MMX technology, SSE, SSE2, \nSSE3, SSSE3, and SSE4), the data types they operate on, and how the data types are packed into MMX and XMM \nregisters.\n\nThe Intel MMX technology was introduced in the Pentium II and Pentium with MMX technology processor families. \nMMX instructions perform SIMD operations on packed byte, word, or doubleword integers located in MMX registers. \nThese instructions are useful in applications that operate on integer arrays and streams of integer data that lend \nthemselves to SIMD processing.\n\nSSE extensions were introduced in the Pentium III processor family. SSE instructions operate on packed single-\nprecision floating-point values contained in XMM registers and on packed integers contained in MMX registers. \nSeveral SSE instructions provide state management, cache control, and memory ordering operations. Other SSE \ninstructions are targeted at applications that operate on arrays of single-precision floating-point data elements (3-\nD geometry, 3-D rendering, and video encoding and decoding applications).\n\nSSE2 extensions were introduced in Pentium 4 and Intel Xeon processors. SSE2 instructions operate on packed \ndouble-precision floating-point values contained in XMM registers and on packed integers contained in MMX and \nXMM registers. SSE2 integer instructions extend IA-32 SIMD operations by adding new 128-bit SIMD integer oper-\nations and by expanding existing 64-bit SIMD integer operations to 128-bit XMM capability. SSE2 instructions also \nprovide new cache control and memory ordering operations.\n\nSSE3 extensions were introduced with the Pentium 4 processor supporting Hyper-Threading Technology (built on \n90 nm process technology). SSE3 offers 13 instructions that accelerate performance of Streaming SIMD Extensions \ntechnology, Streaming SIMD Extensions 2 technology, and x87-FP math capabilities.\n\nSSSE3 extensions were introduced with the Intel Xeon processor 5100 series and Intel Core 2 processor family. \nSSSE3 offer 32 instructions to accelerate processing of SIMD integer data.\n\nSSE4 extensions offer 54 instructions. 47 of them are referred to as SSE4.1 instructions. SSE4.1 are introduced \nwith Intel Xeon processor 5400 series and Intel Core 2 Extreme processor QX9650. The other 7 SSE4 instructions \nare referred to as SSE4.2 instructions.\n2-14 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nAESNI and PCLMULQDQ introduce 7 new instructions. Six of them are primitives for accelerating algorithms based \non AES encryption/decryption standard, referred to as AESNI.\n\nThe PCLMULQDQ instruction accelerates general-purpose block encryption, which can perform carry-less multipli-\ncation for two binary numbers up to 64-bit wide.\n\nIntel 64 architecture allows four generations of 128-bit SIMD extensions to access up to 16 XMM registers. IA-32 \narchitecture provides 8 XMM registers.\n\nIntel® Advanced Vector Extensions offers comprehensive architectural enhancements over previous generations of \nStreaming SIMD Extensions. Intel AVX introduces the following architectural enhancements:\n• Support for 256-bit wide vectors and SIMD register set.\n• 256-bit floating-point instruction set enhancement with up to 2X performance gain relative to 128-bit \n\nStreaming SIMD extensions.\n• Instruction syntax support for generalized three-operand syntax to improve instruction programming flexibility \n\nand efficient encoding of new instruction extensions.\n• Enhancement of legacy 128-bit SIMD instruction extensions to support three operand syntax and to simplify \n\ncompiler vectorization of high-level language expressions.\n• Support flexible deployment of 256-bit AVX code, 128-bit AVX code, legacy 128-bit code and scalar code.\nIn addition to performance considerations, programmers should also be cognizant of the implications of VEX-\nencoded AVX instructions with the expectations of system software components that manage the processor state \ncomponents enabled by XCR0. For additional information see Section 2.3.10.1, “Vector Length Transition and \nProgramming Considerations” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A.\n\nSee also: \n• Section 5.4, “MMX™ Instructions,” and Chapter 9, “Programming with Intel® MMX™ Technology”\n• Section 5.5, “SSE Instructions,” and Chapter 10, “Programming with Intel® Streaming SIMD Extensions \n\n(Intel® SSE)”\n• Section 5.6, “SSE2 Instructions,” and Chapter 11, “Programming with Intel® Streaming SIMD Extensions 2 \n\n(Intel® SSE2)”\n• Section 5.7, “SSE3 Instructions”, Section 5.8, “Supplemental Streaming SIMD Extensions 3 (SSSE3) Instruc-\n\ntions”, Section 5.9, “SSE4 Instructions”, and Chapter 12, “Programming with Intel® SSE3, SSSE3, Intel® \nSSE4 and Intel® AESNI”\nVol. 1 2-15\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.2.8 Intel® Hyper-Threading Technology\nIntel Hyper-Threading Technology (Intel HT Technology) was developed to improve the performance of IA-32 \nprocessors when executing multi-threaded operating system and application code or single-threaded applications \nunder multi-tasking environments. The technology enables a single physical processor to execute two or more \nseparate code streams (threads) concurrently using shared execution resources. \n\nIntel HT Technology is one form of hardware multi-threading capability in IA-32 processor families. It differs from \nmulti-processor capability using separate physically distinct packages with each physical processor package mated \nwith a physical socket. Intel HT Technology provides hardware multi-threading capability with a single physical \npackage by using shared execution resources in a processor core.\n\nArchitecturally, an IA-32 processor that supports Intel HT Technology consists of two or more logical processors, \neach of which has its own IA-32 architectural state. Each logical processor consists of a full set of IA-32 data regis-\nters, segment registers, control registers, debug registers, and most of the MSRs. Each also has its own advanced \nprogrammable interrupt controller (APIC). \n\nFigure 2-5 shows a comparison of a processor that supports Intel HT Technology (implemented with two logical \nprocessors) and a traditional dual processor system. \n\nFigure 2-4.  SIMD Extensions, Register Layouts, and Data Types\n\n4 Packed Word Integers\n\n8 Packed Byte Integers\n\n2 Packed Doubleword Integers\n\nMMX Registers\n\nQuadword\n\nMMX Technology - SSSE3\n\nData TypeRegister LayoutSIMD Extension\n\nSSE - AVX\n\n4 Packed Single-Precision\nFloating-Point Values\n\n2 Packed Double-Precision\nFloating-Point Values\n\n8 Packed Word Integers\n\n16 Packed Byte Integers\n\n4 Packed Doubleword\n\n2 Quadword Integers\n\nDouble Quadword\n\nIntegers\n\nXMM Registers\n\n8 Packed SP FP Values\n\n4 Packed DP FP Values\n\nYMM Registers\nAVX\n\n2 128-bit Data\n2-16 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nUnlike a traditional MP system configuration that uses two or more separate physical IA-32 processors, the logical \nprocessors in an IA-32 processor supporting Intel HT Technology share the core resources of the physical \nprocessor. This includes the execution engine and the system bus interface. After power up and initialization, each \nlogical processor can be independently directed to execute a specified thread, interrupted, or halted.\n\nIntel HT Technology leverages the process and thread-level parallelism found in contemporary operating systems \nand high-performance applications by providing two or more logical processors on a single chip. This configuration \nallows two or more threads1 to be executed simultaneously on each a physical processor. Each logical processor \nexecutes instructions from an application thread using the resources in the processor core. The core executes \nthese threads concurrently, using out-of-order instruction scheduling to maximize the use of execution units during \neach clock cycle.\n\n2.2.8.1  Some Implementation Notes\nAll Intel HT Technology configurations require:\n• A processor that supports Intel HT Technology\n• A chipset and BIOS that utilize the technology\n• Operating system optimizations\n\nSee http://www.intel.com/products/ht/hyperthreading_more.htm for information.\n\nAt the firmware (BIOS) level, the basic procedures to initialize the logical processors in a processor supporting Intel \nHT Technology are the same as those for a traditional DP or MP platform. The mechanisms that are described in the \nMultiprocessor Specification, Version 1.4 to power-up and initialize physical processors in an MP system also apply \nto logical processors in a processor that supports Intel HT Technology. \n\nAn operating system designed to run on a traditional DP or MP platform may use CPUID to determine the presence \nof hardware multi-threading support feature and the number of logical processors they provide.\n\nAlthough existing operating system and application code should run correctly on a processor that supports Intel HT \nTechnology, some code modifications are recommended to get the optimum benefit. These modifications are \ndiscussed in Chapter 7, “Multiple-Processor Management,” Intel® 64 and IA-32 Architectures Software Devel-\noper’s Manual, Volume 3A.\n\nFigure 2-5.  Comparison of an IA-32 Processor Supporting Hyper-Threading Technology and a Traditional Dual \nProcessor System\n\n1. In the remainder of this document, the term “thread” will be used as a general term for the terms “process” and “thread.”\n\nProcessor Core Processor CoreProcessor Core\n\nAS ASASAS\n\nTraditional Multiple Processor (MP) SystemIA-32 Processor Supporting\nHyper-Threading Technology\n\nAS = IA-32 Architectural State\n\nIA-32 processor IA-32 processor\n\nTwo logical \nprocessors that share \na single core\n\nEach processor is a \nseparate physical \npackage\n\nIA-32 processor\n\nOM16522\nVol. 1 2-17\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.2.9 Multi-Core Technology\nMulti-core technology is another form of hardware multi-threading capability in IA-32 processor families. Multi-core \ntechnology enhances hardware multi-threading capability by providing two or more execution cores in a physical \npackage.\n\nThe Intel Pentium processor Extreme Edition is the first member in the IA-32 processor family to introduce multi-\ncore technology. The processor provides hardware multi-threading support with both two processor cores and Intel \nHyper-Threading Technology. This means that the Intel Pentium processor Extreme Edition provides four logical \nprocessors in a physical package (two logical processors for each processor core). The Dual-Core Intel Xeon \nprocessor features multi-core, Intel Hyper-Threading Technology and supports multi-processor platforms. \n\nThe Intel Pentium D processor also features multi-core technology. This processor provides hardware multi-\nthreading support with two processor cores but does not offer Intel Hyper-Threading Technology. This means that \nthe Intel Pentium D processor provides two logical processors in a physical package, with each logical processor \nowning the complete execution resources of a processor core.\n\nThe Intel Core 2 processor family, Intel Xeon processor 3000 series, Intel Xeon processor 5100 series, and Intel \nCore Duo processor offer power-efficient multi-core technology. The processor contains two cores that share a \nsmart second level cache. The Level 2 cache enables efficient data sharing between two cores to reduce memory \ntraffic to the system bus.\n\nThe Pentium® dual-core processor is based on the same technology as the Intel Core 2 Duo processor family.\n\nThe Intel Xeon processor 7300, 5300 and 3200 series, Intel Core 2 Extreme Quad-Core processor, and Intel Core 2 \nQuad processors support Intel quad-core technology. The Quad-core Intel Xeon processors and the Quad-Core \nIntel Core 2 processor family are also in Figure 2-7. \n\nFigure 2-6.  Intel 64 and IA-32 Processors that Support Dual-Core \n\nArchitectual \nState\n\nSystem Bus\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual \nState\n\nBus Interface Bus Interface\n\nLocal APIC Local APIC\n\nArchitectual \nState\n\nArchitectual \nState\n\nPentium Processor Extreme Edition\nSystem Bus\n\nArchitectual State\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual State\n\nBus Interface\n\nIntel Core Duo Processor\nIntel Core 2 Duo Processor\n\nIntel Pentium dual-core Processor\n\nSecond Level Cache\n\nArchitectual State\n\nSystem Bus\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual State\n\nBus Interface Bus Interface\n\nPentium D Processor\n\nOM19809\n2-18 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Core i7 processors support Intel quad-core technology, Intel HyperThreading Technology, provides Intel \nQuickPath interconnect link to the chipset and have integrated memory controller supporting three channel to \nDDR3 memory.\n\nFigure 2-7.  Intel 64 Processors that Support Quad-Core \n\nFigure 2-8.  Intel Core i7 Processor \n\nSystem Bus\n\nIntel Core 2 Extreme Quad-core Processor\nIntel Core 2 Quad Processor\n\nIntel Xeon Processor 3200 Series\nIntel Xeon Processor 5300 Series\n\nArchitectual State\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual State\n\nBus Interface\n\nSecond Level Cache\n\nArchitectual State\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual State\n\nBus Interface\n\nSecond Level Cache\n\nOM19810\n\nChipset\n\nIntel Core i7  Processor\n\nQPI\n\nLogical \nProces\n\nsor\n\nL1 and L2\n\nExecution Engine Execution Engine\n\nL1 and L2 L1 and L2\n\nExecution Engine Execution Engine\n\nL1 and L2\n\nQuickPath Interconnect (QPI) Interface, Integrated Memory Controller\n\nThird Level Cache\n\nOM19810b\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nDDR3\n\nIMC\nVol. 1 2-19\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.2.10 Intel® 64 Architecture\nIntel 64 architecture increases the linear address space for software to 64 bits and supports physical address space \nup to 52 bits. The technology also introduces a new operating mode referred to as IA-32e mode.\n\nIA-32e mode operates in one of two sub-modes: (1) compatibility mode enables a 64-bit operating system to run \nmost legacy 32-bit software unmodified, (2) 64-bit mode enables a 64-bit operating system to run applications \nwritten to access 64-bit address space. \n\nIn the 64-bit mode, applications may access:\n• 64-bit flat linear addressing\n• 8 additional general-purpose registers (GPRs)\n• 8 additional registers for streaming SIMD extensions (SSE, SSE2, SSE3 and SSSE3)\n• 64-bit-wide GPRs and instruction pointers\n• uniform byte-register addressing\n• fast interrupt-prioritization mechanism\n• a new instruction-pointer relative-addressing mode\n\nAn Intel 64 architecture processor supports existing IA-32 software because it is able to run all non-64-bit legacy \nmodes supported by IA-32 architecture. Most existing IA-32 applications also run in compatibility mode.\n\n2.2.11 Intel® Virtualization Technology (Intel® VT)\nIntel® Virtualization Technology for Intel 64 and IA-32 architectures provide extensions that support virtualization. \nThe extensions are referred to as Virtual Machine Extensions (VMX). An Intel 64 or IA-32 platform with VMX can \nfunction as multiple virtual systems (or virtual machines). Each virtual machine can run operating systems and \napplications in separate partitions. \n\nVMX also provides programming interface for a new layer of system software (called the Virtual Machine Monitor \n(VMM)) used to manage the operation of virtual machines. Information on VMX and on the programming of VMMs \nis in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C.\n\nIntel Core i7 processor provides the following enhancements to Intel Virtualization Technology:\n• Virtual processor ID (VPID) to reduce the cost of VMM managing transitions.\n• Extended page table (EPT) to reduce the number of transitions for VMM to manage memory virtualization.\n• Reduced latency of VM transitions.\n\n2.3 INTEL® 64 AND IA-32 PROCESSOR GENERATIONS\nIn the mid-1960s, Intel cofounder and Chairman Emeritus Gordon Moore had this observation: “... the number of \ntransistors that would be incorporated on a silicon die would double every 18 months for the next several years.” \nOver the past three and half decades, this prediction known as “Moore's Law” has continued to hold true.\n\nThe computing power and the complexity (or roughly, the number of transistors per processor) of Intel architecture \nprocessors has grown in close relation to Moore's law. By taking advantage of new process technology and new \nmicroarchitecture designs, each new generation of IA-32 processors has demonstrated frequency-scaling head-\nroom and new performance levels over the previous generation processors.\n2-20 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nThe key features of the Intel Pentium 4 processor, Intel Xeon processor, Intel Xeon processor MP, Pentium III \nprocessor, and Pentium III Xeon processor with advanced transfer cache are shown in Table 2-1. Older generation \nIA-32 processors, which do not employ on-die Level 2 cache, are shown in Table 2-2. \n\nTable 2-1.  Key Features of Most Recent IA-32 Processors \n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architecture Top-Bin Clock \nFre-quency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes1\n\nNOTES:\n1. The register size and external data bus size are given in bits.\n\nSystem \nBus Band-\nwidth\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches2\n\n2. First level cache is denoted using the abbreviation L1, 2nd level cache is denoted as L2. The size\nof L1 includes the first-level data cache and the instruction cache where applicable, but \ndoes not include the trace cache.\n\nIntel Pentium \nM\nProcessor \n7553\n\n3. Intel processor numbers are not a measure of performance. Processor numbers differentiate \nfeatures within each processor family, not across different processor families. \nSee http://www.intel.com/products/processor_number for details.\n\n2004 Intel Pentium M \nProcessor\n\n2.00 GHz 140 M GP: 32 \nFPU: 80 \nMMX: 64\nXMM: 128\n\n3.2 GB/s 4 GB L1: 64 KB\nL2: 2 MB\n\nIntel Core Duo\nProcessor \nT26003\n\n2006 Improved Intel \nPentium M \nProcessor \nMicroarchitecture; \nDual Core;\n\nIntel Smart Cache, \nAdvanced Thermal \nManager\n\n2.16 GHz  152M GP: 32 \nFPU: 80 \nMMX: 64\nXMM: 128\n\n5.3 GB/s 4 GB L1: 64 KB\nL2: 2 MB \n(2MB Total)\n\nIntel Atom\nProcessor \nZ5xx series\n\n2008 Intel Atom \nMicroarchitecture; \n\nIntel Virtualization \nTechnology.\n\n1.86 GHz - \n800 MHz\n\n 47M GP: 32 \nFPU: 80 \nMMX: 64\nXMM: 128\n\nUp to 4.2 \nGB/s\n\n4 GB L1: 56 KB4\n\nL2: 512KB \n\n4. In Intel Atom Processor, the size of L1 instruction cache is 32 KBytes, L1 data cache is 24 KBytes.\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\n\n64-bit Intel \nXeon\nProcessor \nwith 800 MHz \nSystem Bus\n\n2004 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture\n\n3.60 GHz 125 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n6.4 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n1 MB L2\n\n64-bit Intel \nXeon\nProcessor MP \nwith 8MB L3\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture \n\n3.33 GHz 675M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n5.3 GB/s 1 1024 GB \n(1 TB)\n\n12K µop \nExecution \nTrace Cache;\n16 KB L1;\n1 MB L2,\n8 MB L3\nVol. 1 2-21\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Pentium \n4\nProcessor \nExtreme \nEdition \nSupporting \nHyper-\nThreading \nTechnology\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture \n\n3.73 GHz 164 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n2 MB L2\n\nIntel Pentium \nProcessor \nExtreme \nEdition 840\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture;\n\nDual-core 2\n\n3.20 GHz 230 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n6.4 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n1MB L2 \n(2MB Total)\n\nDual-Core Intel \nXeon \nProcessor \n7041\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture;\n\nDual-core 3\n\n3.00 GHz  321M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n6.4 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n2MB L2 \n(4MB Total)\n\nIntel Pentium \n4\nProcessor 672\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n3.80 GHz 164 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n6.4 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n2MB L2 \n\nIntel Pentium \nProcessor \nExtreme \nEdition 955\n\n2006 Intel NetBurst \nMicroarchitecture; \nIntel 64 \nArchitecture; Dual \nCore;\n\nIntel Virtualization \nTechnology.\n\n3.46 GHz  376M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n2MB L2 \n\n(4MB Total)\n\nIntel Core 2 \nExtreme \nProcessor \nX6800\n\n2006 Intel Core \nMicroarchitecture; \nDual Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.93 GHz  291M GP: 32,64 \nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 64 GB L1: 64 KB\nL2: 4MB \n(4MB Total)\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\n2-22 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Xeon\nProcessor \n5160\n\n2006 Intel Core \nMicroarchitecture; \nDual Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n3.00 GHz  291M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n10.6 GB/s 64 GB L1: 64 KB\nL2: 4MB \n(4MB Total)\n\nIntel Xeon\nProcessor \n7140\n\n2006 Intel NetBurst \nMicroarchitecture; \nDual Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n3.40 GHz  1.3 B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n12.8 GB/s 64 GB L1: 64 KB\nL2: 1MB \n(2MB Total)\n\nL3: 16 MB \n(16MB Total)\n\nIntel Core 2 \nExtreme \nProcessor \nQX6700\n\n2006 Intel Core \nMicroarchitecture; \nQuad Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.66 GHz 582M GP: 32,64 \nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 64 GB L1: 64 KB\nL2: 4MB \n(4MB Total)\n\nQuad-core \nIntel Xeon\nProcessor \n5355\n\n2006 Intel Core \nMicroarchitecture; \nQuad Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.66 GHz 582 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n10.6 GB/s 256 GB L1: 64 KB\nL2: 4MB (8 \nMB Total)\n\nIntel Core 2 \nDuo Processor \nE6850\n\n2007 Intel Core \nMicroarchitecture; \nDual Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology;\n\nIntel Trusted \nExecution \nTechnology\n\n3.00 GHz 291 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n10.6 GB/s 64 GB L1: 64 KB\nL2: 4MB \n(4MB Total)\n\nIntel Xeon\nProcessor \n7350\n\n2007 Intel Core \nMicroarchitecture; \nQuad Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.93 GHz  582 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 1024 GB L1: 64 KB\nL2: 4MB \n(8MB Total)\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\nVol. 1 2-23\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Xeon\nProcessor \n5472\n\n2007 Enhanced Intel \nCore \nMicroarchitecture; \nQuad Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n3.00 GHz  820 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n12.8 GB/s 256 GB L1: 64 KB\nL2: 6MB \n(12MB Total)\n\nIntel Atom\nProcessor\n\n2008 Intel Atom \nMicroarchitecture; \nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.0 - 1.60 \nGHz\n\n47 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nUp to 4.2 \nGB/s\n\nUp to \n64GB\n\nL1: 56 KB4\n\nL2: 512KB \n\nIntel Xeon\nProcessor \n7460\n\n2008 Enhanced Intel \nCore \nMicroarchitecture; \nSix Cores; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.67 GHz  1.9 B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 1024 GB L1: 64 KB\nL2: 3MB \n(9MB Total)\n\nL3: 16MB\n\nIntel Atom\nProcessor 330\n\n2008 Intel Atom \nMicroarchitecture; \nIntel 64 \nArchitecture;\n\nDual core;\n\nIntel Virtualization \nTechnology.\n\n1.60 GHz 94 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nUp to 4.2 \nGB/s\n\nUp to \n64GB\n\nL1: 56 KB5\n\nL2: 512KB \n(1MB Total)\n\nIntel Core i7-\n965\nProcessor \nExtreme \nEdition\n\n2008 Intel \nmicroarchitecture \ncode name \nNehalem; \nQuadcore; \nHyperThreading \nTechnology; Intel \nQPI; Intel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n3.20 GHz  731 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nQPI: 6.4 \nGT/s; \nMemory: \n25 GB/s \n\n64 GB L1: 64 KB\nL2: 256KB \n\nL3: 8MB\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\n2-24 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Core i7-\n620M\nProcessor \n\n2010 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name \nWestmere; \nDualcore; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology., \nIntegrated graphics\n\n2.66 GHz  383 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n64 GB L1: 64 KB\nL2: 256KB \n\nL3: 4MB\n\nIntel Xeon-\nProcessor \n5680\n\n2010 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name \nWestmere; Six core; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n3.33 GHz 1.1B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nQPI: 6.4 \nGT/s; 32 \nGB/s\n\n1 TB L1: 64 KB\nL2: 256KB \n\nL3: 12MB\n\nIntel Xeon-\nProcessor \n7560\n\n2010 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name \nNehalem; Eight \ncore; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n2.26 GHz 2.3B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nQPI: 6.4 \nGT/s; \nMemory: \n76 GB/s \n\n16 TB L1: 64 KB\nL2: 256KB \n\nL3: 24MB\n\nIntel Core i7-\n2600K\nProcessor \n\n2011 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name Sandy \nBridge; Four core; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology., \nProcessor graphics, \nQuicksync Video\n\n3.40 GHz  995M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nYMM: 256\n\nDMI: 5 \nGT/s; \nMemory: \n21 GB/s\n\n64 GB L1: 64 KB\nL2: 256KB \n\nL3: 8MB\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\nVol. 1 2-25\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Xeon-\nProcessor E3-\n1280\n\n2011 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name Sandy \nBridge; Four core; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n3.50 GHz GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nYMM: 256\n\nDMI: 5 \nGT/s; \nMemory: \n21 GB/s\n\n1 TB L1: 64 KB\nL2: 256KB \n\nL3: 8MB\n\nIntel Xeon-\nProcessor E7-\n8870\n\n2011 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name \nWestmere; Ten \ncore; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n2.40 GHz 2.2B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nQPI: 6.4 \nGT/s; \nMemory: \n102 GB/s \n\n16 TB L1: 64 KB\nL2: 256KB \n\nL3: 30MB\n\nNOTES:\n1. The 64-bit Intel Xeon Processor MP with an 8-MByte L3 supports a multi-processor platform with a dual system bus; this creates a \n\nplatform bandwidth with 10.6 GBytes.\n2. In Intel Pentium Processor Extreme Edition 840, the size of on-die cache is listed for each core. The total size of L2 in the physical\n\npackage in 2 MBytes.\n3. In Dual-Core Intel Xeon Processor 7041, the size of on-die cache is listed for each core. The total size of L2 in the physical package in\n\n4 MBytes.\n4. In Intel Atom Processor, the size of L1 instruction cache is 32 KBytes, L1 data cache is 24 KBytes.\n5. In Intel Atom Processor, the size of L1 instruction cache is 32 KBytes, L1 data cache is 24 KBytes.\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\n2-26 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nTable 2-3.  Key Features of Previous Generations of IA-32 Processors\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMax. Clock \nFrequency/\nTechnology at \nIntroduction\n\nTran-\nsistors\n\nRegister \nSizes1\n\nExt. Data \nBus Size2\n\nMax. \nExtern. \nAddr. \nSpace\n\nCaches \n\n8086 1978 8 MHz 29 K 16 GP 16 1 MB None\n\nIntel 286 1982 12.5 MHz 134 K 16 GP 16 16 MB Note 3\n\nIntel386 DX \nProcessor\n\n1985 20 MHz 275 K 32 GP 32 4 GB Note 3\n\nIntel486 DX \nProcessor\n\n1989 25 MHz 1.2 M 32 GP\n80 FPU\n\n32 4 GB L1: 8 KB\n\nPentium Processor 1993 60 MHz 3.1 M 32 GP\n80 FPU\n\n64 4 GB L1:16 KB\n\nPentium Pro \nProcessor\n\n1995 200 MHz 5.5 M 32 GP\n80 FPU\n\n64 64 GB L1: 16 KB\nL2: 256 KB or \n512 KB \n\nPentium II Processor 1997 266 MHz 7 M 32 GP\n80 FPU\n64 MMX\n\n64 64 GB L1: 32 KB\nL2: 256 KB or \n512 KB\n\nPentium III Processor 1999 500 MHz 8.2 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB L1: 32 KB\nL2: 512 KB\n\nPentium III and \nPentium III Xeon \nProcessors\n\n1999 700 MHz 28 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB L1: 32 KB\nL2: 256 KB\n\nPentium 4 Processor 2000 1.50 GHz, Intel \nNetBurst \nMicroarchitecture\n\n42 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB 12K µop \nExecution \nTrace Cache; \nL1: 8KB\nL2: 256 KB\n\nIntel Xeon Processor 2001 1.70 GHz, Intel \nNetBurst \nMicroarchitecture\n\n42 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB 12K µop \nExecution \nTrace Cache; \nL1: 8KB\nL2: 512KB\n\nIntel Xeon Processor 2002 2.20 GHz, Intel \nNetBurst \nMicroarchitecture, \nHyperThreading \nTechnology\n\n55 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB 12K µop \nExecution \nTrace Cache; \nL1: 8KB\nL2: 512KB\n\nPentium M Processor 2003 1.60 GHz, Intel \nNetBurst \nMicroarchitecture\n\n77 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 4 GB L1: 64KB\nL2: 1 MB\nVol. 1 2-27\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nNOTE:\n1. The register size and external data bus size are given in bits. Note also that each 32-bit general-purpose (GP) registers can be \n\naddressed as an 8- or a 16-bit data registers in all of the processors.\n2. Internal data paths are 2 to 4 times wider than the external data bus for each processor.\n\n2.4 PROPOSED REMOVAL OF INTEL INSTRUCTION SET ARCHITECTURE AND \nFEATURES FROM UPCOMING PRODUCTS\n\nThis section lists Intel Instruction Set Architecture (ISA) and features that Intel plans to remove from select prod-\nucts starting from a specific year.\n\n2.5 INTEL INSTRUCTION SET ARCHITECTURE AND FEATURES REMOVED\nThis section lists Intel ISA and features that Intel has already removed for select upcoming products. All sections \nrelevant to the removed features will be identified as such and may be moved to an archived section in future \nIntel® 64 and IA-32 Architectures Software Developer's Manual releases.\n\nIntel Pentium 4\nProcessor \nSupporting Hyper-\nThreading \nTechnology at 90 nm \nprocess\n\n2004 3.40 GHz, Intel \nNetBurst \nMicroarchitecture, \nHyperThreading \nTechnology\n\n125 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB 12K µop \nExecution \nTrace Cache; \nL1: 16KB\nL2: 1 MB\n\nTable 2-4.  Proposed Intel ISA and Features Removal List \n\nIntel ISA/Feature Year of Removal\n\nNA NA\n\nTable 2-5.  Intel ISA and Features Removal List \n\nIntel ISA/Feature Year of Removal\n\nIntel® Memory Protection Extensions (Intel® MPX) 2019 onwards\n\n MSR_TEST_CTRL, bit 31 (MSR address 33H) 2019 onwards\n\nHardware Lock Elision (HLE) 2019 onwards\n\nTable 2-3.  Key Features of Previous Generations of IA-32 Processors (Contd.)\n2-28 Vol. 1\n\n\n\nCHAPTER 3\nBASIC EXECUTION ENVIRONMENT\n\nThis chapter describes the basic execution environment of an Intel 64 or IA-32 processor as seen by assembly-\nlanguage programmers. It describes how the processor executes instructions and how it stores and manipulates \ndata. The execution environment described here includes memory (the address space), general-purpose data \nregisters, segment registers, the flag register, and the instruction pointer register.\n\n3.1 MODES OF OPERATION\nThe IA-32 architecture supports three basic operating modes: protected mode, real-address mode, and system \nmanagement mode. The operating mode determines which instructions and architectural features are accessible:\n• Protected mode — This mode is the native state of the processor. Among the capabilities of protected mode \n\nis the ability to directly execute “real-address mode” 8086 software in a protected, multi-tasking environment. \nThis feature is called virtual-8086 mode, although it is not actually a processor mode. Virtual-8086 mode is \nactually a protected mode attribute that can be enabled for any task. \n\n• Real-address mode — This mode implements the programming environment of the Intel 8086 processor with \nextensions (such as the ability to switch to protected or system management mode). The processor is placed in \nreal-address mode following power-up or a reset.\n\n• System management mode (SMM) — This mode provides an operating system or executive with a \ntransparent mechanism for implementing platform-specific functions such as power management and system \nsecurity. The processor enters SMM when the external SMM interrupt pin (SMI#) is activated or an SMI is \nreceived from the advanced programmable interrupt controller (APIC). \nIn SMM, the processor switches to a separate address space while saving the basic context of the currently \nrunning program or task. SMM-specific code may then be executed transparently. Upon returning from SMM, \nthe processor is placed back into its state prior to the system management interrupt. SMM was introduced with \nthe Intel386™ SL and Intel486™ SL processors and became a standard IA-32 feature with the Pentium \nprocessor family. \n\n3.1.1 Intel® 64 Architecture\nIntel 64 architecture adds IA-32e mode. IA-32e mode has two sub-modes.\nThese are:\n• Compatibility mode (sub-mode of IA-32e mode) — Compatibility mode permits most legacy 16-bit and \n\n32-bit applications to run without re-compilation under a 64-bit operating system. For brevity, the compatibility \nsub-mode is referred to as compatibility mode in IA-32 architecture. The execution environment of compati-\nbility mode is the same as described in Section 3.2. Compatibility mode also supports all of the privilege levels \nthat are supported in 64-bit and protected modes. Legacy applications that run in Virtual 8086 mode or use \nhardware task management will not work in this mode. \nCompatibility mode is enabled by the operating system (OS) on a code segment basis. This means that a single \n64-bit OS can support 64-bit applications running in 64-bit mode and support legacy 32-bit applications (not \nrecompiled for 64-bits) running in compatibility mode.\nCompatibility mode is similar to 32-bit protected mode. Applications access only the first 4 GByte of linear-\naddress space. Compatibility mode uses 16-bit and 32-bit address and operand sizes. Like protected mode, this \nmode allows applications to access physical memory greater than 4 GByte using PAE (Physical Address Exten-\nsions). \n\n• 64-bit mode (sub-mode of IA-32e mode) — This mode enables a 64-bit operating system to run applica-\ntions written to access 64-bit linear address space. For brevity, the 64-bit sub-mode is referred to as 64-bit \nmode in IA-32 architecture.\nVol. 1 3-1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n64-bit mode extends the number of general purpose registers and SIMD extension registers from 8 to 16. \nGeneral purpose registers are widened to 64 bits. The mode also introduces a new opcode prefix (REX) to \naccess the register extensions. See Section 3.2.1 for a detailed description.\n64-bit mode is enabled by the operating system on a code-segment basis. Its default address size is 64 bits and \nits default operand size is 32 bits. The default operand size can be overridden on an instruction-by-instruction \nbasis using a REX opcode prefix in conjunction with an operand size override prefix. \nREX prefixes allow a 64-bit operand to be specified when operating in 64-bit mode. By using this mechanism, \nmany existing instructions have been promoted to allow the use of 64-bit registers and 64-bit addresses.\n\n3.2 OVERVIEW OF THE BASIC EXECUTION ENVIRONMENT\nAny program or task running on an IA-32 processor is given a set of resources for executing instructions and for \nstoring code, data, and state information. These resources (described briefly in the following paragraphs and \nshown in Figure 3-1) make up the basic execution environment for an IA-32 processor. \n\nAn Intel 64 processor supports the basic execution environment of an IA-32 processor, and a similar environment \nunder IA-32e mode that can execute 64-bit programs (64-bit sub-mode) and 32-bit programs (compatibility sub-\nmode). \n\nThe basic execution environment is used jointly by the application programs and the operating system or executive \nrunning on the processor.\n• Address space — Any task or program running on an IA-32 processor can address a linear address space of \n\nup to 4 GBytes (232 bytes) and a physical address space of up to 64 GBytes (236 bytes). See Section 3.3.6, \n“Extended Physical Addressing in Protected Mode,” for more information about addressing an address space \ngreater than 4 GBytes.\n\n• Basic program execution registers — The eight general-purpose registers, the six segment registers, the \nEFLAGS register, and the EIP (instruction pointer) register comprise a basic execution environment in which to \nexecute a set of general-purpose instructions. These instructions perform basic integer arithmetic on byte, \nword, and doubleword integers, handle program flow control, operate on bit and byte strings, and address \nmemory. See Section 3.4, “Basic Program Execution Registers,” for more information about these registers.\n\n• x87 FPU registers — The eight x87 FPU data registers, the x87 FPU control register, the status register, the \nx87 FPU instruction pointer register, the x87 FPU operand (data) pointer register, the x87 FPU tag register, and \nthe x87 FPU opcode register provide an execution environment for operating on single-precision, double-\nprecision, and double extended-precision floating-point values, word integers, doubleword integers, quadword \nintegers, and binary coded decimal (BCD) values. See Section 8.1, “x87 FPU Execution Environment,” for more \ninformation about these registers.\n\n• MMX registers — The eight MMX registers support execution of single-instruction, multiple-data (SIMD) \noperations on 64-bit packed byte, word, and doubleword integers. See Section 9.2, “The MMX Technology \nProgramming Environment,” for more information about these registers.\n\n• XMM registers — The eight XMM data registers and the MXCSR register support execution of SIMD operations \non 128-bit packed single-precision and double-precision floating-point values and on 128-bit packed byte, \nword, doubleword, and quadword integers. See Section 10.2, “SSE Programming Environment,” for more \ninformation about these registers.\n\n• YMM registers — The YMM data registers support execution of 256-bit SIMD operations on 256-bit packed \nsingle-precision and double-precision floating-point values and on 256-bit packed byte, word, doubleword, and \nquadword integers. \n\n• Bounds registers — Each of the BND0-BND3 register stores the lower and upper bounds (64 bits each) \nassociated with the pointer to a memory buffer. They support execution of the Intel MPX instructions. \n\n• BNDCFGU and BNDSTATUS— BNDCFGU configures user mode MPX operations on bounds checking. \nBNDSTATUS provides additional information on the #BR caused by an MPX operation.\n3-2 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nFigure 3-1.  IA-32 Basic Execution Environment for Non-64-bit Modes\n\n0\n\n2^32 -1\nEight 32-bit\n\n32-bits\n\n32-bits\n\nGeneral-Purpose Registers\n\nSegment Registers\n\nEFLAGS Register\n\nEIP (Instruction Pointer Register)\n\nAddress Space*\n\n*The address space can be\n\nSix 16-bit\nRegisters\n\nRegisters\n\nEight 80-bit\nRegisters\n\nFloating-Point\nData Registers\n\nEight 64-bit\nRegisters MMX Registers\n\nflat or segmented. Using\n\nXMM Registers\nEight 128-bit\n\nRegisters\n\n16 bits Control Register\n\n16 bits Status Register\n\n48 bits FPU Instruction Pointer Register\n\n48 bits FPU Data (Operand) Pointer Register\n\nFPU Registers\n\nMMX Registers\n\nXMM Registers\n\n32-bits MXCSR Register\n\nOpcode Register (11-bits)\n\nBasic Program Execution Registers\n\n16 bits Tag Register\n\nthe physical address\nextension mechanism, a\nphysical address space of\n2^36 - 1 can be addressed.\n\nYMM Registers\nEight 256-bit\n\nRegisters\n\nYMM Registers\n\nFour 128-bit Registers\n\nBounds Registers\n\nBNDCFGU BNDSTATUS\nVol. 1 3-3\n\n\n\nBASIC EXECUTION ENVIRONMENT\n• Stack — To support procedure or subroutine calls and the passing of parameters between procedures or \nsubroutines, a stack and stack management resources are included in the execution environment. The stack \n(not shown in Figure 3-1) is located in memory. See Section 6.2, “Stacks,” for more information about stack \nstructure.\n\nIn addition to the resources provided in the basic execution environment, the IA-32 architecture provides the \nfollowing resources as part of its system-level architecture. They provide extensive support for operating-system \nand system-development software. Except for the I/O ports, the system resources are described in detail in the \nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 3A & 3B.\n• I/O ports — The IA-32 architecture supports a transfers of data to and from input/output (I/O) ports. See \n\nChapter 19, “Input/Output,” in this volume.\n• Control registers — The five control registers (CR0 through CR4) determine the operating mode of the \n\nprocessor and the characteristics of the currently executing task. See Chapter 2, “System Architecture \nOverview,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\n\n• Memory management registers — The GDTR, IDTR, task register, and LDTR specify the locations of data \nstructures used in protected mode memory management. See Chapter 2, “System Architecture Overview,” in \nthe Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\n\n• Debug registers — The debug registers (DR0 through DR7) control and allow monitoring of the processor’s \ndebugging operations. See in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B.\n\n• Memory type range registers (MTRRs) — The MTRRs are used to assign memory types to regions of \nmemory. See the sections on MTRRs in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolumes 3A & 3B.\n\n• Model-specific registers (MSRs) — The processor provides a variety of model-specific registers that are \nused to control and report on processor performance. Virtually all MSRs handle system related functions and \nare not accessible to an application program. One exception to this rule is the time-stamp counter. The MSRs \nare described in Chapter 2, “Model-Specific Registers (MSRs)” of the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volume 4.\n\n• Machine check registers — The machine check registers consist of a set of control, status, and error-\nreporting MSRs that are used to detect and report on hardware (machine) errors. See Chapter 15, “Machine-\nCheck Architecture,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\n\n• Performance monitoring counters — The performance monitoring counters allow processor performance \nevents to be monitored. See Chapter 18, “Performance Monitoring,” in the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volume 3B.\n\nThe remainder of this chapter describes the organization of memory and the address space, the basic program \nexecution registers, and addressing modes. Refer to the following chapters in this volume for descriptions of the \nother program execution resources shown in Figure 3-1:\n• x87 FPU registers — See Chapter 8, “Programming with the x87 FPU.”\n• MMX Registers — See Chapter 9, “Programming with Intel® MMX™ Technology.”\n• XMM registers — See Chapter 10, “Programming with Intel® Streaming SIMD Extensions (Intel® SSE),” \n\nChapter 11, “Programming with Intel® Streaming SIMD Extensions 2 (Intel® SSE2),” and Chapter 12, \n“Programming with Intel® SSE3, SSSE3, Intel® SSE4 and Intel® AESNI.”\n\n• YMM registers — See Chapter 14, “Programming with AVX, FMA and AVX2”. \n• BND registers, BNDCFGU, BNDSTATUS — See Chapter 13, “Managing State Using the XSAVE Feature Set,” \n\nand Chapter 17, “Intel® MPX”. \n• Stack implementation and procedure calls — See Chapter 6, “Procedure Calls, Interrupts, and Exceptions.”\n3-4 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.2.1 64-Bit Mode Execution Environment\nThe execution environment for 64-bit mode is similar to that described in Section 3.2. The following paragraphs \ndescribe the differences that apply. \n• Address space — A task or program running in 64-bit mode on an IA-32 processor can address linear address \n\nspace of up to 264 bytes (subject to the canonical addressing requirement described in Section 3.3.7.1) and \nphysical address space of up to 252 bytes. Software can query CPUID for the physical address size supported \nby a processor.\n\n• Basic program execution registers — The number of general-purpose registers (GPRs) available is 16. \nGPRs are 64-bits wide and they support operations on byte, word, doubleword and quadword integers. \nAccessing byte registers is done uniformly to the lowest 8 bits. The instruction pointer register becomes 64 bits. \nThe EFLAGS register is extended to 64 bits wide, and is referred to as the RFLAGS register. The upper 32 bits \nof RFLAGS is reserved. The lower 32 bits of RFLAGS is the same as EFLAGS. See Figure 3-2.\n\n• XMM registers — There are 16 XMM data registers for SIMD operations. See Section 10.2, “SSE Programming \nEnvironment,” for more information about these registers.\n\n• YMM registers — There are 16 YMM data registers for SIMD operations. See Chapter 14, “Programming with \nAVX, FMA and AVX2” for more information about these registers.\n\n• BND registers, BNDCFGU, BNDSTATUS — See Chapter 13, “Managing State Using the XSAVE Feature Set,” \nand Chapter 17, “Intel® MPX”. \n\n• Stack — The stack pointer size is 64 bits. Stack size is not controlled by a bit in the SS descriptor (as it is in \nnon-64-bit modes) nor can the pointer size be overridden by an instruction prefix.\n\n• Control registers — Control registers expand to 64 bits. A new control register (the task priority register: CR8 \nor TPR) has been added. See Chapter 2, “Intel® 64 and IA-32 Architectures,” in this volume.\n\n• Debug registers — Debug registers expand to 64 bits. See Chapter 17, “Debug, Branch Profile, TSC, and \nIntel® Resource Director Technology (Intel® RDT) Features,” in the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volume 3A.\nVol. 1 3-5\n\n\n\nBASIC EXECUTION ENVIRONMENT\n• Descriptor table registers — The global descriptor table register (GDTR) and interrupt descriptor table \nregister (IDTR) expand to 10 bytes so that they can hold a full 64-bit base address. The local descriptor table \nregister (LDTR) and the task register (TR) also expand to hold a full 64-bit base address.\n\n3.3 MEMORY ORGANIZATION\nThe memory that the processor addresses on its bus is called physical memory. Physical memory is organized as \na sequence of 8-bit bytes. Each byte is assigned a unique address, called a physical address. The physical \naddress space ranges from zero to a maximum of 236 − 1 (64 GBytes) if the processor does not support Intel \n64 architecture. Intel 64 architecture introduces a set of changes in physical and linear address space; these \nare described in Section 3.3.3, Section 3.3.4, and Section 3.3.7.\n\nFigure 3-2.  64-Bit Mode Execution Environment\n\n0\n\n2^64 -1Sixteen 64-bit\n\n64-bits\n\n64-bits\n\nGeneral-Purpose Registers\n\nSegment Registers\n\nRFLAGS Register\n\nRIP (Instruction Pointer Register)\n\nAddress Space\n\nSix 16-bit\nRegisters\n\nRegisters\n\nEight 80-bit\nRegisters Floating-Point\n\nData Registers\n\nEight 64-bit\nRegisters MMX Registers\n\nXMM Registers\nSixteen 128-bit\n\nRegisters\n\n16 bits Control Register\n\n16 bits Status Register\n\n64 bits FPU Instruction Pointer Register\n\n64 bits FPU Data (Operand) Pointer Register\n\nFPU Registers\n\nMMX Registers\n\nXMM Registers\n\n32-bits MXCSR Register\n\nOpcode Register (11-bits)\n\nBasic Program Execution Registers\n\n16 bits Tag Register\n\nFour 128-bit Registers\n\nBounds Registers\n\nBNDCFGU BNDSTATUS\n\nYMM Registers\nSixteen 256-bit\n\nRegisters\n\nYMM Registers\n3-6 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nVirtually any operating system or executive designed to work with an IA-32 or Intel 64 processor will use the \nprocessor’s memory management facilities to access memory. These facilities provide features such as segmenta-\ntion and paging, which allow memory to be managed efficiently and reliably. Memory management is described in \ndetail in Chapter 3, “Protected-Mode Memory Management,” in the Intel® 64 and IA-32 Architectures Software \nDeveloper’s Manual, Volume 3A. The following paragraphs describe the basic methods of addressing memory when \nmemory management is used.\n\n3.3.1 IA-32 Memory Models\nWhen employing the processor’s memory management facilities, programs do not directly address physical \nmemory. Instead, they access memory using one of three memory models: flat, segmented, or real address mode:\n• Flat memory model — Memory appears to a program as a single, continuous address space (Figure 3-3). This \n\nspace is called a linear address space. Code, data, and stacks are all contained in this address space. Linear \naddress space is byte addressable, with addresses running contiguously from 0 to 232 - 1 (if not in 64-bit \nmode). An address for any byte in linear address space is called a linear address.\n\n• Segmented memory model — Memory appears to a program as a group of independent address spaces \ncalled segments. Code, data, and stacks are typically contained in separate segments. To address a byte in a \nsegment, a program issues a logical address. This consists of a segment selector and an offset (logical \naddresses are often referred to as far pointers). The segment selector identifies the segment to be accessed \nand the offset identifies a byte in the address space of the segment. Programs running on an IA-32 processor \ncan address up to 16,383 segments of different sizes and types, and each segment can be as large as 232 \nbytes.\nInternally, all the segments that are defined for a system are mapped into the processor’s linear address space. \nTo access a memory location, the processor thus translates each logical address into a linear address. This \ntranslation is transparent to the application program.\nThe primary reason for using segmented memory is to increase the reliability of programs and systems. For \nexample, placing a program’s stack in a separate segment prevents the stack from growing into the code or \ndata space and overwriting instructions or data, respectively.\n\n• Real-address mode memory model — This is the memory model for the Intel 8086 processor. It is \nsupported to provide compatibility with existing programs written to run on the Intel 8086 processor. The real-\naddress mode uses a specific implementation of segmented memory in which the linear address space for the \nprogram and the operating system/executive consists of an array of segments of up to 64 KBytes in size each. \nThe maximum size of the linear address space in real-address mode is 220 bytes. \nSee also: Chapter 19, “8086 Emulation,” Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 3B.\nVol. 1 3-7\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.3.2 Paging and Virtual Memory\nWith the flat or the segmented memory model, linear address space is mapped into the processor’s physical \naddress space either directly or through paging. When using direct mapping (paging disabled), each linear address \nhas a one-to-one correspondence with a physical address. Linear addresses are sent out on the processor’s address \nlines without translation. \n\nWhen using the IA-32 architecture’s paging mechanism (paging enabled), linear address space is divided into \npages which are mapped to virtual memory. The pages of virtual memory are then mapped as needed into physical \nmemory. When an operating system or executive uses paging, the paging mechanism is transparent to an applica-\ntion program. All that the application sees is linear address space.\n\nIn addition, IA-32 architecture’s paging mechanism includes extensions that support:\n• Physical Address Extensions (PAE) to address physical address space greater than 4 GBytes.\n• Page Size Extensions (PSE) to map linear address to physical address in 4-MBytes pages.\n\nSee also: Chapter 3, “Protected-Mode Memory Management,” in the Intel® 64 and IA-32 Architectures Software \nDeveloper’s Manual, Volume 3A.\n\n3.3.3 Memory Organization in 64-Bit Mode\nIntel 64 architecture supports physical address space greater than 64 GBytes; the actual physical address size of \nIA-32 processors is implementation specific. In 64-bit mode, there is architectural support for 64-bit linear address \nspace. However, processors supporting Intel 64 architecture may implement less than 64-bits (see Section \n3.3.7.1). The linear address space is mapped into the processor physical address space through the PAE paging \nmechanism.\n\nFigure 3-3.  Three Memory Management Models\n\nLinear Address\n\nFlat Model\n\nLinear\nAddress\nSpace*\n\nSegment Selector\n\nOffset\n\nSegment Selector\n\nSegmented Model\n\nReal-Address Mode Model\n\nLinear Address\n\nLogical\n\nOffset (effective address)\n\nSpace Divided\nInto Equal\n\nSized Segments\n\nAddress\n\nLogical\nAddress\n\nLinear\nAddress\n\nSpace*\n\nSegments\n\n* The linear address space\ncan be paged when using the \nflat or segmented model.\n3-8 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.3.4 Modes of Operation vs. Memory Model\nWhen writing code for an IA-32 or Intel 64 processor, a programmer needs to know the operating mode the \nprocessor is going to be in when executing the code and the memory model being used. The relationship between \noperating modes and memory models is as follows:\n• Protected mode — When in protected mode, the processor can use any of the memory models described in \n\nthis section. (The real-addressing mode memory model is ordinarily used only when the processor is in the \nvirtual-8086 mode.) The memory model used depends on the design of the operating system or executive. \nWhen multitasking is implemented, individual tasks can use different memory models.\n\n• Real-address mode — When in real-address mode, the processor only supports the real-address mode \nmemory model.\n\n• System management mode — When in SMM, the processor switches to a separate address space, called the \nsystem management RAM (SMRAM). The memory model used to address bytes in this address space is similar \nto the real-address mode model. See Chapter 30, “System Management Mode,” in the Intel® 64 and IA-32 \nArchitectures Software Developer’s Manual, Volume 3C, for more information on the memory model used in \nSMM.\n\n• Compatibility mode — Software that needs to run in compatibility mode should observe the same memory \nmodel as those targeted to run in 32-bit protected mode. The effect of segmentation is the same as it is in 32-\nbit protected mode semantics.\n\n• 64-bit mode — Segmentation is generally (but not completely) disabled, creating a flat 64-bit linear-address \nspace. Specifically, the processor treats the segment base of CS, DS, ES, and SS as zero in 64-bit mode (this \nmakes a linear address equal an effective address). Segmented and real address modes are not available in 64-\nbit mode.\n\n3.3.5 32-Bit and 16-Bit Address and Operand Sizes\nIA-32 processors in protected mode can be configured for 32-bit or 16-bit address and operand sizes. With 32-bit \naddress and operand sizes, the maximum linear address or segment offset is FFFFFFFFH (232-1); operand sizes are \ntypically 8 bits or 32 bits. With 16-bit address and operand sizes, the maximum linear address or segment offset is \nFFFFH (216-1); operand sizes are typically 8 bits or 16 bits. \n\nWhen using 32-bit addressing, a logical address (or far pointer) consists of a 16-bit segment selector and a 32-bit \noffset; when using 16-bit addressing, an address consists of a 16-bit segment selector and a 16-bit offset. \n\nInstruction prefixes allow temporary overrides of the default address and/or operand sizes from within a program.\n\nWhen operating in protected mode, the segment descriptor for the currently executing code segment defines the \ndefault address and operand size. A segment descriptor is a system data structure not normally visible to applica-\ntion code. Assembler directives allow the default addressing and operand size to be chosen for a program. The \nassembler and other tools then set up the segment descriptor for the code segment appropriately.\n\nWhen operating in real-address mode, the default addressing and operand size is 16 bits. An address-size override \ncan be used in real-address mode to enable 32-bit addressing. However, the maximum allowable 32-bit linear \naddress is still 000FFFFFH (220-1).\n\n3.3.6 Extended Physical Addressing in Protected Mode\nBeginning with P6 family processors, the IA-32 architecture supports addressing of up to 64 GBytes (236 bytes) of \nphysical memory. A program or task could not address locations in this address space directly. Instead, it \naddresses individual linear address spaces of up to 4 GBytes that mapped to 64-GByte physical address space \nthrough a virtual memory management mechanism. Using this mechanism, an operating system can enable a \nprogram to switch 4-GByte linear address spaces within 64-GByte physical address space.\n\nThe use of extended physical addressing requires the processor to operate in protected mode and the operating \nsystem to provide a virtual memory management system. See “36-Bit Physical Addressing Using the PAE Paging \nMechanism” in Chapter 3, “Protected-Mode Memory Management,” of the Intel® 64 and IA-32 Architectures Soft-\nware Developer’s Manual, Volume 3A.\nVol. 1 3-9\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.3.7 Address Calculations in 64-Bit Mode\nIn most cases, 64-bit mode uses flat address space for code, data, and stacks. In 64-bit mode (if there is no \naddress-size override), the size of effective address calculations is 64 bits. An effective-address calculation uses a \n64-bit base and index registers and sign-extend displacements to 64 bits.\n\nIn the flat address space of 64-bit mode, linear addresses are equal to effective addresses because the base \naddress is zero. In the event that FS or GS segments are used with a non-zero base, this rule does not hold. In 64-\nbit mode, the effective address components are added and the effective address is truncated (See for example the \ninstruction LEA) before adding the full 64-bit segment base. The base is never truncated, regardless of addressing \nmode in 64-bit mode.\n\nThe instruction pointer is extended to 64 bits to support 64-bit code offsets. The 64-bit instruction pointer is called \nthe RIP. Table 3-1 shows the relationship between RIP, EIP, and IP.\n\nTable 3-1.  Instruction Pointer Sizes\n\nGenerally, displacements and immediates in 64-bit mode are not extended to 64 bits. They are still limited to 32 \nbits and sign-extended during effective-address calculations. In 64-bit mode, however, support is provided for 64-\nbit displacement and immediate forms of the MOV instruction. \n\nAll 16-bit and 32-bit address calculations are zero-extended in IA-32e mode to form 64-bit addresses. Address \ncalculations are first truncated to the effective address size of the current mode (64-bit mode or compatibility \nmode), as overridden by any address-size prefix. The result is then zero-extended to the full 64-bit address width. \nBecause of this, 16-bit and 32-bit applications running in compatibility mode can access only the low 4 GBytes of \nthe 64-bit mode effective addresses. Likewise, a 32-bit address generated in 64-bit mode can access only the low \n4 GBytes of the 64-bit mode effective addresses.\n\n3.3.7.1  Canonical Addressing\nIn 64-bit mode, an address is considered to be in canonical form if address bits 63 through to the most-significant \nimplemented bit by the microarchitecture are set to either all ones or all zeros.\n\nIntel 64 architecture defines a 64-bit linear address. Implementations can support less. The first implementation of \nIA-32 processors with Intel 64 architecture supports a 48-bit linear address. This means a canonical address must \nhave bits 63 through 48 set to zeros or ones (depending on whether bit 47 is a zero or one).\n\nAlthough implementations may not use all 64 bits of the linear address, they should check bits 63 through the \nmost-significant implemented bit to see if the address is in canonical form. If a linear-memory reference is not in \ncanonical form, the implementation should generate an exception. In most cases, a general-protection exception \n(#GP) is generated. However, in the case of explicit or implied stack references, a stack fault (#SS) is generated. \n\nInstructions that have implied stack references, by default, use the SS segment register. These include PUSH/POP-\nrelated instructions and instructions using RSP/RBP as base registers. In these cases, the canonical fault is #SS. \n\nIf an instruction uses base registers RSP/RBP and uses a segment override prefix to specify a non-SS segment, a \ncanonical fault generates a #GP (instead of an #SS). In 64-bit mode, only FS and GS segment-overrides are appli-\ncable in this situation. Other segment override prefixes (CS, DS, ES and SS) are ignored. Note that this also means \nthat an SS segment-override applied to a “non-stack” register reference is ignored. Such a sequence still produces \na #GP for a canonical fault (and not an #SS).\n\n3.4 BASIC PROGRAM EXECUTION REGISTERS\nIA-32 architecture provides 16 basic program execution registers for use in general system and application \nprograming (see Figure 3-4). These registers can be grouped as follows:\n\nBits 63:32 Bits 31:16 Bits 15:0\n\n16-bit instruction pointer Not Modified IP\n\n32-bit instruction pointer Zero Extension EIP\n\n64-bit instruction pointer RIP\n3-10 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n• General-purpose registers. These eight registers are available for storing operands and pointers.\n• Segment registers. These registers hold up to six segment selectors.\n• EFLAGS (program status and control) register. The EFLAGS register report on the status of the program \n\nbeing executed and allows limited (application-program level) control of the processor. \n• EIP (instruction pointer) register. The EIP register contains a 32-bit pointer to the next instruction to be \n\nexecuted. \n\n3.4.1 General-Purpose Registers\nThe 32-bit general-purpose registers EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP are provided for holding the \nfollowing items:\n• Operands for logical and arithmetic operations\n• Operands for address calculations\n• Memory pointers\n\nAlthough all of these registers are available for general storage of operands, results, and pointers, caution should \nbe used when referencing the ESP register. The ESP register holds the stack pointer and as a general rule should \nnot be used for another purpose. \n\nMany instructions assign specific registers to hold operands. For example, string instructions use the contents of \nthe ECX, ESI, and EDI registers as operands. When using a segmented memory model, some instructions assume \nthat pointers in certain registers are relative to specific segments. For instance, some instructions assume that a \npointer in the EBX register points to a memory location in the DS segment. \n\nFigure 3-4.  General System and Application Programming Registers\n\n031\nEAX\nEBX\nECX\n\nEDX\nESI\n\nEDI\nEBP\n\nESP\n\nSegment Registers\n\nCS\n\nDS\nSS\n\nES\nFS\n\nGS\n\n015\n\n031\nEFLAGS\n\nEIP\n31 0\n\nGeneral-Purpose Registers\n\nProgram Status and Control Register\n\nInstruction Pointer\nVol. 1 3-11\n\n\n\nBASIC EXECUTION ENVIRONMENT\nThe special uses of general-purpose registers by instructions are described in Chapter 5, “Instruction Set \nSummary,” in this volume. See also: Chapter 3, Chapter 4 and Chapter 5 of Intel® 64 and IA-32 Architectures Soft-\nware Developer’s Manual, Volumes 2A, 2B & 2C. The following is a summary of special uses:\n• EAX — Accumulator for operands and results data\n• EBX — Pointer to data in the DS segment\n• ECX — Counter for string and loop operations\n• EDX — I/O pointer\n• ESI — Pointer to data in the segment pointed to by the DS register; source pointer for string operations\n• EDI — Pointer to data (or destination) in the segment pointed to by the ES register; destination pointer for \n\nstring operations\n• ESP — Stack pointer (in the SS segment)\n• EBP — Pointer to data on the stack (in the SS segment)\n\nAs shown in Figure 3-5, the lower 16 bits of the general-purpose registers map directly to the register set found in \nthe 8086 and Intel 286 processors and can be referenced with the names AX, BX, CX, DX, BP, SI, DI, and SP. Each \nof the lower two bytes of the EAX, EBX, ECX, and EDX registers can be referenced by the names AH, BH, CH, and \nDH (high bytes) and AL, BL, CL, and DL (low bytes).\n\n3.4.1.1  General-Purpose Registers in 64-Bit Mode\nIn 64-bit mode, there are 16 general purpose registers and the default operand size is 32 bits. However, general-\npurpose registers are able to work with either 32-bit or 64-bit operands. If a 32-bit operand size is specified: EAX, \nEBX, ECX, EDX, EDI, ESI, EBP, ESP, R8D - R15D are available. If a 64-bit operand size is specified: RAX, RBX, RCX, \nRDX, RDI, RSI, RBP, RSP, R8-R15 are available. R8D-R15D/R8-R15 represent eight new general-purpose registers. \nAll of these registers can be accessed at the byte, word, dword, and qword level. REX prefixes are used to generate \n64-bit operand sizes or to reference registers R8-R15.\n\nRegisters only available in 64-bit mode (R8-R15 and XMM8-XMM15) are preserved across transitions from 64-bit \nmode into compatibility mode then back into 64-bit mode. However, values of R8-R15 and XMM8-XMM15 are unde-\nfined after transitions from 64-bit mode through compatibility mode to legacy or real mode and then back through \ncompatibility mode to 64-bit mode.\n\nFigure 3-5.  Alternate General-Purpose Register Names\n\n071531 16 8\n\nAH AL\n\nBH BL\n\nCH CL\n\nDH DL\n\nBP\n\nSI\n\nDI\n\nSP\n\n16-bit\n\nAX\n\nDX\n\nCX\n\nBX\n\n32-bit\n\nEAX\n\nEBX\n\nECX\n\nEDX\n\nEBP\n\nESI\n\nESP\n\nGeneral-Purpose Registers\n\nEDI\n3-12 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nIn 64-bit mode, there are limitations on accessing byte registers. An instruction cannot reference legacy high-\nbytes (for example: AH, BH, CH, DH) and one of the new byte registers at the same time (for example: the low \nbyte of the RAX register). However, instructions may reference legacy low-bytes (for example: AL, BL, CL or DL) \nand new byte registers at the same time (for example: the low byte of the R8 register, or RBP). The architecture \nenforces this limitation by changing high-byte references (AH, BH, CH, DH) to low byte references (BPL, SPL, DIL, \nSIL: the low 8 bits for RBP, RSP, RDI and RSI) for instructions using a REX prefix.\n\nWhen in 64-bit mode, operand size determines the number of valid bits in the destination general-purpose \nregister: \n• 64-bit operands generate a 64-bit result in the destination general-purpose register.\n• 32-bit operands generate a 32-bit result, zero-extended to a 64-bit result in the destination general-purpose \n\nregister.\n• 8-bit and 16-bit operands generate an 8-bit or 16-bit result. The upper 56 bits or 48 bits (respectively) of the \n\ndestination general-purpose register are not modified by the operation. If the result of an 8-bit or 16-bit \noperation is intended for 64-bit address calculation, explicitly sign-extend the register to the full 64-bits. \n\nBecause the upper 32 bits of 64-bit general-purpose registers are undefined in 32-bit modes, the upper 32 bits of \nany general-purpose register are not preserved when switching from 64-bit mode to a 32-bit mode (to protected \nmode or compatibility mode). Software must not depend on these bits to maintain a value after a 64-bit to 32-bit \nmode switch.\n\n3.4.2 Segment Registers\nThe segment registers (CS, DS, SS, ES, FS, and GS) hold 16-bit segment selectors. A segment selector is a special \npointer that identifies a segment in memory. To access a particular segment in memory, the segment selector for \nthat segment must be present in the appropriate segment register.\n\nWhen writing application code, programmers generally create segment selectors with assembler directives and \nsymbols. The assembler and other tools then create the actual segment selector values associated with these \ndirectives and symbols. If writing system code, programmers may need to create segment selectors directly. See \nChapter 3, “Protected-Mode Memory Management,” in the Intel® 64 and IA-32 Architectures Software Developer’s \nManual, Volume 3A.\n\nHow segment registers are used depends on the type of memory management model that the operating system or \nexecutive is using. When using the flat (unsegmented) memory model, segment registers are loaded with segment \nselectors that point to overlapping segments, each of which begins at address 0 of the linear address space (see \nFigure 3-6). These overlapping segments then comprise the linear address space for the program. Typically, two \noverlapping segments are defined: one for code and another for data and stacks. The CS segment register points \nto the code segment and all the other segment registers point to the data and stack segment.\n\nWhen using the segmented memory model, each segment register is ordinarily loaded with a different segment \nselector so that each segment register points to a different segment within the linear address space (see \nFigure 3-7). At any time, a program can thus access up to six segments in the linear address space. To access a \nsegment not pointed to by one of the segment registers, a program must first load the segment selector for the \nsegment to be accessed into a segment register.\n\nTable 3-2.  Addressable General Purpose Registers\nRegister Type Without REX With REX\n\nByte Registers AL, BL, CL, DL, AH, BH, CH, DH AL, BL, CL, DL, DIL, SIL, BPL, SPL, R8B - R15B\n\nWord Registers AX, BX, CX, DX, DI, SI, BP, SP AX, BX, CX, DX, DI, SI, BP, SP, R8W - R15W\n\nDoubleword Registers EAX, EBX, ECX, EDX, EDI, ESI, EBP, ESP EAX, EBX, ECX, EDX, EDI, ESI, EBP, ESP, R8D - R15D\n\nQuadword Registers N.A. RAX, RBX, RCX, RDX, RDI, RSI, RBP, RSP, R8 - R15\nVol. 1 3-13\n\n\n\nBASIC EXECUTION ENVIRONMENT\nEach of the segment registers is associated with one of three types of storage: code, data, or stack. For example, \nthe CS register contains the segment selector for the code segment, where the instructions being executed are \nstored. The processor fetches instructions from the code segment, using a logical address that consists of the \nsegment selector in the CS register and the contents of the EIP register. The EIP register contains the offset within \nthe code segment of the next instruction to be executed. The CS register cannot be loaded explicitly by an applica-\ntion program. Instead, it is loaded implicitly by instructions or internal processor operations that change program \ncontrol (such as procedure calls, interrupt handling, or task switching).\n\nThe DS, ES, FS, and GS registers point to four data segments. The availability of four data segments permits effi-\ncient and secure access to different types of data structures. For example, four separate data segments might be \ncreated: one for the data structures of the current module, another for the data exported from a higher-level \nmodule, a third for a dynamically created data structure, and a fourth for data shared with another program. To \naccess additional data segments, the application program must load segment selectors for these segments into the \nDS, ES, FS, and GS registers, as needed.\n\nThe SS register contains the segment selector for the stack segment, where the procedure stack is stored for the \nprogram, task, or handler currently being executed. All stack operations use the SS register to find the stack \n\nFigure 3-6.  Use of Segment Registers for Flat Memory Model\n\nFigure 3-7.  Use of Segment Registers in Segmented Memory Model\n\nSegment Registers\n\nCS\n\nSS\nDS\n\nES\nFS\nGS\n\nLinear Address\nSpace for Program\n\nThe segment selector in\neach segment register\npoints to an overlapping \n\nOverlapping\nSegments\n\nof up to\n4 GBytes\n\nsegment in the linear\naddress space.\n\nBeginning at\nAddress 0\n\nSegment Registers\n\nCS\nDS\nSS\nES\nFS\nGS\n\nCode\nSegment\n\nData\nSegment\n\nStack\nSegment\n\nData\nSegment\n\nData\nSegment\n\nData\nSegment\n\nAll segments\nare mapped\nto the same\nlinear-address\nspace\n3-14 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nsegment. Unlike the CS register, the SS register can be loaded explicitly, which permits application programs to set \nup multiple stacks and switch among them.\n\nSee Section 3.3, “Memory Organization,” for an overview of how the segment registers are used in real-address \nmode.\n\nThe four segment registers CS, DS, SS, and ES are the same as the segment registers found in the Intel 8086 and \nIntel 286 processors and the FS and GS registers were introduced into the IA-32 Architecture with the Intel386™ \nfamily of processors.\n\n3.4.2.1  Segment Registers in 64-Bit Mode\nIn 64-bit mode: CS, DS, ES, SS are treated as if each segment base is 0, regardless of the value of the associated \nsegment descriptor base. This creates a flat address space for code, data, and stack. FS and GS are exceptions. \nBoth segment registers may be used as additional base registers in linear address calculations (in the addressing \nof local data and certain operating system data structures). \n\nEven though segmentation is generally disabled, segment register loads may cause the processor to perform \nsegment access assists. During these activities, enabled processors will still perform most of the legacy checks on \nloaded values (even if the checks are not applicable in 64-bit mode). Such checks are needed because a segment \nregister loaded in 64-bit mode may be used by an application running in compatibility mode. \n\nLimit checks for CS, DS, ES, SS, FS, and GS are disabled in 64-bit mode.\n\n3.4.3 EFLAGS Register\nThe 32-bit EFLAGS register contains a group of status flags, a control flag, and a group of system flags. Figure 3-8 \ndefines the flags within this register. Following initialization of the processor (either by asserting the RESET pin or \nthe INIT pin), the state of the EFLAGS register is 00000002H. Bits 1, 3, 5, 15, and 22 through 31 of this register \nare reserved. Software should not use or depend on the states of any of these bits.\n\nSome of the flags in the EFLAGS register can be modified directly, using special-purpose instructions (described in \nthe following sections). There are no instructions that allow the whole register to be examined or modified directly. \n\nThe following instructions can be used to move groups of flags to and from the procedure stack or the EAX register: \nLAHF, SAHF, PUSHF, PUSHFD, POPF, and POPFD. After the contents of the EFLAGS register have been transferred to \nthe procedure stack or EAX register, the flags can be examined and modified using the processor’s bit manipulation \ninstructions (BT, BTS, BTR, and BTC).\n\nWhen suspending a task (using the processor’s multitasking facilities), the processor automatically saves the state \nof the EFLAGS register in the task state segment (TSS) for the task being suspended. When binding itself to a new \ntask, the processor loads the EFLAGS register with data from the new task’s TSS.\n\nWhen a call is made to an interrupt or exception handler procedure, the processor automatically saves the state of \nthe EFLAGS registers on the procedure stack. When an interrupt or exception is handled with a task switch, the \nstate of the EFLAGS register is saved in the TSS for the task being suspended.\nVol. 1 3-15\n\n\n\nBASIC EXECUTION ENVIRONMENT\nAs the IA-32 Architecture has evolved, flags have been added to the EFLAGS register, but the function and place-\nment of existing flags have remained the same from one family of the IA-32 processors to the next. As a result, \ncode that accesses or modifies these flags for one family of IA-32 processors works as expected when run on later \nfamilies of processors.\n\n3.4.3.1  Status Flags\nThe status flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, \nsuch as the ADD, SUB, MUL, and DIV instructions. The status flag functions are:\nCF (bit 0) Carry flag — Set if an arithmetic operation generates a carry or a borrow out of the most-\n\nsignificant bit of the result; cleared otherwise. This flag indicates an overflow condition for \nunsigned-integer arithmetic. It is also used in multiple-precision arithmetic.\n\nPF (bit 2) Parity flag — Set if the least-significant byte of the result contains an even number of 1 bits; \ncleared otherwise.\n\nAF (bit 4) Auxiliary Carry flag — Set if an arithmetic operation generates a carry or a borrow out of bit \n3 of the result; cleared otherwise. This flag is used in binary-coded decimal (BCD) arithmetic.\n\nZF (bit 6) Zero flag — Set if the result is zero; cleared otherwise.\nSF (bit 7) Sign flag — Set equal to the most-significant bit of the result, which is the sign bit of a signed \n\ninteger. (0 indicates a positive value and 1 indicates a negative value.)\nOF (bit 11) Overflow flag — Set if the integer result is too large a positive number or too small a negative \n\nnumber (excluding the sign-bit) to fit in the destination operand; cleared otherwise. This flag \nindicates an overflow condition for signed-integer (two’s complement) arithmetic.\n\nOf these status flags, only the CF flag can be modified directly, using the STC, CLC, and CMC instructions. Also the \nbit instructions (BT, BTS, BTR, and BTC) copy a specified bit into the CF flag.\n\nFigure 3-8.  EFLAGS Register\n\n31 2930 28 27 26 25 24 23 22 21 20 19 18 17 16\n\n0 R\nF\n\nI\nD\n\nA\nC\n\nV\nM\n\nX  Virtual-8086 Mode (VM)\nX Resume Flag (RF)\nX Nested Task (NT)\nX  I/O Privilege Level (IOPL)\nS Overflow Flag (OF)\nC Direction Flag (DF)\nX  Interrupt Enable Flag (IF)\n\nX  Alignment Check / Access Control (AC)\n\nX ID Flag (ID)\nX Virtual Interrupt Pending (VIP)\n\n15 1314 12 11 10 9 8 7 6 5 4 3 2 1 0\n\n0 C\nF\n\nA\nF\n\nP\nF 1D\n\nF\nI\nF\n\nT\nF\n\nS\nF\n\nZ\nF\n\nN\nT 000 0 0 0 0 0 0 0 0\n\nV\nI\nP\n\nV\nI\nF\n\nO\nF\n\nI\nO\nP\nL\n\nX  Virtual Interrupt Flag (VIF)\n\nX  Trap Flag (TF)\nS  Sign Flag (SF)\nS  Zero Flag (ZF)\nS  Auxiliary Carry Flag (AF)\nS  Parity Flag (PF)\nS  Carry Flag (CF)\n\nS  Indicates a Status Flag\nC  Indicates a Control Flag\nX  Indicates a System Flag\n\nReserved bit positions. DO NOT USE.\nAlways set to values previously read.\n3-16 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nThe status flags allow a single arithmetic operation to produce results for three different data types: unsigned inte-\ngers, signed integers, and BCD integers. If the result of an arithmetic operation is treated as an unsigned integer, \nthe CF flag indicates an out-of-range condition (carry or a borrow); if treated as a signed integer (two’s comple-\nment number), the OF flag indicates a carry or borrow; and if treated as a BCD digit, the AF flag indicates a carry \nor borrow. The SF flag indicates the sign of a signed integer. The ZF flag indicates either a signed- or an unsigned-\ninteger zero.\n\nWhen performing multiple-precision arithmetic on integers, the CF flag is used in conjunction with the add with \ncarry (ADC) and subtract with borrow (SBB) instructions to propagate a carry or borrow from one computation to \nthe next. \n\nThe condition instructions Jcc (jump on condition code cc), SETcc (byte set on condition code cc), LOOPcc, and \nCMOVcc (conditional move) use one or more of the status flags as condition codes and test them for branch, set-\nbyte, or end-loop conditions.\n\n3.4.3.2  DF Flag\nThe direction flag (DF, located in bit 10 of the EFLAGS register) controls string instructions (MOVS, CMPS, SCAS, \nLODS, and STOS). Setting the DF flag causes the string instructions to auto-decrement (to process strings from \nhigh addresses to low addresses). Clearing the DF flag causes the string instructions to auto-increment \n(process strings from low addresses to high addresses).\n\nThe STD and CLD instructions set and clear the DF flag, respectively.\n\n3.4.3.3  System Flags and IOPL Field\nThe system flags and IOPL field in the EFLAGS register control operating-system or executive operations. They \nshould not be modified by application programs. The functions of the system flags are as follows:\nTF (bit 8) Trap flag — Set to enable single-step mode for debugging; clear to disable single-step mode.\nIF (bit 9) Interrupt enable flag — Controls the response of the processor to maskable interrupt \n\nrequests. Set to respond to maskable interrupts; cleared to inhibit maskable interrupts.\nIOPL (bits 12 and 13)\n\nI/O privilege level field — Indicates the I/O privilege level of the currently running program \nor task. The current privilege level (CPL) of the currently running program or task must be less \nthan or equal to the I/O privilege level to access the I/O address space. The POPF and IRET \ninstructions can modify this field only when operating at a CPL of 0.\n\nNT (bit 14) Nested task flag — Controls the chaining of interrupted and called tasks. Set when the \ncurrent task is linked to the previously executed task; cleared when the current task is not \nlinked to another task.\n\nRF (bit 16) Resume flag — Controls the processor’s response to debug exceptions.\nVM (bit 17) Virtual-8086 mode flag — Set to enable virtual-8086 mode; clear to return to protected \n\nmode without virtual-8086 mode semantics.\nAC (bit 18) Alignment check (or access control) flag — If the AM bit is set in the CR0 register, align-\n\nment checking of user-mode data accesses is enabled if and only if this flag is 1.\nIf the SMAP bit is set in the CR4 register, explicit supervisor-mode data accesses to user-mode \npages are allowed if and only if this bit is 1. See Section 4.6, “Access Rights,” in the Intel® 64 \nand IA-32 Architectures Software Developer’s Manual, Volume 3A.\n\nVIF (bit 19) Virtual interrupt flag — Virtual image of the IF flag. Used in conjunction with the VIP flag. \n(To use this flag and the VIP flag the virtual mode extensions are enabled by setting the VME \nflag in control register CR4.)\n\nVIP (bit 20) Virtual interrupt pending flag — Set to indicate that an interrupt is pending; clear when no \ninterrupt is pending. (Software sets and clears this flag; the processor only reads it.) Used in \nconjunction with the VIF flag.\n\nID (bit 21) Identification flag — The ability of a program to set or clear this flag indicates support for \nthe CPUID instruction.\nVol. 1 3-17\n\n\n\nBASIC EXECUTION ENVIRONMENT\nFor a detailed description of these flags: see Chapter 3, “Protected-Mode Memory Management,” in the Intel® 64 \nand IA-32 Architectures Software Developer’s Manual, Volume 3A. \n\n3.4.3.4  RFLAGS Register in 64-Bit Mode\nIn 64-bit mode, EFLAGS is extended to 64 bits and called RFLAGS. The upper 32 bits of RFLAGS register is \nreserved. The lower 32 bits of RFLAGS is the same as EFLAGS.\n\n3.5 INSTRUCTION POINTER\nThe instruction pointer (EIP) register contains the offset in the current code segment for the next instruction to be \nexecuted. It is advanced from one instruction boundary to the next in straight-line code or it is moved ahead or \nbackwards by a number of instructions when executing JMP, Jcc, CALL, RET, and IRET instructions. \n\nThe EIP register cannot be accessed directly by software; it is controlled implicitly by control-transfer instructions \n(such as JMP, Jcc, CALL, and RET), interrupts, and exceptions. The only way to read the EIP register is to execute a \nCALL instruction and then read the value of the return instruction pointer from the procedure stack. The EIP \nregister can be loaded indirectly by modifying the value of a return instruction pointer on the procedure stack and \nexecuting a return instruction (RET or IRET). See Section 6.2.4.2, “Return Instruction Pointer.”\n\nAll IA-32 processors prefetch instructions. Because of instruction prefetching, an instruction address read from the \nbus during an instruction load does not match the value in the EIP register. Even though different processor gener-\nations use different prefetching mechanisms, the function of the EIP register to direct program flow remains fully \ncompatible with all software written to run on IA-32 processors.\n\n3.5.1 Instruction Pointer in 64-Bit Mode\nIn 64-bit mode, the RIP register becomes the instruction pointer. This register holds the 64-bit offset of the next \ninstruction to be executed. 64-bit mode also supports a technique called RIP-relative addressing. Using this tech-\nnique, the effective address is determined by adding a displacement to the RIP of the next instruction.\n\n3.6 OPERAND-SIZE AND ADDRESS-SIZE ATTRIBUTES\nWhen the processor is executing in protected mode, every code segment has a default operand-size attribute and \naddress-size attribute. These attributes are selected with the D (default size) flag in the segment descriptor for the \ncode segment (see Chapter 3, “Protected-Mode Memory Management,” in the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volume 3A). When the D flag is set, the 32-bit operand-size and address-size attri-\nbutes are selected; when the flag is clear, the 16-bit size attributes are selected. When the processor is executing \nin real-address mode, virtual-8086 mode, or SMM, the default operand-size and address-size attributes are always \n16 bits.\n\nThe operand-size attribute selects the size of operands. When the 16-bit operand-size attribute is in force, oper-\nands can generally be either 8 bits or 16 bits, and when the 32-bit operand-size attribute is in force, operands can \ngenerally be 8 bits or 32 bits.\n\nThe address-size attribute selects the sizes of addresses used to address memory: 16 bits or 32 bits. When the 16-\nbit address-size attribute is in force, segment offsets and displacements are 16 bits. This restriction limits the size \nof a segment to 64 KBytes. When the 32-bit address-size attribute is in force, segment offsets and displacements \nare 32 bits, allowing up to 4 GBytes to be addressed.\n\nThe default operand-size attribute and/or address-size attribute can be overridden for a particular instruction by \nadding an operand-size and/or address-size prefix to an instruction. See Chapter 2, “Instruction Format,” in the \nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A. The effect of this prefix applies only \nto the targeted instruction.\n\nTable 3-4 shows effective operand size and address size (when executing in protected mode or compatibility mode) \ndepending on the settings of the D flag and the operand-size and address-size prefixes.\n3-18 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.6.1 Operand Size and Address Size in 64-Bit Mode\nIn 64-bit mode, the default address size is 64 bits and the default operand size is 32 bits. Defaults can be over-\nridden using prefixes. Address-size and operand-size prefixes allow mixing of 32/64-bit data and 32/64-bit \naddresses on an instruction-by-instruction basis. Table 3-4 shows valid combinations of the 66H instruction prefix \nand the REX.W prefix that may be used to specify operand-size overrides in 64-bit mode. Note that 16-bit \naddresses are not supported in 64-bit mode.\n\nREX prefixes consist of 4-bit fields that form 16 different values. The W-bit field in the REX prefixes is referred to as \nREX.W. If the REX.W field is properly set, the prefix specifies an operand size override to 64 bits. Note that software \ncan still use the operand-size 66H prefix to toggle to a 16-bit operand size. However, setting REX.W takes prece-\ndence over the operand-size prefix (66H) when both are used.\n\nIn the case of SSE/SSE2/SSE3/SSSE3 SIMD instructions: the 66H, F2H, and F3H prefixes are mandatory for \nopcode extensions. In such a case, there is no interaction between a valid REX.W prefix and a 66H opcode exten-\nsion prefix.\n\nSee Chapter 2, “Instruction Format,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 2A.\n\n3.7 OPERAND ADDRESSING\nIA-32 machine-instructions act on zero or more operands. Some operands are specified explicitly and others are \nimplicit. The data for a source operand can be located in:\n• the instruction itself (an immediate operand)\n• a register\n• a memory location\n• an I/O port\n\nTable 3-3.  Effective Operand- and Address-Size Attributes\nD Flag in Code Segment Descriptor 0 0 0 0 1 1 1 1 \n\nOperand-Size Prefix 66H N N Y Y N N Y Y \n\nAddress-Size Prefix 67H N Y N Y N Y N Y \n\nEffective Operand Size 16 16 32 32 32 32 16 16 \n\nEffective Address Size 16 32 16 32 32 16 32 16\n\nNOTES:\nY: Yes - this instruction prefix is present.\nN: No - this instruction prefix is not present.\n\nTable 3-4.  Effective Operand- and Address-Size Attributes in 64-Bit Mode\n\nL Flag in Code Segment Descriptor\n1 1 1 1 1 1 1 1 \n\nREX.W Prefix 0 0 0 0 1 1 1 1 \n\nOperand-Size Prefix 66H N N Y Y N N Y Y \n\nAddress-Size Prefix 67H N Y N Y N Y N Y \n\nEffective Operand Size 32 32 16 16 64 64 64 64\n\nEffective Address Size 64 32 64 32 64 32 64 32\n\nNOTES:\nY: Yes - this instruction prefix is present.\nN: No - this instruction prefix is not present.\nVol. 1 3-19\n\n\n\nBASIC EXECUTION ENVIRONMENT\nWhen an instruction returns data to a destination operand, it can be returned to:\n• a register\n• a memory location\n• an I/O port\n\n3.7.1 Immediate Operands\nSome instructions use data encoded in the instruction itself as a source operand. These operands are called imme-\ndiate operands (or simply immediates). For example, the following ADD instruction adds an immediate value of 14 \nto the contents of the EAX register:\n\nADD EAX, 14\n\nAll arithmetic instructions (except the DIV and IDIV instructions) allow the source operand to be an immediate \nvalue. The maximum value allowed for an immediate operand varies among instructions, but can never be greater \nthan the maximum value of an unsigned doubleword integer (232).\n\n3.7.2 Register Operands\nSource and destination operands can be any of the following registers, depending on the instruction being \nexecuted:\n• 32-bit general-purpose registers (EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP)\n• 16-bit general-purpose registers (AX, BX, CX, DX, SI, DI, SP, or BP)\n• 8-bit general-purpose registers (AH, BH, CH, DH, AL, BL, CL, or DL)\n• segment registers (CS, DS, SS, ES, FS, and GS)\n• EFLAGS register\n• x87 FPU registers (ST0 through ST7, status word, control word, tag word, data operand pointer, and instruction \n\npointer)\n• MMX registers (MM0 through MM7)\n• XMM registers (XMM0 through XMM7) and the MXCSR register\n• control registers (CR0, CR2, CR3, and CR4) and system table pointer registers (GDTR, LDTR, IDTR, and task \n\nregister)\n• debug registers (DR0, DR1, DR2, DR3, DR6, and DR7)\n• MSR registers\n\nSome instructions (such as the DIV and MUL instructions) use quadword operands contained in a pair of 32-bit \nregisters. Register pairs are represented with a colon separating them. For example, in the register pair EDX:EAX, \nEDX contains the high order bits and EAX contains the low order bits of a quadword operand. \n\nSeveral instructions (such as the PUSHFD and POPFD instructions) are provided to load and store the contents of \nthe EFLAGS register or to set or clear individual flags in this register. Other instructions (such as the Jcc instruc-\ntions) use the state of the status flags in the EFLAGS register as condition codes for branching or other decision \nmaking operations.\n\nThe processor contains a selection of system registers that are used to control memory management, interrupt and \nexception handling, task management, processor management, and debugging activities. Some of these system \nregisters are accessible by an application program, the operating system, or the executive through a set of system \ninstructions. When accessing a system register with a system instruction, the register is generally an implied \noperand of the instruction.\n3-20 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.7.2.1  Register Operands in 64-Bit Mode\nRegister operands in 64-bit mode can be any of the following:\n• 64-bit general-purpose registers (RAX, RBX, RCX, RDX, RSI, RDI, RSP, RBP, or R8-R15)\n• 32-bit general-purpose registers (EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP, or R8D-R15D)\n• 16-bit general-purpose registers (AX, BX, CX, DX, SI, DI, SP, BP, or R8W-R15W)\n• 8-bit general-purpose registers: AL, BL, CL, DL, SIL, DIL, SPL, BPL, and R8B-R15B are available using REX \n\nprefixes; AL, BL, CL, DL, AH, BH, CH, DH are available without using REX prefixes.\n• Segment registers (CS, DS, SS, ES, FS, and GS)\n• RFLAGS register\n• x87 FPU registers (ST0 through ST7, status word, control word, tag word, data operand pointer, and instruction \n\npointer)\n• MMX registers (MM0 through MM7)\n• XMM registers (XMM0 through XMM15) and the MXCSR register\n• Control registers (CR0, CR2, CR3, CR4, and CR8) and system table pointer registers (GDTR, LDTR, IDTR, and \n\ntask register)\n• Debug registers (DR0, DR1, DR2, DR3, DR6, and DR7)\n• MSR registers\n• RDX:RAX register pair representing a 128-bit operand\n\n3.7.3 Memory Operands\nSource and destination operands in memory are referenced by means of a segment selector and an offset (see \nFigure 3-9). Segment selectors specify the segment containing the operand. Offsets specify the linear or effective \naddress of the operand. Offsets can be 32 bits (represented by the notation m16:32) or 16 bits (represented by the \nnotation m16:16).\n\n3.7.3.1  Memory Operands in 64-Bit Mode\nIn 64-bit mode, a memory operand can be referenced by a segment selector and an offset. The offset can be 16 \nbits, 32 bits or 64 bits (see Figure 3-10).\n\n3.7.4 Specifying a Segment Selector\nThe segment selector can be specified either implicitly or explicitly. The most common method of specifying a \nsegment selector is to load it in a segment register and then allow the processor to select the register implicitly, \ndepending on the type of operation being performed. The processor automatically chooses a segment according to \nthe rules given in Table 3-5. \n\nFigure 3-9.  Memory Operand Address\n\nFigure 3-10.  Memory Operand Address in 64-Bit Mode\n\nOffset (or Linear Address)\n015\n\nSegment\n310\n\nSelector\n\nOffset (or Linear Address)\n015\n\nSegment\n630\n\nSelector\nVol. 1 3-21\n\n\n\nBASIC EXECUTION ENVIRONMENT\nWhen storing data in memory or loading data from memory, the DS segment default can be overridden to allow \nother segments to be accessed. Within an assembler, the segment override is generally handled with a colon “:” \noperator. For example, the following MOV instruction moves a value from register EAX into the segment pointed to \nby the ES register. The offset into the segment is contained in the EBX register:\n\nMOV ES:[EBX], EAX\n\nAt the machine level, a segment override is specified with a segment-override prefix, which is a byte placed at the \nbeginning of an instruction. The following default segment selections cannot be overridden:\n• Instruction fetches must be made from the code segment.\n• Destination strings in string instructions must be stored in the data segment pointed to by the ES register.\n• Push and pop operations must always reference the SS segment.\n\nSome instructions require a segment selector to be specified explicitly. In these cases, the 16-bit segment selector \ncan be located in a memory location or in a 16-bit register. For example, the following MOV instruction moves a \nsegment selector located in register BX into segment register DS:\n\nMOV DS, BX\n\nSegment selectors can also be specified explicitly as part of a 48-bit far pointer in memory. Here, the first double-\nword in memory contains the offset and the next word contains the segment selector.\n\n3.7.4.1  Segmentation in 64-Bit Mode\nIn IA-32e mode, the effects of segmentation depend on whether the processor is running in compatibility mode or \n64-bit mode. In compatibility mode, segmentation functions just as it does in legacy IA-32 mode, using the 16-bit \nor 32-bit protected mode semantics described above.\n\nIn 64-bit mode, segmentation is generally (but not completely) disabled, creating a flat 64-bit linear-address \nspace. The processor treats the segment base of CS, DS, ES, SS as zero, creating a linear address that is equal to \nthe effective address. The exceptions are the FS and GS segments, whose segment registers (which hold the \nsegment base) can be used as additional base registers in some linear address calculations.\n\n3.7.5 Specifying an Offset\nThe offset part of a memory address can be specified directly as a static value (called a displacement) or through \nan address computation made up of one or more of the following components:\n• Displacement — An 8-, 16-, or 32-bit value.\n• Base — The value in a general-purpose register.\n• Index — The value in a general-purpose register.\n• Scale factor — A value of 2, 4, or 8 that is multiplied by the index value.\n\nTable 3-5.  Default Segment Selection Rules\n\nReference Type Register Used Segment Used Default Selection Rule\n\nInstructions CS Code Segment All instruction fetches.\n\nStack SS Stack Segment All stack pushes and pops.\nAny memory reference which uses the ESP or EBP register as a base \nregister.\n\nLocal Data DS Data Segment All data references, except when relative to stack or string destination.\n\nDestination Strings ES Data Segment \npointed to with the \nES register\n\nDestination of string instructions.\n3-22 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nThe offset which results from adding these components is called an effective address. Each of these components \ncan have either a positive or negative (2s complement) value, with the exception of the scaling factor. Figure 3-11 \nshows all the possible ways that these components can be combined to create an effective address in the selected \nsegment.\n\nThe uses of general-purpose registers as base or index components are restricted in the following manner:\n• The ESP register cannot be used as an index register.\n• When the ESP or EBP register is used as the base, the SS segment is the default segment. In all other cases, \n\nthe DS segment is the default segment.\n\nThe base, index, and displacement components can be used in any combination, and any of these components can \nbe NULL. A scale factor may be used only when an index also is used. Each possible combination is useful for data \nstructures commonly used by programmers in high-level languages and assembly language. \n\nThe following addressing modes suggest uses for common combinations of address components.\n• Displacement ⎯ A displacement alone represents a direct (uncomputed) offset to the operand. Because the \n\ndisplacement is encoded in the instruction, this form of an address is sometimes called an absolute or static \naddress. It is commonly used to access a statically allocated scalar operand.\n\n• Base ⎯ A base alone represents an indirect offset to the operand. Since the value in the base register can \nchange, it can be used for dynamic storage of variables and data structures.\n\n• Base + Displacement ⎯ A base register and a displacement can be used together for two distinct purposes:\n\n— As an index into an array when the element size is not 2, 4, or 8 bytes—The displacement component \nencodes the static offset to the beginning of the array. The base register holds the results of a calculation \nto determine the offset to a specific element within the array.\n\n— To access a field of a record: the base register holds the address of the beginning of the record, while the \ndisplacement is a static offset to the field.\n\nAn important special case of this combination is access to parameters in a procedure activation record. A \nprocedure activation record is the stack frame created when a procedure is entered. Here, the EBP register is \nthe best choice for the base register, because it automatically selects the stack segment. This is a compact \nencoding for this common function.\n\n• (Index ∗ Scale) + Displacement ⎯ This address mode offers an efficient way to index into a static array \nwhen the element size is 2, 4, or 8 bytes. The displacement locates the beginning of the array, the index \nregister holds the subscript of the desired array element, and the processor automatically converts the \nsubscript into an index by applying the scaling factor.\n\n• Base + Index + Displacement ⎯ Using two registers together supports either a two-dimensional array (the \ndisplacement holds the address of the beginning of the array) or one of several instances of an array of records \n(the displacement is an offset to a field within the record).\n\n• Base + (Index ∗ Scale) + Displacement ⎯ Using all the addressing components together allows efficient \nindexing of a two-dimensional array when the elements of the array are 2, 4, or 8 bytes in size.\n\nFigure 3-11.  Offset (or Effective Address) Computation\n\nOffset = Base + (Index * Scale) + Displacement\n\nBase\n\nEAX\nEBX\nECX\nEDX\nESP\nEBP\nESI\nEDI\n\nEAX\nEBX\nECX\nEDX\nEBP\nESI\nEDI\n\n1 None\n\n2\n\n4\n\n8\n\n8-bit\n\n16-bit\n\n32-bit\n\nIndex Scale Displacement\n\n*\n+ +\nVol. 1 3-23\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.7.5.1  Specifying an Offset in 64-Bit Mode\nThe offset part of a memory address in 64-bit mode can be specified directly as a static value or through an address \ncomputation made up of one or more of the following components:\n• Displacement — An 8-bit, 16-bit, or 32-bit value.\n• Base — The value in a 64-bit general-purpose register.\n• Index — The value in a 64-bit general-purpose register.\n• Scale factor — A value of 2, 4, or 8 that is multiplied by the index value.\n\nThe base and index value can be specified in one of sixteen available general-purpose registers in most cases. See \nChapter 2, “Instruction Format,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A.\n\nThe following unique combination of address components is also available.\n• RIP + Displacement ⎯ In 64-bit mode, RIP-relative addressing uses a signed 32-bit displacement to \n\ncalculate the effective address of the next instruction by sign-extend the 32-bit value and add to the 64-bit \nvalue in RIP.\n\n3.7.6 Assembler and Compiler Addressing Modes\nAt the machine-code level, the selected combination of displacement, base register, index register, and scale factor \nis encoded in an instruction. All assemblers permit a programmer to use any of the allowable combinations of these \naddressing components to address operands. High-level language compilers will select an appropriate combination \nof these components based on the language construct a programmer defines.\n\n3.7.7 I/O Port Addressing\nThe processor supports an I/O address space that contains up to 65,536 8-bit I/O ports. Ports that are 16-bit and \n32-bit may also be defined in the I/O address space. An I/O port can be addressed with either an immediate \noperand or a value in the DX register. See Chapter 19, “Input/Output,” for more information about I/O port \naddressing.\n3-24 Vol. 1\n\n\n\nCHAPTER 4\nDATA TYPES\n\nThis chapter introduces data types defined for the Intel 64 and IA-32 architectures. A section at the end of this \nchapter describes the real-number and floating-point concepts used in x87 FPU, SSE, SSE2, SSE3, SSSE3, SSE4 \nand Intel AVX extensions.\n\n4.1 FUNDAMENTAL DATA TYPES\nThe fundamental data types are bytes, words, doublewords, quadwords, and double quadwords (see Figure 4-1). \nA byte is eight bits, a word is 2 bytes (16 bits), a doubleword is 4 bytes (32 bits), a quadword is 8 bytes (64 bits), \nand a double quadword is 16 bytes (128 bits). A subset of the IA-32 architecture instructions operates on these \nfundamental data types without any additional operand typing.\n\nThe quadword data type was introduced into the IA-32 architecture in the Intel486 processor; the double quadword \ndata type was introduced in the Pentium III processor with the SSE extensions.\n\nFigure 4-2 shows the byte order of each of the fundamental data types when referenced as operands in memory. \nThe low byte (bits 0 through 7) of each data type occupies the lowest address in memory and that address is also \nthe address of the operand.\n\nFigure 4-1.  Fundamental Data Types\n\n0\n\n63\n\nDouble \n\n0\n\nWord\n\n31\n\n0\n\nDoubleword\n\n15\n\n0\n\nByte\n\n7\n\n78\n\nLow WordHigh Word\n\nLow DoublewordHigh Doubleword\n\n1516\n\n3132\n\nN+1\n\nN+2\n\nN+4\n\nLow\nByte\n\nHigh\nByte\n\nN\n\nLow QuadwordHigh Quadword\nQuadword\n\nN\n\nN\n\nN\n\nN\n\nN+8\n\n0\n\nQuadword\n\n127 6364\nVol. 1 4-1\n\n\n\nDATA TYPES\n4.1.1 Alignment of Words, Doublewords, Quadwords, and Double Quadwords\nWords, doublewords, and quadwords do not need to be aligned in memory on natural boundaries. The natural \nboundaries for words, double words, and quadwords are even-numbered addresses, addresses evenly divisible by \nfour, and addresses evenly divisible by eight, respectively. However, to improve the performance of programs, data \nstructures (especially stacks) should be aligned on natural boundaries whenever possible. The reason for this is \nthat the processor requires two memory accesses to make an unaligned memory access; aligned accesses require \nonly one memory access. A word or doubleword operand that crosses a 4-byte boundary or a quadword operand \nthat crosses an 8-byte boundary is considered unaligned and requires two separate memory bus cycles for access.\n\nSome instructions that operate on double quadwords require memory operands to be aligned on a natural \nboundary. These instructions generate a general-protection exception (#GP) if an unaligned operand is specified. A \nnatural boundary for a double quadword is any address evenly divisible by 16. Other instructions that operate on \ndouble quadwords permit unaligned access (without generating a general-protection exception). However, addi-\ntional memory bus cycles are required to access unaligned data from memory.\n\n4.2 NUMERIC DATA TYPES\nAlthough bytes, words, and doublewords are fundamental data types, some instructions support additional inter-\npretations of these data types to allow operations to be performed on numeric data types (signed and unsigned \nintegers, and floating-point numbers). Single-precision (32-bit) floating-point and double-precision (64-bit) \nfloating-point data types are supported across all generations of SSE extensions and Intel AVX extensions. Half-\nprecision (16-bit) floating-point data type is supported only with F16C extensions (VCVTPH2PS, VCVTPS2PH). See \nFigure 4-3. \n\nFigure 4-2.  Bytes, Words, Doublewords, Quadwords, and Double Quadwords in Memory\n\nEH\n\nDH7AH\n\nCHFEH\n\nBH06H\n\nAH36H\n\n9H1FH\n\n8HA4H\n\n7H23H\n\n6H0BH\n\n5H\n\n4H\n\n3H74H\n\n2HCBH\n\n1H31H\n\n0H\n\nQuadword at Address 6H\nContains \n\nDoubleword at Address AH\nContains 7AFE0636H\n\nWord at Address BH\nContains FE06H\n\nByte at Address 9H\nContains 1FH\n\nWord at Address 6H\nContains 230BH\n\nWord at Address 1H\nContains CB31H\n\nWord at Address 2H\nContains 74CBH\n\nDouble quadword at Address 0H\n\n45H\n\n67H\n\n12H\n\nContains\n\n12H\n\n7AFE06361FA4230BH\n\n4E127AFE06361FA4230B456774CB3112\n\n4EH FH\n4-2 Vol. 1\n\n\n\nDATA TYPES\n4.2.1 Integers\nThe Intel 64 and IA-32 architectures define two types of integers: unsigned and signed. Unsigned integers are ordi-\nnary binary values ranging from 0 to the maximum positive number that can be encoded in the selected operand \nsize. Signed integers are two’s complement binary values that can be used to represent both positive and negative \ninteger values.\n\nSome integer instructions (such as the ADD, SUB, PADDB, and PSUBB instructions) operate on either unsigned or \nsigned integer operands. Other integer instructions (such as IMUL, MUL, IDIV, DIV, FIADD, and FISUB) operate on \nonly one integer type.\n\nThe following sections describe the encodings and ranges of the two types of integers.\n\n4.2.1.1  Unsigned Integers\nUnsigned integers are unsigned binary numbers contained in a byte, word, doubleword, and quadword. Their \nvalues range from 0 to 255 for an unsigned byte integer, from 0 to 65,535 for an unsigned word integer, from 0 \n\nFigure 4-3.  Numeric Data Types\n\n0\n\n0\n\n022\n\n0\n\nDouble Extended Precision\n\n63 62\n\n0\n\nWord Signed Integer\n\n0\n\nByte Signed Integer\n\n7 6\n\nSign\n\nSign\n\nDoubleword Signed Integer\n\n15 14\n\nSign\n\n31 30\n\nSign\n\nQuadword Signed Integer\n\n0\n\n0\n\nWord Unsigned Integer\n\n0\nByte Unsigned Integer\n\n7\n\nDoubleword Unsigned Integer\n\n15\n\n31\n\nQuadword Unsigned Integer\n\n63\n\n0\n\n0\n\n233031\n\n51526263\n\n64 63 62 79 78\nFloating Point\n\nSingle Precision\nFloating Point\n\nDouble Precision\nFloating Point\n\nSign\n\nInteger Bit\n\nSign\n\nSign\n\n091415\n\nHalf Precision\nFloating Point\n\nSign\nVol. 1 4-3\n\n\n\nDATA TYPES\nto 232 – 1 for an unsigned doubleword integer, and from 0 to 264 – 1 for an unsigned quadword integer. Unsigned \nintegers are sometimes referred to as ordinals.\n\n4.2.1.2  Signed Integers\nSigned integers are signed binary numbers held in a byte, word, doubleword, or quadword. All operations on signed \nintegers assume a two's complement representation. The sign bit is located in bit 7 in a byte integer, bit 15 in a \nword integer, bit 31 in a doubleword integer, and bit 63 in a quadword integer (see the signed integer encodings in \nTable 4-1).\n\nThe sign bit is set for negative integers and cleared for positive integers and zero. Integer values range from –128 \nto +127 for a byte integer, from –32,768 to +32,767 for a word integer, from –231 to +231 – 1 for a doubleword \ninteger, and from –263 to +263 – 1 for a quadword integer.\n\nWhen storing integer values in memory, word integers are stored in 2 consecutive bytes; doubleword integers are \nstored in 4 consecutive bytes; and quadword integers are stored in 8 consecutive bytes.\n\nThe integer indefinite is a special value that is sometimes returned by the x87 FPU when operating on integer \nvalues. For more information, see Section 8.2.1, “Indefinites.”\n\n4.2.2 Floating-Point Data Types\nThe IA-32 architecture defines and operates on three floating-point data types: single-precision floating-point, \ndouble-precision floating-point, and double-extended precision floating-point (see Figure 4-3). The data formats \nfor these data types correspond directly to formats specified in the IEEE Standard 754 for Binary Floating-Point \nArithmetic. \n\nHalf-precision (16-bit) floating-point data type is supported only for conversion operation with single-precision \nfloating data using F16C extensions (VCVTPH2PS, VCVTPS2PH).\n\nTable 4-2 gives the length, precision, and approximate normalized range that can be represented by each of these \ndata types. Denormal values are also supported in each of these types.\n\nTable 4-1.  Signed Integer Encodings\nClass Two’s Complement Encoding\n\nSign\n\nPositive Largest 0 11..11\n\n. .\n\n. .\n\nSmallest 0 00..01\n\nZero 0 00..00\n\nNegative Smallest 1 11..11\n\n. .\n\n. .\n\nLargest 1 00..00\n\nInteger indefinite 1 00..00\n\nSigned Byte Integer:\nSigned Word Integer:\nSigned Doubleword Integer:\nSigned Quadword Integer:\n\n← 7 bits →\n← 15 bits →\n← 31 bits →\n← 63 bits →\n4-4 Vol. 1\n\n\n\nDATA TYPES\nNOTE\nSection 4.8, “Real Numbers and Floating-Point Formats,” gives an overview of the IEEE Standard \n754 floating-point formats and defines the terms integer bit, QNaN, SNaN, and denormal value.\n\nTable 4-3 shows the floating-point encodings for zeros, denormalized finite numbers, normalized finite numbers, \ninfinites, and NaNs for each of the three floating-point data types. It also gives the format for the QNaN floating-\npoint indefinite value. (See Section 4.8.3.7, “QNaN Floating-Point Indefinite,” for a discussion of the use of the \nQNaN floating-point indefinite value.)\n\nFor the single-precision and double-precision formats, only the fraction part of the significand is encoded. The \ninteger is assumed to be 1 for all numbers except 0 and denormalized finite numbers. For the double extended-\nprecision format, the integer is contained in bit 63, and the most-significant fraction bit is bit 62. Here, the integer \nis explicitly set to 1 for normalized numbers, infinities, and NaNs, and to 0 for zero and denormalized numbers.\n\nTable 4-2.  Length, Precision, and Range of Floating-Point Data Types\nData Type Length Precision\n\n(Bits)\nApproximate Normalized Range\n\nBinary Decimal\n\nHalf Precision 16 11 2–14 to 215 3.1 × 10–5 to 6.50 × 104\n\nSingle Precision 32 24 2–126 to 2127 1.18 × 10–38 to 3.40 × 1038\n\nDouble Precision 64 53 2–1022 to 21023 2.23 × 10–308 to 1.79 × 10308\n\nDouble Extended \nPrecision\n\n80 64 2–16382 to 216383 3.37 × 10–4932 to 1.18 × 104932\n\nTable 4-3.  Floating-Point Number and NaN Encodings\n\nClass Sign Biased Exponent\nSignificand\n\nInteger1 Fraction\n\nPositive +∞ 0 11..11 1 00..00\n\n+Normals 0\n.\n.\n0\n\n11..10\n    .\n    .\n\n00..01\n\n1\n.\n.\n1\n\n11..11\n    .\n    .\n\n00..00\n\n+Denormals 0\n.\n.\n0\n\n00..00\n    .\n    .\n\n00..00\n\n0\n.\n.\n0\n\n11.11\n    .\n    .\n\n00..01\n\n+Zero 0 00..00 0 00..00\n\nNegative −Zero 1 00..00 0 00..00\n\n−Denormals 1\n.\n.\n1\n\n00..00\n    .\n    .\n\n00..00\n\n0\n.\n.\n0\n\n00..01\n    .\n    .\n\n11..11\n\n−Normals 1\n.\n.\n1\n\n00..01\n    .\n    .\n\n11..10\n\n1\n.\n.\n1\n\n00..00\n    .\n    .\n\n11..11\n\n-∞ 1 11..11 1 00..00\nVol. 1 4-5\n\n\n\nDATA TYPES\nThe exponent of each floating-point data type is encoded in biased format; see Section 4.8.2.2, “Biased Exponent.” \nThe biasing constant is 15 for the half-precision format, 127 for the single-precision format, 1023 for the double-\nprecision format, and 16,383 for the double extended-precision format.\n\nWhen storing floating-point values in memory, half-precision values are stored in 2 consecutive bytes in memory; \nsingle-precision values are stored in 4 consecutive bytes in memory; double-precision values are stored in 8 \nconsecutive bytes; and double extended-precision values are stored in 10 consecutive bytes.\n\nThe single-precision and double-precision floating-point data types are operated on by x87 FPU, and \nSSE/SSE2/SSE3/SSE4.1 and Intel AVX instructions. The double-extended-precision floating-point format is only \noperated on by the x87 FPU. See Section 11.6.8, “Compatibility of SIMD and x87 FPU Floating-Point Data Types,” \nfor a discussion of the compatibility of single-precision and double-precision floating-point data types between the \nx87 FPU and SSE/SSE2/SSE3 extensions.\n\n4.3 POINTER DATA TYPES\nPointers are addresses of locations in memory. \n\nIn non-64-bit modes, the architecture defines two types of pointers: a near pointer and a far pointer. A near \npointer is a 32-bit (or 16-bit) offset (also called an effective address) within a segment. Near pointers are used \nfor all memory references in a flat memory model or for references in a segmented model where the identity of the \nsegment being accessed is implied. \n\nA far pointer is a logical address, consisting of a 16-bit segment selector and a 32-bit (or 16-bit) offset. Far pointers \nare used for memory references in a segmented memory model where the identity of a segment being accessed \nmust be specified explicitly. Near and far pointers with 32-bit offsets are shown in Figure 4-4.\n\nNaNs SNaN X 11..11 1 0X..XX2\n\nQNaN X 11..11 1 1X..XX\n\nQNaN Floating-\nPoint Indefinite\n\n1 11..11 1 10..00\n\nHalf-Precision\n\nSingle-Precision:\nDouble-Precision:\nDouble Extended-Precision:\n\n← 5Bits →\n← 8 Bits →\n← 11 Bits →\n← 15 Bits →\n\n← 10 Bits →\n← 23 Bits →\n← 52 Bits →\n← 63 Bits →\n\nNOTES:\n1. Integer bit is implied and not stored for single-precision and double-precision formats.\n2. The fraction for SNaN encodings must be non-zero with the most-significant bit 0.\n\nFigure 4-4.  Pointer Data Types\n\nTable 4-3.  Floating-Point Number and NaN Encodings (Contd.)\n\nClass Sign Biased Exponent\nSignificand\n\nInteger1 Fraction\n\n047\n\nFar Pointer or Logical Address\nSegment Selector\n\n32 31\nOffset\n\nNear Pointer\n\n031\nOffset\n4-6 Vol. 1\n\n\n\nDATA TYPES\n4.3.1 Pointer Data Types in 64-Bit Mode\nIn 64-bit mode (a sub-mode of IA-32e mode), a near pointer is 64 bits. This equates to an effective address. Far \npointers in 64-bit mode can be one of three forms: \n• 16-bit segment selector, 16-bit offset if the operand size is 32 bits \n• 16-bit segment selector, 32-bit offset if the operand size is 32 bits \n• 16-bit segment selector, 64-bit offset if the operand size is 64 bits\n\nSee Figure 4-5.\n\n4.4 BIT FIELD DATA TYPE\nA bit field (see Figure 4-6) is a contiguous sequence of bits. It can begin at any bit position of any byte in memory \nand can contain up to 32 bits.\n\nFigure 4-5.  Pointers in 64-Bit Mode\n\nFigure 4-6.  Bit Field Data Type\n\n16-bit Segment Selector 16-bit Offset\n\n016 1531\n\n16-bit Segment Selector 32-bit Offset\n\n032 3147\n\n16-bit Segment Selector 64-bit Offset\n\n064 6379\n\n64-bit Offset\n\n063\n\nNear Pointer\n\nFar Pointer with 64-bit Operand Size\n\nFar Pointer with 32-bit Operand Size\n\nFar Pointer with 32-bit Operand Size\n\nBit Field\n\nField Length\n\nLeast\n\nBit\nSignificant\nVol. 1 4-7\n\n\n\nDATA TYPES\n4.5 STRING DATA TYPES\nStrings are continuous sequences of bits, bytes, words, or doublewords. A bit string can begin at any bit position \nof any byte and can contain up to 232 – 1 bits. A byte string can contain bytes, words, or doublewords and can \nrange from zero to 232 – 1 bytes (4 GBytes).\n\n4.6 PACKED SIMD DATA TYPES\nIntel 64 and IA-32 architectures define and operate on a set of 64-bit and 128-bit packed data type for use in SIMD \noperations. These data types consist of fundamental data types (packed bytes, words, doublewords, and quad-\nwords) and numeric interpretations of fundamental types for use in packed integer and packed floating-point oper-\nations.\n\n4.6.1 64-Bit SIMD Packed Data Types\nThe 64-bit packed SIMD data types were introduced into the IA-32 architecture in the Intel MMX technology. They \nare operated on in MMX registers. The fundamental 64-bit packed data types are packed bytes, packed words, and \npacked doublewords (see Figure 4-7). When performing numeric SIMD operations on these data types, these data \ntypes are interpreted as containing byte, word, or doubleword integer values.\n\n4.6.2 128-Bit Packed SIMD Data Types\nThe 128-bit packed SIMD data types were introduced into the IA-32 architecture in the SSE extensions and used \nwith SSE2, SSE3 and SSSE3 extensions. They are operated on primarily in the 128-bit XMM registers and memory. \nThe fundamental 128-bit packed data types are packed bytes, packed words, packed doublewords, and packed \nquadwords (see Figure 4-8). When performing SIMD operations on these fundamental data types in XMM registers, \nthese data types are interpreted as containing packed or scalar single-precision floating-point or double-precision \nfloating-point values, or as containing packed byte, word, doubleword, or quadword integer values.\n\nFigure 4-7.  64-Bit Packed SIMD Data Types\n\nPacked Words\n\nPacked Bytes\n\nPacked Doublewords\n\n063\n\n063\n\n063\n\nPacked Word Integers\n\nPacked Byte Integers\n\nPacked Doubleword Integers\n\n063\n\n063\n\n063\n\nFundamental 64-Bit Packed SIMD Data Types\n\n64-Bit Packed Integer Data Types\n4-8 Vol. 1\n\n\n\nDATA TYPES\n4.7 BCD AND PACKED BCD INTEGERS\nBinary-coded decimal integers (BCD integers) are unsigned 4-bit integers with valid values ranging from 0 to 9. IA-\n32 architecture defines operations on BCD integers located in one or more general-purpose registers or in one or \nmore x87 FPU registers (see Figure 4-9).\n\nFigure 4-8.  128-Bit Packed SIMD Data Types\n\n0127\n\nPacked Words\n\nPacked Bytes\n\nPacked Doublewords\n\nPacked Word Integers\n\nPacked Byte Integers\n\nPacked Doubleword Integers\n\nFundamental 128-Bit Packed SIMD Data Types\n\n128-Bit Packed Floating-Point and Integer Data Types\n\nPacked Quadwords\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\nPacked Quadword Integers\n\nPacked Single Precision \nFloating Point\n\nPacked Double Precision \nFloating Point\nVol. 1 4-9\n\n\n\nDATA TYPES\nWhen operating on BCD integers in general-purpose registers, the BCD values can be unpacked (one BCD digit per \nbyte) or packed (two BCD digits per byte). The value of an unpacked BCD integer is the binary value of the low half-\nbyte (bits 0 through 3). The high half-byte (bits 4 through 7) can be any value during addition and subtraction, but \nmust be zero during multiplication and division. Packed BCD integers allow two BCD digits to be contained in one \nbyte. Here, the digit in the high half-byte is more significant than the digit in the low half-byte.\n\nWhen operating on BCD integers in x87 FPU data registers, BCD values are packed in an 80-bit format and referred \nto as decimal integers. In this format, the first 9 bytes hold 18 BCD digits, 2 digits per byte. The least-significant \ndigit is contained in the lower half-byte of byte 0 and the most-significant digit is contained in the upper half-byte \nof byte 9. The most significant bit of byte 10 contains the sign bit (0 = positive and 1 = negative; bits 0 through 6 \nof byte 10 are don’t care bits). Negative decimal integers are not stored in two's complement form; they are distin-\nguished from positive decimal integers only by the sign bit. The range of decimal integers that can be encoded in \nthis format is –1018 + 1 to 1018 – 1. \nThe decimal integer format exists in memory only. When a decimal integer is loaded in an x87 FPU data register, it \nis automatically converted to the double-extended-precision floating-point format. All decimal integers are exactly \nrepresentable in double extended-precision format.\n\nTable 4-4 gives the possible encodings of value in the decimal integer data type.\n\nFigure 4-9.  BCD Data Types\n\nTable 4-4.  Packed Decimal Integer Encodings\n\nClass Sign\nMagnitude\n\ndigit digit digit digit ... digit\n\nPositive\n\n Largest 0 0000000 1001 1001 1001 1001 ... 1001\n\n. . .\n\n. . .\n\n Smallest 0 0000000 0000 0000 0000 0000 ... 0001\n\n Zero 0 0000000 0000 0000 0000 0000 ... 0000\n\nNegative\n\n Zero 1 0000000 0000 0000 0000 0000 ... 0000\n\n Smallest 1 0000000 0000 0000 0000 0000 ... 0001\n\n. . .\n\n. . .\n\n Largest 1 0000000 1001 1001 1001 1001 ... 1001\n\nPacked BCD Integers\n\nBCDBCD\n\n0\n\nBCD Integers\n\n7\nBCDX\n\n34\n\n0\n\n80-Bit Packed BCD Decimal Integers\n\n79\nD0\n\n4 Bits = 1 BCD Digit\n\nSign\nD1D2D3D4D5D6D7D8D9D10D11D12D13D14D15D16D17\n\n78 72 71\nX\n\n07 34\n4-10 Vol. 1\n\n\n\nDATA TYPES\nThe packed BCD integer indefinite encoding (FFFFC000000000000000H) is stored by the FBSTP instruction in \nresponse to a masked floating-point invalid-operation exception. Attempting to load this value with the FBLD \ninstruction produces an undefined result.\n\n4.8 REAL NUMBERS AND FLOATING-POINT FORMATS\nThis section describes how real numbers are represented in floating-point format in x87 FPU and \nSSE/SSE2/SSE3/SSE4.1 and Intel AVX floating-point instructions. It also introduces terms such as normalized \nnumbers, denormalized numbers, biased exponents, signed zeros, and NaNs. Readers who are already familiar \nwith floating-point processing techniques and the IEEE Standard 754 for Binary Floating-Point Arithmetic may wish \nto skip this section.\n\n4.8.1 Real Number System\nAs shown in Figure 4-10, the real-number system comprises the continuum of real numbers from minus infinity (−\n∞) to plus infinity (+ ∞).\n\nBecause the size and number of registers that any computer can have is limited, only a subset of the real-number \ncontinuum can be used in real-number (floating-point) calculations. As shown at the bottom of Figure 4-10, the \nsubset of real numbers that the IA-32 architecture supports represents an approximation of the real number \nsystem. The range and precision of this real-number subset is determined by the IEEE Standard 754 floating-point \nformats. \n\n4.8.2 Floating-Point Format\nTo increase the speed and efficiency of real-number computations, computers and microprocessors typically repre-\nsent real numbers in a binary floating-point format. In this format, a real number has three parts: a sign, a signif-\nicand, and an exponent (see Figure 4-11).\n\nThe sign is a binary value that indicates whether the number is positive (0) or negative (1). The significand has \ntwo parts: a 1-bit binary integer (also referred to as the J-bit) and a binary fraction. The integer-bit is often not \nrepresented, but instead is an implied value. The exponent is a binary integer that represents the base-2 power by \nwhich the significand is multiplied.\n\nTable 4-5 shows how the real number 178.125 (in ordinary decimal format) is stored in IEEE Standard 754 floating-\npoint format. The table lists a progression of real number notations that leads to the single-precision, 32-bit \nfloating-point format. In this format, the significand is normalized (see Section 4.8.2.1, “Normalized Numbers”) \nand the exponent is biased (see Section 4.8.2.2, “Biased Exponent”). For the single-precision floating-point \nformat, the biasing constant is +127.\n\nPacked BCD \nInteger \nIndefinite\n\n1 1111111 1111 1111 1100 0000 ... 0000\n\n← 1 byte → ← 9 bytes →\n\nTable 4-4.  Packed Decimal Integer Encodings (Contd.)\n\nClass Sign\nMagnitude\n\ndigit digit digit digit ... digit\nVol. 1 4-11\n\n\n\nDATA TYPES\nFigure 4-10.  Binary Real Number System\n\nFigure 4-11.  Binary Floating-Point Format\n\nTable 4-5.  Real and Floating-Point Number Notation\n\nNotation Value\n\nOrdinary Decimal 178.125\n\nScientific Decimal 1.78125E10 2\n\nScientific Binary 1.0110010001E2111\n\nScientific Binary\n(Biased Exponent)\n\n 1.0110010001E210000110\n\nIEEE Single-Precision Format Sign Biased Exponent Normalized Significand\n\n0 10000110 01100100010000000000000\n\n          1. (Implied)\n\nBinary Real Number System\n\nSubset of binary real numbers that can be represented with\nIEEE single-precision (32-bit) floating-point format\n\n+10\n\n10.0000000000000000000000\n\n1.11111111111111111111111\nPrecision 24 Binary Digits\n\nNumbers within this range\ncannot be represented.\n\nςς ςς\n-100 -10 -1 0 1 10 100\n\nςς ςς\n-100 -10 -1 0 1 10 100\n\nSign\n\nInteger or J-Bit\n\nExponent Significand\n\nFraction\n4-12 Vol. 1\n\n\n\nDATA TYPES\n4.8.2.1  Normalized Numbers\nIn most cases, floating-point numbers are encoded in normalized form. This means that except for zero, the signif-\nicand is always made up of an integer of 1 and the following fraction:\n\n1.fff...ff\n\nFor values less than 1, leading zeros are eliminated. (For each leading zero eliminated, the exponent is decre-\nmented by one.)\n\nRepresenting numbers in normalized form maximizes the number of significant digits that can be accommodated \nin a significand of a given width. To summarize, a normalized real number consists of a normalized significand that \nrepresents a real number between 1 and 2 and an exponent that specifies the number’s binary point.\n\n4.8.2.2  Biased Exponent\nIn the IA-32 architecture, the exponents of floating-point numbers are encoded in a biased form. This means that \na constant is added to the actual exponent so that the biased exponent is always a positive number. The value of \nthe biasing constant depends on the number of bits available for representing exponents in the floating-point \nformat being used. The biasing constant is chosen so that the smallest normalized number can be reciprocated \nwithout overflow.\n\nSee Section 4.2.2, “Floating-Point Data Types,” for a list of the biasing constants that the IA-32 architecture uses \nfor the various sizes of floating-point data-types.\n\n4.8.3 Real Number and Non-number Encodings\nA variety of real numbers and special values can be encoded in the IEEE Standard 754 floating-point format. These \nnumbers and values are generally divided into the following classes:\n• Signed zeros\n• Denormalized finite numbers\n• Normalized finite numbers\n• Signed infinities\n• NaNs\n• Indefinite numbers\n\n(The term NaN stands for “Not a Number.”)\n\nFigure 4-12 shows how the encodings for these numbers and non-numbers fit into the real number continuum. The \nencodings shown here are for the IEEE single-precision floating-point format. The term “S” indicates the sign bit, \n“E” the biased exponent, and “Sig” the significand. The exponent values are given in decimal. The integer bit is \nshown for the significands, even though the integer bit is implied in single-precision floating-point format.\nVol. 1 4-13\n\n\n\nDATA TYPES\nAn IA-32 processor can operate on and/or return any of these values, depending on the type of computation being \nperformed. The following sections describe these number and non-number classes.\n\n4.8.3.1  Signed Zeros\nZero can be represented as a +0 or a −0 depending on the sign bit. Both encodings are equal in value. The sign of \na zero result depends on the operation being performed and the rounding mode being used. Signed zeros have \nbeen provided to aid in implementing interval arithmetic. The sign of a zero may indicate the direction from which \nunderflow occurred, or it may indicate the sign of an ∞ that has been reciprocated.\n\n4.8.3.2  Normalized and Denormalized Finite Numbers\nNon-zero, finite numbers are divided into two classes: normalized and denormalized. The normalized finite \nnumbers comprise all the non-zero finite values that can be encoded in a normalized real number format between \nzero and ∞. In the single-precision floating-point format shown in Figure 4-12, this group of numbers includes all \nthe numbers with biased exponents ranging from 1 to 25410 (unbiased, the exponent range is from −12610 to \n+12710).\n\nWhen floating-point numbers become very close to zero, the normalized-number format can no longer be used to \nrepresent the numbers. This is because the range of the exponent is not large enough to compensate for shifting \nthe binary point to the right to eliminate leading zeros.\n\nWhen the biased exponent is zero, smaller numbers can only be represented by making the integer bit (and \nperhaps other leading bits) of the significand zero. The numbers in this range are called denormalized numbers. \nThe use of leading zeros with denormalized numbers allows smaller numbers to be represented. However, this \ndenormalization may cause a loss of precision (the number of significant bits is reduced by the leading zeros).\n\nWhen performing normalized floating-point computations, an IA-32 processor normally operates on normalized \nnumbers and produces normalized numbers as results. Denormalized numbers represent an underflow condition. \nThe exact conditions are specified in Section 4.9.1.5, “Numeric Underflow Exception (#U).”\n\nA denormalized number is computed through a technique called gradual underflow. Table 4-6 gives an example of \ngradual underflow in the denormalization process. Here the single-precision format is being used, so the minimum \nexponent (unbiased) is −12610. The true result in this example requires an exponent of −12910 in order to have a \n\nFigure 4-12.  Real Numbers and NaNs\n\n1 0\nS E Sig1\n\n− 0\n\n1 0 − Denormalized\nFinite\n\nNaN\n\n1 1...254 − Normalized\nFinite\n\n1 255 − ∞\n\n255 SNaN\n\n255 QNaN\n\nNOTES:\n\n3. Sign bit ignored.\n2. Fraction must be non-zero.\n\n0 0\nS E Sig1\n\n0 0\n\nNaN\n\n0 1...254\n\n0 255\n\nX3 255 1.0XX...2\n\n255 1.1XX...\n\n+ 0\n\n+Denormalized\nFinite\n\n+Normalized\nFinite\n\n+ ∞\n\nSNaN\n\nQNaN X3\n\nX3\n\nX3\n\nReal Number and NaN Encodings For 32-Bit Floating-Point Format\n\n− Denormalized Finite\n− Normalized Finite − 0− ∞ + ∞\n\n+ Denormalized Finite\n+ Normalized Finite+ 0\n\n0.XXX...2\n\n0.000...\n\n1.000...\n\n1.XXX...\n\n1.000...\n\n0.000...\n\n0.XXX...2\n\n1.XXX...\n\n1.0XX...2\n\n1.1XX...\n\n1. Integer bit of fraction implied for\nsingle-precision floating-point format.\n4-14 Vol. 1\n\n\n\nDATA TYPES\nnormalized number.   Since  −12910 is beyond the allowable exponent range, the result is denormalized by inserting \nleading zeros until the minimum exponent of −12610 is reached.\n\nIn the extreme case, all the significant bits are shifted out to the right by leading zeros, creating a zero result. \n\nThe Intel 64 and IA-32 architectures deal with denormal values in the following ways:\n• It avoids creating denormals by normalizing numbers whenever possible.\n• It provides the floating-point underflow exception to permit programmers to detect cases when denormals are \n\ncreated.\n• It provides the floating-point denormal-operand exception to permit procedures or programs to detect when \n\ndenormals are being used as source operands for computations.\n\n4.8.3.3  Signed Infinities\nThe two infinities, + ∞ and − ∞, represent the maximum positive and negative real numbers, respectively, that can \nbe represented in the floating-point format. Infinity is always represented by a significand of 1.00...00 (the integer \nbit may be implied) and the maximum biased exponent allowed in the specified format (for example, 25510 for the \nsingle-precision format).\n\nThe signs of infinities are observed, and comparisons are possible. Infinities are always interpreted in the affine \nsense; that is, –∞ is less than any finite number and +∞ is greater than any finite number. Arithmetic on infinities \nis always exact. Exceptions are generated only when the use of an infinity as a source operand constitutes an \ninvalid operation.\n\nWhereas denormalized numbers may represent an underflow condition, the two ∞ numbers may represent the \nresult of an overflow condition. Here, the normalized result of a computation has a biased exponent greater than \nthe largest allowable exponent for the selected result format.\n\n4.8.3.4  NaNs\nSince NaNs are non-numbers, they are not part of the real number line. In Figure 4-12, the encoding space for \nNaNs in the floating-point formats is shown above the ends of the real number line. This space includes any value \nwith the maximum allowable biased exponent and a non-zero fraction (the sign bit is ignored for NaNs).\n\nThe IA-32 architecture defines two classes of NaNs: quiet NaNs (QNaNs) and signaling NaNs (SNaNs). A QNaN is a \nNaN with the most significant fraction bit set; an SNaN is a NaN with the most significant fraction bit clear. QNaNs \nare allowed to propagate through most arithmetic operations without signaling an exception. SNaNs generally \nsignal a floating-point invalid-operation exception whenever they appear as operands in arithmetic operations.\n\nSNaNs are typically used to trap or invoke an exception handler. They must be inserted by software; that is, the \nprocessor never generates an SNaN as a result of a floating-point operation.\n\nTable 4-6.  Denormalization Process\n\nOperation Sign Exponent* Significand\n\nTrue Result 0 −129 1.01011100000...00\n\nDenormalize 0 −128 0.10101110000...00\n\nDenormalize 0 −127 0.01010111000...00\n\nDenormalize 0 −126 0.00101011100...00\n\nDenormal Result 0 −126 0.00101011100...00\n\n* Expressed as an unbiased, decimal number.\nVol. 1 4-15\n\n\n\nDATA TYPES\n4.8.3.5  Operating on SNaNs and QNaNs\nWhen a floating-point operation is performed on an SNaN and/or a QNaN, the result of the operation is either a \nQNaN delivered to the destination operand or the generation of a floating-point invalid operation exception, \ndepending on the following rules:\n• If one of the source operands is an SNaN and the floating-point invalid-operation exception is not masked (see \n\nSection 4.9.1.1, “Invalid Operation Exception (#I)”), then a floating-point invalid-operation exception is \nsignaled and no result is stored in the destination operand. If one of the source operands is a QNaN and the \nfloating-point invalid-operation exception is not masked and the operation is one that generates an invalid-\noperation exception for QNaN operands as described in Section 8.5.1.2, “Invalid Arithmetic Operand Exception \n(#IA),” or Section 11.5.2.1, “Invalid Operation Exception (#I)”, then a floating-point invalid-operation \nexception is signaled and no result is stored in the destination operand.\n\n• If either or both of the source operands are NaNs and floating-point invalid-operation exception is masked, the \nresult is as shown in Table 4-7. When an SNaN is converted to a QNaN, the conversion is handled by setting the \nmost-significant fraction bit of the SNaN to 1. Also, when one of the source operands is an SNaN, or when it is \na QNaN and the operation is one that generates an invalid-operation exception for QNaN operands as described \nin Section 8.5.1.2, “Invalid Arithmetic Operand Exception (#IA),” or Section 11.5.2.1, “Invalid Operation \nException (#I)”, then the floating-point invalid-operation exception flag is set. Note that for some combinations \nof source operands, the result is different for x87 FPU operations and for SSE/SSE2/SSE3/SSE4.1 operations. \nIntel AVX follows the same behavior as SSE/SSE2/SSE3/SSE4.1 in this respect.\n\n• When neither of the source operands is a NaN, but the operation generates a floating-point invalid-operation \nexception (see Tables 8-10 and 11-1), the result is commonly a QNaN FP Indefinite (Section 4.8.3.7).\n\nAny exceptions to the behavior described in Table 4-7 are described in Section 8.5.1.2, “Invalid Arithmetic Operand \nException (#IA),” and Section 11.5.2.1, “Invalid Operation Exception (#I).”\n\n4.8.3.6  Using SNaNs and QNaNs in Applications\nExcept for the rules given at the beginning of Section 4.8.3.4, “NaNs,” for encoding SNaNs and QNaNs, software is \nfree to use the bits in the significand of a NaN for any purpose. Both SNaNs and QNaNs can be encoded to carry and \nstore data, such as diagnostic information.\n\nTable 4-7.  Rules for Handling NaNs \n\nSource Operands Result1\n\nSNaN and QNaN x87 FPU — QNaN source operand.\n\nSSE/SSE2/SSE3/SSE4.1/AVX — First source operand (if this operand is an \nSNaN, it is converted to a QNaN)\n\nTwo SNaNs x87 FPU—SNaN source operand with the larger significand, converted into a \nQNaN\n\nSSE/SSE2/SSE3/SSE4.1/AVX — First source operand converted to a QNaN\n\nTwo QNaNs x87 FPU — QNaN source operand with the larger\nsignificand\n\nSSE/SSE2/SSE3/SSE4.1/AVX — First source operand\n\nSNaN and a floating-point value SNaN source operand, converted into a QNaN\n\nQNaN and a floating-point value QNaN source operand\n\nSNaN (for instructions that take only one operand) SNaN source operand, converted into a QNaN\n\nQNaN (for instructions that take only one operand) QNaN source operand\n\nNOTE:\n1. For SSE/SSE2/SSE3/SSE4.1 instructions, the first operand is generally a source operand that becomes the destination operand. For \n\nAVX instructions, the first source operand is usually the 2nd operand in a non-destructive source syntax. Within the Result column, \nthe x87 FPU notation also applies to the FISTTP instruction in SSE3; the SSE3 notation applies to the SIMD floating-point instruc-\ntions.\n4-16 Vol. 1\n\n\n\nDATA TYPES\nBy unmasking the invalid operation exception, the programmer can use signaling NaNs to trap to the exception \nhandler. The generality of this approach and the large number of NaN values that are available provide the sophis-\nticated programmer with a tool that can be applied to a variety of special situations.\n\nFor example, a compiler can use signaling NaNs as references to uninitialized (real) array elements. The compiler \ncan preinitialize each array element with a signaling NaN whose significand contains the index (relative position) of \nthe element. Then, if an application program attempts to access an element that it has not initialized, it can use the \nNaN placed there by the compiler. If the invalid operation exception is unmasked, an interrupt will occur, and the \nexception handler will be invoked. The exception handler can determine which element has been accessed, since \nthe operand address field of the exception pointer will point to the NaN, and the NaN will contain the index number \nof the array element.\n\nQuiet NaNs are often used to speed up debugging. In its early testing phase, a program often contains multiple \nerrors. An exception handler can be written to save diagnostic information in memory whenever it is invoked. After \nstoring the diagnostic data, it can supply a quiet NaN as the result of the erroneous instruction, and that NaN can \npoint to its associated diagnostic area in memory. The program will then continue, creating a different NaN for each \nerror. When the program ends, the NaN results can be used to access the diagnostic data saved at the time the \nerrors occurred. Many errors can thus be diagnosed and corrected in one test run.\n\nIn embedded applications that use computed results in further computations, an undetected QNaN can invalidate \nall subsequent results. Such applications should therefore periodically check for QNaNs and provide a recovery \nmechanism to be used if a QNaN result is detected. \n\n4.8.3.7  QNaN Floating-Point Indefinite\nFor the floating-point data type encodings (single-precision, double-precision, and double-extended-precision), \none unique encoding (a QNaN) is reserved for representing the special value QNaN floating-point indefinite. The \nx87 FPU and the SSE/SSE2/SSE3/SSE4.1/AVX extensions return these indefinite values as responses to some \nmasked floating-point exceptions. Table 4-3 shows the encoding used for the QNaN floating-point indefinite.\n\n4.8.3.8  Half-Precision Floating-Point Operation\nHalf-precision floating-point values are not used by the processor directly for arithmetic operations. Two instruc-\ntions, VCVTPH2PS, VCVTPS2PH, provide conversion only between half-precision and single-precision floating-point \nvalues.\n\nThe SIMD floating-point exception behavior of VCVTPH2PS and VCVTPS2PH are described in Section 14.4.1.\n\n4.8.4 Rounding\nWhen performing floating-point operations, the processor produces an infinitely precise floating-point result in the \ndestination format (single-precision, double-precision, or double extended-precision floating-point) whenever \npossible. However, because only a subset of the numbers in the real number continuum can be represented in IEEE \nStandard 754 floating-point formats, it is often the case that an infinitely precise result cannot be encoded exactly \nin the format of the destination operand.\n\nFor example, the following value (a) has a 24-bit fraction. The least-significant bit of this fraction (the underlined \nbit) cannot be encoded exactly in the single-precision format (which has only a 23-bit fraction):\n\n(a) 1.0001 0000 1000 0011 1001 0111E2 101\n\nTo round this result (a), the processor first selects two representable fractions b and c that most closely bracket a \nin value (b < a < c).\n\n(b) 1.0001 0000 1000 0011 1001 011E2 101\n\n(c) 1.0001 0000 1000 0011 1001 100E2 101\n\nThe processor then sets the result to b or to c according to the selected rounding mode. Rounding introduces an \nerror in a result that is less than one unit in the last place (the least significant bit position of the floating-point \nvalue) to which the result is rounded.\nVol. 1 4-17\n\n\n\nDATA TYPES\nThe IEEE Standard 754 defines four rounding modes (see Table 4-8): round to nearest, round up, round down, and \nround toward zero. The default rounding mode (for the Intel 64 and IA-32 architectures) is round to nearest. This \nmode provides the most accurate and statistically unbiased estimate of the true result and is suitable for most \napplications. \n\nThe round up and round down modes are termed directed rounding and can be used to implement interval arith-\nmetic. Interval arithmetic is used to determine upper and lower bounds for the true result of a multistep computa-\ntion, when the intermediate results of the computation are subject to rounding. \n\nThe round toward zero mode (sometimes called the “chop” mode) is commonly used when performing integer \narithmetic with the x87 FPU.\n\nThe rounded result is called the inexact result. When the processor produces an inexact result, the floating-point \nprecision (inexact) flag (PE) is set (see Section 4.9.1.6, “Inexact-Result (Precision) Exception (#P)”).\n\nThe rounding modes have no effect on comparison operations, operations that produce exact results, or operations \nthat produce NaN results.\n\n4.8.4.1  Rounding Control (RC) Fields\nIn the Intel 64 and IA-32 architectures, the rounding mode is controlled by a 2-bit rounding-control (RC) field \n(Table 4-8 shows the encoding of this field). The RC field is implemented in two different locations: \n• x87 FPU control register (bits 10 and 11)\n• The MXCSR register (bits 13 and 14)\n\nAlthough these two RC fields perform the same function, they control rounding for different execution environ-\nments within the processor. The RC field in the x87 FPU control register controls rounding for computations \nperformed with the x87 FPU instructions; the RC field in the MXCSR register controls rounding for SIMD floating-\npoint computations performed with the SSE/SSE2 instructions.\n\n4.8.4.2  Truncation with SSE and SSE2 Conversion Instructions\nThe following SSE/SSE2 instructions automatically truncate the results of conversions from floating-point values to \nintegers when the result it inexact: CVTTPD2DQ, CVTTPS2DQ, CVTTPD2PI, CVTTPS2PI, CVTTSD2SI, CVTTSS2SI. \nHere, truncation means the round toward zero mode described in Table 4-8.\n\n4.9 OVERVIEW OF FLOATING-POINT EXCEPTIONS\nThe following section provides an overview of floating-point exceptions and their handling in the IA-32 architecture. \nFor information specific to the x87 FPU and to the SSE/SSE2/SSE3/SSE4.1 extensions, refer to the following \nsections:\n• Section 8.4, “x87 FPU Floating-Point Exception Handling”\n\nTable 4-8.  Rounding Modes and Encoding of Rounding Control (RC) Field\n\nRounding Mode RC Field \nSetting\n\nDescription\n\nRound to \nnearest (even)\n\n00B Rounded result is the closest to the infinitely precise result. If two values are equally close, the \nresult is the even value (that is, the one with the least-significant bit of zero). Default\n\nRound down \n(toward −∞)\n\n01B Rounded result is closest to but no greater than the infinitely precise result.\n\nRound up \n(toward +∞)\n\n10B Rounded result is closest to but no less than the infinitely precise result.\n\nRound toward \nzero (Truncate)\n\n11B Rounded result is closest to but no greater in absolute value than the infinitely precise result.\n4-18 Vol. 1\n\n\n\nDATA TYPES\n• Section 11.5, “SSE, SSE2, and SSE3 Exceptions”\n\nWhen operating on floating-point operands, the IA-32 architecture recognizes and detects six classes of exception \nconditions:\n• Invalid operation (#I)\n• Divide-by-zero (#Z)\n• Denormalized operand (#D)\n• Numeric overflow (#O)\n• Numeric underflow (#U)\n• Inexact result (precision) (#P)\n\nThe nomenclature of “#” symbol followed by one or two letters (for example, #P) is used in this manual to indicate \nexception conditions. It is merely a short-hand form and is not related to assembler mnemonics.\n\nNOTE\nAll of the exceptions listed above except the denormal-operand exception (#D) are defined in IEEE \nStandard 754.\n\nThe invalid-operation, divide-by-zero and denormal-operand exceptions are pre-computation exceptions (that is, \nthey are detected before any arithmetic operation occurs). The numeric-underflow, numeric-overflow and precision \nexceptions are post-computation exceptions.\n\nEach of the six exception classes has a corresponding flag bit (IE, ZE, OE, UE, DE, or PE) and mask bit (IM, ZM, OM, \nUM, DM, or PM). When one or more floating-point exception conditions are detected, the processor sets the appro-\npriate flag bits, then takes one of two possible courses of action, depending on the settings of the corresponding \nmask bits:\n• Mask bit set. Handles the exception automatically, producing a predefined (and often times usable) result, \n\nwhile allowing program execution to continue undisturbed.\n• Mask bit clear. Invokes a software exception handler to handle the exception.\n\nThe masked (default) responses to exceptions have been chosen to deliver a reasonable result for each exception \ncondition and are generally satisfactory for most floating-point applications. By masking or unmasking specific \nfloating-point exceptions, programmers can delegate responsibility for most exceptions to the processor and \nreserve the most severe exception conditions for software exception handlers. \n\nBecause the exception flags are “sticky,” they provide a cumulative record of the exceptions that have occurred \nsince they were last cleared. A programmer can thus mask all exceptions, run a calculation, and then inspect the \nexception flags to see if any exceptions were detected during the calculation.\n\nIn the IA-32 architecture, floating-point exception flag and mask bits are implemented in two different locations: \n• x87 FPU status word and control word. The flag bits are located at bits 0 through 5 of the x87 FPU status word \n\nand the mask bits are located at bits 0 through 5 of the x87 FPU control word (see Figures 8-4 and 8-6).\n• MXCSR register. The flag bits are located at bits 0 through 5 of the MXCSR register and the mask bits are \n\nlocated at bits 7 through 12 of the register (see Figure 10-3).\n\nAlthough these two sets of flag and mask bits perform the same function, they report on and control exceptions for \ndifferent execution environments within the processor. The flag and mask bits in the x87 FPU status and control \nwords control exception reporting and masking for computations performed with the x87 FPU instructions; the \ncompanion bits in the MXCSR register control exception reporting and masking for SIMD floating-point computa-\ntions performed with the SSE/SSE2/SSE3 instructions.\n\nNote that when exceptions are masked, the processor may detect multiple exceptions in a single instruction, \nbecause it continues executing the instruction after performing its masked response. For example, the processor \ncan detect a denormalized operand, perform its masked response to this exception, and then detect numeric \nunderflow.\n\nSee Section 4.9.2, “Floating-Point Exception Priority,” for a description of the rules for exception precedence when \nmore than one floating-point exception condition is detected for an instruction.\nVol. 1 4-19\n\n\n\nDATA TYPES\n4.9.1 Floating-Point Exception Conditions\nThe following sections describe the various conditions that cause a floating-point exception to be generated and the \nmasked response of the processor when these conditions are detected. The Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volumes 3A & 3B, list the floating-point exceptions that can be signaled for each \nfloating-point instruction.\n\n4.9.1.1  Invalid Operation Exception (#I)\nThe processor reports an invalid operation exception in response to one or more invalid arithmetic operands. If the \ninvalid operation exception is masked, the processor sets the IE flag and returns an indefinite value or a QNaN. This \nvalue overwrites the destination register specified by the instruction. If the invalid operation exception is not \nmasked, the IE flag is set, a software exception handler is invoked, and the operands remain unaltered.\n\nSee Section 4.8.3.6, “Using SNaNs and QNaNs in Applications,” for information about the result returned when an \nexception is caused by an SNaN.\n\nThe processor can detect a variety of invalid arithmetic operations that can be coded in a program. These opera-\ntions generally indicate a programming error, such as dividing ∞ by ∞ . See the following sections for information \nregarding the invalid-operation exception when detected while executing x87 FPU or SSE/SSE2/SSE3/SSE4.1 or \nAVX instructions:\n• x87 FPU; Section 8.5.1, “Invalid Operation Exception”.\n• SIMD floating-point exceptions; Section 11.5.2.1, “Invalid Operation Exception (#I)”.\n\n4.9.1.2  Denormal Operand Exception (#D)\nThe processor reports the denormal-operand exception if an arithmetic instruction attempts to operate on a \ndenormal operand (see Section 4.8.3.2, “Normalized and Denormalized Finite Numbers”). When the exception is \nmasked, the processor sets the DE flag and proceeds with the instruction. Operating on denormal numbers will \nproduce results at least as good as, and often better than, what can be obtained when denormal numbers are \nflushed to zero. Programmers can mask this exception so that a computation may proceed, then analyze any loss \nof accuracy when the final result is delivered.\n\nWhen a denormal-operand exception is not masked, the DE flag is set, a software exception handler is invoked, and \nthe operands remain unaltered. When denormal operands have reduced significance due to loss of low-order bits, \nit may be advisable to not operate on them. Precluding denormal operands from computations can be accom-\nplished by an exception handler that responds to unmasked denormal-operand exceptions.\n\nSee the following sections for information regarding the denormal-operand exception when detected while \nexecuting x87 FPU or SSE/SSE2/SSE3 instructions:\n• x87 FPU; Section 8.5.2, “Denormal Operand Exception (#D)”.\n• SIMD floating-point exceptions; Section 11.5.2.2, “Denormal-Operand Exception (#D)”.\n\n4.9.1.3  Divide-By-Zero Exception (#Z)\nThe processor reports the floating-point divide-by-zero exception whenever an instruction attempts to divide a \nfinite non-zero operand by 0. The masked response for the divide-by-zero exception is to set the ZE flag and return \nan infinity signed with the exclusive OR of the sign of the operands. If the divide-by-zero exception is not masked, \nthe ZE flag is set, a software exception handler is invoked, and the operands remain unaltered.\n\nSee the following sections for information regarding the divide-by-zero exception when detected while executing \nx87 FPU or SSE/SSE2 instructions:\n• x87 FPU; Section 8.5.3, “Divide-By-Zero Exception (#Z)”.\n• SIMD floating-point exceptions; Section 11.5.2.3, “Divide-By-Zero Exception (#Z)”.\n4-20 Vol. 1\n\n\n\nDATA TYPES\n4.9.1.4  Numeric Overflow Exception (#O)\nThe processor reports a floating-point numeric overflow exception whenever the rounded result of an instruction \nexceeds the largest allowable finite value that will fit into the destination operand. Table 4-9 shows the threshold \nrange for numeric overflow for each of the floating-point formats; overflow occurs when a rounded result falls at or \noutside this threshold range.\n\nWhen a numeric-overflow exception occurs and the exception is masked, the processor sets the OE flag and \nreturns one of the values shown in Table 4-10, according to the current rounding mode. See Section 4.8.4, \n“Rounding.”\n\nWhen numeric overflow occurs and the numeric-overflow exception is not masked, the OE flag is set, a software \nexception handler is invoked, and the source and destination operands either remain unchanged or a biased result \nis stored in the destination operand (depending whether the overflow exception was generated during an \nSSE/SSE2/SSE3 floating-point operation or an x87 FPU operation).\n\nSee the following sections for information regarding the numeric overflow exception when detected while executing \nx87 FPU instructions or while executing SSE/SSE2/SSE3 instructions:\n• x87 FPU; Section 8.5.4, “Numeric Overflow Exception (#O)”\n• SIMD floating-point exceptions; Section 11.5.2.4, “Numeric Overflow Exception (#O)”\n\n4.9.1.5  Numeric Underflow Exception (#U)\nThe processor detects a potential floating-point numeric underflow condition whenever the result of rounding with \nunbounded exponent (taking into account precision control for x87) is non-zero and tiny; that is, non-zero and less \nthan the smallest possible normalized, finite value that will fit into the destination operand. Table 4-11 shows the \nthreshold range for numeric underflow for each of the floating-point formats (assuming normalized results); \nunderflow occurs when a rounded result falls strictly within the threshold range. The ability to detect and handle \nunderflow is provided to prevent a very small result from propagating through a computation and causing another \nexception (such as overflow during division) to be generated at a later time. Results which trigger underflow are \nalso potentially less accurate.\n\nTable 4-9.  Numeric Overflow Thresholds\n\nFloating-Point Format Overflow Thresholds\n\nSingle Precision | x | ≥ 1.0 ∗ 2128\n\nDouble Precision | x | ≥ 1.0 ∗ 21024\n\nDouble Extended Precision | x | ≥ 1.0 ∗ 216384\n\nTable 4-10.  Masked Responses to Numeric Overflow\n\nRounding Mode Sign of True Result Result\n\nTo nearest + +∞\n\n– –∞\n\nToward –∞ + Largest finite positive number\n\n– –∞\n\nToward +∞ + +∞\n\n– Largest finite negative number\n\nToward zero + Largest finite positive number\n\n– Largest finite negative number\nVol. 1 4-21\n\n\n\nDATA TYPES\nHow the processor handles an underflow condition, depends on two related conditions:\n• creation of a tiny, non-zero result\n• creation of an inexact result; that is, a result that cannot be represented exactly in the destination format\n\nWhich of these events causes an underflow exception to be reported and how the processor responds to the excep-\ntion condition depends on whether the underflow exception is masked:\n• Underflow exception masked — The underflow exception is reported (the UE flag is set) only when the result \n\nis both tiny and inexact. The processor returns a correctly signed result whose magnitude is less than or equal \nto the smallest positive normal floating-point number to the destination operand, regardless of inexactness.\n\n• Underflow exception not masked — The underflow exception is reported when the result is non-zero tiny, \nregardless of inexactness. The processor leaves the source and destination operands unaltered or stores a \nbiased result in the destination operand (depending whether the underflow exception was generated during an \nSSE/SSE2/SSE3 floating-point operation or an x87 FPU operation) and invokes a software exception handler.\n\nSee the following sections for information regarding the numeric underflow exception when detected while \nexecuting x87 FPU instructions or while executing SSE/SSE2/SSE3 instructions:\n• x87 FPU; Section 8.5.5, “Numeric Underflow Exception (#U)”\n• SIMD floating-point exceptions; Section 11.5.2.5, “Numeric Underflow Exception (#U)”\n\n4.9.1.6  Inexact-Result (Precision) Exception (#P)\nThe inexact-result exception (also called the precision exception) occurs if the result of an operation is not exactly \nrepresentable in the destination format. For example, the fraction 1/3 cannot be precisely represented in binary \nfloating-point form. This exception occurs frequently and indicates that some (normally acceptable) accuracy will \nbe lost due to rounding. The exception is supported for applications that need to perform exact arithmetic only. \nBecause the rounded result is generally satisfactory for most applications, this exception is commonly masked.\n\nIf the inexact-result exception is masked when an inexact-result condition occurs and a numeric overflow or under-\nflow condition has not occurred, the processor sets the PE flag and stores the rounded result in the destination \noperand. The current rounding mode determines the method used to round the result. See Section 4.8.4, \n“Rounding.”\n\nIf the inexact-result exception is not masked when an inexact result occurs and numeric overflow or underflow has \nnot occurred, the PE flag is set, the rounded result is stored in the destination operand, and a software exception \nhandler is invoked.\n\nIf an inexact result occurs in conjunction with numeric overflow or underflow, one of the following operations is \ncarried out:\n• If an inexact result occurs along with masked overflow or underflow, the OE flag or UE flag and the PE flag are \n\nset and the result is stored as described for the overflow or underflow exceptions; see Section 4.9.1.4, \n“Numeric Overflow Exception (#O),” or Section 4.9.1.5, “Numeric Underflow Exception (#U).” If the inexact \nresult exception is unmasked, the processor also invokes a software exception handler.\n\n• If an inexact result occurs along with unmasked overflow or underflow and the destination operand is a register, \nthe OE or UE flag and the PE flag are set, the result is stored as described for the overflow or underflow \nexceptions, and a software exception handler is invoked.\n\nIf an unmasked numeric overflow or underflow exception occurs and the destination operand is a memory location \n(which can happen only for a floating-point store), the inexact-result condition is not reported and the C1 flag is \ncleared.\n\nTable 4-11.  Numeric Underflow (Normalized) Thresholds\n\nFloating-Point Format Underflow Thresholds*\n\nSingle Precision | x | < 1.0 ∗ 2−126\n\nDouble Precision | x | < 1.0 ∗ 2−1022\n\nDouble Extended Precision | x | < 1.0 ∗ 2−16382\n\n* Where ‘x’ is the result rounded to destination precision with an unbounded exponent range.\n4-22 Vol. 1\n\n\n\nDATA TYPES\nSee the following sections for information regarding the inexact-result exception when detected while executing \nx87 FPU or SSE/SSE2/SSE3 instructions:\n• x87 FPU; Section 8.5.6, “Inexact-Result (Precision) Exception (#P)”\n• SIMD floating-point exceptions; Section 11.5.2.3, “Divide-By-Zero Exception (#Z)”\n\n4.9.2 Floating-Point Exception Priority\nThe processor handles exceptions according to a predetermined precedence. When an instruction generates two or \nmore exception conditions, the exception precedence sometimes results in the higher-priority exception being \nhandled and the lower-priority exceptions being ignored. For example, dividing an SNaN by zero can potentially \nsignal an invalid-operation exception (due to the SNaN operand) and a divide-by-zero exception. Here, if both \nexceptions are masked, the processor handles the higher-priority exception only (the invalid-operation exception), \nreturning a QNaN to the destination. Alternately, a denormal-operand or inexact-result exception can accompany \na numeric underflow or overflow exception with both exceptions being handled.\n\nThe precedence for floating-point exceptions is as follows:\n\n1. Invalid-operation exception, subdivided as follows:\n\na. stack underflow (occurs with x87 FPU only)\n\nb. stack overflow (occurs with x87 FPU only)\n\nc. operand of unsupported format (occurs with x87 FPU only when using the double extended-precision \nfloating-point format)\n\nd. SNaN operand\n\n2. QNaN operand. Though this is not an exception, the handling of a QNaN operand has precedence over lower-\npriority exceptions. For example, a QNaN divided by zero results in a QNaN, not a zero-divide exception.\n\n3. Any other invalid-operation exception not mentioned above or a divide-by-zero exception.\n\n4. Denormal-operand exception. If masked, then instruction execution continues and a lower-priority exception \ncan occur as well.\n\n5. Numeric overflow and underflow exceptions; possibly in conjunction with the inexact-result exception.\n\n6. Inexact-result exception.\n\nInvalid operation, zero divide, and denormal operand exceptions are detected before a floating-point operation \nbegins. Overflow, underflow, and precision exceptions are not detected until a true result has been computed. \nWhen an unmasked pre-operation exception is detected, the destination operand has not yet been updated, and \nappears as if the offending instruction has not been executed. When an unmasked post-operation exception is \ndetected, the destination operand may be updated with a result, depending on the nature of the exception (except \nfor SSE/SSE2/SSE3 instructions, which do not update their destination operands in such cases).\n\n4.9.3 Typical Actions of a Floating-Point Exception Handler\nAfter the floating-point exception handler is invoked, the processor handles the exception in the same manner that \nit handles non-floating-point exceptions. The floating-point exception handler is normally part of the operating \nsystem or executive software, and it usually invokes a user-registered floating-point exception handle. \n\nA typical action of the exception handler is to store state information in memory. Other typical exception handler \nactions include:\n• Examining the stored state information to determine the nature of the error\n• Taking actions to correct the condition that caused the error\n• Clearing the exception flags\n• Returning to the interrupted program and resuming normal execution\n\nIn lieu of writing recovery procedures, the exception handler can do the following:\n• Increment in software an exception counter for later display or printing\nVol. 1 4-23\n\n\n\nDATA TYPES\n• Print or display diagnostic information (such as the state information)\n• Halt further program execution\n4-24 Vol. 1\n\n\n\nCHAPTER 5\nINSTRUCTION SET SUMMARY\n\nThis chapter provides an abridged overview of Intel 64 and IA-32 instructions. Instructions are divided into the \nfollowing groups:\n• Section 5.1, “General-Purpose Instructions”.\n• Section 5.2, “x87 FPU Instructions”.\n• Section 5.3, “x87 FPU AND SIMD State Management Instructions”.\n• Section 5.4, “MMX™ Instructions”.\n• Section 5.5, “SSE Instructions”.\n• Section 5.6, “SSE2 Instructions”.\n• Section 5.7, “SSE3 Instructions”.\n• Section 5.8, “Supplemental Streaming SIMD Extensions 3 (SSSE3) Instructions”.\n• Section 5.9, “SSE4 Instructions”.\n• Section 5.10, “SSE4.1 Instructions”.\n• Section 5.11, “SSE4.2 Instruction Set”.\n• Section 5.12, “Intel® AES-NI and PCLMULQDQ”.\n• Section 5.13, “Intel® Advanced Vector Extensions (Intel® AVX)”.\n• Section 5.14, “16-bit Floating-Point Conversion”.\n• Section 5.15, “Fused-Multiply-ADD (FMA)”.\n• Section 5.16, “Intel® Advanced Vector Extensions 2 (Intel® AVX2)”.\n• Section 5.17, “Intel® Transactional Synchronization Extensions (Intel® TSX)”.\n• Section 5.18, “Intel® SHA Extensions”.\n• Section 5.19, “Intel® Advanced Vector Extensions 512 (Intel® AVX-512)”.\n• Section 5.20, “System Instructions”.\n• Section 5.21, “64-Bit Mode Instructions”.\n• Section 5.22, “Virtual-Machine Extensions”.\n• Section 5.23, “Safer Mode Extensions”.\n• Section 5.24, “Intel® Memory Protection Extensions”.\n• Section 5.25, “Intel® Software Guard Extensions”.\n• Section 5.26, “Shadow Stack Management Instructions”.\n• Section 5.27, “Control Transfer Terminating Instructions”.\n\nTable 5-1 lists the groups and IA-32 processors that support each group. More recent instruction set extensions are \nlisted in Table 5-2. Within these groups, most instructions are collected into functional subgroups.\n\nTable 5-1.  Instruction Groups in Intel 64 and IA-32 Processors\n\nInstruction Set \nArchitecture Intel 64 and IA-32 Processor Support\n\nGeneral Purpose All Intel 64 and IA-32 processors.\n\n x87 FPU Intel486, Pentium, Pentium with MMX Technology, Celeron, Pentium Pro, Pentium II, Pentium II Xeon, \nPentium III, Pentium III Xeon, Pentium 4, Intel Xeon processors, Pentium M, Intel Core Solo, Intel Core Duo, \nIntel Core 2 Duo processors, Intel Atom processors.\n\nx87 FPU and SIMD State \nManagement\n\nPentium II, Pentium II Xeon, Pentium III, Pentium III Xeon, Pentium 4, Intel Xeon processors, Pentium M, \nIntel Core Solo, Intel Core Duo, Intel Core 2 Duo processors, Intel Atom processors.\nVol. 1 5-1\n\n\n\nINSTRUCTION SET SUMMARY\nMMX Technology Pentium with MMX Technology, Celeron, Pentium II, Pentium II Xeon, Pentium III, Pentium III Xeon, Pentium \n4, Intel Xeon processors, Pentium M, Intel Core Solo, Intel Core Duo, Intel Core 2 Duo processors, Intel Atom \nprocessors.\n\nSSE Extensions Pentium III, Pentium III Xeon, Pentium 4, Intel Xeon processors, Pentium M, Intel Core Solo, Intel Core Duo, \nIntel Core 2 Duo processors, Intel Atom processors.\n\nSSE2 Extensions Pentium 4, Intel Xeon processors, Pentium M, Intel Core Solo, Intel Core Duo, Intel Core 2 Duo processors, \nIntel Atom processors.\n\nSSE3 Extensions Pentium 4 supporting HT Technology (built on 90nm process technology), Intel Core Solo, Intel Core Duo, \nIntel Core 2 Duo processors, Intel Xeon processor 3xxxx, 5xxx, 7xxx Series, Intel Atom processors.\n\nSSSE3 Extensions Intel Xeon processor 3xxx, 5100, 5200, 5300, 5400, 5500, 5600, 7300, 7400, 7500 series, Intel Core 2 \nExtreme processors QX6000 series, Intel Core 2 Duo, Intel Core 2 Quad processors, Intel Pentium Dual-Core \nprocessors, Intel Atom processors.\n\nIA-32e mode: 64-bit \nmode instructions\n\nIntel 64 processors.\n\nSystem Instructions Intel 64 and IA-32 processors.\n\nVMX Instructions Intel 64 and IA-32 processors supporting Intel Virtualization Technology.\n\nSMX Instructions Intel Core 2 Duo processor E6x50, E8xxx; Intel Core 2 Quad processor Q9xxx.\n\nTable 5-2.  Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors\n\nInstruction Set \nArchitecture Processor Generation Introduction\n\nSSE4.1 Extensions Intel® Xeon® processor 3100, 3300, 5200, 5400, 7400, 7500 series, Intel® Core™ 2 Extreme processors \nQX9000 series, Intel® Core™ 2 Quad processor Q9000 series, Intel® Core™ 2 Duo processors 8000 series \nand T9000 series, Intel Atom® processor based on Silvermont microarchitecture.\n\nSSE4.2 Extensions, \nCRC32, POPCNT\n\nIntel® Core™ i7 965 processor, Intel® Xeon® processors X3400, X3500, X5500, X6500, X7500 series, \nIntel Atom processor based on Silvermont microarchitecture.\n\nIntel® AES-NI, \nPCLMULQDQ\n\nIntel® Xeon® processor E7 series, Intel® Xeon® processors X3600 and X5600, Intel® Core™ i7 980X \nprocessor, Intel Atom processor based on Silvermont microarchitecture. Use CPUID to verify presence of \nIntel AES-NI and PCLMULQDQ across Intel® Core™ processor families.\n\nIntel® AVX Intel® Xeon® processor E3 and E5 families, 2nd Generation Intel® Core™ i7, i5, i3 processor 2xxx families.\n\nF16C 3rd Generation Intel® Core™ processors, Intel® Xeon® processor E3-1200 v2 product family, Intel® Xeon® \nprocessor E5 v2 and E7 v2 families.\n\nRDRAND 3rd Generation Intel Core processors, Intel Xeon processor E3-1200 v2 product family, Intel Xeon \nprocessor E5 v2 and E7 v2 families, Intel Atom processor based on Silvermont microarchitecture.\n\nFS/GS base access 3rd Generation Intel Core processors, Intel Xeon processor E3-1200 v2 product family, Intel Xeon \nprocessor E5 v2 and E7 v2 families, Intel Atom® processor based on Goldmont microarchitecture.\n\nFMA, AVX2, BMI1, BMI2, \nINVPCID, LZCNT, Intel® \nTSX\n\nIntel® Xeon® processor E3/E5/E7 v3 product families, 4th Generation Intel® Core™ processor family.\n\nMOVBE Intel Xeon processor E3/E5/E7 v3 product families, 4th Generation Intel Core processor family, Intel Atom \nprocessors.\n\nPREFETCHW Intel® Core™ M processor family; 5th Generation Intel® Core™ processor family, Intel Atom processor based \non Silvermont microarchitecture.\n\nTable 5-1.  Instruction Groups in Intel 64 and IA-32 Processors (Contd.)\n\nInstruction Set \nArchitecture Intel 64 and IA-32 Processor Support\n5-2 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nADX Intel Core M processor family, 5th Generation Intel Core processor family.\n\nRDSEED, CLAC, STAC Intel Core M processor family, 5th Generation Intel Core processor family, Intel Atom processor based on \nGoldmont microarchitecture.\n\nAVX512ER, AVX512PF, \nPREFETCHWT1\n\nIntel® Xeon Phi™ Processor 3200, 5200, 7200 Series.\n\nAVX512F, AVX512CD Intel Xeon Phi Processor 3200, 5200, 7200 Series, Intel® Xeon® Processor Scalable Family, Intel® Core™ i3-\n8121U processor.\n\nCLFLUSHOPT, XSAVEC, \nXSAVES, Intel® MPX\n\nIntel Xeon Processor Scalable Family, 6th Generation Intel® Core™ processor family, Intel Atom processor \nbased on Goldmont microarchitecture.\n\nSGX1 6th Generation Intel Core processor family, Intel Atom® processor based on Goldmont Plus \nmicroarchitecture.\n\nAVX512DQ, AVX512BW, \nAVX512VL\n\nIntel Xeon Processor Scalable Family, Intel Core i3-8121U processor based on Cannon Lake \nmicroarchitecture.\n\nCLWB Intel Xeon Processor Scalable Family, Intel Atom® processor based on Tremont microarchitecture, 11th \nGeneration Intel Core processor family based on Tiger Lake microarchitecture.\n\nPKU Intel Xeon Processor Scalable Family, 10th generation Intel® Core™ processors based on Comet Lake \nmicroarchitecture.\n\nAVX512_IFMA, \nAVX512_VBMI\n\nIntel Core i3-8121U processor based on Cannon Lake microarchitecture.\n\nIntel® SHA Extensions Intel Core i3-8121U processor based on Cannon Lake microarchitecture , Intel Atom processor based on \nGoldmont microarchitecture, 3rd Generation Intel® Xeon® Processor Scalable Family based on Ice Lake \nmicroarchitecture.\n\nUMIP Intel Core i3-8121U processor based on Cannon Lake microarchitecture, Intel Atom processor based on \nGoldmont Plus microarchitecture.\n\nPTWRITE Intel Atom processor based on Goldmont Plus microarchitecture.\n\nRDPID 10th Generation Intel® Core™ processor family based on Ice Lake microarchitecture, Intel Atom processor \nbased on Goldmont Plus microarchitecture.\n\nAVX512_4FMAPS, \nAVX512_4VNNIW\n\nIntel® Xeon Phi™ Processor 7215, 7285, 7295 Series.\n\nAVX512_VNNI 2nd Generation Intel® Xeon® Processor Scalable Family, 10th Generation Intel Core processor family based \non Ice Lake microarchitecture.\n\nAVX512_VPOPCNTDQ Intel Xeon Phi Processor 7215, 7285, 7295 Series, 10th Generation Intel Core processor family based on \nIce Lake microarchitecture.\n\nFast Short REP MOV 10th Generation Intel Core processor family based on Ice Lake microarchitecture.\n\nGFNI (SSE) 10th Generation Intel Core processor family based on Ice Lake microarchitecture, Intel Atom processor \nbased on Tremont microarchitecture.\n\nVAES, \nGFNI (AVX/AVX512), \nAVX512_VBMI2, \nVPCLMULQDQ, \nAVX512_BITALG\n\n10th Generation Intel Core processor family based on Ice Lake microarchitecture.\n\nENCLV Intel Atom processor based on Tremont microarchitecture, 3rd Generation Intel® Xeon® Processor Scalable \nProcessors based on Ice Lake microarchitecture.\n\nSplit Lock Detection 10th Generation Intel Core processor family based on Ice Lake microarchitecture, Intel Atom processor \nbased on Tremont microarchitecture.\n\nTable 5-2.  Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors (Contd.)\n\nInstruction Set \nArchitecture Processor Generation Introduction\nVol. 1 5-3\n\n\n\nINSTRUCTION SET SUMMARY\nThe following sections list instructions in each major group and subgroup. Given for each instruction is its \nmnemonic and descriptive names. When two or more mnemonics are given (for example, CMOVA/CMOVNBE), they \nrepresent different mnemonics for the same instruction opcode. Assemblers support redundant mnemonics for \nsome instructions to make it easier to read code listings. For instance, CMOVA (Conditional move if above) and \nCMOVNBE (Conditional move if not below or equal) represent the same condition. For detailed information about \nspecific instructions, see the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 2A, 2B, 2C \n& 2D.\n\n5.1 GENERAL-PURPOSE INSTRUCTIONS\nThe general-purpose instructions perform basic data movement, arithmetic, logic, program flow, and string opera-\ntions that programmers commonly use to write application and system software to run on Intel 64 and IA-32 \nprocessors. They operate on data contained in memory, in the general-purpose registers (EAX, EBX, ECX, EDX, \nEDI, ESI, EBP, and ESP) and in the EFLAGS register. They also operate on address information contained in \nmemory, the general-purpose registers, and the segment registers (CS, DS, SS, ES, FS, and GS). \n\nThis group of instructions includes the data transfer, binary integer arithmetic, decimal arithmetic, logic operations, \nshift and rotate, bit and byte operations, program control, string, flag control, segment register operations, and \nmiscellaneous subgroups. The sections that follow introduce each subgroup. \n\nFor more detailed information on general purpose-instructions, see Chapter 7, “Programming With General-\nPurpose Instructions.”\n\n5.1.1 Data Transfer Instructions\nThe data transfer instructions move data between memory and the general-purpose and segment registers. They \nalso perform specific operations such as conditional moves, stack access, and data conversion.\n\nCLDEMOTE Intel Atom processor based on Tremont microarchitecture.\n\nDirect stores: MOVDIRI, \nMOVDIR64B \n\nIntel Atom processor based on Tremont microarchitecture, 11th Generation Intel Core processor family \nbased on Tiger Lake microarchitecture.\n\nUser wait: TPAUSE, \nUMONITOR, UMWAIT\n\nIntel Atom processor based on Tremont microarchitecture.\n\nAVX512_BF16 3rd Generation Intel® Xeon® Processor Scalable Processors based on Cooper Lake product.\n\nAVX512_VP2INTERSECT 11th Generation Intel Core processor family based on Tiger Lake microarchitecture.\n\nKey Locker1 11th Generation Intel Core processor family based on Tiger Lake microarchitecture.\n\nControl-flow Enforcement \nTechnology (CET)\n\n11th Generation Intel Core processor family based on Tiger Lake microarchitecture.\n\nMKTME2, PCONFIG 3rd Generation Intel® Xeon® Processor Scalable Family based on Ice Lake microarchitecture.\n\nWBNOINVD 3rd Generation Intel® Xeon® Processor Scalable Family based on Ice Lake microarchitecture.\n\nSupervisor Memory \nProtection Keys (PKS)\n\nFuture Intel processors\n\nNOTES:\n1. Details on Key Locker can be found in the Intel Key Locker Specification here:\n\n https://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html. \n2. Further details on MKTME usage can be found here: \n\nhttps://software.intel.com/sites/default/files/managed/a5/16/Multi-Key-Total-Memory-Encryption-Spec.pdf.\n\nTable 5-2.  Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors (Contd.)\n\nInstruction Set \nArchitecture Processor Generation Introduction\n5-4 Vol. 1\n\nhttps://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html\nhttps://software.intel.com/sites/default/files/managed/a5/16/Multi-Key-Total-Memory-Encryption-Spec.pdf\n\n\nINSTRUCTION SET SUMMARY\nMOV Move data between general-purpose registers; move data between memory and general-\npurpose or segment registers; move immediates to general-purpose registers.\n\nCMOVE/CMOVZ Conditional move if equal/Conditional move if zero.\nCMOVNE/CMOVNZ Conditional move if not equal/Conditional move if not zero.\nCMOVA/CMOVNBE Conditional move if above/Conditional move if not below or equal.\nCMOVAE/CMOVNB Conditional move if above or equal/Conditional move if not below.\nCMOVB/CMOVNAE Conditional move if below/Conditional move if not above or equal.\nCMOVBE/CMOVNA Conditional move if below or equal/Conditional move if not above.\nCMOVG/CMOVNLE Conditional move if greater/Conditional move if not less or equal.\nCMOVGE/CMOVNL Conditional move if greater or equal/Conditional move if not less.\nCMOVL/CMOVNGE Conditional move if less/Conditional move if not greater or equal.\nCMOVLE/CMOVNG Conditional move if less or equal/Conditional move if not greater.\nCMOVC Conditional move if carry.\nCMOVNC Conditional move if not carry.\nCMOVO Conditional move if overflow.\nCMOVNO Conditional move if not overflow.\nCMOVS Conditional move if sign (negative).\nCMOVNS Conditional move if not sign (non-negative).\nCMOVP/CMOVPE Conditional move if parity/Conditional move if parity even.\nCMOVNP/CMOVPO Conditional move if not parity/Conditional move if parity odd.\nXCHG Exchange.\nBSWAP Byte swap.\nXADD Exchange and add.\nCMPXCHG Compare and exchange.\nCMPXCHG8B Compare and exchange 8 bytes.\nPUSH Push onto stack.\nPOP Pop off of stack.\nPUSHA/PUSHAD Push general-purpose registers onto stack.\nPOPA/POPAD Pop general-purpose registers from stack.\nCWD/CDQ Convert word to doubleword/Convert doubleword to quadword.\nCBW/CWDE Convert byte to word/Convert word to doubleword in EAX register.\nMOVSX Move and sign extend.\nMOVZX Move and zero extend.\n\n5.1.2 Binary Arithmetic Instructions\nThe binary arithmetic instructions perform basic binary integer computations on byte, word, and doubleword inte-\ngers located in memory and/or the general purpose registers.\nADCX Unsigned integer add with carry.\nADOX Unsigned integer add with overflow.\nADD Integer add.\nADC Add with carry.\nSUB Subtract.\nSBB Subtract with borrow.\nIMUL Signed multiply.\nMUL Unsigned multiply.\nIDIV Signed divide.\nVol. 1 5-5\n\n\n\nINSTRUCTION SET SUMMARY\nDIV Unsigned divide.\nINC Increment.\nDEC Decrement.\nNEG Negate.\nCMP Compare.\n\n5.1.3 Decimal Arithmetic Instructions\nThe decimal arithmetic instructions perform decimal arithmetic on binary coded decimal (BCD) data.\nDAA Decimal adjust after addition.\nDAS Decimal adjust after subtraction.\nAAA ASCII adjust after addition.\nAAS ASCII adjust after subtraction.\nAAM ASCII adjust after multiplication.\nAAD ASCII adjust before division.\n\n5.1.4 Logical Instructions\nThe logical instructions perform basic AND, OR, XOR, and NOT logical operations on byte, word, and doubleword \nvalues.\nAND Perform bitwise logical AND.\nOR Perform bitwise logical OR.\nXOR Perform bitwise logical exclusive OR.\nNOT Perform bitwise logical NOT.\n\n5.1.5 Shift and Rotate Instructions\nThe shift and rotate instructions shift and rotate the bits in word and doubleword operands.\nSAR Shift arithmetic right.\nSHR Shift logical right.\nSAL/SHL Shift arithmetic left/Shift logical left.\nSHRD Shift right double.\nSHLD Shift left double.\nROR Rotate right.\nROL Rotate left.\nRCR Rotate through carry right.\nRCL Rotate through carry left.\n\n5.1.6 Bit and Byte Instructions\nBit instructions test and modify individual bits in word and doubleword operands. Byte instructions set the value of \na byte operand to indicate the status of flags in the EFLAGS register.\nBT Bit test.\nBTS Bit test and set.\nBTR Bit test and reset.\nBTC Bit test and complement.\nBSF Bit scan forward.\n5-6 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nBSR Bit scan reverse.\nSETE/SETZ Set byte if equal/Set byte if zero.\nSETNE/SETNZ Set byte if not equal/Set byte if not zero.\nSETA/SETNBE Set byte if above/Set byte if not below or equal.\nSETAE/SETNB/SETNC Set byte if above or equal/Set byte if not below/Set byte if not carry.\nSETB/SETNAE/SETC Set byte if below/Set byte if not above or equal/Set byte if carry.\nSETBE/SETNA Set byte if below or equal/Set byte if not above.\nSETG/SETNLE Set byte if greater/Set byte if not less or equal.\nSETGE/SETNL Set byte if greater or equal/Set byte if not less.\nSETL/SETNGE Set byte if less/Set byte if not greater or equal.\nSETLE/SETNG Set byte if less or equal/Set byte if not greater.\nSETS Set byte if sign (negative).\nSETNS Set byte if not sign (non-negative).\nSETO Set byte if overflow.\nSETNO Set byte if not overflow.\nSETPE/SETP Set byte if parity even/Set byte if parity.\nSETPO/SETNP Set byte if parity odd/Set byte if not parity.\nTEST Logical compare.\nCRC321 Provides hardware acceleration to calculate cyclic redundancy checks for fast and efficient \n\nimplementation of data integrity protocols.\nPOPCNT2 This instruction calculates of number of bits set to 1 in the second operand (source) and \n\nreturns the count in the first operand (a destination register).\n\n5.1.7 Control Transfer Instructions\nThe control transfer instructions provide jump, conditional jump, loop, and call and return operations to control \nprogram flow.\nJMP Jump.\nJE/JZ Jump if equal/Jump if zero.\nJNE/JNZ Jump if not equal/Jump if not zero.\nJA/JNBE Jump if above/Jump if not below or equal.\nJAE/JNB Jump if above or equal/Jump if not below.\nJB/JNAE Jump if below/Jump if not above or equal.\nJBE/JNA Jump if below or equal/Jump if not above.\nJG/JNLE Jump if greater/Jump if not less or equal.\nJGE/JNL Jump if greater or equal/Jump if not less.\nJL/JNGE Jump if less/Jump if not greater or equal.\nJLE/JNG Jump if less or equal/Jump if not greater.\nJC Jump if carry.\nJNC Jump if not carry.\nJO Jump if overflow.\nJNO Jump if not overflow.\nJS Jump if sign (negative).\nJNS Jump if not sign (non-negative).\n\n1. Processor support of CRC32 is enumerated by CPUID.01:ECX[SSE4.2] = 1\n\n2. Processor support of POPCNT is enumerated by CPUID.01:ECX[POPCNT] = 1\nVol. 1 5-7\n\n\n\nINSTRUCTION SET SUMMARY\nJPO/JNP Jump if parity odd/Jump if not parity.\nJPE/JP Jump if parity even/Jump if parity.\nJCXZ/JECXZ Jump register CX zero/Jump register ECX zero.\nLOOP Loop with ECX counter.\nLOOPZ/LOOPE Loop with ECX and zero/Loop with ECX and equal.\nLOOPNZ/LOOPNE Loop with ECX and not zero/Loop with ECX and not equal.\nCALL Call procedure.\nRET Return.\nIRET Return from interrupt.\nINT Software interrupt.\nINTO Interrupt on overflow.\nBOUND Detect value out of range.\nENTER High-level procedure entry.\nLEAVE High-level procedure exit.\n\n5.1.8 String Instructions\nThe string instructions operate on strings of bytes, allowing them to be moved to and from memory.\nMOVS/MOVSB Move string/Move byte string.\nMOVS/MOVSW Move string/Move word string.\nMOVS/MOVSD Move string/Move doubleword string.\nCMPS/CMPSB Compare string/Compare byte string.\nCMPS/CMPSW Compare string/Compare word string.\nCMPS/CMPSD Compare string/Compare doubleword string.\nSCAS/SCASB Scan string/Scan byte string.\nSCAS/SCASW Scan string/Scan word string.\nSCAS/SCASD Scan string/Scan doubleword string.\nLODS/LODSB Load string/Load byte string.\nLODS/LODSW Load string/Load word string.\nLODS/LODSD Load string/Load doubleword string.\nSTOS/STOSB Store string/Store byte string.\nSTOS/STOSW Store string/Store word string.\nSTOS/STOSD Store string/Store doubleword string.\nREP Repeat while ECX not zero.\nREPE/REPZ Repeat while equal/Repeat while zero.\nREPNE/REPNZ Repeat while not equal/Repeat while not zero.\n\n5.1.9 I/O Instructions\nThese instructions move data between the processor’s I/O ports and a register or memory.\nIN Read from a port.\nOUT Write to a port.\nINS/INSB Input string from port/Input byte string from port.\nINS/INSW Input string from port/Input word string from port.\nINS/INSD Input string from port/Input doubleword string from port.\nOUTS/OUTSB Output string to port/Output byte string to port.\nOUTS/OUTSW Output string to port/Output word string to port.\n5-8 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nOUTS/OUTSD Output string to port/Output doubleword string to port.\n\n5.1.10 Enter and Leave Instructions\nThese instructions provide machine-language support for procedure calls in block-structured languages.\nENTER High-level procedure entry.\nLEAVE High-level procedure exit.\n\n5.1.11 Flag Control (EFLAG) Instructions\nThe flag control instructions operate on the flags in the EFLAGS register.\nSTC Set carry flag.\nCLC Clear the carry flag.\nCMC Complement the carry flag.\nCLD Clear the direction flag.\nSTD Set direction flag.\nLAHF Load flags into AH register.\nSAHF Store AH register into flags.\nPUSHF/PUSHFD Push EFLAGS onto stack.\nPOPF/POPFD Pop EFLAGS from stack.\nSTI Set interrupt flag.\nCLI Clear the interrupt flag.\n\n5.1.12 Segment Register Instructions\nThe segment register instructions allow far pointers (segment addresses) to be loaded into the segment registers.\nLDS Load far pointer using DS.\nLES Load far pointer using ES.\nLFS Load far pointer using FS.\nLGS Load far pointer using GS.\nLSS Load far pointer using SS.\n\n5.1.13 Miscellaneous Instructions\nThe miscellaneous instructions provide such functions as loading an effective address, executing a “no-operation,” \nand retrieving processor identification information.\nLEA Load effective address.\nNOP No operation.\nUD Undefined instruction.\nXLAT/XLATB Table lookup translation.\nCPUID Processor identification.\nMOVBE1 Move data after swapping data bytes.\nPREFETCHW Prefetch data into cache in anticipation of write.\nPREFETCHWT1 Prefetch hint T1 with intent to write.\n\n1. Processor support of MOVBE is enumerated by CPUID.01:ECX.MOVBE[bit 22] = 1.\nVol. 1 5-9\n\n\n\nINSTRUCTION SET SUMMARY\nCLFLUSH Flushes and invalidates a memory operand and its associated cache line from all levels of \nthe processor’s cache hierarchy.\n\nCLFLUSHOPT Flushes and invalidates a memory operand and its associated cache line from all levels of \nthe processor’s cache hierarchy with optimized memory system throughput.\n\n5.1.14 User Mode Extended Sate Save/Restore Instructions\nXSAVE Save processor extended states to memory.\nXSAVEC Save processor extended states with compaction to memory.\nXSAVEOPT Save processor extended states to memory, optimized.\nXRSTOR Restore processor extended states from memory.\nXGETBV Reads the state of an extended control register.\n\n5.1.15 Random Number Generator Instructions\nRDRAND Retrieves a random number generated from hardware.\nRDSEED Retrieves a random number generated from hardware.\n\n5.1.16 BMI1, BMI2\nANDN Bitwise AND of first source with inverted 2nd source operands.\nBEXTR Contiguous bitwise extract.\nBLSI Extract lowest set bit.\nBLSMSK Set all lower bits below first set bit to 1.\n\nBLSR Reset lowest set bit.\nBZHI Zero high bits starting from specified bit position.\nLZCNT Count the number leading zero bits.\nMULX Unsigned multiply without affecting arithmetic flags.\nPDEP Parallel deposit of bits using a mask.\nPEXT Parallel extraction of bits using a mask.\nRORX Rotate right without affecting arithmetic flags.\nSARX Shift arithmetic right.\nSHLX Shift logic left.\nSHRX Shift logic right.\nTZCNT Count the number trailing zero bits.\n\n5.1.16.1  Detection of VEX-encoded GPR Instructions, LZCNT and TZCNT, PREFETCHW\nVEX-encoded general-purpose instructions do not operate on any vector registers. \nThere are separate feature flags for the following subsets of instructions that operate on general purpose registers, \nand the detection requirements for hardware support are:\nCPUID.(EAX=07H, ECX=0H):EBX.BMI1[bit 3]: if 1 indicates the processor supports the first group of advanced bit \nmanipulation extensions (ANDN, BEXTR, BLSI, BLSMSK, BLSR, TZCNT);\nCPUID.(EAX=07H, ECX=0H):EBX.BMI2[bit 8]: if 1 indicates the processor supports the second group of advanced \nbit manipulation extensions (BZHI, MULX, PDEP, PEXT, RORX, SARX, SHLX, SHRX);\nCPUID.EAX=80000001H:ECX.LZCNT[bit 5]: if 1 indicates the processor supports the LZCNT instruction.\nCPUID.EAX=80000001H:ECX.PREFTEHCHW[bit 8]: if 1 indicates the processor supports the PREFTEHCHW instruc-\ntion. CPUID.(EAX=07H, ECX=0H):ECX.PREFTEHCHWT1[bit 0]: if 1 indicates the processor supports the \nPREFTEHCHWT1 instruction.\n5-10 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\n5.2 X87 FPU INSTRUCTIONS\nThe x87 FPU instructions are executed by the processor’s x87 FPU. These instructions operate on floating-point, \ninteger, and binary-coded decimal (BCD) operands. For more detail on x87 FPU instructions, see Chapter 8, \n“Programming with the x87 FPU.”\n\nThese instructions are divided into the following subgroups: data transfer, load constants, and FPU control instruc-\ntions. The sections that follow introduce each subgroup.\n\n5.2.1 x87 FPU Data Transfer Instructions\nThe data transfer instructions move floating-point, integer, and BCD values between memory and the x87 FPU \nregisters. They also perform conditional move operations on floating-point operands.\nFLD Load floating-point value.\nFST Store floating-point value.\nFSTP Store floating-point value and pop.\nFILD Load integer.\nFIST Store integer.\nFISTP1 Store integer and pop.\nFBLD Load BCD.\nFBSTP Store BCD and pop.\nFXCH Exchange registers.\nFCMOVE Floating-point conditional move if equal.\nFCMOVNE Floating-point conditional move if not equal.\nFCMOVB Floating-point conditional move if below.\nFCMOVBE Floating-point conditional move if below or equal.\nFCMOVNB Floating-point conditional move if not below.\nFCMOVNBE Floating-point conditional move if not below or equal.\nFCMOVU Floating-point conditional move if unordered.\nFCMOVNU Floating-point conditional move if not unordered.\n\n5.2.2 x87 FPU Basic Arithmetic Instructions\nThe basic arithmetic instructions perform basic arithmetic operations on floating-point and integer operands.\nFADD Add floating-point\nFADDP Add floating-point and pop\nFIADD Add integer\nFSUB Subtract floating-point\nFSUBP Subtract floating-point and pop\nFISUB Subtract integer\nFSUBR Subtract floating-point reverse\nFSUBRP Subtract floating-point reverse and pop\nFISUBR Subtract integer reverse\nFMUL Multiply floating-point\nFMULP Multiply floating-point and pop\nFIMUL Multiply integer\nFDIV Divide floating-point\n\n1. SSE3 provides an instruction FISTTP for integer conversion.\nVol. 1 5-11\n\n\n\nINSTRUCTION SET SUMMARY\nFDIVP Divide floating-point and pop\nFIDIV Divide integer\nFDIVR Divide floating-point reverse\nFDIVRP Divide floating-point reverse and pop\nFIDIVR Divide integer reverse\nFPREM Partial remainder\nFPREM1 IEEE Partial remainder\nFABS Absolute value\nFCHS Change sign\nFRNDINT Round to integer\nFSCALE Scale by power of two\nFSQRT Square root\nFXTRACT Extract exponent and significand\n\n5.2.3 x87 FPU Comparison Instructions\nThe compare instructions examine or compare floating-point or integer operands.\nFCOM Compare floating-point.\nFCOMP Compare floating-point and pop.\nFCOMPP Compare floating-point and pop twice.\nFUCOM Unordered compare floating-point.\nFUCOMP Unordered compare floating-point and pop.\nFUCOMPP Unordered compare floating-point and pop twice.\nFICOM Compare integer.\nFICOMP Compare integer and pop.\nFCOMI Compare floating-point and set EFLAGS.\nFUCOMI Unordered compare floating-point and set EFLAGS.\nFCOMIP Compare floating-point, set EFLAGS, and pop.\nFUCOMIP Unordered compare floating-point, set EFLAGS, and pop.\nFTST Test floating-point (compare with 0.0).\nFXAM Examine floating-point.\n\n5.2.4 x87 FPU Transcendental Instructions\nThe transcendental instructions perform basic trigonometric and logarithmic operations on floating-point operands.\nFSIN Sine\nFCOS Cosine\nFSINCOS Sine and cosine\nFPTAN Partial tangent\nFPATAN Partial arctangent\nF2XM1 2x − 1\nFYL2X y∗log2x\nFYL2XP1 y∗log2(x+1)\n\n5.2.5 x87 FPU Load Constants Instructions\nThe load constants instructions load common constants, such as π, into the x87 floating-point registers.\n5-12 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nFLD1 Load +1.0\nFLDZ Load +0.0\nFLDPI Load π\nFLDL2E Load log2e\nFLDLN2 Load loge2\nFLDL2T Load log210\nFLDLG2 Load log102\n\n5.2.6 x87 FPU Control Instructions\nThe x87 FPU control instructions operate on the x87 FPU register stack and save and restore the x87 FPU state.\nFINCSTP Increment FPU register stack pointer.\nFDECSTP Decrement FPU register stack pointer.\nFFREE Free floating-point register.\nFINIT Initialize FPU after checking error conditions.\nFNINIT Initialize FPU without checking error conditions.\nFCLEX Clear floating-point exception flags after checking for error conditions.\nFNCLEX Clear floating-point exception flags without checking for error conditions.\nFSTCW Store FPU control word after checking error conditions.\nFNSTCW Store FPU control word without checking error conditions.\nFLDCW Load FPU control word.\nFSTENV Store FPU environment after checking error conditions.\nFNSTENV Store FPU environment without checking error conditions.\nFLDENV Load FPU environment.\nFSAVE Save FPU state after checking error conditions.\nFNSAVE Save FPU state without checking error conditions.\nFRSTOR Restore FPU state.\nFSTSW Store FPU status word after checking error conditions.\nFNSTSW Store FPU status word without checking error conditions.\nWAIT/FWAIT Wait for FPU.\nFNOP FPU no operation.\n\n5.3 X87 FPU AND SIMD STATE MANAGEMENT INSTRUCTIONS\nTwo state management instructions were introduced into the IA-32 architecture with the Pentium II processor \nfamily:\nFXSAVE Save x87 FPU and SIMD state.\nFXRSTOR Restore x87 FPU and SIMD state.\n\nInitially, these instructions operated only on the x87 FPU (and MMX) registers to perform a fast save and restore, \nrespectively, of the x87 FPU and MMX state. With the introduction of SSE extensions in the Pentium III processor \nfamily, these instructions were expanded to also save and restore the state of the XMM and MXCSR registers. Intel \n64 architecture also supports these instructions.\n\nSee Section 10.5, “FXSAVE and FXRSTOR Instructions,” for more detail.\n\n5.4 MMX™ INSTRUCTIONS\nFour extensions have been introduced into the IA-32 architecture to permit IA-32 processors to perform single-\ninstruction multiple-data (SIMD) operations. These extensions include the MMX technology, SSE extensions, SSE2 \nVol. 1 5-13\n\n\n\nINSTRUCTION SET SUMMARY\nextensions, and SSE3 extensions. For a discussion that puts SIMD instructions in their historical context, see \nSection 2.2.7, “SIMD Instructions.”\n\nMMX instructions operate on packed byte, word, doubleword, or quadword integer operands contained in memory, \nin MMX registers, and/or in general-purpose registers. For more detail on these instructions, see Chapter 9, \n“Programming with Intel® MMX™ Technology.” \n\nMMX instructions can only be executed on Intel 64 and IA-32 processors that support the MMX technology. Support \nfor these instructions can be detected with the CPUID instruction. See the description of the CPUID instruction in \nChapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 2A.\n\nMMX instructions are divided into the following subgroups: data transfer, conversion, packed arithmetic, compar-\nison, logical, shift and rotate, and state management instructions. The sections that follow introduce each \nsubgroup.\n\n5.4.1 MMX Data Transfer Instructions\nThe data transfer instructions move doubleword and quadword operands between MMX registers and between MMX \nregisters and memory.\nMOVD Move doubleword.\nMOVQ Move quadword.\n\n5.4.2 MMX Conversion Instructions\nThe conversion instructions pack and unpack bytes, words, and doublewords\nPACKSSWB Pack words into bytes with signed saturation.\nPACKSSDW Pack doublewords into words with signed saturation.\nPACKUSWB Pack words into bytes with unsigned saturation.\nPUNPCKHBW Unpack high-order bytes.\nPUNPCKHWD Unpack high-order words.\nPUNPCKHDQ Unpack high-order doublewords.\nPUNPCKLBW Unpack low-order bytes.\nPUNPCKLWD Unpack low-order words.\nPUNPCKLDQ Unpack low-order doublewords.\n\n5.4.3 MMX Packed Arithmetic Instructions\nThe packed arithmetic instructions perform packed integer arithmetic on packed byte, word, and doubleword inte-\ngers.\nPADDB Add packed byte integers.\nPADDW Add packed word integers.\nPADDD Add packed doubleword integers.\nPADDSB Add packed signed byte integers with signed saturation.\nPADDSW Add packed signed word integers with signed saturation.\nPADDUSB Add packed unsigned byte integers with unsigned saturation.\nPADDUSW Add packed unsigned word integers with unsigned saturation.\nPSUBB Subtract packed byte integers.\nPSUBW Subtract packed word integers.\nPSUBD Subtract packed doubleword integers.\nPSUBSB Subtract packed signed byte integers with signed saturation.\nPSUBSW Subtract packed signed word integers with signed saturation.\n5-14 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nPSUBUSB Subtract packed unsigned byte integers with unsigned saturation.\nPSUBUSW Subtract packed unsigned word integers with unsigned saturation.\nPMULHW Multiply packed signed word integers and store high result.\nPMULLW Multiply packed signed word integers and store low result.\nPMADDWD Multiply and add packed word integers.\n\n5.4.4 MMX Comparison Instructions\nThe compare instructions compare packed bytes, words, or doublewords.\nPCMPEQB Compare packed bytes for equal.\nPCMPEQW Compare packed words for equal.\nPCMPEQD Compare packed doublewords for equal.\nPCMPGTB Compare packed signed byte integers for greater than.\nPCMPGTW Compare packed signed word integers for greater than.\nPCMPGTD Compare packed signed doubleword integers for greater than.\n\n5.4.5 MMX Logical Instructions\nThe logical instructions perform AND, AND NOT, OR, and XOR operations on quadword operands.\nPAND Bitwise logical AND.\nPANDN Bitwise logical AND NOT.\nPOR Bitwise logical OR.\nPXOR Bitwise logical exclusive OR.\n\n5.4.6 MMX Shift and Rotate Instructions\nThe shift and rotate instructions shift and rotate packed bytes, words, or doublewords, or quadwords in 64-bit \noperands.\nPSLLW Shift packed words left logical.\nPSLLD Shift packed doublewords left logical.\nPSLLQ Shift packed quadword left logical.\nPSRLW Shift packed words right logical.\nPSRLD Shift packed doublewords right logical.\nPSRLQ Shift packed quadword right logical.\nPSRAW Shift packed words right arithmetic.\nPSRAD Shift packed doublewords right arithmetic.\n\n5.4.7 MMX State Management Instructions\nThe EMMS instruction clears the MMX state from the MMX registers.\nEMMS Empty MMX state.\n\n5.5 SSE INSTRUCTIONS\nSSE instructions represent an extension of the SIMD execution model introduced with the MMX technology. For \nmore detail on these instructions, see Chapter 10, “Programming with Intel® Streaming SIMD Extensions (Intel® \nSSE).”\nVol. 1 5-15\n\n\n\nINSTRUCTION SET SUMMARY\nSSE instructions can only be executed on Intel 64 and IA-32 processors that support SSE extensions. Support for \nthese instructions can be detected with the CPUID instruction. See the description of the CPUID instruction in \nChapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 2A.\n\nSSE instructions are divided into four subgroups (note that the first subgroup has subordinate subgroups of its \nown):\n• SIMD single-precision floating-point instructions that operate on the XMM registers.\n• MXCSR state management instructions.\n• 64-bit SIMD integer instructions that operate on the MMX registers.\n• Cacheability control, prefetch, and instruction ordering instructions.\n\nThe following sections provide an overview of these groups.\n\n5.5.1 SSE SIMD Single-Precision Floating-Point Instructions\nThese instructions operate on packed and scalar single-precision floating-point values located in XMM registers \nand/or memory. This subgroup is further divided into the following subordinate subgroups: data transfer, packed \narithmetic, comparison, logical, shuffle and unpack, and conversion instructions.\n\n5.5.1.1  SSE Data Transfer Instructions\nSSE data transfer instructions move packed and scalar single-precision floating-point operands between XMM \nregisters and between XMM registers and memory.\nMOVAPS Move four aligned packed single-precision floating-point values between XMM registers or \n\nbetween and XMM register and memory.\nMOVUPS Move four unaligned packed single-precision floating-point values between XMM registers \n\nor between and XMM register and memory.\nMOVHPS Move two packed single-precision floating-point values to an from the high quadword of an \n\nXMM register and memory.\nMOVHLPS Move two packed single-precision floating-point values from the high quadword of an XMM \n\nregister to the low quadword of another XMM register.\nMOVLPS Move two packed single-precision floating-point values to an from the low quadword of an \n\nXMM register and memory.\nMOVLHPS Move two packed single-precision floating-point values from the low quadword of an XMM \n\nregister to the high quadword of another XMM register.\nMOVMSKPS Extract sign mask from four packed single-precision floating-point values.\nMOVSS Move scalar single-precision floating-point value between XMM registers or between an \n\nXMM register and memory.\n\n5.5.1.2  SSE Packed Arithmetic Instructions\nSSE packed arithmetic instructions perform packed and scalar arithmetic operations on packed and scalar single-\nprecision floating-point operands.\nADDPS Add packed single-precision floating-point values.\nADDSS Add scalar single-precision floating-point values.\nSUBPS Subtract packed single-precision floating-point values.\nSUBSS Subtract scalar single-precision floating-point values.\nMULPS Multiply packed single-precision floating-point values.\nMULSS Multiply scalar single-precision floating-point values.\nDIVPS Divide packed single-precision floating-point values.\nDIVSS Divide scalar single-precision floating-point values.\n5-16 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nRCPPS Compute reciprocals of packed single-precision floating-point values.\nRCPSS Compute reciprocal of scalar single-precision floating-point values.\nSQRTPS Compute square roots of packed single-precision floating-point values.\nSQRTSS Compute square root of scalar single-precision floating-point values.\nRSQRTPS Compute reciprocals of square roots of packed single-precision floating-point values.\nRSQRTSS Compute reciprocal of square root of scalar single-precision floating-point values.\nMAXPS Return maximum packed single-precision floating-point values.\nMAXSS Return maximum scalar single-precision floating-point values.\nMINPS Return minimum packed single-precision floating-point values.\nMINSS Return minimum scalar single-precision floating-point values.\n\n5.5.1.3  SSE Comparison Instructions\nSSE compare instructions compare packed and scalar single-precision floating-point operands.\nCMPPS Compare packed single-precision floating-point values.\nCMPSS Compare scalar single-precision floating-point values.\nCOMISS Perform ordered comparison of scalar single-precision floating-point values and set flags in \n\nEFLAGS register.\nUCOMISS Perform unordered comparison of scalar single-precision floating-point values and set flags \n\nin EFLAGS register.\n\n5.5.1.4  SSE Logical Instructions\nSSE logical instructions perform bitwise AND, AND NOT, OR, and XOR operations on packed single-precision \nfloating-point operands.\nANDPS Perform bitwise logical AND of packed single-precision floating-point values.\nANDNPS Perform bitwise logical AND NOT of packed single-precision floating-point values.\nORPS Perform bitwise logical OR of packed single-precision floating-point values.\nXORPS Perform bitwise logical XOR of packed single-precision floating-point values.\n\n5.5.1.5  SSE Shuffle and Unpack Instructions\nSSE shuffle and unpack instructions shuffle or interleave single-precision floating-point values in packed single-\nprecision floating-point operands.\nSHUFPS Shuffles values in packed single-precision floating-point operands.\nUNPCKHPS Unpacks and interleaves the two high-order values from two single-precision floating-point \n\noperands.\nUNPCKLPS Unpacks and interleaves the two low-order values from two single-precision floating-point \n\noperands.\n\n5.5.1.6  SSE Conversion Instructions\nSSE conversion instructions convert packed and individual doubleword integers into packed and scalar single-\nprecision floating-point values and vice versa.\nCVTPI2PS Convert packed doubleword integers to packed single-precision floating-point values.\nCVTSI2SS Convert doubleword integer to scalar single-precision floating-point value.\nCVTPS2PI Convert packed single-precision floating-point values to packed doubleword integers.\nCVTTPS2PI Convert with truncation packed single-precision floating-point values to packed double-\n\nword integers.\nCVTSS2SI Convert a scalar single-precision floating-point value to a doubleword integer.\nVol. 1 5-17\n\n\n\nINSTRUCTION SET SUMMARY\nCVTTSS2SI Convert with truncation a scalar single-precision floating-point value to a scalar double-\nword integer.\n\n5.5.2 SSE MXCSR State Management Instructions\nMXCSR state management instructions allow saving and restoring the state of the MXCSR control and status \nregister.\nLDMXCSR Load MXCSR register.\nSTMXCSR Save MXCSR register state.\n\n5.5.3 SSE 64-Bit SIMD Integer Instructions\nThese SSE 64-bit SIMD integer instructions perform additional operations on packed bytes, words, or doublewords \ncontained in MMX registers. They represent enhancements to the MMX instruction set described in Section 5.4, \n“MMX™ Instructions.”\nPAVGB Compute average of packed unsigned byte integers.\nPAVGW Compute average of packed unsigned word integers.\nPEXTRW Extract word.\nPINSRW Insert word.\nPMAXUB Maximum of packed unsigned byte integers.\nPMAXSW Maximum of packed signed word integers.\nPMINUB Minimum of packed unsigned byte integers.\nPMINSW Minimum of packed signed word integers.\nPMOVMSKB Move byte mask.\nPMULHUW Multiply packed unsigned integers and store high result.\nPSADBW Compute sum of absolute differences.\nPSHUFW Shuffle packed integer word in MMX register.\n\n5.5.4 SSE Cacheability Control, Prefetch, and Instruction Ordering Instructions\nThe cacheability control instructions provide control over the caching of non-temporal data when storing data from \nthe MMX and XMM registers to memory. The PREFETCHh allows data to be prefetched to a selected cache level. The \nSFENCE instruction controls instruction ordering on store operations.\nMASKMOVQ Non-temporal store of selected bytes from an MMX register into memory.\nMOVNTQ Non-temporal store of quadword from an MMX register into memory.\nMOVNTPS Non-temporal store of four packed single-precision floating-point values from an XMM \n\nregister into memory.\nPREFETCHh Load 32 or more of bytes from memory to a selected level of the processor’s cache hier-\n\narchy\nSFENCE Serializes store operations.\n\n5.6 SSE2 INSTRUCTIONS\nSSE2 extensions represent an extension of the SIMD execution model introduced with MMX technology and the \nSSE extensions. SSE2 instructions operate on packed double-precision floating-point operands and on packed \nbyte, word, doubleword, and quadword operands located in the XMM registers. For more detail on these instruc-\ntions, see Chapter 11, “Programming with Intel® Streaming SIMD Extensions 2 (Intel® SSE2).”\n\nSSE2 instructions can only be executed on Intel 64 and IA-32 processors that support the SSE2 extensions. \nSupport for these instructions can be detected with the CPUID instruction. See the description of the CPUID instruc-\n5-18 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\ntion in Chapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s \nManual, Volume 2A.\n\nThese instructions are divided into four subgroups (note that the first subgroup is further divided into subordinate \nsubgroups):\n• Packed and scalar double-precision floating-point instructions.\n• Packed single-precision floating-point conversion instructions.\n• 128-bit SIMD integer instructions.\n• Cacheability-control and instruction ordering instructions.\n\nThe following sections give an overview of each subgroup.\n\n5.6.1 SSE2 Packed and Scalar Double-Precision Floating-Point Instructions\nSSE2 packed and scalar double-precision floating-point instructions are divided into the following subordinate \nsubgroups: data movement, arithmetic, comparison, conversion, logical, and shuffle operations on double-preci-\nsion floating-point operands. These are introduced in the sections that follow.\n\n5.6.1.1  SSE2 Data Movement Instructions\nSSE2 data movement instructions move double-precision floating-point data between XMM registers and between \nXMM registers and memory.\nMOVAPD Move two aligned packed double-precision floating-point values between XMM registers or \n\nbetween and XMM register and memory.\nMOVUPD Move two unaligned packed double-precision floating-point values between XMM registers \n\nor between and XMM register and memory.\nMOVHPD Move high packed double-precision floating-point value to an from the high quadword of an \n\nXMM register and memory.\nMOVLPD Move low packed single-precision floating-point value to an from the low quadword of an \n\nXMM register and memory.\nMOVMSKPD Extract sign mask from two packed double-precision floating-point values.\nMOVSD Move scalar double-precision floating-point value between XMM registers or between an \n\nXMM register and memory.\n\n5.6.1.2  SSE2 Packed Arithmetic Instructions\nThe arithmetic instructions perform addition, subtraction, multiply, divide, square root, and maximum/minimum \noperations on packed and scalar double-precision floating-point operands.\nADDPD Add packed double-precision floating-point values.\nADDSD Add scalar double precision floating-point values.\nSUBPD Subtract packed double-precision floating-point values.\nSUBSD Subtract scalar double-precision floating-point values.\nMULPD Multiply packed double-precision floating-point values.\nMULSD Multiply scalar double-precision floating-point values.\nDIVPD Divide packed double-precision floating-point values.\nDIVSD Divide scalar double-precision floating-point values.\nSQRTPD Compute packed square roots of packed double-precision floating-point values.\nSQRTSD Compute scalar square root of scalar double-precision floating-point values.\nMAXPD Return maximum packed double-precision floating-point values.\nMAXSD Return maximum scalar double-precision floating-point values.\nMINPD Return minimum packed double-precision floating-point values.\nVol. 1 5-19\n\n\n\nINSTRUCTION SET SUMMARY\nMINSD Return minimum scalar double-precision floating-point values.\n\n5.6.1.3  SSE2 Logical Instructions\nSSE2 logical instructions perform AND, AND NOT, OR, and XOR operations on packed double-precision floating-\npoint values.\nANDPD Perform bitwise logical AND of packed double-precision floating-point values.\nANDNPD Perform bitwise logical AND NOT of packed double-precision floating-point values.\nORPD Perform bitwise logical OR of packed double-precision floating-point values.\nXORPD Perform bitwise logical XOR of packed double-precision floating-point values.\n\n5.6.1.4  SSE2 Compare Instructions\nSSE2 compare instructions compare packed and scalar double-precision floating-point values and return the \nresults of the comparison either to the destination operand or to the EFLAGS register.\nCMPPD Compare packed double-precision floating-point values.\nCMPSD Compare scalar double-precision floating-point values.\nCOMISD Perform ordered comparison of scalar double-precision floating-point values and set flags \n\nin EFLAGS register.\nUCOMISD Perform unordered comparison of scalar double-precision floating-point values and set \n\nflags in EFLAGS register.\n\n5.6.1.5  SSE2 Shuffle and Unpack Instructions\nSSE2 shuffle and unpack instructions shuffle or interleave double-precision floating-point values in packed double-\nprecision floating-point operands.\nSHUFPD Shuffles values in packed double-precision floating-point operands.\nUNPCKHPD Unpacks and interleaves the high values from two packed double-precision floating-point \n\noperands.\nUNPCKLPD Unpacks and interleaves the low values from two packed double-precision floating-point \n\noperands.\n\n5.6.1.6  SSE2 Conversion Instructions\nSSE2 conversion instructions convert packed and individual doubleword integers into packed and scalar double-\nprecision floating-point values and vice versa. They also convert between packed and scalar single-precision and \ndouble-precision floating-point values.\nCVTPD2PI Convert packed double-precision floating-point values to packed doubleword integers.\nCVTTPD2PI Convert with truncation packed double-precision floating-point values to packed double-\n\nword integers.\nCVTPI2PD Convert packed doubleword integers to packed double-precision floating-point values.\nCVTPD2DQ Convert packed double-precision floating-point values to packed doubleword integers.\nCVTTPD2DQ Convert with truncation packed double-precision floating-point values to packed double-\n\nword integers.\nCVTDQ2PD Convert packed doubleword integers to packed double-precision floating-point values.\nCVTPS2PD Convert packed single-precision floating-point values to packed double-precision floating-\n\npoint values.\nCVTPD2PS Convert packed double-precision floating-point values to packed single-precision floating-\n\npoint values.\nCVTSS2SD Convert scalar single-precision floating-point values to scalar double-precision floating-\n\npoint values.\n5-20 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nCVTSD2SS Convert scalar double-precision floating-point values to scalar single-precision floating-\npoint values.\n\nCVTSD2SI Convert scalar double-precision floating-point values to a doubleword integer.\nCVTTSD2SI Convert with truncation scalar double-precision floating-point values to scalar doubleword \n\nintegers.\nCVTSI2SD Convert doubleword integer to scalar double-precision floating-point value.\n\n5.6.2 SSE2 Packed Single-Precision Floating-Point Instructions\nSSE2 packed single-precision floating-point instructions perform conversion operations on single-precision \nfloating-point and integer operands. These instructions represent enhancements to the SSE single-precision \nfloating-point instructions.\nCVTDQ2PS Convert packed doubleword integers to packed single-precision floating-point values.\nCVTPS2DQ Convert packed single-precision floating-point values to packed doubleword integers.\nCVTTPS2DQ Convert with truncation packed single-precision floating-point values to packed double-\n\nword integers.\n\n5.6.3 SSE2 128-Bit SIMD Integer Instructions\nSSE2 SIMD integer instructions perform additional operations on packed words, doublewords, and quadwords \ncontained in XMM and MMX registers.\nMOVDQA Move aligned double quadword.\nMOVDQU Move unaligned double quadword.\nMOVQ2DQ Move quadword integer from MMX to XMM registers.\nMOVDQ2Q Move quadword integer from XMM to MMX registers.\nPMULUDQ Multiply packed unsigned doubleword integers.\nPADDQ Add packed quadword integers.\nPSUBQ Subtract packed quadword integers.\nPSHUFLW Shuffle packed low words.\nPSHUFHW Shuffle packed high words.\nPSHUFD Shuffle packed doublewords.\nPSLLDQ Shift double quadword left logical.\nPSRLDQ Shift double quadword right logical.\nPUNPCKHQDQ Unpack high quadwords.\nPUNPCKLQDQ Unpack low quadwords.\n\n5.6.4 SSE2 Cacheability Control and Ordering Instructions\nSSE2 cacheability control instructions provide additional operations for caching of non-temporal data when storing \ndata from XMM registers to memory. LFENCE and MFENCE provide additional control of instruction ordering on \nstore operations.\nCLFLUSH See Section 5.1.13.\nLFENCE Serializes load operations.\nMFENCE Serializes load and store operations.\nPAUSE Improves the performance of “spin-wait loops”.\nMASKMOVDQU Non-temporal store of selected bytes from an XMM register into memory.\nMOVNTPD Non-temporal store of two packed double-precision floating-point values from an XMM \n\nregister into memory.\nMOVNTDQ Non-temporal store of double quadword from an XMM register into memory.\nVol. 1 5-21\n\n\n\nINSTRUCTION SET SUMMARY\nMOVNTI Non-temporal store of a doubleword from a general-purpose register into memory.\n\n5.7 SSE3 INSTRUCTIONS\nThe SSE3 extensions offers 13 instructions that accelerate performance of Streaming SIMD Extensions technology, \nStreaming SIMD Extensions 2 technology, and x87-FP math capabilities. These instructions can be grouped into the \nfollowing categories:\n• One x87FPU instruction used in integer conversion.\n• One SIMD integer instruction that addresses unaligned data loads.\n• Two SIMD floating-point packed ADD/SUB instructions.\n• Four SIMD floating-point horizontal ADD/SUB instructions.\n• Three SIMD floating-point LOAD/MOVE/DUPLICATE instructions.\n• Two thread synchronization instructions.\n\nSSE3 instructions can only be executed on Intel 64 and IA-32 processors that support SSE3 extensions. Support \nfor these instructions can be detected with the CPUID instruction. See the description of the CPUID instruction in \nChapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 2A.\n\nThe sections that follow describe each subgroup.\n\n5.7.1 SSE3 x87-FP Integer Conversion Instruction\nFISTTP Behaves like the FISTP instruction but uses truncation, irrespective of the rounding mode \n\nspecified in the floating-point control word (FCW).\n\n5.7.2 SSE3 Specialized 128-bit Unaligned Data Load Instruction\nLDDQU Special 128-bit unaligned load designed to avoid cache line splits.\n\n5.7.3 SSE3 SIMD Floating-Point Packed ADD/SUB Instructions\nADDSUBPS Performs single-precision addition on the second and fourth pairs of 32-bit data elements \n\nwithin the operands; single-precision subtraction on the first and third pairs.\nADDSUBPD Performs double-precision addition on the second pair of quadwords, and double-precision \n\nsubtraction on the first pair.\n\n5.7.4 SSE3 SIMD Floating-Point Horizontal ADD/SUB Instructions\nHADDPS Performs a single-precision addition on contiguous data elements. The first data element of \n\nthe result is obtained by adding the first and second elements of the first operand; the \nsecond element by adding the third and fourth elements of the first operand; the third by \nadding the first and second elements of the second operand; and the fourth by adding the \nthird and fourth elements of the second operand.\n\nHSUBPS Performs a single-precision subtraction on contiguous data elements. The first data \nelement of the result is obtained by subtracting the second element of the first operand \nfrom the first element of the first operand; the second element by subtracting the fourth \nelement of the first operand from the third element of the first operand; the third by \nsubtracting the second element of the second operand from the first element of the second \noperand; and the fourth by subtracting the fourth element of the second operand from the \nthird element of the second operand.\n5-22 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nHADDPD Performs a double-precision addition on contiguous data elements. The first data element \nof the result is obtained by adding the first and second elements of the first operand; the \nsecond element by adding the first and second elements of the second operand.\n\nHSUBPD Performs a double-precision subtraction on contiguous data elements. The first data \nelement of the result is obtained by subtracting the second element of the first operand \nfrom the first element of the first operand; the second element by subtracting the second \nelement of the second operand from the first element of the second operand.\n\n5.7.5 SSE3 SIMD Floating-Point LOAD/MOVE/DUPLICATE Instructions\nMOVSHDUP Loads/moves 128 bits; duplicating the second and fourth 32-bit data elements.\nMOVSLDUP Loads/moves 128 bits; duplicating the first and third 32-bit data elements.\nMOVDDUP Loads/moves 64 bits (bits[63:0] if the source is a register) and returns the same 64 bits in \n\nboth the lower and upper halves of the 128-bit result register; duplicates the 64 bits from \nthe source.\n\n5.7.6 SSE3 Agent Synchronization Instructions\nMONITOR Sets up an address range used to monitor write-back stores.\nMWAIT Enables a logical processor to enter into an optimized state while waiting for a write-back \n\nstore to the address range set up by the MONITOR instruction.\n\n5.8 SUPPLEMENTAL STREAMING SIMD EXTENSIONS 3 (SSSE3) INSTRUCTIONS\nSSSE3 provide 32 instructions (represented by 14 mnemonics) to accelerate computations on packed integers. \nThese include:\n• Twelve instructions that perform horizontal addition or subtraction operations.\n• Six instructions that evaluate absolute values.\n• Two instructions that perform multiply and add operations and speed up the evaluation of dot products.\n• Two instructions that accelerate packed-integer multiply operations and produce integer values with scaling.\n• Two instructions that perform a byte-wise, in-place shuffle according to the second shuffle control operand.\n• Six instructions that negate packed integers in the destination operand if the signs of the corresponding \n\nelement in the source operand is less than zero.\n• Two instructions that align data from the composite of two operands.\n\nSSSE3 instructions can only be executed on Intel 64 and IA-32 processors that support SSSE3 extensions. Support \nfor these instructions can be detected with the CPUID instruction. See the description of the CPUID instruction in \nChapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s \nManual, Volume 2A.\n\nThe sections that follow describe each subgroup.\n\n5.8.1 Horizontal Addition/Subtraction\nPHADDW Adds two adjacent, signed 16-bit integers horizontally from the source and destination \n\noperands and packs the signed 16-bit results to the destination operand.\nPHADDSW Adds two adjacent, signed 16-bit integers horizontally from the source and destination \n\noperands and packs the signed, saturated 16-bit results to the destination operand.\nPHADDD Adds two adjacent, signed 32-bit integers horizontally from the source and destination \n\noperands and packs the signed 32-bit results to the destination operand.\nPHSUBW Performs horizontal subtraction on each adjacent pair of 16-bit signed integers by \n\nsubtracting the most significant word from the least significant word of each pair in the \nVol. 1 5-23\n\n\n\nINSTRUCTION SET SUMMARY\nsource and destination operands. The signed 16-bit results are packed and written to the \ndestination operand.\n\nPHSUBSW Performs horizontal subtraction on each adjacent pair of 16-bit signed integers by \nsubtracting the most significant word from the least significant word of each pair in the \nsource and destination operands. The signed, saturated 16-bit results are packed and \nwritten to the destination operand.\n\nPHSUBD Performs horizontal subtraction on each adjacent pair of 32-bit signed integers by \nsubtracting the most significant doubleword from the least significant double word of each \npair in the source and destination operands. The signed 32-bit results are packed and \nwritten to the destination operand.\n\n5.8.2 Packed Absolute Values\nPABSB Computes the absolute value of each signed byte data element.\nPABSW Computes the absolute value of each signed 16-bit data element.\nPABSD Computes the absolute value of each signed 32-bit data element. \n\n5.8.3 Multiply and Add Packed Signed and Unsigned Bytes\nPMADDUBSW Multiplies each unsigned byte value with the corresponding signed byte value to produce \n\nan intermediate, 16-bit signed integer. Each adjacent pair of 16-bit signed values are \nadded horizontally. The signed, saturated 16-bit results are packed to the destination \noperand.\n\n5.8.4 Packed Multiply High with Round and Scale\nPMULHRSW Multiplies vertically each signed 16-bit integer from the destination operand with the corre-\n\nsponding signed 16-bit integer of the source operand, producing intermediate, signed 32-\nbit integers. Each intermediate 32-bit integer is truncated to the 18 most significant bits. \nRounding is always performed by adding 1 to the least significant bit of the 18-bit interme-\ndiate result. The final result is obtained by selecting the 16 bits immediately to the right of \nthe most significant bit of each 18-bit intermediate result and packed to the destination \noperand.\n\n5.8.5 Packed Shuffle Bytes\nPSHUFB Permutes each byte in place, according to a shuffle control mask. The least significant \n\nthree or four bits of each shuffle control byte of the control mask form the shuffle index. \nThe shuffle mask is unaffected. If the most significant bit (bit 7) of a shuffle control byte is \nset, the constant zero is written in the result byte.\n\n5.8.6 Packed Sign\nPSIGNB/W/D Negates each signed integer element of the destination operand if the sign of the corre-\n\nsponding data element in the source operand is less than zero.\n\n5.8.7 Packed Align Right\nPALIGNR Source operand is appended after the destination operand forming an intermediate value \n\nof twice the width of an operand. The result is extracted from the intermediate value into \nthe destination operand by selecting the 128 bit or 64 bit value that are right-aligned to the \nbyte offset specified by the immediate value.\n5-24 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\n5.9 SSE4 INSTRUCTIONS\nIntel® Streaming SIMD Extensions 4 (SSE4) introduces 54 new instructions. 47 of the SSE4 instructions are \nreferred to as SSE4.1 in this document, 7 new SSE4 instructions are referred to as SSE4.2. \n\nSSE4.1 is targeted to improve the performance of media, imaging, and 3D workloads. SSE4.1 adds instructions \nthat improve compiler vectorization and significantly increase support for packed dword computation. The tech-\nnology also provides a hint that can improve memory throughput when reading from uncacheable WC memory \ntype.\n\nThe 47 SSE4.1 instructions include:\n• Two instructions perform packed dword multiplies.\n• Two instructions perform floating-point dot products with input/output selects.\n• One instruction performs a load with a streaming hint.\n• Six instructions simplify packed blending.\n• Eight instructions expand support for packed integer MIN/MAX.\n• Four instructions support floating-point round with selectable rounding mode and precision exception override.\n• Seven instructions improve data insertion and extractions from XMM registers\n• Twelve instructions improve packed integer format conversions (sign and zero extensions).\n• One instruction improves SAD (sum absolute difference) generation for small block sizes.\n• One instruction aids horizontal searching operations.\n• One instruction improves masked comparisons.\n• One instruction adds qword packed equality comparisons.\n• One instruction adds dword packing with unsigned saturation.\n\nThe SSE4.2 instructions operating on XMM registers include:\n• String and text processing that can take advantage of single-instruction multiple-data programming \n\ntechniques.\n• A SIMD integer instruction that enhances the capability of the 128-bit integer SIMD capability in SSE4.1.\n\n5.10 SSE4.1 INSTRUCTIONS\nSSE4.1 instructions can use an XMM register as a source or destination. Programming SSE4.1 is similar to \nprogramming 128-bit Integer SIMD and floating-point SIMD instructions in SSE/SSE2/SSE3/SSSE3. SSE4.1 does \nnot provide any 64-bit integer SIMD instructions operating on MMX registers. The sections that follow describe \neach subgroup.\n\n5.10.1 Dword Multiply Instructions \nPMULLD Returns four lower 32-bits of the 64-bit results of signed 32-bit integer multiplies.\nPMULDQ Returns two 64-bit signed result of signed 32-bit integer multiplies.\n\n5.10.2 Floating-Point Dot Product Instructions\nDPPD Perform double-precision dot product for up to 2 elements and broadcast.\nDPPS Perform single-precision dot products for up to 4 elements and broadcast.\n\n5.10.3 Streaming Load Hint Instruction\nMOVNTDQA Provides a non-temporal hint that can cause adjacent 16-byte items within an aligned 64-\n\nbyte region (a streaming line) to be fetched and held in a small set of temporary buffers \nVol. 1 5-25\n\n\n\nINSTRUCTION SET SUMMARY\n(“streaming load buffers”). Subsequent streaming loads to other aligned 16-byte items in \nthe same streaming line may be supplied from the streaming load buffer and can improve \nthroughput.\n\n5.10.4 Packed Blending Instructions\nBLENDPD Conditionally copies specified double-precision floating-point data elements in the source \n\noperand to the corresponding data elements in the destination, using an immediate byte \ncontrol. \n\nBLENDPS Conditionally copies specified single-precision floating-point data elements in the source \noperand to the corresponding data elements in the destination, using an immediate byte \ncontrol.\n\nBLENDVPD Conditionally copies specified double-precision floating-point data elements in the source \noperand to the corresponding data elements in the destination, using an implied mask. \n\nBLENDVPS Conditionally copies specified single-precision floating-point data elements ","extracted_metadata":{"pdf:docinfo:title":["Intel(R) 64 and IA-32 Architectures Software Developer's Manual, Combined Volumes: 1, 2ABCD, 3ABCD, and 4"],"xmp:CreatorTool":["FrameMaker 10.0.2"],"X-TIKA:EXCEPTION:write_limit_reached":["true"],"access_permission:can_print":["true"],"access_permission:can_modify":["true"],"X-TIKA:Parsed-By":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"xmp:MetadataDate":["2021-06-28T21:13:42Z"],"dcterms:created":["2021-06-28T12:21:04Z"],"pdf:hasXFA":["false"],"pdf:docinfo:creator":["Intel Corporation"],"Content-Type":["application/pdf"],"pdf:producer":["Acrobat Distiller 21.0 (Windows)"],"pdf:hasXMP":["true"],"xmp:CreateDate":["2021-06-28T12:21:04Z"],"xmpMM:DocumentID":["uuid:f01d258b-da68-460f-9726-fe37142e8506"],"pdf:docinfo:producer":["Acrobat Distiller 21.0 (Windows)"],"access_permission:extract_for_accessibility":["true"],"pdf:docinfo:created":["2021-06-28T12:21:04Z"],"Content-Length":["52916900"],"pdf:encrypted":["true"],"dc:title":["Intel(R) 64 and IA-32 Architectures Software Developer's Manual, Combined Volumes: 1, 2ABCD, 3ABCD, and 4"],"xmp:ModifyDate":["2021-06-28T21:13:42Z"],"dc:creator":["Intel Corporation"],"access_permission:can_print_degraded":["true"],"pdf:hasCollection":["false"],"xmpTPg:NPages":["4778"],"access_permission:extract_content":["true"],"pdf:docinfo:creator_tool":["FrameMaker 10.0.2"],"pdf:docinfo:modified":["2021-06-28T21:13:42Z"],"pdf:charsPerPage":["510","1733","463","1733","9242","10567","11233","11450","10983","11312","11084","10649","10927","10604","10692","10169","10690","8265","462","11000","10871","400","10551","10613","2871","22","2568","2086","4320","4108","4071","2397","2164","1328","2431","27","2904","3939","3523","2946","3163","2884","1996","3298","1608","3739","1888","2755","2537","3961","2333","1947","2884","2623","1122","2939","2511","1839","1659","1475","1543","1598","1464","1579","3697","4232","894","3924","2178","1567","3048","2091","4238","4063","1662","2404","4010","2111","3177","2618","3951","4067","2324","2695","2238","3044","3507","1847","1345","2434","1404","2274","1872","2517","994","2047","718","2211","2716","779","2163","3080","3046","3759","4081","3223","3769","3645","2693","4067","3550","123","2355","3483","3120","3424","2191","1387","2159","1864","1566","2461","1939","1494","2203","2452","1844","3039","2906","2598","2876","2865","2474","2853","3336","2820","2747"],"access_permission:modify_annotations":["true"],"access_permission:assemble_document":["true"],"dc:format":["application/pdf; version=1.6"],"resourceName":["Intel 64 and IA-32 Architectures Software Developer's Manual - Combined Volumes 1-4 - June 2021 (325462-sdm-vol-1-2abcd-3abcd).pdf"],"pdf:PDFVersion":["1.6"],"access_permission:fill_in_form":["true"],"pdf:unmappedUnicodeCharsPerPage":["0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0"],"dcterms:modified":["2021-06-28T21:13:42Z"],"pdf:hasMarkedContent":["false"],"X-TIKA:Parsed-By-Full-Set":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"]},"metadata_field_count":40,"attempts":1,"timestamp":1754064908.364074,"platform":"Linux","python_version":"3.13.5"},{"file_path":"test_documents/pdfs/Fundamentals_of_Deep_Learning_2014.pdf","file_size":56715281,"file_type":"pdf","category":"huge","framework":"extractous","iteration":1,"extraction_time":0.44991016387939453,"startup_time":null,"peak_memory_mb":429.578125,"avg_memory_mb":487.52890625,"peak_cpu_percent":90.9,"avg_cpu_percent":18.18,"total_io_mb":null,"status":"success","character_count":38842,"word_count":4872,"error_type":null,"error_message":null,"quality_metrics":{"char_count":38842,"word_count":4872,"sentence_count":285,"paragraph_count":535,"avg_word_length":5.3273809523809526,"avg_sentence_length":17.428070175438595,"extraction_completeness":1.0,"text_coherence":0.6666666666666666,"noise_ratio":0.40676175274187737,"gibberish_ratio":0.006369426751592357,"flesch_reading_ease":30.866139586346748,"gunning_fog_index":17.539937445140875,"has_proper_formatting":true,"maintains_line_breaks":true,"preserves_whitespace":true,"table_structure_preserved":true,"format_specific_score":0.49999999999999994,"expected_content_preserved":false,"has_encoding_issues":true,"has_ocr_artifacts":true,"preserves_pdf_formatting":true},"overall_quality_score":0.5373445602423348,"extracted_text":"\nFundamentals\t\r  of\t\r  Deep\t\r  Learning\t\r  \nof\t\r  Representa5ons\t\r  \n\n\t\r  \t\r  \nTel-­‐Aviv\t\r  University\t\r  \n\nDeep\t\r  Learning\t\r  Master\t\r  Class\t\r  \t\r  \n\t\r  \n\nYoshua\t\r  Bengio\t\r  \t\r  \nNovember\t\r  7,\t\r  2014,\t\r  Tel-­‐Aviv\t\r  \n\n\t\r  \n\n\n\nUltimate Goal \n• Understand\t\r  the\t\r  principles\t\r  \ngiving\t\r  rise\t\r  to\t\r  intelligence\t\r  \n\n\t\r  \n\n2\t\r  \n\n\n\nFocus \n• \t\r  Learning:\t\r  mathema5cal\t\r  \nand\t\r  computa5onal\t\r  \nprinciples\t\r  allowing\t\r  one\t\r  to\t\r  \nlearn\t\r  from\t\r  examples\t\r  in\t\r  \norder\t\r  to\t\r  acquire\t\r  knowledge\t\r  \t\r  \n\n\t\r  \n3\t\r  \n\n\n\nBreakthrough \n• \t\r  Deep\t\r  Learning:\t\r  machine\t\r  \nlearning\t\r  algorithms\t\r  inspired\t\r  \nby\t\r  brains,\t\r  based\t\r  on\t\r  learning\t\r  \nmul5ple\t\r  levels\t\r  of\t\r  \nrepresenta5on\t\r  /\t\r  abstrac5on.\t\r  \n\n\t\r  \n4\t\r  \n\n\n\nImpact \nDeep\t\r  learning\t\r  has\t\r  revolu5onized\t\r  \t\r  \n• Speech\t\r  recogni5on\t\r  \n• Object\t\r  recogni5on\t\r  \nMore\t\r  coming,\t\r  including\t\r  other\t\r  \nareas\t\r  of\t\r  computer\t\r  vision,\t\r  NLP,\t\r  \nmachine\t\r  transla5on,\t\r  dialogue,\t\r  \nreinforcement\t\r  learning…\t\r  \n\t\r  \n5\t\r  \n\n\n\nTechnical Goals Hierarchy \n\nTo\t\r  reach\t\r  AI:\t\r  \n•  Needs\t\r  knowledge\t\r  \n•  Needs\t\r  learning\t\r   \t\r   \t\r   \t\r   \t\r   \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \n\n(involves\t\r  priors\t\r  +\t\r  op#miza#on/search\t\r  +\t\r  efficient\t\r  computa#on)\t\r  \n\n•  Needs\t\r  generaliza5on\t\r   \t\r   \t\r   \t\r   \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \n(guessing\t\r  where\t\r  probability\t\r  mass\t\r  concentrates)\t\r  \n\n•  Needs\t\r  ways\t\r  to\t\r  fight\t\r  the\t\r  curse\t\r  of\t\r  dimensionality\t\r  \n(exponenHally\t\r  many\t\r  configuraHons\t\r  of\t\r  the\t\r  variables\t\r  to\t\r  consider)\t\r  \n\n•  Needs\t\r  disentangling\t\r  the\t\r  underlying\t\r  explanatory\t\r  factors\t\r  \n(making\t\r  sense\t\r  of\t\r  the\t\r  data)\t\r  \n\n6\t\r  \n\n\n\nEasy Learning \n\nlearned function: prediction = f(x)\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n*\n\ntrue unknown function\n\n= example (x,y)*\n\nx\n\ny\n\n\n\nML 101. What We Are Fighting Against:  \nThe Curse of Dimensionality \n\n\t\r  \t\r  \t\r  To\t\r  generalize\t\r  locally,\t\r  \nneed\t\r  representaHve\t\r  \nexamples\t\r  for\t\r  all\t\r  \nrelevant\t\r  variaHons!\t\r  \n\n\t\r  \n\n\n\nNot Dimensionality so much as \nNumber of Variations \n\n•  Theorem:\t\r  Gaussian\t\r  kernel\t\r  machines\t\r  need\t\r  at\t\r  least\t\r  k\t\r  examples\t\r  \nto\t\r  learn\t\r  a\t\r  funcHon\t\r  that\t\r  has\t\r  2k\t\r  zero-­‐crossings\t\r  along\t\r  some\t\r  line\t\r  \n\n\t\r  \n\t\r  \n\t\r  \n\t\r  \n\t\r  \n•  Theorem:\t\r  For\t\r  a\t\r  Gaussian\t\r  kernel\t\r  machine\t\r  to\t\r  learn\t\r  some\t\r  \n\nmaximally\t\r  varying\t\r  funcHons\t\r  \t\r  over\t\r  d\t\r  inputs\t\r  requires\t\r  O(2d)\t\r  \nexamples\t\r  \n\n\t\r  \n\n(Bengio, Dellalleau & Le Roux 2007) \n\n\n\n10\t\r  \n\nFor AI Tasks: Manifold structure \n\n•  examples\t\r  concentrate\t\r  near\t\r  a\t\r  lower\t\r  dimensional\t\r  “manifold\t\r  \n•  Evidence:\t\r  most\t\r  input\t\r  configura5ons\t\r  are\t\r  unlikely\t\r  \n\n\n\n•  Good\t\r  features\t\r  essenHal\t\r  for\t\r  successful\t\r  ML:\t\r  90%\t\r  of\t\r  effort\t\r  \n\n•  HandcraYing\t\r  features\t\r  vs\t\r  learning\t\r  them\t\r  \n\n•  Good\t\r  representaHon?\t\r  \n•  guesses\t\r  \n\t\r  \t\r  \t\r  \t\r  \t\r  the\t\r  features\t\r  /\t\r  factors\t\r  /\t\r  causes\t\r  \n\nRepresentation Learning \n\n11\t\r  \n\nraw\t\r  \ninput\t\r  \ndata\t\r  \n\nrepresented\t\r  \nby\t\r  chosen\t\r  \nfeatures\t\r  \n\nMACHINE\t\r  \nLEARNING\t\r  \t\r  \n\nrepresented\t\r  \nby\t\r  learned\t\r  \nfeatures\t\r  \n\n\n\nInput\n\nHand-\ndesigned \nprogram\n\nOutput\n\nInput\n\nHand-\ndesigned \nfeatures\n\nMapping \nfrom \n\nfeatures\n\nOutput\n\nInput\n\nFeatures\n\nMapping \nfrom \n\nfeatures\n\nOutput\n\nInput\n\nSimplest \nfeatures\n\nMapping \nfrom \n\nfeatures\n\nOutput\n\nMost \ncomplex \nfeatures\n\nRule-based\nsystems\n\nClassic\nmachine\nlearning\n\nRepresentation\nlearning\n\nDeep\nlearning\n\nAutomating \nFeature Discovery \n\n12\t\r  \n\n\n\nLearning multiple levels of \nrepresentation \nThere\t\r  is\t\r  theoreHcal\t\r  and\t\r  empirical\t\r  evidence\t\r  in\t\r  favor\t\r  of\t\r  \nmulHple\t\r  levels\t\r  of\t\r  representaHon\t\r  \n\n\t\r  Exponen5al\t\r  gain\t\r  for\t\r  some\t\r  families\t\r  of\t\r  func5ons\t\r  \n\nBiologically\t\r  inspired\t\r  learning\t\r  \n\nBrain\t\r  has\t\r  a\t\r  deep\t\r  architecture\t\r  \n\nCortex\t\r  seems\t\r  to\t\r  have\t\r  a\t\r  \t\r  \ngeneric\t\r  learning\t\r  algorithm\t\r  \t\r  \n\nHumans\t\r  first\t\r  learn\t\r  simpler\t\r  \t\r  \nconcepts\t\r  and\t\r  compose\t\r  them\t\r  \n\nIt\t\r  works!\t\r  Speech\t\r  +\t\r  vision\t\r  breakthroughs\t\r  \n13\t\r  \n\n\n\nVisualizing and Understanding Convolutional Networks\n\n(a) (b)\n\n(c) (d) (e)\n\nFigure 6. (a): 1st layer features without feature scale clipping. Note that one feature dominates. (b): 1st layer features\nfrom (Krizhevsky et al., 2012). (c): Our 1st layer features. The smaller stride (2 vs 4) and filter size (7x7 vs 11x11)\nresults in more distinctive features and fewer “dead” features. (d): Visualizations of 2nd layer features from (Krizhevsky\net al., 2012). (e): Visualizations of our 2nd layer features. These are cleaner, with no aliasing artifacts that are visible in\n(d).\n\nCar wheel\nRacer\nCab\nPolice van\n\n \n\nPomeranian\nTennis ball\nKeeshond\nPekinese\n\nAfghan hound\nGordon setter\nIrish setter\nMortarboard\nFur coat\nAcademic gown\nAustralian terrier\nIce lolly\nVizsla\nNeck brace\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n0.8\n\n0.9\n\n \n\n \n\n0.05\n\n0.1\n\n0.15\n\n0.2\n\n0.25\n\nTrue Label: Pomeranian\n\n(a) Input Image (b) Layer 5, strongest feature map\n(c) Layer 5, strongest\nfeature map projections\n\n(d) Classifier, probability \nof correct class \n\n(e) Classifier, most \nprobable class \n\nTrue Label: Car Wheel\n\nTrue Label: Afghan Hound\n\nFigure 7. Three test examples where we systematically cover up di↵erent portions of the scene with a gray square (1st\ncolumn) and see how the top (layer 5) feature maps ((b) & (c)) and classifier output ((d) & (e)) changes. (b): for each\nposition of the gray scale, we record the total activation in one layer 5 feature map (the one with the strongest response\nin the unoccluded image). (c): a visualization of this feature map projected down into the input image (black square),\nalong with visualizations of this map from other images. The first row example shows the strongest feature to be the\ndog’s face. When this is covered-up the activity in the feature map decreases (blue area in (b)). (d): a map of correct\nclass probability, as a function of the position of the gray square. E.g. when the dog’s face is obscured, the probability\nfor “pomeranian” drops significantly. (e): the most probable label as a function of occluder position. E.g. in the 1st row,\nfor most locations it is “pomeranian”, but if the dog’s face is obscured but not the ball, then it predicts “tennis ball”. In\nthe 2nd example, text on the car is the strongest feature in layer 5, but the classifier is most sensitive to the wheel. The\n3rd example contains multiple objects. The strongest feature in layer 5 picks out the faces, but the classifier is sensitive\nto the dog (blue region in (d)), since it uses multiple feature maps.\n\nVisualizing and Understanding Convolutional Networks\n\n(a) (b)\n\n(c) (d) (e)\n\nFigure 6. (a): 1st layer features without feature scale clipping. Note that one feature dominates. (b): 1st layer features\nfrom (Krizhevsky et al., 2012). (c): Our 1st layer features. The smaller stride (2 vs 4) and filter size (7x7 vs 11x11)\nresults in more distinctive features and fewer “dead” features. (d): Visualizations of 2nd layer features from (Krizhevsky\net al., 2012). (e): Visualizations of our 2nd layer features. These are cleaner, with no aliasing artifacts that are visible in\n(d).\n\nCar wheel\nRacer\nCab\nPolice van\n\n \n\nPomeranian\nTennis ball\nKeeshond\nPekinese\n\nAfghan hound\nGordon setter\nIrish setter\nMortarboard\nFur coat\nAcademic gown\nAustralian terrier\nIce lolly\nVizsla\nNeck brace\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n0.8\n\n0.9\n\n \n\n \n\n0.05\n\n0.1\n\n0.15\n\n0.2\n\n0.25\n\nTrue Label: Pomeranian\n\n(a) Input Image (b) Layer 5, strongest feature map\n(c) Layer 5, strongest\nfeature map projections\n\n(d) Classifier, probability \nof correct class \n\n(e) Classifier, most \nprobable class \n\nTrue Label: Car Wheel\n\nTrue Label: Afghan Hound\n\nFigure 7. Three test examples where we systematically cover up di↵erent portions of the scene with a gray square (1st\ncolumn) and see how the top (layer 5) feature maps ((b) & (c)) and classifier output ((d) & (e)) changes. (b): for each\nposition of the gray scale, we record the total activation in one layer 5 feature map (the one with the strongest response\nin the unoccluded image). (c): a visualization of this feature map projected down into the input image (black square),\nalong with visualizations of this map from other images. The first row example shows the strongest feature to be the\ndog’s face. When this is covered-up the activity in the feature map decreases (blue area in (b)). (d): a map of correct\nclass probability, as a function of the position of the gray square. E.g. when the dog’s face is obscured, the probability\nfor “pomeranian” drops significantly. (e): the most probable label as a function of occluder position. E.g. in the 1st row,\nfor most locations it is “pomeranian”, but if the dog’s face is obscured but not the ball, then it predicts “tennis ball”. In\nthe 2nd example, text on the car is the strongest feature in layer 5, but the classifier is most sensitive to the wheel. The\n3rd example contains multiple objects. The strongest feature in layer 5 picks out the faces, but the classifier is sensitive\nto the dog (blue region in (d)), since it uses multiple feature maps.\n\nVisualizing and Understanding Convolutional Networks\n\n(a) (b)\n\n(c) (d) (e)\n\nFigure 6. (a): 1st layer features without feature scale clipping. Note that one feature dominates. (b): 1st layer features\nfrom (Krizhevsky et al., 2012). (c): Our 1st layer features. The smaller stride (2 vs 4) and filter size (7x7 vs 11x11)\nresults in more distinctive features and fewer “dead” features. (d): Visualizations of 2nd layer features from (Krizhevsky\net al., 2012). (e): Visualizations of our 2nd layer features. These are cleaner, with no aliasing artifacts that are visible in\n(d).\n\nCar wheel\nRacer\nCab\nPolice van\n\n \n\nPomeranian\nTennis ball\nKeeshond\nPekinese\n\nAfghan hound\nGordon setter\nIrish setter\nMortarboard\nFur coat\nAcademic gown\nAustralian terrier\nIce lolly\nVizsla\nNeck brace\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n0.8\n\n0.9\n\n \n\n \n\n0.05\n\n0.1\n\n0.15\n\n0.2\n\n0.25\n\nTrue Label: Pomeranian\n\n(a) Input Image (b) Layer 5, strongest feature map\n(c) Layer 5, strongest\nfeature map projections\n\n(d) Classifier, probability \nof correct class \n\n(e) Classifier, most \nprobable class \n\nTrue Label: Car Wheel\n\nTrue Label: Afghan Hound\n\nFigure 7. Three test examples where we systematically cover up di↵erent portions of the scene with a gray square (1st\ncolumn) and see how the top (layer 5) feature maps ((b) & (c)) and classifier output ((d) & (e)) changes. (b): for each\nposition of the gray scale, we record the total activation in one layer 5 feature map (the one with the strongest response\nin the unoccluded image). (c): a visualization of this feature map projected down into the input image (black square),\nalong with visualizations of this map from other images. The first row example shows the strongest feature to be the\ndog’s face. When this is covered-up the activity in the feature map decreases (blue area in (b)). (d): a map of correct\nclass probability, as a function of the position of the gray square. E.g. when the dog’s face is obscured, the probability\nfor “pomeranian” drops significantly. (e): the most probable label as a function of occluder position. E.g. in the 1st row,\nfor most locations it is “pomeranian”, but if the dog’s face is obscured but not the ball, then it predicts “tennis ball”. In\nthe 2nd example, text on the car is the strongest feature in layer 5, but the classifier is most sensitive to the wheel. The\n3rd example contains multiple objects. The strongest feature in layer 5 picks out the faces, but the classifier is sensitive\nto the dog (blue region in (d)), since it uses multiple feature maps.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisible layer\n(input pixels)\n\n1st hidden layer\n(edges)\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\n2nd hidden layer\n(corners and\n\ncontours)\n\n3rd hidden layer\n(object parts)\n\nCAR PERSON ANIMAL Output\n(object identity)\n\nComposing Features on Features \n\n14\t\r  \n\nHigher-­‐level\t\r  features\t\r  \n\nare\t\r  defined\t\r  in\t\r  terms\t\r  of\t\r  \n\nlower-­‐level\t\r  \n\nfeatures\t\r  \n\n\n\nGoogle Image Search: \nDifferent object types represented in the \nsame space \n\nGoogle:\t\r  \nS.\t\r  Bengio,\t\r  J.\t\r  \nWeston\t\r  &\t\r  N.\t\r  \nUsunier\t\r  \n\n(IJCAI\t\r  2011,\t\r  \nNIPS’2010,\t\r  \nJMLR\t\r  2010,\t\r  \nMLJ\t\r  2010)\t\r  \n\n\n\nFollowing up on (Bengio et al NIPS’2000) \nNeural word embeddings - visualization \n\n16\t\r  \n\n\n\nNeural Language Models \n•  Meanings\t\r  and\t\r  their\t\r  combinaHon\t\r  all\t\r  ‘learned’\t\r  together.\t\r  \n\nMinimal\t\r  structure\t\r  imposed.\t\r  \t\r  \n\t\r  \n\t\r  \n\t\r  \n\t\r  \nPouHne\t\r   \t\r  is\t\r   \t\r  a\t\r   \t\r  curious\t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  _____________\t\r  .\t\r  \n\n\t\r  \n\na1\t\r  \na2\t\r  \na3\t\r  \na4\t\r  \n….\t\r  \n\t\r  \n\nb1\t\r  \nb2\t\r  \nb3\t\r  \nb4\t\r  \n….\t\r  \n\t\r  \n\nc1\t\r  \nc2\t\r  \nc3\t\r  \nc4\t\r  \n….\t\r  \n\t\r  \n\nd1\t\r  \nd2\t\r  \nd3\t\r  \nd4\t\r  \n….\t\r  \n\t\r  \n\n\t\r  representaHon\t\r  \nx1\t\r  x2\t\r  x3\t\r  x4\t\r  x5\t\r  …\t\r  \n\nA\t\r  guess\t\r  \n\nPARAMETERS\t\r  \n\nMORE\t\r  \nPARAMETERS\t\r  \n\n\n\nAnalogical Representations for Free \n(Mikolov et al, ICLR 2013) \n\n•  SemanHc\t\r  relaHons\t\r  appear\t\r  as\t\r  linear\t\r  relaHonships\t\r  in\t\r  the\t\r  space\t\r  of\t\r  \nlearned\t\r  representaHons\t\r  \n\n•  King\t\r  –\t\r  Queen\t\r  ≈\t\r  \t\r  Man\t\r  –\t\r  Woman\t\r  \n•  Paris\t\r  –\t\r  France\t\r  +\t\r  Italy\t\r  ≈\t\r  Rome\t\r  \n\n18\t\r  \n\nParis\t\r  \n\nFrance\t\r  \nItaly\t\r  \n\nRome\t\r  \n\n\n\nThe Next Challenge: Rich Semantic \nRepresentations for Word Sequences \n\n•  Impressive\t\r  progress\t\r  in\t\r  \ncapturing\t\r  word\t\r  semanHcs\t\r  \nEasier\t\r  learning:\t\r  non-­‐parametric\t\r  \n(table\t\r  look-­‐up)\t\r  \n\n•  OpHmizaHon\t\r  challenge\t\r  for\t\r  \nmapping\t\r  sequences\t\r  to\t\r  rich\t\r  &\t\r  \ncomplete\t\r  representaHons\t\r  \n\n•  Good\t\r  test\t\r  case:\t\r  machine\t\r  \ntranslaHon\t\r  \n\n19\t\r  \n\n\n\nBreakthroughs in Machine Translation \n\n•  (Cho\t\r  et\t\r  al,\t\r  EMNLP\t\r  2014)\t\r  Learning\t\r  Phrase\t\r  RepresentaHons\t\r  using\t\r  \nRNN\t\r  Encoder–Decoder\t\r  for\t\r  StaHsHcal\t\r  Machine\t\r  TranslaHon\t\r  \t\r  \n\n•  (Sutskever\t\r  et\t\r  al,\t\r  NIPS\t\r  2014)\t\r  Sequence\t\r  to\t\r  sequence\t\r  learning\t\r  with\t\r  \nneural\t\r  networks,\t\r  3\t\r  BLEU\t\r  points\t\r  improvement\t\r  for\t\r  English-­‐French\t\r  \n\n•  (Devlin\t\r  et\t\r  al,\t\r  ACL\t\r  2014)\t\r  Fast\t\r  and\t\r  Robust\t\r  Neural\t\r  Network\t\r  Joint\t\r  \nModels\t\r  for\t\r  StaHsHcal\t\r  Machine\t\r  TranslaHon\t\r  \t\r  \n\nBest\t\r  paper\t\r  award,\t\r  6\t\r  BLEU\t\r  points\t\r  improvement\t\r  for\t\r  Arabic-­‐English\t\r  \n\n20\t\r  \n\n�� �� ��\n\n��� �� ��\n\n�\n\n�\t�\n�\t�\n\n\r��\n�\t�\n\nFrench\t\r  \nencoder\t\r  \n\nEnglish\t\r  \ndecoder\t\r  \n\nFrench\t\r  sentence\t\r  \n\nEnglish\t\r  sentence\t\r  \n\nEnglish\t\r  \nencoder\t\r  \n\nEnglish\t\r  \ndecoder\t\r  \n\nEnglish\t\r  sentence\t\r  \n\nEnglish\t\r  sentence\t\r  \n\nFo\nr\t\r  b\n\nite\nxt\n\t\r  d\nat\na\t\r  \n\nFo\nr\t\r  u\n\nni\nlin\ngu\nal\n\t\r  d\nat\na\t\r  \n\n\n\nmain \n\nsubroutine1 includes \nsubsub1 code and \nsubsub2 code and \nsubsubsub1 code \n\n“Shallow” computer program \n\nsubroutine2 includes \nsubsub2 code and \nsubsub3 code and \nsubsubsub3 code and … \n\n\n\nmain \n\nsub1 sub2 sub3 \n\nsubsub1 subsub2 subsub3 \n\nsubsubsub1 subsubsub2 \nsubsubsub3 \n\n“Deep” computer program \n\n\n\nSharing Components in a Deep \nArchitecture \n\nSum-­‐product\t\r  \nnetwork\t\r  \n\nPolynomial\t\r  expressed\t\r  with\t\r  shared\t\r  components:\t\r  advantage\t\r  of\t\r  \ndepth\t\r  may\t\r  grow\t\r  exponenHally\t\r  \t\r  \n\t\r  \n\nTheorems\t\r  in\t\r  \t\r  \n(Bengio\t\r  &\t\r  Delalleau,\t\r  ALT\t\r  2011;\t\r  \nDelalleau\t\r  &\t\r  Bengio\t\r  NIPS\t\r  2011)\t\r  \n\n\n\nDeep Architectures are More \nExpressive \nTheoreHcal\t\r  arguments:\t\r  \n\n…\t\r  \n1\t\r   2\t\r   3\t\r   2n \n\n1\t\r   2\t\r   3\t\r  \n…\t\r  \n\nn\t\r  \n\n= universal approximator 2 layers of \nLogic gates \nFormal neurons \nRBF units \n\nTheorems on advantage of depth: \n(Hastad et al 86 & 91, Bengio et al 2007, \nBengio & Delalleau 2011, Braverman 2011, \nPascanu et al 2014) \n\nSome functions compactly \nrepresented with k layers may \nrequire exponential size with 2 \nlayers \n\nRBMs & auto-encoders = universal approximator \n\n\n\nNew theoretical result: \nExpressiveness of deep nets with \npiecewise-linear activation fns \n\n25\t\r  \n\n(Pascanu,\t\r  Montufar,\t\r  Cho\t\r  &\t\r  Bengio;\t\r  ICLR\t\r  2014)\t\r  \n\nDeeper\t\r  nets\t\r  with\t\r  recHfier/maxout\t\r  units\t\r  are\t\r  exponenHally\t\r  more\t\r  \nexpressive\t\r  than\t\r  shallow\t\r  ones\t\r  (1\t\r  hidden\t\r  layer)\t\r  because\t\r  they\t\r  can\t\r  split\t\r  \nthe\t\r  input\t\r  space\t\r  in\t\r  many\t\r  more\t\r  (not-­‐independent)\t\r  linear\t\r  regions,\t\r  with\t\r  \nconstraints,\t\r  e.g.,\t\r  with\t\r  abs\t\r  units,\t\r  each\t\r  unit\t\r  creates\t\r  mirror\t\r  responses,\t\r  \nfolding\t\r  the\t\r  input\t\r  space:\t\r  \t\r  \n\n\t\r  \n\n\t\r  \n\n\n\n•  Clustering,\t\r  Nearest-­‐\nNeighbors,\t\r  RBF\t\r  SVMs,\t\r  local\t\r  \nnon-­‐parametric\t\r  density\t\r  \nesHmaHon\t\r  &\t\r  predicHon,\t\r  \ndecision\t\r  trees,\t\r  etc.\t\r  \n\n•  Parameters\t\r  for\t\r  each\t\r  \ndisHnguishable\t\r  region\t\r  \n\n•  #\t\r  of\t\r  dis5nguishable\t\r  regions\t\r  \nis\t\r  linear\t\r  in\t\r  #\t\r  of\t\r  parameters\t\r  \n\nNon-distributed representations \n\nClustering\t\r  \n\n26\t\r  \n\nà\t\r  No\t\r  non-­‐trivial\t\r  generalizaHon\t\r  to\t\r  regions\t\r  without\t\r  examples\t\r  \n\n\n\n•  Factor\t\r  models,\t\r  PCA,\t\r  RBMs,\t\r  \nNeural\t\r  Nets,\t\r  Sparse\t\r  Coding,\t\r  \nDeep\t\r  Learning,\t\r  etc.\t\r  \n\n•  Each\t\r  parameter\t\r  influences\t\r  \nmany\t\r  regions,\t\r  not\t\r  just\t\r  local\t\r  \nneighbors\t\r  \n\n•  #\t\r  of\t\r  dis5nguishable\t\r  regions\t\r  \ngrows\t\r  almost\t\r  exponen5ally\t\r  \nwith\t\r  #\t\r  of\t\r  parameters\t\r  \n\n•  GENERALIZE\t\r  NON-­‐LOCALLY\t\r  \nTO\t\r  NEVER-­‐SEEN\t\r  REGIONS\t\r  \n\nThe need for distributed \nrepresentations \n\nMulH-­‐\t\r  \nClustering\t\r  \n\n27\t\r  \n\nC1\t\r   C2\t\r   C3\t\r  \n\ninput\t\r  \n\nNon-­‐mutually\t\r  \nexclusive\t\r  features/\navributes\t\r  create\t\r  a\t\r  \ncombinatorially\t\r  large\t\r  \nset\t\r  of\t\r  disHnguiable\t\r  \nconfiguraHons\t\r  \n\n\n\nThe need for distributed \nrepresentations \n\nMulH-­‐\t\r  \nClustering\t\r  Clustering\t\r  \n\n28\t\r  \n\nLearning\t\r  a\t\r  set\t\r  of\t\r  features\t\r  that\t\r  are\t\r  not\t\r  mutually\t\r  exclusive\t\r  \ncan\t\r  be\t\r  exponenHally\t\r  more\t\r  staHsHcally\t\r  efficient\t\r  than\t\r  \nhaving\t\r  nearest-­‐neighbor-­‐like\t\r  or\t\r  clustering-­‐like\t\r  models\t\r  \n\n\n\nMontréal \nToronto \n\nBengio \n\nHinton \nLe Cun \n\nMajor Breakthrough in 2006 \n\n•  Ability\t\r  to\t\r  train\t\r  deep\t\r  architectures\t\r  by\t\r  \nusing\t\r  layer-­‐wise\t\r  unsupervised\t\r  \nlearning,\t\r  whereas\t\r  previous\t\r  purely\t\r  \nsupervised\t\r  avempts\t\r  had\t\r  failed\t\r  \n\n•  Unsupervised\t\r  feature\t\r  learners:\t\r  \n•  RBMs\t\r  \n•  Auto-­‐encoder\t\r  variants\t\r  \n•  Sparse\t\r  coding\t\r  variants\t\r  \n\nNew York \n29\t\r   (Bengio\t\r  &\t\r  LeCun\t\r  2007),\t\r  Scaling\t\r  Learning\t\r  Algorithms\t\r  towards\t\r  AI\t\r  \t\r  \n\n\n\nIssues with Back-Prop \n•  In\t\r  very\t\r  deep\t\r  nets\t\r  or\t\r  recurrent\t\r  nets\t\r  with\t\r  many\t\r  steps,\t\r  \nnon-­‐lineariHes\t\r  compose\t\r  and\t\r  yield\t\r  sharp\t\r  non-­‐linearity\t\r  \nà\t\r  gradients\t\r  vanish\t\r  or\t\r  explode\t\r  \n\n•  Training\t\r  deeper\t\r  nets:\t\r  harder\t\r  opHmizaHon\t\r  \n•  In\t\r  the\t\r  extreme\t\r  of\t\r  non-­‐linearity:\t\r  discrete\t\r  funcHons,\t\r  \ncan’t\t\r  use\t\r  back-­‐prop\t\r  \n\n•  Not\t\r  biologically\t\r  plausible?\t\r  \n\n¢\t\r   =\t\r  ¢\t\r   …\t\r  \n\n\n\n31\t\r  \n\nEffect of Initial Conditions \nin Deep Nets \n\n•  (Erhan\t\r  et\t\r  al\t\r  2009,\t\r  JMLR)\t\r  \n•  Supervised\t\r  deep\t\r  net\t\r  with\t\r  vs\t\r  w/o\t\r  \t\r  \n\t\r  \t\r  unsupervised\t\r  pre-­‐training\t\r  èvery\t\r  different\t\r  minima\t\r  \n\nNeural\t\r  net\t\r  trajectories\t\r  in\t\r  \t\r  \nfuncHon\t\r  space,\t\r  visualized\t\r  by\t\r  \nt-­‐SNE\t\r  \n\nNo\t\r  two\t\r  training\t\r  trajectories\t\r  \nend\t\r  up\t\r  in\t\r  the\t\r  same\t\r  place\t\r  à\t\r  \nhuge\t\r  number\t\r  of\t\r  effecHve\t\r  \nlocal\t\r  minima\t\r  \n\nw/o\t\r  unsupervised\t\r  pre-­‐training\t\r  \n\nwith\t\r  unsupervised\t\r  pre-­‐training\t\r  \n\n\n\nOrder & Selection of Examples Matters \n(Bengio,\t\r  Louradour,\t\r  Collobert\t\r  &\t\r  Weston,\t\r  ICML’2009)\t\r  \t\r  \t\r  \t\r  A\t\r  \n\n• Curriculum\t\r  learning\t\r  \t\r  \n•  (Bengio\t\r  et\t\r  al\t\r  2009,\t\r  Krueger\t\r  &\t\r  Dayan\t\r  2009)\t\r  \t\r  \t\r  \n\n•  Start\t\r  with\t\r  easier\t\r  examples\t\r  \n\n•  Faster\t\r  convergence\t\r  to\t\r  a\t\r  bever\t\r  local\t\r  \nminimum\t\r  in\t\r  deep\t\r  architectures\t\r  \n\n!\"#$%\n\n&%\n\n&\"!$%\n\n&\"$%\n\n'% $''% ('''% ($''%\n\n!\"\n#\n$%\n&\n'\n(\n)'\n*\n+\n,)\n-\n\"\n%.\n/)\n\n01!!1\"'))\n\n23.&,*4)\n\n)*++,)*-*.%\n\n/01)*++,)*-*.%\n\n!\"#$%\n\n&%\n\n&\"!$%\n\n&\"$%\n\n'% $''% ('''% ($''%\n\n!\"\n#\n$%\n&\n'\n(\n)'\n*\n+\n,)\n-\n\"\n%.\n/)\n\n01!!1\"'))\n\n23.&,*4)\n\n)*++,)*-*.%\n\n/01)*++,)*-*.%\n\n32\t\r  \n\n\n\nCurriculum Learning \n\nGuided learning helps training humans and animals  \n\n Shaping \n\n \n\nStart from simpler examples / easier tasks   (Piaget 1952, Skinner 1958) \n\nEducation \n\n \n\n\n\nContinuation Methods \n\nTrack local minima \n\n \n\nFinal solution \n\n \n\nEasy to find minimum \n\n \n\n\n\nGuided Training, Intermediate \nConcepts \n\n•  In\t\r  (Gulcehre\t\r  &\t\r  Bengio\t\r  ICLR’2013)\t\r  we\t\r  set\t\r  up\t\r  a\t\r  task\t\r  that\t\r  seems\t\r  \nalmost\t\r  impossible\t\r  to\t\r  learn\t\r  by\t\r  shallow\t\r  nets,\t\r  deep\t\r  nets,\t\r  SVMs,\t\r  \ntrees,\t\r  boosHng\t\r  etc\t\r  \n\n•  Breaking\t\r  the\t\r  problem\t\r  in\t\r  two\t\r  sub-­‐problems\t\r  and\t\r  pre-­‐training\t\r  \neach\t\r  module\t\r  separately,\t\r  then\t\r  fine-­‐tuning,\t\r  nails\t\r  it\t\r  \n\n•  Need\t\r  prior\t\r  knowledge\t\r  to\t\r  decompose\t\r  the\t\r  task\t\r  \n•  Guided\t\r  pre-­‐training\t\r  allows\t\r  to\t\r  find\t\r  much\t\r  bever\t\r  soluHons,\t\r  escape\t\r  \n\neffecHve\t\r  local\t\r  minima\t\r  \n\n35\t\r  \n\nHINTS\t\r  \n\n\n\n•  TradiHonal\t\r  thinking\t\r  is\t\r  that\t\r  major\t\r  obstacle\t\r  for\t\r  training\t\r  deep\t\r  nets\t\r  is\t\r  \nlocal\t\r  minima\t\r  \n\n•  TheoreHcal\t\r  and\t\r  empirical\t\r  evidence\t\r  suggest\t\r  instead\t\r  that\t\r  saddle\t\r  \npoints\t\r  are\t\r  exponenHally\t\r  more\t\r  prevalent\t\r  criHcal\t\r  points,\t\r  and\t\r  local\t\r  \nminima\t\r  tend\t\r  to\t\r  be\t\r  of\t\r  cost\t\r  near\t\r  that\t\r  of\t\r  global\t\r  minimum\t\r  \n\n•  (Pascanu,\t\r  Dauphin,\t\r  Ganguli,\t\r  Bengio\t\r  2014):\t\r  On\t\r  the\t\r  saddle\t\r  point\t\r  \nproblem\t\r  for\t\r  non-­‐convex\t\r  opNmizaNon.\t\r  \t\r  \t\r  \n\nSaddle Points, not Local Minima \n\n36\t\r  \n\n\n\nCIFAR\t\r  MNIST\t\r  \n\nSaddle Points \n\n•  Local\t\r  minima\t\r  dominate\t\r  in\t\r  low-­‐D,\t\r  but\t\r  \nsaddle\t\r  points\t\r  dominate\t\r  in\t\r  high-­‐D\t\r  \n\n•  Most\t\r  local\t\r  minima\t\r  are\t\r  close\t\r  to\t\r  the\t\r  \nbovom\t\r  (global\t\r  minimum\t\r  error)\t\r  \n\n37\t\r  \n\n\n\nIt is possible to escape saddle points! \n\n•  NIPS’2014\t\r  paper,\t\r  Dauphin\t\r  et\t\r  al.\t\r  \n•  More\t\r  work\t\r  is\t\r  ongoing\t\r  to\t\r  make\t\r  it\t\r  online\t\r  \n•  Challenge:\t\r  track\t\r  the\t\r  most\t\r  negaHve\t\r  eigenvector,\t\r  which\t\r  is\t\r  easy\t\r  in\t\r  \n\nbatch\t\r  mode\t\r  with\t\r  power\t\r  method,\t\r  if\t\r  we\t\r  also\t\r  track\t\r  most\t\r  posiHve,\t\r  \nvia\t\r  \t\r  \t\r  \n\n38\t\r  \n\nv  (H � �I)v\n\n\n\nSaddle-Free Optimization  \n(Dauphin et al NIPS’2014) \n\n•  Replace\t\r  eigenvalues\t\r  λ\t\r  of\t\r  Hessian\t\r  by\t\r  |λ|\t\r  \n\n39\t\r  \n\n\n\nDeep Supervised Neural Nets \n\n•  Now\t\r  can\t\r  train\t\r  them\t\r  even\t\r  without\t\r  \nunsupervised\t\r  pre-­‐training:\t\r  \t\r  \nbe]er\t\r  ini5aliza5on\t\r  and\t\r  non-­‐\nlineari5es\t\r  (recHfiers,\t\r  maxout),\t\r  \ngeneralize\t\r  well\t\r  with\t\r  large\t\r  labeled\t\r  \nsets\t\r  and\t\r  regularizers\t\r  (dropout)\t\r  \n\n•  Unsupervised\t\r  pre-­‐training:\t\r  \t\r  \nrare\t\r  classes,\t\r  transfer,\t\r  smaller\t\r  \nlabeled\t\r  sets,\t\r  or\t\r  as\t\r  extra\t\r  \nregularizer.\t\r  \n\n40\t\r  \n\n\n\nWhy Unsupervised Learning? \n\n•  Recent\t\r  progress\t\r  mostly\t\r  in\t\r  supervised\t\r  DL\t\r  \n•  \t\r  \t\r  \t\r  \t\r  real\t\r  challenges\t\r  for\t\r  unsupervised\t\r  DL\t\r  \n•  PotenHal\t\r  benefits:\t\r  \n\n•  Exploit\t\r  tons\t\r  of\t\r  unlabeled\t\r  data\t\r  \n•  Answer\t\r  new\t\r  quesHons\t\r  about\t\r  the\t\r  variables\t\r  observed\t\r  \n•  Regularizer\t\r  –\t\r  transfer\t\r  learning\t\r  –\t\r  domain\t\r  adaptaHon\t\r  \n•  Easier\t\r  opHmizaHon\t\r  (local\t\r  training\t\r  signal)\t\r  \n•  Structured\t\r  outputs\t\r  \n\n41\t\r  \n\nE\t\r  \n\n\n\nInvariance and Disentangling \n\n•  Invariant\t\r  features\t\r  \n\n•  Which\t\r  invariances?\t\r  \n\n•  AlternaHve:\t\r  learning\t\r  to\t\r  disentangle\t\r  factors\t\r  \n\n•  Good\t\r  disentangling\t\r  à\t\r  \t\r  \n\t\r  avoid\t\r  the\t\r  curse\t\r  of\t\r  dimensionality\t\r  \n\n42\t\r  \n\n\n\nEmergence of Disentangling \n•  (Goodfellow\t\r  et\t\r  al.\t\r  2009):\t\r  sparse\t\r  auto-­‐encoders\t\r  trained\t\r  \n\non\t\r  images\t\r  \t\r  \n•  some\t\r  higher-­‐level\t\r  features\t\r  more\t\r  invariant\t\r  to\t\r  \ngeometric\t\r  factors\t\r  of\t\r  variaHon\t\r  \t\r  \n\n•  (Glorot\t\r  et\t\r  al.\t\r  2011):\t\r  sparse\t\r  recHfied\t\r  denoising\t\r  auto-­‐\nencoders\t\r  trained\t\r  on\t\r  bags\t\r  of\t\r  words\t\r  for\t\r  senHment\t\r  \nanalysis\t\r  \n•  different\t\r  features\t\r  specialize\t\r  on\t\r  different\t\r  aspects\t\r  \n(domain,\t\r  senHment)\t\r  \n\n43\t\r  \n\nWHY?\t\r  \n\n\n\nHow do humans generalize \nfrom very few examples? \n\n44\t\r  \n\n•  They\t\r  transfer\t\r  knowledge\t\r  from\t\r  previous\t\r  learning:\t\r  \n•  RepresentaHons\t\r  \n\n•  Explanatory\t\r  factors\t\r  \n\n•  Previous\t\r  learning\t\r  from:\t\r  unlabeled\t\r  data\t\r  \t\r  \n\n\t\r   \t\r   \t\r  \t\r  \t\r  \t\r  \t\r   \t\r  +\t\r  labels\t\r  for\t\r  other\t\r  tasks\t\r  \n\n•  Prior:\t\r  shared\t\r  underlying\t\r  explanatory\t\r  factors,\t\r  in\t\r  \npar5cular\t\r  between\t\r  P(x)\t\r  and\t\r  P(Y|x)\t\r  \t\r  \n\n\t\r  \n\n\n\nRaw\t\r  data\t\r  \n1\t\r  layer\t\r   2\t\r  layers\t\r  \n\n4\t\r  layers\t\r  \n3\t\r  layers\t\r  \n\nICML’2011\t\r  \nworkshop\t\r  on\t\r  \nUnsup.\t\r  &\t\r  \nTransfer\t\r  Learning\t\r  \n\nNIPS’2011\t\r  \nTransfer\t\r  \nLearning\t\r  \nChallenge\t\r  \t\r  \nPaper:\t\r  \nICML’2012\t\r  \n\nUnsupervised and Transfer Learning \nChallenge + Transfer Learning \nChallenge: Deep Learning 1st Place \n\n\n\n46\t\r  \n\nAuto-Encoders Learn Salient \nVariations, like a non-linear PCA \n\n•  Minimizing\t\r  reconstrucHon\t\r  error\t\r  forces\t\r  to\t\r  \nkeep\t\r  variaHons\t\r  along\t\r  manifold.\t\r  \n\n•  Regularizer\t\r  wants\t\r  to\t\r  throw\t\r  away\t\r  all\t\r  \nvariaHons.\t\r  \n\n•  With\t\r  both:\t\r  keep\t\r  ONLY\t\r  sensiHvity\t\r  to\t\r  \nvariaHons\t\r  ON\t\r  the\t\r  manifold.\t\r  \n\n\n\nSpace-Filling in Representation-Space \n•  Deeper\t\r  representa5ons\t\r  !\t\r  abstrac5ons\t\r  !\t\r  disentangling\t\r  \n•  Manifolds\t\r  are\t\r  expanded\t\r  and\t\r  fla]ened\t\r  \n\nLinear\t\r  interpolaHon\t\r  at\t\r  layer\t\r  2\t\r  \n\nLinear\t\r  interpolaHon\t\r  at\t\r  layer\t\r  1\t\r  \n\n3’s\t\r  manifold\t\r  \n\n9’s\t\r  manifold\t\r  \n\nLinear\t\r  interpolaHon\t\r  in\t\r  pixel\t\r  space\t\r  \n\nPixel\t\r  space\t\r  \n\n9’s\t\r  manifold\t\r   3’s\t\r  manifold\t\r  \n\nRepresentaHon\t\r  space\t\r  \n\n9’s\t\r  manifold\t\r   3’s\t\r  manifold\t\r  \n\nX-­‐space\t\r  \n\nH-­‐space\t\r  \n\n\n\nWhy Unsupervised Representation \nLearning? Because of Causality. \n\n•  If\t\r  Ys\t\r  of\t\r  interest\t\r  are\t\r  among\t\r  the\t\r  causal\t\r  factors\t\r  of\t\r  X,\t\r  then\t\r  \n\nis\t\r  Hed\t\r  to\t\r  P(X)\t\r  and\t\r  P(X|Y),\t\r  and\t\r  P(X)\t\r  is\t\r  defined\t\r  in\t\r  terms\t\r  of\t\r  P(X|Y),\t\r  i.e.\t\r  \n•  The\t\r  best\t\r  possible\t\r  model\t\r  of\t\r  X\t\r  (unsupervised\t\r  learning)\t\r  MUST\t\r  \n\ninvolve\t\r  Y\t\r  as\t\r  a\t\r  latent\t\r  factor,\t\r  implicitly\t\r  or\t\r  explicitly.\t\r  \n•  RepresentaHon\t\r  learning\t\r  SEEKS\t\r  the\t\r  latent\t\r  variables\t\r  H\t\r  that\t\r  \n\nexplain\t\r  the\t\r  variaHons\t\r  of\t\r  X,\t\r  making\t\r  it\t\r  likely\t\r  to\t\r  also\t\r  uncover\t\r  Y.\t\r  \n•  We\t\r  need\t\r  3\t\r  pieces:\t\r  \t\r  \n\n•  latent\t\r  variable\t\r  model\t\r  P(H),\t\r  \t\r  \n•  generaHve\t\r  decoder\t\r  P(X|H),\t\r  and\t\r  \t\r  \n•  approximate\t\r  inference\t\r  encoder\t\r  Q(H|X).\t\r  \n\n\t\r  \t\r  \n48\t\r  \n\nP (Y |X) =\nP (X|Y )P (Y )\n\nP (X)\n\n\n\nChallenges with Graphical Models with \nLatent Variables \n\n•  Latent\t\r  variables\t\r  help\t\r  to\t\r  avoid\t\r  the\t\r  curse\t\r  of\t\r  dimensionality\t\r  \n\n•  But\t\r  they\t\r  come\t\r  with\t\r  intractabiliHes\t\r  due\t\r  to\t\r  sums\t\r  over\t\r  an\t\r  \nexponenHally\t\r  large\t\r  number\t\r  of\t\r  terms\t\r  (marginalizaHon):\t\r  \n\n•  Exact\t\r  inference\t\r  (P(h|x))\t\r  is\t\r  typically\t\r  intractable\t\r  \n\n• With\t\r  undirected\t\r  models,\t\r  the\t\r  normalizaHon\t\r  constant\t\r  and\t\r  its\t\r  \ngradient\t\r  are\t\r  intractable\t\r  \n\n\t\r  \n\n49\t\r  \n\n\n\nIssues with Boltzmann Machines \n•  Sampling\t\r  from\t\r  the\t\r  MCMC\t\r  of\t\r  the\t\r  model\t\r  is\t\r  required\t\r  in\t\r  the\t\r  inner\t\r  \n\nloop\t\r  of\t\r  training\t\r  \n•  As\t\r  the\t\r  model\t\r  gets\t\r  sharper,\t\r  mixing\t\r  between\t\r  well-­‐separated\t\r  \n\nmodes\t\r  stalls\t\r  \n\n50\t\r  \n\nTraining\t\r  updates\t\r  \n\nMixing\t\r  \nvicious\t\r  circle\t\r  \n\n\n\nparameters\t\r  \n\ngenerated\t\r  \nsamples\t\r  \n\nBypassing Normalization Constants \nwith Generative Black Boxes \n•  Instead\t\r  of\t\r  parametrizing\t\r  p(x),\t\r  \n\nparametrize\t\r  a\t\r  machine\t\r  which\t\r  \ngenerates\t\r  samples\t\r  \n\n•  \t\r  (Goodfellow\t\r  et\t\r  al,\t\r  NIPS\t\r  2014,\t\r  \nGeneraHve\t\r  adversarial\t\r  nets)\t\r  for\t\r  the\t\r  \ncase\t\r  of\t\r  ancestral\t\r  sampling\t\r  in\t\r  a\t\r  deep\t\r  \ngeneraHve\t\r  net.\t\r  VariaHonal\t\r  auto-­‐\nencoders\t\r  are\t\r  closely\t\r  related.\t\r  \n\n•  (Bengio\t\r  et\t\r  al,\t\r  ICML\t\r  2014,\t\r  GeneraHve\t\r  \nStochasHc\t\r  Networks),\t\r  learning\t\r  the\t\r  \ntransiHon\t\r  operator\t\r  of\t\r  a\t\r  Markov\t\r  chain\t\r  \nthat\t\r  generates\t\r  the\t\r  data.\t\r  \n\n51\t\r  \n\nrandom\t\r  \nnumbers\t\r  \n\ngenerated\t\r  \nsamples\t\r  \n\nrandom\t\r  \nnumbers\t\r  \n\nprevious\t\r  state\t\r  \n\n\t\r  next\t\r  state\t\r  \n\ngenerated\t\r  \nsamples\t\r  \n\ngenerated\t\r  \nsamples\t\r  \n\nparameters\t\r  \n\n\n\nAdversarial Nets \nmovies \n\nEach\t\r  movie\t\r  =\t\r  linear\t\r  interpolaHon\t\r  \nbetween\t\r  2\t\r  random\t\r  samples\t\r  in\t\r  \nrepresentaHon-­‐space\t\r  \n\n52\t\r  \n\n\n\nAncestral Sampling with Learned \nApproximate Inference \n\n•  Helmholtz\t\r  machine\t\r  &\t\r  Wake-­‐Sleep\t\r  algorithm\t\r  \n•  (Dayan,\t\r  Hinton,\t\r  Neal,\t\r  Zemel\t\r  1995)\t\r  \n\n•  VariaHonal\t\r  Auto-­‐Encoders\t\r  \n•  (Kingma\t\r  &\t\r  Welling\t\r  2013,\t\r  ICLR\t\r  2014)\t\r  \n•  (Gregor\t\r  et\t\r  al\t\r  ICML\t\r  2014)\t\r  \n•  (Rezende\t\r  et\t\r  al\t\r  ICML\t\r  2014)\t\r  \n•  (Mnih\t\r  &\t\r  Gregor\t\r  ICML\t\r  2014)\t\r  \n\n•  Reweighted\t\r  Wake-­‐Sleep\t\r  (Bornschein\t\r  &\t\r  Bengio\t\r  2014)\t\r  \n•  Target\t\r  PropagaHon\t\r  (Bengio\t\r  2014)\t\r  \n•  Deep\t\r  Directed\t\r  GeneraHve\t\r  Auto-­‐Encoders\t\r  (Ozair\t\r  &\t\r  Bengio\t\r  2014)\t\r  \n•  NICE\t\r  (Dinh\t\r  et\t\r  al\t\r  2014)\t\r  \n53\t\r  \n\nTrained\t\r  approximate\t\r  \ninference\t\r  \n\nvisible\t\r  \n\nlatent\t\r  \n\nP\t\r  Q\t\r  \n\n\n\nExtracting Structure By Gradual \nDisentangling and Manifold Unfolding \n(Bengio 2014, arXiv 1407.7906)  \nEach\t\r  level\t\r  transforms\t\r  the\t\r  \ndata\t\r  into\t\r  a\t\r  representaHon\t\r  in\t\r  \nwhich\t\r  it\t\r  is\t\r  easier\t\r  to\t\r  model,\t\r  \nunfolding\t\r  it\t\r  more,\t\r  \ncontracHng\t\r  the\t\r  noise\t\r  \ndimensions\t\r  and\t\r  mapping\t\r  the\t\r  \nsignal\t\r  dimensions\t\r  to\t\r  a\t\r  \nfactorized\t\r  (uniform-­‐like)\t\r  \ndistribuHon.\t\r  \n\t\r  \n\t\r  \nfor\t\r  each\t\r  intermediate\t\r  level\t\r  h\t\r  \n\n54\t\r  \n\nQ(x)\t\r  \n\nf1\t\r  \ng1\t\r  \n\nQ(h1)\t\r  \nP(h1)\t\r  \n\nfL\t\r   gL\t\r  \n\nQ(hL)\t\r  \nP(hL)\t\r  no\n\nise\n\t\r  \n\nsignal\t\r  \n\n…\t\r  \n\nP(x|h1)\t\r  \nQ(h1|x)\t\r  \n\nQ(h2|h1)\t\r   f2\t\r   P(h2|h1)\t\r  g2\t\r  \n\nminKL(Q(x, h)||P (x, h))\n\n\n\nNICE: \nNonlinear Independent Component Estimation \n\n•  Perfect\t\r  auto-­‐encoder\t\r  g=f-­‐1\t\r  \n•  No\t\r  need\t\r  for\t\r  reconstrucHon\t\r  error\t\r  \n•  DeterminisHc\t\r  encoder,\t\r  no\t\r  need\t\r  for\t\r  entropy\t\r  term\t\r  \n•  But\t\r  need\t\r  to\t\r  correct\t\r  for\t\r  density\t\r  scaling\t\r  \n\n•  Exact\t\r  tractable\t\r  likelihood\t\r  \n\n55\t\r  \n\n(Dinh,\t\r  Krueger\t\r  &\t\r  Bengio\t\r  2014,\t\r  arxiv\t\r  1410.8516)\t\r  \n\nlog pX(x) = log pH(f(x)) + log\n\n����det\n@f(x)\n\n@x\n\n����\n\t\r  \nfactorized\t\r  prior\t\r  \n\nPH(h) =\nY\n\ni\n\nPHi(hi)\n\nf\t\r   g=f-­‐1\t\r  \n\nQ(h)\t\r  \n\nP(h)\t\r  \n\n\n\nNICE \nInpaiting \nMovies \n(not \nconv.) \n\n56\t\r  \n\n\n\nUnfolding AND Disentangling \n\n•  The\t\r  previous\t\r  criteria\t\r  may\t\r  allow\t\r  us\t\r  to\t\r  unfold\t\r  and\t\r  flaven\t\r  the\t\r  data\t\r  \nmanifold\t\r  \n\n•  What\t\r  about\t\r  disentangling\t\r  the\t\r  underflying\t\r  factors\t\r  of\t\r  variaHon?\t\r  \n•  Is\t\r  it\t\r  enough\t\r  to\t\r  assume\t\r  they\t\r  are\t\r  marginally\t\r  independent?\t\r  \n•  They\t\r  are\t\r  not\t\r  condiHonally\t\r  independent…\t\r  \n•  There\t\r  may\t\r  be\t\r  intrinsinc\t\r  ambiguiHes\t\r  what\t\r  makes\t\r  the\t\r  \n\ndisentangling\t\r  job\t\r  impossible\t\r  à\t\r  need\t\r  more\t\r  prior\t\r  knowledge.\t\r  \n\n57\t\r  \n\n\n\nBroad Priors as Hints to Disentangle \nthe Factors of Variation \n\n•  MulNple\t\r  factors:\t\r  distributed\t\r  representaHons\t\r  \n•  MulHple\t\r  levels\t\r  of\t\r  abstracHon:\t\r  depth\t\r  \n•  Semi-­‐supervised\t\r  learning:\t\r  Y\t\r  is\t\r  one\t\r  of\t\r  the\t\r  factors\t\r  explaining\t\r  X\t\r  \n•  MulN-­‐task\t\r  learning:\t\r  different\t\r  tasks\t\r  share\t\r  some\t\r  factors\t\r  \n•  Manifold\t\r  hypothesis:\t\r  probability\t\r  mass\t\r  concentraHon\t\r  \n•  Natural\t\r  clustering:\t\r  class\t\r  =\t\r  manifold,\t\r  well-­‐separated\t\r  manifolds\t\r  \n•  Temporal\t\r  and\t\r  spaHal\t\r  coherence\t\r  \n•  Sparsity:\t\r  most\t\r  factors\t\r  irrelevant\t\r  for\t\r  parHcular\t\r  X\t\r  \n•  Simplicity\t\r  of\t\r  factor\t\r  dependencies\t\r  (in\t\r  the\t\r  right\t\r  representaHon)\t\r  \n\n58\t\r  \n\n\n\nLearning Multiple Levels of \nAbstraction \n\n•  The\t\r  big\t\r  payoff\t\r  of\t\r  deep\t\r  learning\t\r  is\t\r  to\t\r  allow\t\r  learning\t\r  \nhigher\t\r  levels\t\r  of\t\r  abstracHon\t\r  \n\n•  Higher-­‐level\t\r  abstracHons\t\r  disentangle\t\r  the\t\r  factors\t\r  of\t\r  \nvariaHon,\t\r  which\t\r  allows\t\r  much\t\r  easier\t\r  generalizaHon\t\r  and\t\r  \ntransfer\t\r  \n\n59\t\r  \n\n\n\nConclusions \n•  Deep\t\r  Learning\t\r  has\t\r  become\t\r  a\t\r  crucial\t\r  machine\t\r  learning\t\r  tool:\t\r  \t\r  \n\n•  Int.\t\r  Conf.\t\r  on\t\r  Learning\t\r  RepresentaHon\t\r  2013\t\r  &\t\r  2014\t\r  a\t\r  huge\t\r  success!\t\r  \nConference\t\r  &\t\r  workshop\t\r  tracks,\t\r  open\t\r  to\t\r  new\t\r  ideas\t\r  J\t\r  \n\n•  Industrial\t\r  applicaHons\t\r  (Google,\t\r  IBM,\t\r  MicrosoY,\t\r  Baidu,\t\r  Facebook,\t\r  \nSamsung,\t\r  Yahoo,\t\r  Intel,\t\r  Apple,\t\r  Nuance,\t\r  BBN,\t\r  …)\t\r  \n\n•  PotenHal\t\r  for\t\r  more\t\r  breakthroughs\t\r  and\t\r  approaching\t\r  the\t\r  \n“understanding”\t\r  part\t\r  of\t\r  AI\t\r  by\t\r  \n•  Scaling\t\r  computaHon\t\r  \t\r  \n•  Numerical\t\r  opHmizaHon\t\r  (bever\t\r  training\t\r  much\t\r  deeper\t\r  nets,\t\r  RNNs)\t\r  \n•  Bypass\t\r  intractable\t\r  marginalizaHons\t\r  and\t\r  exploit\t\r  broad\t\r  priors\t\r  and\t\r  \nlayer-­‐wise\t\r  training\t\r  signals\t\r  to\t\r  learn\t\r  more\t\r  disentangled\t\r  \nabstracHons\t\r  for\t\r  unsupervised\t\r  &\t\r  structured\t\r  output\t\r  learning\t\r  \n\n60\t\r  \n\n\n\nMerci! Questions? LISA team: \n\n\n","extracted_metadata":{"pdf:hasXMP":["false"],"access_permission:extract_for_accessibility":["true"],"pdf:docinfo:creator":["Yoshua Bengio"],"dcterms:created":["2014-11-06T21:19:27Z"],"X-TIKA:Parsed-By":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"X-TIKA:Parsed-By-Full-Set":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"pdf:totalUnmappedUnicodeChars":["169"],"pdf:docinfo:modified":["2014-11-06T21:19:27Z"],"pdf:hasCollection":["false"],"access_permission:modify_annotations":["true"],"pdf:encrypted":["false"],"pdf:hasXFA":["false"],"pdf:docinfo:title":["Tel-Aviv-6nov2014.pptx"],"pdf:PDFVersion":["1.3"],"pdf:docinfo:created":["2014-11-06T21:19:27Z"],"xmpTPg:NPages":["61"],"pdf:docinfo:producer":["Mac OS X 10.9.5 Quartz PDFContext"],"pdf:unmappedUnicodeCharsPerPage":["1","0","2","3","4","6","0","2","2","1","3","0","5","0","0","0","3","4","5","7","0","0","1","1","2","6","6","4","1","4","2","1","0","0","4","6","1","2","0","5","5","1","4","2","0","5","7","4","4","0","6","2","3","3","2","0","4","9","4","10","0"],"xmp:CreatorTool":["PowerPoint"],"pdf:containsNonEmbeddedFont":["false"],"Content-Type":["application/pdf"],"access_permission:can_print":["true"],"pdf:num3DAnnotations":["0"],"access_permission:can_print_degraded":["true"],"pdf:hasMarkedContent":["false"],"access_permission:fill_in_form":["true"],"Content-Length":["56715281"],"dcterms:modified":["2014-11-06T21:19:27Z"],"pdf:overallPercentageUnmappedUnicodeChars":["0.00590310525149107"],"dc:format":["application/pdf; version=1.3"],"access_permission:extract_content":["true"],"pdf:producer":["Mac OS X 10.9.5 Quartz PDFContext"],"resourceName":["Fundamentals_of_Deep_Learning_2014.pdf"],"pdf:docinfo:creator_tool":["PowerPoint"],"pdf:containsDamagedFont":["false"],"access_permission:assemble_document":["true"],"dc:title":["Tel-Aviv-6nov2014.pptx"],"pdf:charsPerPage":["142","73","129","146","197","429","101","150","337","143","289","301","386","11169","161","83","288","240","285","647","180","101","224","431","433","323","448","236","364","314","373","451","165","79","431","403","166","260","97","319","338","179","361","303","249","252","352","585","367","225","596","108","504","466","375","37","378","537","241","653","29"],"access_permission:can_modify":["true"],"dc:creator":["Yoshua Bengio"]},"metadata_field_count":40,"attempts":1,"timestamp":1754064908.8995314,"platform":"Linux","python_version":"3.13.5"},{"file_path":"test_documents/pdfs/Proof of Concept or GTFO - v13 (October 18th, 2016).pdf","file_size":62061798,"file_type":"pdf","category":"huge","framework":"extractous","iteration":2,"extraction_time":19.098371505737305,"startup_time":null,"peak_memory_mb":496.44140625,"avg_memory_mb":483.06875,"peak_cpu_percent":62.3,"avg_cpu_percent":12.459999999999999,"total_io_mb":null,"status":"success","character_count":249077,"word_count":49251,"error_type":null,"error_message":null,"quality_metrics":{"char_count":249077,"word_count":49251,"sentence_count":2476,"paragraph_count":3887,"avg_word_length":3.931026781182108,"avg_sentence_length":20.149434571890147,"extraction_completeness":1.0,"text_coherence":0.65130336229694,"noise_ratio":0.4415935634362065,"gibberish_ratio":0.0,"flesch_reading_ease":63.174401982914816,"gunning_fog_index":14.645896292590756,"has_proper_formatting":true,"maintains_line_breaks":true,"preserves_whitespace":true,"table_structure_preserved":true,"format_specific_score":0.8,"expected_content_preserved":false,"has_encoding_issues":false,"has_ocr_artifacts":true,"preserves_pdf_formatting":true},"overall_quality_score":0.6344930384824043,"extracted_text":"\nPoC||GTFOPoC||GTFOP\nr\no\no\nf\n\nCo\nncep\nt\n\nGe\nt\n\nT\nh\ne\n\nF\nu\nc\nk\n\nO\nu\nt\n\no r\n\nfo\n\nPASTOR LAPHROAIG’S MERCY SHIPPASTOR LAPHROAIG’S MERCY SHIP\nHOLDS STONES FROM THE IVORY TOWER,HOLDS STONES FROM THE IVORY TOWER,\n\nBUT ONLY AS BALLAST!BUT ONLY AS BALLAST!\n\ne0, $0 USD, 10s 6d GBP, 0 RSD, 0 SEK, $50 CAD, 6× 1029 Pengő (3× 108 Adópengő).\nÜres hasnak elég a szép szó; это самиздат. pocorgtfo13.pdf. October 18, 2016.\n\n13:213:2 Atari Star RaidersAtari Star Raiders\n\n13:313:3 Slowing Down a Race ConditionSlowing Down a Race Condition\n\n13:413:4 Glitching Attacks over USB; or,Glitching Attacks over USB; or,\n\nA Wacom Tablet Reads RFIDsA Wacom Tablet Reads RFIDs\n\n13:513:5 Running AMBE Firmware in LinuxRunning AMBE Firmware in Linux\n\n13:613:6 A Rogue Strategy for SpinlocksA Rogue Strategy for Spinlocks\n\n13:713:7 Reverse Engineering LoRa’s PHYReverse Engineering LoRa’s PHY\n\n13:813:8 Concerning Plumbers and PopperConcerning Plumbers and Popper\n\n13:913:9 Where is ShimDBC.exe?Where is ShimDBC.exe?\n\n13:1013:10 Postscript for Schizophrenic GhostsPostscript for Schizophrenic Ghosts\n\n\n\nLegal Note: In solidarity with , the Author Formerly Known as Homer Hickam, we place no restrictions\nof any kind upon our authors. They are quite welcome to do whatever the hell they like with their own\nwork, in any medium they like, including but not limited to endeavors of theater and interpretive dance.\n\nReprints: Bitrot will burn libraries with merciless indignity that even Pets Dot Com didn’t deserve. Please\nmirror—don’t merely link!—pocorgtfo13.pdf and our other issues far and wide, so our articles can help fight\nthe coming flame deluge. We like the following mirrors.\nhttps://unpack.debug.su/pocorgtfo/\nhttps://pocorgtfo.hacke.rs/\nhttps://www.alchemistowl.org/pocorgtfo/\nhttp://www.sultanik.com/pocorgtfo/\n\nTechnical Note: As described in PoC‖GTFO 13:10, pocorgtfo13.pdf is a polyglot that may be inter-\npreted as both a PDF and a PostScript file. As a PDF, this file is mostly harmless, but we warn you that\nthe Postscript will render differently each time, including both a randomly generated maze and—if Tavis\nOrmandy hasn’t killed such a lovely bug yet—a copy of your /etc/passwd file.\n\nCover Art: The cover artwork from this issue is by Harry Clarke, first used to illustrate the poem Sea\nFever by John Masefield in the collection The Year’s at the Spring, 1920.\n\nPrinting Instructions: Pirate print runs of this journal are most welcome! PoC‖GTFO is to be printed\nduplex, then folded and stapled in the center. Print on A3 paper in Europe and Tabloid (11” x 17”) paper in\nSamland, then fold to get a booklet in A4 or Letter size. Secret volcano labs in Canada may use P3 (280 mm\nx 430 mm) if they like, folded to make P4. The outermost sheet should be on thicker paper to form a cover.\n\n# This is how to convert an issue for duplex printing.\nsudo apt-get install pdfjam\npdfbook --short-edge --vanilla --paper a3paper pocorgtfo13.pdf -o pocorgtfo13-book.pdf\n\nMan of The Book Manul Laphroaig\nEditor of Last Resort Melilot\nTEXnician Evan Sultanik\nEditorial Whipping Boy Jacob Torrey\nFunky File Supervisor Ange Albertini\nAssistant Scenic Designer Philippe Teuwen\n\nand sundry others\n\n2\n\n\n\n1 Read me if you want to live!\n\nNeighbors, please join me in reading this four-\nteenth release of the International Journal of Proof\nof Concept or Get the Fuck Out, a friendly little\ncollection of articles for ladies and gentlemen of dis-\ntinguished ability and taste in the field of reverse en-\ngineering and worshippers of weird machines. This\nfourteenth release is given on paper to the fine neigh-\nbors of São Paulo, San Diego, and Budapest.\n\nIf you are missing the first thirteen issues, we the\neditors suggest pirating them from the usual loca-\ntions, or on paper from a neighbor who picked up a\ncopy of the first in Vegas, the second in São Paulo,\nthe third in Hamburg, the fourth in Heidelberg, the\nfifth in Montréal, the sixth in Las Vegas, the seventh\nfrom his parents’ inkjet printer during the Thanks-\ngiving holiday, the eighth in Heidelberg, the ninth in\nMontréal, the tenth in Novi Sad or Stockholm, the\neleventh in Washington D.C., the twelfth in Heidel-\nberg, or the thirteenth in Montréal.\n\nAfter our paper release, and only when qual-\nity control has been passed, we will make an elec-\ntronic release named pocorgtfo13.pdf. It is valid\nas PDF, ZIP, and PostScript; please read it with\nAdobe Reader, unzip, and gv.\n\nWe begin on page 5 with the story of how STAR\nRAIDERS by Doug Neubauer for the Atari 400 was\ntaken apart by Lorenz Weist, from a mere ROM car-\ntridge dump to annotated and literate 6502 disas-\nsembly. By a stroke of luck, Lorenz was able to read\nDoug’s original source code for the game after com-\n\npleting his reverse engineering project, giving him\nthe rare opportunity to confirm his understanding\nof the game’s design and behavior.\n\nOn page 24, James Forshaw introduces us to a\nnifty little trick for simplifying reliable exploitation\nof race condition vulnerabilities. Rather than spin\nup a dozen attempts to improve racetrack odds, he\ninstead induces situations with pathological perfor-\nmance penalties to Windows NT system calls, stun-\nning the threads of execution that might interfere\nwith his exploit for twenty minutes or more!\n\nMicah Elizabeth Scott continues to send us bril-\nliant articles that refuse to be described by a single\nabstract, so let’s just say that on page 30 she ex-\nplains a USB magic trick in which her FaceWhis-\nperer board—combining the Facedancer and the\nChip Whisperer—is able to reliably glitch the USB\nstack of an embedded device to dump its firmware.\nOr, we could say that on page 30 she explains how\nto use undocumented commands from that firmware\ndump to program the Harvard device by ROP. Or,\nwe could say that on page 30 she shows you to read\nRFID tags with a Wacom tablet. These tricks are\nall the same article, and you’d be a fool not to read\nit.\n\n3\n\n\n\nIn PoC‖GTFO 10:8, Travis Goodspeed jailbroke\nthe Tytera MD380 radio to allow for firmware ex-\ntraction and patching. Since then, a lively open\nsource project has sprung up, with fancy new fea-\ntures and fixes to old bugs. On page 38, he describes\nhow to rip the AMBE audio codec out of the radio\nfirmware, transforming it into a command line audio\nprocessing tool that runs on any Linux workstation.\nSimilar tricks can be used to quickly toss together\nemulators for many ARM and PowerPC embedded\nsystems, re-using their library functions, or fuzzing\ntheir parsers in the familiar environment of an ev-\neryday laptop.\n\nEvan Sultanik is back with a safe cracking adven-\nture that could only be expressed as a play in three\nacts, narrated by our own Pastor Manul Laphroaig.\nSpeaking parts are available for Alice Feynman, Bob\nSchrute, Havva al-Kindi, and the ghost of Paul\nErdős. You’ll find Evan’s script on page 43.\n\nMatt Knight has been reverse engineering the\nPHY of LoRa, a low-power protocol for sub-GHz\nwireless networking over long distances. On page 48\nyou will find not just the protocol details that al-\nlowed him to write an open source receiver, but, far\nmore importantly, you will also find the methods by\nwhich he reverse engineered this information from\ncaptured packets, vague application notes, and the\noutright lies of the patent application.\n\nPastor Manul Laphroaig, your friendly neighbor-\nhood evangelist of the gospel of the weird machines,\n\nhas a sermon for you on page 60. He reminds us\nthat science takes place neither on stage in front of\na live studio audience nor in committees and gov-\nernment offices, but over a glass of fine scotch that’s\naccompanied by finer conversation of practitioners.\nIn the same way that we oughtn’t put Tim the “Tool\nMan” Taylor in charge of vocational education, we\nought to leave the teaching of science to those who\ndo it, not those who talk about it on TV.\n\nGeoff Chappell is an old-school reverse engineer,\nan x86 archaeologist who has spent the past twenty-\nfour years reading Windows binaries to identify all\nthe forgotten features and corner cases that the rest\nof us might take for granted.1 On page 63, he\nintroduces us to the mystery of Microsoft’s Shim\nDatabase Compiler, an unpublished tool for compil-\ning driver shims that doesn’t seem to be available\nto the outside world. Geoff shows us that, in fact,\nthe tool is available, wrapped up inside of a GUI\nas QFixApp.exe or CompatAdmin.exe. By patch-\ning the program to expose its intact winmain(), he\ncan recover the long-lost ShimDBC.exe for compiling\nWindows driver compatibility shims from XML!\n\nEvan Sultanik and Philippe Teuwen have teamed\nup on page 71, to explain the inner workings of\npocorgtfo13.pdf, which you can rename to read\nas pocorgtfo13.zip or pocorgtfo13.ps.\n\nOn page 72, the last page, we pass around the\ncollection plate. Our church has no interest in cash\nor cheques, but we’d love your donation of a nifty\nreverse engineering story. Please send one our way.\n\n1Geoff was the first to discover Aaron R. Reynolds’ “AARD” code from the beta release of Windows 3.1 that intentionally\nbroke compatibility with DR-DOS. He also has a delightful article on exactly how AOL exploited a buffer overflow in their own\nAOL Instant Messenger client to distinguish it from Microsoft’s clone, MSN Messenger.\n\n4\n\n\n\n2 Reverse Engineering Star Raiders\nby Lorenz Wiest\n\n2.1 Introduction\n\nSTAR RAIDERS is a seminal computer game pub-\nlished by Atari Inc. in 1979 as one of the first titles\nfor the original Atari 8-bit Home Computer System\n(Atari 400 and Atari 800). It was written by Atari\nengineer Doug Neubauer, who also created the sys-\ntem’s POKEY sound chip. STAR RAIDERS is consid-\n\nered to be one of the ten most important computer\ngames of all time.2.\n\nCONTROLLER JACKS\n\nSYSTEM\nRESET\n\nOPTION\n\nSELECT\n\nSTART\n\n21 3 4\n\nPLYR 1 PLYR 2 PLYR 3 PLYR 4\n\nThe game is a 3D space combat flight simulation\nwhere you fly your starship through space, shooting\nat attacking Zylon spaceships.The game’s universe\nis made up of a 16 × 8 grid of sectors Some of\nthem contain enemy Zylon units some a friendly\nstarbase The Zylon units converge toward the star-\nbases and try to destroy them. The starbases serve\nas repair and refueling points for your starship. You\nmove your starship between sectors with your hyper-\nwarp drive The game is over if you have destroyed\nall Zylon ships, have ran out of energy, or if the\nZylons have destroyed all starbases.\n\nAt a time when home computer games were\npretty static – think SPACE INVADERS (1978) and\nPAC MAN (1980) – STAR RAIDERS was a huge hit\nbecause the game play centered on the very dynamic\n3D first-person view out of your starship’s cockpit\nwindow.\n\nThe original Atari 8-bit Home Computer System\n2“Is That Just Some Game? No, It’s a Cultural Artifact.” Heather Chaplin, The New York Times, March 12, 2007.\n\n5\n\n\n\nhas up to 48 KB RAM and uses a Motorola 6502\nCPU. The same CPU is also used in the Apple II,\nthe Commodore C64 (a 6502 variant), and the T-\n800 Terminator 3 Several proprietary Atari custom\nchips provide additional capabilities to the system.\nSTAR RAIDERS shows off many of them: 5 Play-\ners (sprites), mixed text and pixel graphics modes,\ndynamic Display Lists, a custom character set, 4-\nchannel sound, Vertical Blank Interrupt and Dis-\nplay List Interrupt code – even the BCD mode of\nthe 6502 CPU is used C\n\nCONTROLLER JACKS21 3 4\n\nPULL     OPEN SYSTEMRESETOPTIONSELECTSTART\n\n@angealbertini 2016\n\nlig\nht\n\n p\nen\n\nso\nun\n\nd\n\nse\nri\n\nal\nbu\n\ns\n\npi\nct\n\nur\ne\n\nco\nns\n\nol\ne \n\nsw\nit\nch\n\nes\n\njo\nys\n\nti\nck\n\n t\nri\n\ngg\ner\n\ns\n\nke\nyb\n\noa\nrd\n\nkeyboard\nspeaker\n\npa\ndd\n\nle\ns\n\nke\nyb\n\noa\nrd\n\nco\nnt\n\nro\nlle\n\nrs\n\njo\nys\n\nti\nck\n\npa\ndd\n\nle\ntr\n\nig\nge\n\nrs\n\nMOS\n6502\n\nRAM left\ncartridge\n\nright\ncartridge OS\n\nROM\ndisk\n\ndrives\n\nother\nperiph.\n\nPOtentiometer\nKEYboard\nintegrated circuit\n\nPeripheral\nInterface\nAdaptor\n\nColor/Graphics\nTelevision\n\nInterface Adaptor16KB - 48KB\n\n1.77-1,79Mhz\n\n16bit freq counter mode\nkeyboard/paddle scanning\nIRQ generator\n\nAlpha-Numeric\nTelevision\nInterface\nControllerSALLY\n\nSprites: player/missile\n\ndisplay lists\n\nprocessor busprocessor bus\n\nI have been always wondering what made STAR\nRAIDERS tick. I was especially curious how that\n3D first-person view star field worked, in particu-\nlar the rotations of the stars when you fly a turn.\nSo I decided to reverse engineer the game, aiming\nat a complete, fully documented assembly language\nsource code of STAR RAIDERS.\n\n;*********************************************************************\n;*                                                                  *\n;*                      S T A R   R A I D E R S                     *\n;*                                                                  *\n;*             for the Atari 8-bit Home Computer System             *\n;*                                                                  *\n;*  Reverse-engineered and documented assembly language source code  *\n;*                                                                  *\n;*                                by                                *\n;*                                                                  *\n;*                           Lorenz Wiest                           *\n;*                                                                  *\n;*                       (lo.wiest(at)web.de)                       *\n;*                                                                  *\n;*                           First Release                          *\n;*                            22-SEP-2015                           *\n;*                                                                  *\n;*                            Last Update                           *\n;*                            10-AUG-2016                           *\n;*                                                                  *\n;*           STAR RAIDERS was created by Douglas Neubauer           *\n;*             STAR RAIDERS was published by Atari Inc.             *\n;*                                                                  *\n;*********************************************************************\n\nIn the following sections I’ll show you how I ap-\nproached the reverse engineering effort, introduce\nmy favorite piece of code in STAR RAIDERS, talk\nabout how the tight memory limits influenced the\nimplementation, reveal some bugs, point at some\nmysterious code, and explain how I got a grip on\ndocumenting STAR RAIDERS. From time to time, to\nprovide some context to you, I will reference memory\nlocations of the game, which you can look up in the\nreverse engineered, complete, and fully documented\nassembly language source code of STAR RAIDERS\navailable on GitHub.4\n\n2.2 Getting Started\n\nSTAR RAIDERS is distributed as an 8 KB ROM car-\ntridge, occupying memory locations $A000 to $BFFF.\n\nThe obvious first step was to prod a ROM dump\nwith a disassembler and to apply Atari’s published\nhardware and OS symbols to the disassembly. To\nmy surprise this soon revealed that code and data\nwere clearly separated into three parts:\n$A000 – $A149 Data (Part 1 of 2)\n$A14A – $B8DE Code (6502 instructions)\n$B8DF – $BFFF Data (Part 2 of 2)\nThis clear separation helped me instantly to get\n\nan overview of the code part, as I could create a\ndisassembly of the code in one go and not having to\nsift slowly through the bytes of the ROM, deciding\nwhich ones are instructions and which ones are data.\n\nCloser inspection of the code part revealed that it\nwas composed of neatly separated subroutines. Each\nsubroutine handles a specific task. The largest sub-\nroutine is the main game loop GAMELOOP ($A1F3),\nshown in Figure 1. What I expected to be spaghetti\ncode – given the development tools of 1979 and the\nsubstantial amount of game features crammed into\nthe 8K ROM – turned out to be surprisingly struc-\ntured code. Table 1 lists all subroutines of STAR\nRAIDERS, as their function emerged during the re-\nverse engineering effort, giving a good overview how\nthe STAR RAIDERS code is organized.\n\nFigure 2 shows the “genome sequence” of the\nSTAR RAIDERS 8 KB ROM: The 8192 bytes of the\ngame are stacked vertically, with each byte repre-\nsented by a tiny, solid horizontal line of 8 pixels.\nThis stack is split into strips of 192 bytes, arranged\nside-by-side. Alternating light and dark blue areas\nrepresent bytes of distinct subroutines. Alternat-\ning light and dark green and purple areas repre-\nsent bytes of distinct sections of data (lookup tables,\ngraphical shapes, etc.). When data bytes represent\ngraphical shapes, the solid line of a byte is replaced\nby its actual bit pattern (in purple color).\n\nThere are a couple of interesting things to see:\n\n• The figure reflects the ROM’s separation into\na data part (green and purple), a code part\n(blue), and one more data part (green and pur-\nple).\n\n• The first data part contains mostly the custom\n3In the movie TERMINATOR (1984) there are scenes showing the Terminator’s point of view in shades of red. In these\n\nscenes lines of source code are listed onscreen. Close inspection of still frames of the movie reveal this to be 6502 assembly\nlanguage source code.\n\n4git clone https://github.com/lwiest/StarRaiders or unzip pocorgtfo13.pdf StarRaiders.zip\n\n6\n\n\n\nGAMELOOP\n$A1F3\n\nUPDATTCOMP Update Attack Computer Display\n$A7BF\n\nHYPERWARP Handle hyperwarp\n$A89B\n\nMANEUVER Maneuver our starship's and Zylon\nphoton torpedoes and Zylon ships$AA79\n\nINITEXPL Initialize explosion\n$AC6B\n\nDOCKING Handle docking at starbase,\nlaunch and return of transfer vessel$ACE6\n\nMODDLST Modify Display List\n$ADF1\n\nCLRPLAYFIELD Clear PLAYFIELD memory\n$AE0D\n\nTRIGGER Handle joystick trigger\n$AE29\n\nNOISE Copy noise sound pattern\n$AEA8\n\nDAMAGE Damage or destroy one of our starship's subsystems\n$AEE1\n\nCOLLISION Detect a collision of our starship's photon torpedoes\n$AF3D\n\nGAMEOVER Handle Game Over\n$B10A\n\nFLUSHGAMELOOP Handle remaining tasks at the end\nof a game loop iteration$B4E4\n\nDRAWLINES Draw horizontal and vertical lines\n$A76F\n\nPROJECTION Calculate pixel column (or row) number\nfrom position vector$AA21\n\nKEYBOARD Handle Keyboard Input\n$AFFE\n\nSETVIEW Set Front view\n$B045\n\nSELECTWARP Select hyperwarp arrival location\non Galactic Chart$B162\n\nROTATE Rotate position vector component\n(coordinate) by fixed angle$B69B\n\nSCREENCOLUMN Calculate pixel column number\nfrom centered pixel column number$B6FB\n\nSCREENROW Calculate pixel row number\nfrom centered pixel row number$B71E\n\nINITPOSVEC Initialize position vector of a space object\n$B764\n\nUPDPANEL Update Control Panel Display\n$B804\n\nDECENERGYDecrease energy\n$B86F\n\nInitialize program (cold start)\n$A14A\nINITCOLD\n\nEntry point when SELECT function key was pressed\n$A15A\nINITSELECT\n\nEntry point when program switches into demo mode\n$A15C\nINITDEMO\n\nEntry point when START function key was pressed\n$A15E\nINITSTART\n\nUPDTITLE Update title line\n$B216\n\nA B A is followed by B in memory A B A calls B (and returns)\n\nA B A jumps to B (no return)\n\n$A6D0\n\nFigure 1. Simplified Call Graph of Start Up and Game Loop\n\n7\n\n\n\n1 $A14A INITCOLD I n i t i a l i z e program (Cold s t a r t )\n$A15A INITSELECT Entry po int when SELECT func t i on key was pre s sed\n\n3 $A15C INITDEMO Entry po int when program swi t che s in to demo mode\n$A15E INITSTART Entry po int when START func t i on key was pre s sed\n\n5 $A1F3 GAMELOOP Game loop\n$A6D1 VBIHNDLR Ve r t i c a l Blank In t e r rup t Handler\n\n7 $A718 DLSTHNDLR Display L i s t In t e r rup t Handler\n$A751 IRQHNDLR Int e r rup t Request (IRQ) Handler\n\n9 $A76F DRAWLINES Draw ho r i z on t a l and v e r t i c a l l i n e s\n$A782 DRAWLINE Draw a s i n g l e ho r i z on t a l or v e r t i c a l l i n e\n\n11 $A784 DRAWLINE2 Draw b l i p in Attack Computer\n$A7BF UPDATTCOMP Update Attack Computer Display\n\n13 $A89B HYPERWARP Handle hyperwarp\n$A980 ABORTWARP Abort hyperwarp\n\n15 $A987 ENDWARP End hyperwarp\n$A98D CLEANUPWARP Clean up hyperwarp v a r i a b l e s\n\n17 $A9B4 INITTRAIL I n i t i a l i z e s t a r t r a i l dur ing STAR TRAIL PHASE of hyperwarp\n$AA21 PROJECTION Calcu la te p i x e l column ( or row ) number from po s i t i o n vec to r\n\n19 $AA79 MANEUVER Maneuver our s t a r s h i p ’ s and Zylon photon torpedoes and Zylon sh ip s\n$AC6B INITEXPL I n i t i a l i z e exp l o s i on\n\n21 $ACAF COPYPOSVEC Copy a po s i t i o n vec to r\n$ACC1 COPYPOSXY Copy x and y components ( coo rd ina t e s ) o f p o s i t i o n vec to r\n\n23 $ACE6 DOCKING Handle docking at s tarbase , launch and return o f t r a n s f e r v e s s e l\n$ADF1 MODDLST Modify Display L i s t\n\n25 $AE0D CLRPLAYFIELD Clear PLAYFIELD memory\n$AE0F CLRMEM Clear memory\n\n27 $AE29 TRIGGER Handle j o y s t i c k t r i g g e r\n$AEA8 NOISE Copy no i s e sound pattern\n\n29 $AECA HOMINGVEL Calcu la te homing v e l o c i t y o f our s t a r s h i p ’ s photon torpedo 0 or 1\n$AEE1 DAMAGE Damage or des t roy one o f our s t a r s h i p ’ s subsystems\n\n31 $AF3D COLLISION Detect a c o l l i s i o n o f our s t a r s h i p ’ s photon torpedoes\n$AFFE KEYBOARD Handle Keyboard Input\n\n33 $B045 SETVIEW Set Front view\n$B07B UPDSCREEN Clear PLAYFIELD, draw Attack\n\n35 $B10A GAMEOVER Handle game over\n$B121 GAMEOVER2 Game over ( Miss ion s u c c e s s f u l )\n\n37 $B162 SELECTWARP Se l e c t hyperwarp a r r i v a l l o c a t i o n on Ga lac t i c Chart\n$B1A7 CALCWARP Calcu la te and d i sp l ay hyperwarp energy\n\n39 $B216 UPDTITLE Update t i t l e l i n e\n$B223 SETTITLE Set t i t l e phrase in t i t l e l i n e\n\n41 $B2AB SOUND Handle sound e f f e c t s\n$B3A6 BEEP Copy beeper sound pattern\n\n43 $B3BA INITIALIZE More game i n i t i a l i z a t i o n\n$B4B9 DRAWGC Draw Galac t i c Chart\n\n45 $B4E4 FLUSHGAMELOOP Handle remaining ta sk s at the end o f a game loop i t e r a t i o n\n$B69B ROTATE Rotate p o s i t i o n vec to r component ( coord inate ) by f i x ed ang le\n\n47 $B6FB SCREENCOLUMN Calcu la te p i x e l column number from cente red p i x e l column number\n$B71E SCREENROW Calcu la te p i x e l row number from cente red p i x e l row number\n\n49 $B764 INITPOSVEC I n i t i a l i z e p o s i t i o n vec to r o f a space ob j e c t\n$B7BE RNDINVXY Randomly i nv e r t the x and y components o f a po s i t i o n vec to r\n\n51 $B7F1 ISSURROUNDED Check i f a s e c t o r i s surrounded by Zylon un i t s\n$B804 UPDPANEL Control Panel Display\n\n53 $B86F DECENERGY Decrease energy\n$B8A7 SHOWCOORD Display a po s i t i o n vec to r component ( coord inate ) in\n\n55 Control Panel Display\n$B8CD SHOWDIGITS Display a value by a readout o f the Control Panel Display\n\nTable 1. Star Raiders Subroutines\n\n8\n\n\n\nCODE DATABITMAP\n\n+00\n\n+08\n\n+10\n\n+18\n\n+20\n\n+28\n\n+30\n\n+38\n\n+40\n\n+48\n\n+50\n\n+58\n\n+60\n\n+68\n\n+70\n\n+78\n\n+80\n\n+88\n\n+90\n\n+98\n\n+A0\n\n+A8\n\n+B0\n\n+B8\n\n+C0\n\nGA\nME\nLO\nOP\n\n## 01 02 03 04 05 06 07 08 09 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43\n\nA000    A180    A300    A480    A600    A780    A900    AA80    AC00    AD80    AF00    B080    B200    B380    B500    B680    B800    B980    BB00    BC80    BE00    BF80\n    A0C0    A240    A3C0    A540    A6C0    A840    A9C0    AB40    ACC0    AE40    AFC0    B140    B2C0    B440    B5C0    B740    B8C0    BA40    BBC0    BD40    BEC0\n\nW\nO\nR\nD\nT\nA\nB\n\nW\nO\nR\nD\nT\nA\nB\n\nMA\nNE\nUV\nER\n\nMA\nNE\nUV\nER\n\nF\nL\nU\nS\nH\nG\nA\nM\nE\nL\nO\nO\nP\n\nFigure 2. Genome Sequence of the STAR RAIDERS ROM\n\nfont (in strips 1-2).\n\n• The largest contiguous (dark) blue chunk rep-\nresents the 1246 bytes of the main game loop\nGAMELOOP ($A1F3) (in strips 3-10).\n\n• At the beginning of the second data part are\nthe shapes for the Players (sprites) (in strips\n34-36).\n\n• The largest contiguous (light) green chunk rep-\nresents the 503 bytes of the game’s word table\nWORDTAB ($BC2B) (in strips 38-41).\n\nA good reverse engineering strategy was to start\nworking from code locations that used Atari’s pub-\nlished symbols, the equivalent of piecing together\nthe border of a jigsaw puzzle first before starting to\ntackle the puzzle’s center. Then, however, came the\ninevitable and very long stretch of reconstructing\nthe game’s logic and variables with a combination\nof educated guesses, trial-and-error, and lots of pa-\ntience. At this stage, the tools I used mostly were\nnothing but a text editor (Notepad) and a word pro-\ncessor (Microsoft Word) to fill the gaps in the doc-\numentation of the code and the data. I also created\n\na memory map text file to list the used memory lo-\ncations and their purpose. These entries were con-\ntinually updated – and more than often discarded\nafter it turned out that I had taken a wrong turn.\n\n2.3 A Programming Gem: Rotating\n3D Vectors\n\nWhat is the most interesting, fascinating, and un-\nexpected piece of code in STAR RAIDERS? My pick\nwould be the very code that started me to reverse\nengineer STAR RAIDERS in the first place: subrou-\ntine ROTATE ($B69B), which rotates objects in the\ngame’s 3D coordinate space (shown in Figure 3).\nAnd here is why: Rotation calculations usually in-\nvolve trigonometry, matrices, and so on – at least\nsome multiplications. But the 6502 CPU has only\n8-bit addition and subtraction operations. It does\nnot provide either a multiplication or a division op-\neration – and certainly no trig operation! So how do\nthe rotation calculations work, then?\n\nLet’s start with the basics: The game uses a 3D\ncoordinate system with the position of our starship\nat the center of the coordinate system. The loca-\ntions of all space objects (Zylon ships, meteors, pho-\n\n9\n\n\n\nton torpedoes, starbase, transfer vessel, Hyperwarp\nTarget Marker, stars, and explosion fragments) are\ndescribed by a position vector relative to our star-\nship.\n\nA position vector is composed of an x, y, and z\ncomponent, whose values I call the x, y, and z coor-\ndinates with the arbitrary unit <KM>. The range\nof a coordinate is −65536 to +65535 <KM>.\n\nEach coordinate is a signed 17-bit integer num-\nber, which fits into three bytes. Bit 16 contains\nthe sign bit, which is 1 for positive and 0 for nega-\ntive sign. Bits 15 to 0 are the mantissa as a two’s-\ncomplement integer.\n\nSign Mantissa\n2 B16 B15 . . . B8 B7 . . . . B0\n\n| | | | |\n4 0000000∗ ∗∗∗∗∗∗∗∗ ∗∗∗∗∗∗∗∗\n\nSome example bit patterns for coordinates:\n\n00000001 11111111 11111111 = +65535 <KM>\n2 00000001 00000001 00000000 = +256 <KM>\n\n00000001 00000000 11111111 = +255 <KM>\n4 00000001 00000000 00000001 = +1 <KM>\n\n00000001 00000000 00000000 = +0 <KM>\n6 00000000 11111111 11111111 = −1 <KM>\n\n00000000 11111111 11111110 = −2 <KM>\n8 00000000 11111111 00000001 = −255 <KM>\n\n00000000 11111111 00000000 = −256 <KM>\n10 00000000 00000000 00000000 = −65536 <KM>\n\nThe position vector for each space object is\nstored in nine tables (3 coordinates × 3 bytes for\neach coordinate). There are up to 49 space objects\nused in the game simultaneously, so each table is 49\nbytes long:\n\nXPOSSIGN XPOSHI XPOSLO\n($09DE..$0A0E) ($0A71..$0AA1) ($0B04..$0B34)\n\nYPOSSIGN YPOSHI YPOSLO\n($0A0F..$0A3F) ($0AA2..$0AD2) ($0B35..$0B65)\n\nZPOSSIGN ZPOSHI ZPOSLO\n($09AD..$09DD) ($0A40..$0A70) ($0AD3..$0B03)\n\nWith that explained, let’s have a look at sub-\nroutine ROTATE ($B69B). This subroutine rotates a\nposition vector component (coordinate) of a space\nobject by a fixed angle around the center of the\n3D coordinate system, the location of our starship.\nThis operation is used in 3 out of 4 of the game’s\nview modes (Front view, Aft view, Long-Range Scan\nview) to rotate space objects in and out of the view.\n\n2.3.1 Rotation Mathematics\n\nThe game uses a left-handed 3D coordinate system\nwith the positive x-axis pointing to the right, the\npositive y-axis pointing up, and the positive z-axis\npointing into flight direction.\n\nry\n\nz-axis\n\nx-axis\nx x’\n\nz\n\nz’\n\ny--axis\n\nx-axis\n\nz-axis\n\nA rotation in this coordinate system around the\ny-axis (horizontal rotation) can be expressed as\n\nx′ = cos(ry)x+ sin(ry)z (1)\nz′ = − sin(ry)x+ cos(ry)z\n\nwhere ry is the clockwise rotation angle around the\ny-axis, x and z are the coordinates before this ro-\ntation, and the primed coordinates x′ and z′ the\ncoordinates after this rotation. The y-coordinate is\nnot changed by this rotation.\n\nrx\n\ny-axis\n\nz-axis\nz z’\n\ny\n\ny’\n\ny-axis\n\nx-axis\n\nz-axis\n\nA rotation in this coordinate system around the\nx-axis (vertical rotation) can be expressed as\n\nz′ = cos(rx)z + sin(rx)y (2)\ny′ = − sin(rx)z + cos(rx)y\n\nwhere rx is the clockwise rotation angle around the\nx-axis, z and y are the coordinates before this ro-\ntation, and the primed coordinates z′ and y′ the\ncoordinates after this rotation. The x-coordinate is\nnot changed by this rotation.\n\n2.3.2 Subroutine Implementation Overview\n\nA single call of subroutine ROTATE ($B69B) is able\nto compute one of the four expressions in Equa-\ntions 1 and 2. To compute all four expressions to\n\n10\n\n\n\nget the new set of coordinates, this subroutine has\nto be called four times. This is done twice in pairs\nin GAMELOOP ($A1F3) at $A391 and $A398, and at\n$A3AE and $A3B5, respectively.\n\nThe first pair of calls calculates the new x and\nz coordinates of a space object due to a horizon-\ntal (left/right) rotation of our starship around the\ny-axis following the expressions of Equation 1.\n\nThe second pair of calls calculates the new y and\nz coordinates of the same space object due to a ver-\ntical (up/down) rotation of our starship around the\nx-axis following the expressions of Equation 2.\n\nIf you look at the code of ROTATE ($B69B), you\nmay be wondering how this calculation is actually\nexecuted, as there is neither a sine nor cosine func-\ntion call. What you’ll actually find implemented,\nhowever, are the following calculations:\n\nJoystick Left\n\nx := x+ z/64 (3)\nz := −x/64 + z\n\nJoystick Right\n\nx := x− z/64 (4)\nz := x/64 + z\n\nJoystick Down\n\ny := y + z/64 (5)\nz := −y/64 + z\n\nJoystick Up\n\ny := y − z/64 (6)\nz := y/64 + z\n\n2.3.3 CORDIC Algorithm\n\nWhen you compare the expressions of Equations 1–2\nwith expressions of Equations 3–6, notice the simi-\nlarity between the expressions if you substitute5\n\nsin(ry)→ 1/64\n\ncos(ry)→ 1\n\nsin(rx)→ 1/64\n\ncos(rx)→ 1\n\nFrom sin(ry) = 1/64 and sin(rx) = 1/64 you can\nderive that the rotation angles ry and rx by which\nthe space object is rotated (per game loop iteration)\nhave a constant value of 0.89◦, as arcsin(1/64) =\n0.89◦.\n\nWhat about cos(ry) and cos(rx)? The substi-\ntution does not match our derived angle exactly,\nbecause cos(0.89◦) = 0.99988 and is not exactly\n1. However, this value is so close that substitut-\ning cos(0.89◦) with 1 is a very good approximation,\nsimplifying calculations significantly.\n\nAnother significant simplification results from\nthe division by 64, as the actual division operation\ncan be replaced with a much faster bit shift opera-\ntion.\n\nThis calculation-friendly way of computing rota-\ntions is also known as the “CORDIC (COordinate\nRotation DIgital Computer)” algorithm.\n\n2.3.4 Minsky Rotation\n\nThere is one more interesting mathematical sub-\ntlety: Did you notice that expressions of Equa-\ntions 1 and 2 use a new (primed) pair of variables\nto store the resulting coordinates, whereas in the\nimplemented Equations 3–6, the value of the first\ncoordinate of a coordinate pair is overwritten with\nits new value and this value is used in the subsequent\ncalculation of the second coordinate? For example,\nwhen the joystick is pushed left, the first call of this\nsubroutine calculates the new value of x according\nto first expression of Equation 3, overwriting the old\nvalue of x. During the second call to calculate z ac-\ncording to the second expression of Equation 3, the\nnew value of x is used instead of the old one. Is this\nto save the memory needed to temporarily store the\nold value of x? Is this a bug? If so, why does the\nrotation calculation actually work?\n\nHave a look at the expressions of Equation 3 (the\nother Equations 4–6 work in a similar fashion):\n\nx := x+ z/64\n\nz := −x/64 + z\n\nIf we substitute 1/64 with e, we get\n\nx := x+ ez\n\nz := −ex+ z\n\n5This substitution gave a friendly mathematician who happened to see it a nasty shock. She yelled at us that cos2x+sin2x = 1\nfor all real x and forever, and therefore this could not possibly be a rotation; it’s a rotation with a stretch! We reminded her\nof the old joke that in wartime the value of the cosine has been known to reach 4. —PML\n\n11\n\n\n\nNote that x is calculated first and then used in\nthe second expression. When using primed coordi-\nnates for the resulting coordinates after calculating\nthe two expressions we get\n\nx′ := x+ ez\n\nz′ :=− ex′ + z\n\n=− e(x+ ez) + z\n\n=− ex+ (1− e2)z\n\nor in matrix form(\nx′\n\nz′\n\n)\n=\n\n(\n1 e\n−e 1− e2\n\n)(\nx\nz\n\n)\nSurprisingly, this turns out to be a rotation ma-\n\ntrix, because its determinant is (1× (1−e2)− (−e×\ne)) = 1. (Incidentally, the column vectors of this\nmatrix do not form an orthogonal basis, as their\nscalar product is 1 × e + (−e × (1 − e2)) = −e2.\nOrthogonality holds for e = 0 only.)\n\nThis kind of rotation calculation is described\nby Marvin Minsky in AIM 239 HAKMEM6 and is\ncalled “Minsky Rotation.”\n\n2.3.5 Subroutine Implementation Details\n\nTo better understand how the implementation of\nthis subroutine works, we must again look at Equa-\ntions 3–6. If you rearrange the expressions a little,\ntheir structure is always of the form:\n\nTERM1 := TERM1 SIGN TERM2/64\n\nor shorter\n\nTERM1 := TERM1 SIGN TERM3\n\nwhere TERM3 := TERM2/64 and SIGN := + or − and\nwhere TERM1 and TERM2 are coordinates. In fact, this\nis all this subroutine actually does: It simply adds\nTERM2 divided by 64 to TERM1 or subtracts TERM2\ndivided by 64 from TERM1.\n\nWhen calling this subroutine the correct table\nindices for the appropriate coordinates TERM1 and\nTERM2 are passed in the CPU’s Y and X registers,\nrespectively.\n\nWhat about SIGN between TERM1 and TERM3?\nAgain, have a look at Equations 3–6. To compute\n\nthe two new coordinates after a rotation, the SIGN\ntoggles from plus to minus and vice versa. The SIGN\nis initialized with the value of JOYSTICKDELTA ($6D)\nbefore calling subroutine ROTATE ($B69B, Figure 3)\nand is toggled in every call of this subroutine. The\ninitial value of SIGN should be positive (+, byte\nvalue $01) if the rotation is clockwise (the joystick is\npushed right or up) and negative (−, byte value $FF)\nif the rotation is counter-clockwise (the joystick is\npushed left or down), respectively. Because SIGN is\nalways toggled in ROTATE ($B69B) before the adding\nor subtraction operation of TERM1 and TERM3 takes\nplace, you have to pass the already toggled value\nwith the first call.\n\nUnclear still are three instructions starting at ad-\ndress $B6AD. They seem to set the two least signifi-\ncant bits of TERM3 in a random fashion. Could this\nbe some quick hack to avoid messing with exact but\npotentially lengthy two’s-complement arithmetic?\n\nCX40\n\n2.4 Dodging Memory Limitations\n\nIt is impressing how much functionality was\nsqueezed into STAR RAIDERS. Not surprisingly, the\nbytes of the 8 KB ROM are used up almost com-\npletely. Only a single byte is left unused at the very\nend of the code. When counting four more bytes\nfrom three orphaned entries in the game’s lookup\ntables, only five bytes in total out of 8,192 bytes are\nactually not used. ROMmemory was extremely pre-\ncious. Here are some techniques that demonstrate\n\n6unzip pocorgtfo13.pdf AIM-239.pdf #Item 149, page 73.\n\n12\n\nNote that x is calculated first and then used in\nthe second expression. When using primed coordi-\nnates for the resulting coordinates after calculating\nthe two expressions we get\n\ny\n\nv= “4+ ez\n\ng:=—ea' +2\n=—e(atez) +z\n=—exr+(1—e?)z\n\nor in matrix form\n\n(2 )-(20 122 )G)\n\nSurprisingly, this turns out to be a rotation ma-\ntrix, because its determinant is (1 x (1 —e?) — (—e x\ne)) = 1. (Incidentally, the column vectors of this\nmatrix do not form an orthogonal basis, as their\nscalar product is 1 x e + (—e x (1 — e?)) = —e?.\nOrthogonality holds for e = 0 only.)\n\nThis kind of rotation calculation is described\nby Marvin Minsky in AIM 239 HAKMEM® and is\n\ncalled “Minsky Rotation.”\n\n2.3.5 Subroutine Implementation Details\n\nTo better understand how the implementation of\nthis subroutine works, we must again look at Equa-\ntions 3-6. If you rearrange the expressions a little,\ntheir structure is always of the form:\n\nTERM1 := TERM1 SIGN TERM2/64\n\nor shorter\n\nTERM1 := TERM1 SIGN TERM3\n\nwhere TERM3 := TERM2/64 and SIGN := + or — and\nwhere TERM1 and TERM2 are coordinates. In fact, this\nis all this subroutine actually does: It simply adds\nTERM2 divided by 64 to TERM1 or subtracts TERM2\ndivided by 64 from TERM1.\n\nWhen calling this subroutine the correct table\nindices for the appropriate coordinates TERM1 and\nTERM2 are passed in the CPU’s Y and X registers,\nrespectively.\n\nWhat about SIGN between TERM1 and TERM3?\nAgain, have a look at Equations 3-6. To compute\n\nSunzip pocorgtfo13.pdf AIM-239.pdf #Item 149, page 73.\n\n12\n\nthe two new coordinates after a rotation, the SIGN\ntoggles from plus to minus and vice versa. The SIGN\nis initialized with the value of JOYSTICKDELTA ($6D)\nbefore calling subroutine ROTATE ($B69B, Figure 3)\nand is toggled in every call of this subroutine. The\ninitial value of SIGN should be positive (+, byte\nvalue $01) if the rotation is clockwise (the joystick is\npushed right or up) and negative (—, byte value $FF)\nif the rotation is counter-clockwise (the joystick is\npushed left or down), respectively. Because SIGN is\nalways toggled in ROTATE ($B69B) before the adding\nor subtraction operation of TERM1 and TERM3 takes\nplace, you have to pass the already toggled value\nwith the first call.\n\nUnclear still are three instructions starting at ad-\ndress $B6AD. They seem to set the two least signifi-\ncant bits of TERM3 in a random fashion. Could this\nbe some quick hack to avoid messing with exact but\npotentially lengthy two’s-complement arithmetic?\n\n2.4 Dodging Memory Limitations\n\nIt is impressing how much functionality was\nsqueezed into STAR RAIDERS. Not surprisingly, the\nbytes of the 8 KB ROM are used up almost com-\npletely. Only a single byte is left unused at the very\nend of the code. When counting four more bytes\nfrom three orphaned entries in the game’s lookup\ntables, only five bytes in total out of 8,192 bytes are\nactually not used. ROM memory was extremely pre-\ncious. Here are some techniques that demonstrate\n\n\n\n\n; INPUT\n2 ;\n\n; X = Pos i t i on vector component index o f TERM2. Used va lues are :\n4 ; $00 . . $30 −> z−component ( z−coord inate ) o f po s i t i on vector 0 . . 4 8\n\n; $31 . . $61 −> x−component (x−coord inate ) o f po s i t i on vector 0 . . 4 8\n6 ; $62 . . $92 −> y−component (y−coord inate ) o f po s i t i on vector 0 . . 4 8\n\n;\n8 ; Y = Pos i t i on vector component index o f TERM1. Used va lues are :\n\n; $00 . . $30 −> z−component ( z−coord inate ) o f po s i t i on vector 0 . . 4 8\n10 ; $31 . . $61 −> x−component (x−coord inate ) o f po s i t i on vector 0 . . 4 8\n\n; $62 . . $92 −> y−component (y−coord inate ) o f po s i t i on vector 0 . . 4 8\n12 ;\n\n; JOYSTICKDELTA ($6D) = I n i t i a l value o f SIGN . Used va lues are :\n14 ; $01 −> (= Pos i t i v e ) Rotate r i gh t or up\n\n; $FF −> (= Negative ) Rotate l e f t or down\n16\n\n; TERM3 i s a 24−b i t value , r epre sented by 3 bytes as\n18 ; $ ( s i gn ) ( high byte ) ( low byte )\n\n=006A L .TERM3LO = $6A ; TERM3 ( high byte ) , where TERM3 := TERM2 / 64\n20 =006B L .TERM3HI = $6B ; TERM3 ( low byte ) , where TERM3 := TERM2 / 64\n\n=006C L .TERM3SIGN = $6C ; TERM3 ( s ign ) , where TERM3 := TERM2 / 64\n22\n\nB69B BDAD09 ROTATE LDA ZPOSSIGN,X ;\n24 B69E 4901 EOR #$01 ;\n\nB6A0 F002 BEQ SKIP224 ; Skip i f s i gn o f TERM2 i s p o s i t i v e\n26 B6A2 A9FF LDA #$FF ;\n\n28 B6A4 856B SKIP224 STA L .TERM3HI ; I f TERM2 pos . −> TERM3 := $0000xx (= TERM2 / 256)\nB6A6 856C STA L .TERM3SIGN ; I f TERM2 neg . −> TERM3 := $FFFFxx (= TERM2 / 256)\n\n30 B6A8 BD400A LDA ZPOSHI ,X ; where xx := TERM2 ( high byte )\nB6AB 856A STA L .TERM3LO ;\n\n32\nB6AD AD0AD2 LDA RANDOM ; (? ) Hack to avoid messing with two−complement ’ s\n\n34 B6B0 09BF ORA #$BF ; (? ) a r i thmet i c ? Provides two l e a s t s i g n i f i c a n t\nB6B2 5DD30A EOR ZPOSLO,X ; (? ) b i t s B1 . . 0 in TERM3.\n\n36\nB6B5 0A ASL A ; TERM3 := TERM3 ∗ 4 (= TERM2 / 256 ∗ 4 = TERM2 / 64)\n\n38 B6B6 266A ROL L .TERM3LO ;\nB6B8 266B ROL L .TERM3HI ;\n\n40 B6BA 0A ASL A ;\nB6BB 266A ROL L .TERM3LO ;\n\n42 B6BD 266B ROL L .TERM3HI ;\n\n44 B6BF A56D LDA JOYSTICKDELTA ; Toggle SIGN fo r next c a l l o f ROTATE\nB6C1 49FF EOR #$FF ;\n\n46 B6C3 856D STA JOYSTICKDELTA ;\nB6C5 301A BMI SKIP225 ; I f SIGN negat ive then subtract , e l s e add TERM3\n\n48\n;∗∗∗ Addition ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗\n\n50 B6C7 18 CLC ; TERM1 := TERM1 + TERM3\nB6C8 B9D30A LDA ZPOSLO,Y ; (24− b i t add i t i on )\n\n52 B6CB 656A ADC L .TERM3LO ;\nB6CD 99D30A STA ZPOSLO,Y ;\n\n54\nB6D0 B9400A LDA ZPOSHI ,Y ;\n\n56 B6D3 656B ADC L .TERM3HI ;\nB6D5 99400A STA ZPOSHI ,Y ;\n\n58\nB6D8 B9AD09 LDA ZPOSSIGN,Y ;\n\n60 B6DB 656C ADC L .TERM3SIGN ;\nB6DD 99AD09 STA ZPOSSIGN,Y ;\n\n62 B6E0 60 RTS ;\n\n64 ;∗∗∗ Subtract ion ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗\nB6E1 38 SKIP225 SEC ; TERM1 := TERM1 − TERM3\n\n66 B6E2 B9D30A LDA ZPOSLO,Y ; (24− b i t subt rac t i on )\nB6E5 E56A SBC L .TERM3LO ;\n\n68 B6E7 99D30A STA ZPOSLO,Y ;\n\n70 B6EA B9400A LDA ZPOSHI ,Y ;\nB6ED E56B SBC L .TERM3HI ;\n\n72 B6EF 99400A STA ZPOSHI ,Y ;\n\n74 B6F2 B9AD09 LDA ZPOSSIGN,Y ;\nB6F5 E56C SBC L .TERM3SIGN ;\n\n76 B6F7 99AD09 STA ZPOSSIGN,Y ;\nB6FA 60 RTS ;\n\nFigure 3. ROTATE Subroutine at $B69B\n\n13\n\n\n\nthe fierce fight for each spare ROM byte.\n\n2.4.1 Loop Jamming\n\nLoop jamming is the technique of combining two\nloops into one, reusing the loop index and option-\nally skipping operations of one loop when the loop\nindex overshoots.\n\nHow much bytes are saved by loop jamming? As\nan example, Figure 4 shows an original 19-byte frag-\nment of subroutine INITIALIZE ($B3BA) using loop\njamming. The same fragment without loop jam-\nming, shown in Figure 5, is 20 bytes long. So loop\njamming saved one single byte.\n\nAnother example is the loop that is set up at\n$A165 in INITCOLD ($A14A). A third example is the\nloop set up at $B413 in INITIALIZE ($B3BA). This\nloop does not explicitly skip loop indices, thus sav-\ning four more bytes (the CMP and BCS instructions)\non top of the one byte saved by regular loop jam-\nming. Thus, seven bytes are saved in total by loop\njamming.\n\n2.4.2 Sharing Blank Characters\n\nOne more technique to save bytes is to let strings\nshare their leading and trailing blank characters. In\nthe game there is a header text line of twenty char-\nacters that displays one of the strings “LONG RANGE\nSCAN,” “AFT VIEW,” or “GALACTIC CHART.” The dis-\nplay hardware directly points to their location in the\nROM. They are enclosed in blank characters (bytes\nof value $00) so that they appear horizontally cen-\ntered.\n\nA naive implementation would use 3 × 20 = 60\nbytes to store these strings in ROM. In the actual\nimplementation, however, the trailing blanks of one\nheader string are reused as leading blanks of the\nfollowing header, as shown in Figure 6. By shar-\ning blank characters the required memory is reduced\nfrom 60 bytes to 54 bytes, saving six bytes.\n\n2.4.3 Reusing Interrupt Exit Code\n\nYet another, rather traditional technique is to reuse\ncode, of course. Figure 7 shows the exit code of the\nVertical Blank Interrupt handler VBIHNDLR ($A6D1)\nat $A715, which jumps into the exit code of the Dis-\nplay List Interrupt handler DLSTHNDLR ($A718) at\n$A74B, reusing the code that restores the registers\nthat were put on the CPU stack before entering the\nVertical Blank Interrupt handler.\n\nThis saves another six bytes (PLA, TAY, PLA, TAX,\nPLA, RTI), but spends three bytes (JMP JUMP004), in\ntotal saving three bytes.\n\n2.5 Bugs\nThere are a few bugs, or let’s call them glitches, in\nSTAR RAIDERS. This is quite astonishing, given the\ncomplex game and the development tools of 1979,\nand is a testament to thorough play testing. The\ninteresting thing is that the often intense game play\ndistracts the players’ attention from noticing these\nglitches, just like what a skilled parlor magician\nwould do.\n\n2.5.1 A Starbase Without Wings\n\nWhen a starbase reaches the lower edge of the graph-\nics screen and overlaps with the Control Panel Dis-\nplay below (Figure 8 (left), screenshot) and you\nnudge the starbase a little bit more downward, its\nwings suddenly vanish (Figure 8 (right), screenshot).\n\nThe reason is shown in the insert on the right\nside of the figure: The starbase is a composite of\nthree Players (sprites). Their bounding boxes are\nindicated by three white rectangles. If the verti-\ncal position of the top border of a Player is larger\nthan a vertical position limit, indicated by the tip\nof the white arrow, the Player is not displayed. The\nrelevant location of the comparison is at $A534 in\nGAMELOOP ($A1F3). While the Player of the central\npart of the starbase does not exceed this vertical\nlimit, the Players that form the starbase’s wings do\nso, and are thus not rendered.\n\nThis glitch is rarely noticed because players do\ntheir best to keep the starbase centered on the\nscreen, a prerequisite for a successful docking.\n\n2.5.2 Shuffling Priorities\n\nThere are two glitches that are almost impossible to\nnotice (and I admit some twisted kind of pleasure to\nexpose them, ;-):\n\n• During regular gameplay, the Zylon ships and\nthe photon torpedoes appear in front of the\ncross hairs (Figure 9 (left)), as if the cross hairs\nwere light years away.\n\n• During docking, the starbase not only appears\nbehind the stars (Figure 9 (right)) as if the\nstarbase is light years away, but the transfer\nvessel moves in front of the cross hairs!\n\n14\n\n\n\n1 B3BA A259 INITIALIZE LDX #89 ; Set 89(+1) GRAPHICS7 rows from DSPLST+5 on\nB3BC A90D LOOP060 LDA #$0D ; Prep DL in s t r u c t i o n $0D ( one row of GRAPHICS7)\n\n3 B3BE 9D8502 STA DSPLST+5,X ; DSPLST+5,X := one row of GRAPHICS7\nB3C1 E00A CPX #10 ;\n\n5 B3C3 B005 BCS SKIP195 ;\nB3C5 BDA9BF LDA PFCOLORTAB,X ; Copy PLAYFIELD co l o r tab l e to zero−page tab l e\n\n7 B3C8 95F2 STA PF0COLOR,X ; ( loop jamming )\nB3CA CA SKIP195 DEX ;\n\n9 B3CB 10EF BPL LOOP060 ;\n\nFigure 4. INITIALIZE Subroutine at $B3BA (Excerpt)\n\n1 B3BA A259 INITIALIZE LDX #89 ; Set 89(+1) GRAPHICS7 rows from DSPLST+5 on\nB3BC A90D LOOP060 LDA #$0D ; Prep DL in s t r u c t i o n $0D ( one row of GRAPHICS7)\n\n3 B3BE 9D8502 STA DSPLST+5,X ; DSPLST+5,X := one row of GRAPHICS7\nB3C1 CA DEX ;\n\n5 B3C2 10F8 BPL LOOP060 ;\nB3C4 A209 LDX #9 ;\n\n7 B3C6 BDAABF LOOP060B LDA PFCOLORTAB,X ; Copy PLAYFIELD co l o r tab l e to zero−page tab l e\nB3C9 95F2 STA PF0COLOR,X ;\n\n9 B3CB CA DEX ;\nB3CC 10F8 BPL LOOP060B ;\n\nFigure 5. INITIALIZE Subroutine Without Loop Jamming (Excerpt)\n\nThe reason is the drawing order or “graphics pri-\nority” of the bit-mapped graphics and the Players\n(sprites). It is controlled by the PRIOR ($D01B) hard-\nware register.\n\nDuring regular flight, see Figure 9 (left), PRIOR\n($D01B) has a value of $11. This arranges the dis-\nplayed elements in the following order, from front to\nback:\n\n• Players 0-4 (photon torpedoes, Zylon ships,\n. . . )\n\n• Bit-mapped graphics (stars, cross hairs)\n\n• Background.\n\nThis arrangement is fine for the stars as they are\nbit-mapped graphics and need to appear behind the\nphoton torpedoes and the Zylon ships, but this ar-\nrangement applies also to the cross hairs – causing\nthe glitch.\n\nDuring docking, see Figure 9 (right), PRIOR\n($D01B) has a value of $14. This arranges the dis-\nplayed elements the following order, from front to\nback:\n\n• Player 4 (transfer vessel)\n\n• Bit-mapped graphics (stars, cross hairs)\n\n• Players 0-3 (starbase, . . . )\n\n• Background.\n\nThis time the arrangement is fine for the cross\nhairs as they are bit-mapped graphics and need to\nappear in front of the starbase, but this arrangement\nalso applies to the stars. In addition, the Player of\nthe white transfer vessel correctly appears in front\nof the bit-mapped stars, but also in front of the bit-\nmapped cross hairs.\n\nFixing these glitches is hardly possible, as the\ndisplay hardware does not allow for a finer control\nof graphics priorities for individual Players.\n\n2.6 A Mysterious Finding\nA simple instruction at location $A175 contained\nthe most mysterious finding in the game’s code.\nThe disassembler reported the following instruction,\nwhich is equivalent to STA $0067,X. (ISVBISYNC has\na value of $67.)\nA175 9D6700 STA ISVBISYNC,X\n\nThe object code assembled from this instruction\nis unusual as its address operand was assembled\nas a 16-bit address and not as an 8-bit zero-page\naddress. Standard 6502 assemblers would always\ngenerate shorter object code, producing 9567 (STA\n$67,X) instead of 9D6700 and saving a byte.\n\nIn my reverse engineered source code, the only\nway to reproduce the original object code was the\nfollowing:\n\n15\n\n\n\n;∗∗∗ Header text o f Long−Range Scan view ( share s spaces with f o l l ow ing header ) ∗\n2 A0F8 00006C6F LRSHEADER .BYTE $00 , $00 , $6C , $6F , $6E , $67 , $00 , $72 ; ‘ ‘ LONG RANGE SCAN’ ’\n\nA0FC 6E670072\n4 A100 616E6765 .BYTE $61 , $6E , $67 , $65 , $00 , $73 , $63 , $61\n\nA104 00736361\n6 A108 6E .BYTE $6E\n\n8 ;∗∗∗ Header text o f Aft view ( share s spaces with f o l l ow ing header ) ∗∗∗∗∗∗∗∗∗∗∗∗∗\nA109 00000000 AFTHEADER .BYTE $00 , $00 , $00 , $00 , $00 , $00 , $61 , $66 ; ‘ ‘ AFT VIEW ‘ ‘\n\n10 A10D 00006166\nA111 74007669 .BYTE $74 , $00 , $76 , $69 , $65 , $77 , $00 , $00\n\n12 A115 65770000\nA119 00 .BYTE $00\n\n14\n;∗∗∗ Header text o f Ga lac t i c Chart view ∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗∗\n\n16 A11A 00000067 GCHEADER .BYTE $00 , $00 , $00 , $67 , $61 , $6C , $61 , $63 ; ‘ ‘ GALACTIC CHART ‘ ‘\nA11E 616C6163\n\n18 A122 74696300 .BYTE $74 , $69 , $63 , $00 , $63 , $68 , $61 , $72\nA126 63686172\n\n20 A12A 74000000 .BYTE $74 , $00 , $00 , $00\n\nFigure 6. Header Texts at $A0F8\n\nA6D1 A9FF VBIHNDLR LDA #$FF ; Star t o f Ve r t i c a l Blank In t e r rupt handler\n2 . . .\n\nA715 4C4BA7 SKIP046 JMP JUMP004 ; End of Ve r t i c a l Blank In t e r rupt handler\n4 . . .\n\nA718 48 DLSTHNDLR PHA ; Star t o f Display L i s t In t e r rupt handler\n6 . . .\n\nA74B 68 JUMP004 PLA ; Restore r e g i s t e r s\n8 A74C A8 TAY ;\n\nA74D 68 PLA ;\n10 A74E AA TAX ;\n\nA74F 68 PLA ;\n12 A750 40 RTI ; End of Display L i s t In t e r rupt Handler\n\nFigure 7. VBIHNDLR and DLSTHNDLR Handlers Share Exit Code\n\n1 ; HACK: Fake STA ISVBISYNC,X with 16b addr\nA175 9D .BYTE $9D\n\n3 A176 6700 .WORD ISVBISYNC\n\nI speculated for a long time whether this strange\nassembler output indicated that the object code of\nthe original ROM cartridge was produced with a\nnon-standard 6502 assembler. I have heard that\nAtari’s in-house development systems ran on PDP-\n11 hardware. Luckily, the month after I finished\nmy reverse engineering effort, the original STAR\nRAIDERS source code re-surfaced.7 To my aston-\nishment it uses exactly the same “hack” to repro-\nduce the three-byte form of the STA ISVBISYNC,X\ninstruction:\n\n1 A175 9D .BYTE $9D ; STA ABS,X\nA176 67 00 .WORD PAGE0 ; STA PAGE0,X (ABSOLUTE)\n\nUnfortunately the comments do not give a clue\nwhy this pattern was chosen. After quite some time\n\nit made click: The instruction STA ISVBISYNC,X is\nused in a loop which iterates the CPU’s X register\nfrom 0 to 255 to clear memory. By using this instruc-\ntion with a 16-bit address (“indexed” mode operand)\nmemory from $0067 to $0166 is cleared. Had the\ncode been using the same operation with an 8-bit ad-\ndress (“indexed, zero-page” mode operand), memory\nfrom $0067 to $00FF would have been cleared, then\nthe indexed address would have wrapped back to\n$0000 clearing memory $0000 to $0066, effectively\noverwriting already initialized memory locations.\n\n2.7 Documenting Star Raiders\n\nRight from the start of reverse engineering STAR\nRAIDERS I not only wanted to understand how the\ngame worked, but I also wanted to document the re-\nsult of my effort. But what would be an appropriate\nform?\n\nFirst, I combined the emerging memory map file\nwith the fledgling assembly language source code in\n\n7https://archive.org/details/AtariStarRaidersSourceCode\nunzip pocorgtfo13.pdf StarRaidersOrig.pdf\n\n16\n\n\n\nFigure 8. A Starbase’s Wings Vanish\n\nFigure 9. Photon torpedo in front of cross hairs and a starbase behind the stars!\n\norder to work with just one file. Then, I switched\nthe source code format to that of MAC/65, a well-\nknown and powerful macro assembler for the Atari\n8-bit Home Computer System. I also planned, at\nsome then distant point in the future, to assemble\nthe finished source code with this assembler on an\n8-bit Atari.\n\nAnother major influence on the emerging docu-\nmentation was the Atari BASIC Source Book, which\nI came across by accident8. It reproduced the com-\nplete, commented assembly language source code of\nthe 8 KB Atari BASIC interpreter cartridge, a truly\nnon-trivial piece of software. But what was more:\nThe source code was accompanied by several chap-\nters of text that explained in increasing detail its\nconcepts and architecture, that is, how Atari BASIC\nactually worked. Deeply impressed, I decided on\nthe spot that my reverse engineered STAR RAIDERS\nsource code should be documented at the same level\nof detail.\n\nThe overall documentation structure for the\nsource code, which I ended up with was fourfold: On\nthe lowest level, end-of-line comments documented\nthe functionality of individual instructions. On the\nnext level, line comments explained groups of in-\nstructions. One level higher still, comments com-\n\nposed of several paragraphs introduced each sub-\nroutine. These paragraphs provided a summary of\nthe subroutine’s implementation and a description\nof all input and output parameters, including the\nvalid value ranges, if possible. On the highest level,\nI added the memory map to the source code as a\nhandy reference. I also planned to add some chap-\nters on the game’s general concepts and overall ar-\nchitecture, just like the Atari BASIC Source Book\nhad done. Unfortunately, I had to drop that idea\ndue to lack of time. I also felt that the detailed sub-\nroutine documentation was quite sufficient. How-\never, I did add sections on the 3D coordinate system\nand the position and velocity vectors to the source\ncode as a tip of the hat to the Atari BASIC Source\nBook.\n\nAfter I was well into reverse engineering STAR\nRAIDERS, slowly adding bits and pieces of informa-\ntion to the raw disassembly of the STAR RAIDERS\nROM and fleshing out the ever growing documen-\ntation, I started to struggle with establishing a con-\nsistent and uniform terminology for the documenta-\ntion (Is it “asteroid,” “meteorite,” or “meteor”? “Ex-\nplosion bits,” “explosion debris,” or “explosion frag-\nments”? “Gun sights” or “cross hairs”?) A look into\nthe STAR RAIDERS instruction manual clarified only\n\n8The Atari BASIC Source Book by Wilkinson, O’Brien, and Laughton. A COMPUTE! publication.\n\n17\n\n\n\na painfully small amount of cases. Incidentally, it\nalso contradicted itself as it called the enemies “Cy-\nlons” while the game called them “Zylons,” such as\nin the message “SHIP DESTROYED BY ZYLON FIRE.”\n\nBut I was not only after uniform documenta-\ntion, I also wanted to unify the symbol names of\nthe source code. For example, I had created a\nhodge-podge of color-related symbol names, which\ncontained fragments such as “COL,” “CLR,” “COLR,”\nand “COLOR.” To make matters worse, color-related\nsymbol names containing “COL” could be confused\nwith symbol names related to (pixel) columns. The\nsame occurred with symbol names related to Players\n(sprites), which contained fragments such as “PL,”\n“PLY,” “PLYR,” “PLAY,” and “PLAYER,” or with sym-\nbol names of lookup tables, which ended in “TB,”\n“TBL,” “TAB,” and “TABLE,” and so on. In addition\nto inventing uniform symbol names I also did not\nwant to exceed a self-imposed symbol name limit of\n15 characters. So I refactored the source code with\nthe search-and-replace functionality of the text edi-\ntor over and over again.\n\n18\n\n\n\nI noticed that I spent more and more time\non refactoring the documentation and the symbol\nnames and less time on adding actual content. In\naddition, the actual formatting of the emerging doc-\numented source code had to be re-adjusted after ev-\nery refactoring step. Handling the source code be-\ncame very unwieldy. And worst of all: How could\nI be sure that the source code still represented the\nexact binary image of the ROM cartridge?\n\nThe solution I found to this problem eventually\nwas to create an automated build pipeline, which\ndealt with the monotonous chores of formatting and\nassembling the source code, as well as comparing the\nproduced ROM cartridge image with a reference im-\nage. This freed time for me to concentrate on the\nactual source code content. Yet another incarnation\nof “separation of form and content,” the automated\nbuild pipeline was always a pleasure to watch work-\ning its magic. (Mental note: I should have created\nthis pipeline much earlier in the reverse engineering\neffort.) These are the steps of the automated build\npipeline:\n\n1. The pipeline starts with a raw, documented as-\nsembly language source code file. It is already\nroughly formatted and uses a little propri-\netary markup, just enough to mark up sections\nof meta-comments that are to be removed in\nthe output as well as subroutine documen-\ntation containing multiple paragraphs, num-\nbered, and unnumbered lists. This source code\nfile is fed to a pre-formatter program, which\nI implemented in Java. The pre-formatter re-\nmoves the meta-comments. It also formats the\nentries of the memory map and the subroutine\n\ndocumentation by wrapping multi-line text at\na preset right margin, out- and indenting list\nitems, numbering lists, and vertically aligning\nparameter descriptions. It also corrects the\nnumber of trailing asterisks in line comments,\nand adjusts the number of asterisks of the box\nheaders that introduce subroutine comments,\ncentering their text content inside the asterisk\nboxes.\n\n2. The output of the pre-formatter from step 1 is\nfed into an Atari 6502 assembler, which I also\nwrote in Java. It is available as open-source\non GitHub.9 Why write an Atari 6502 assem-\nbler? There are other 6502 assemblers readily\navailable, but not all produce object code for\nthe Atari 8-bit Home Computer System, not\nall use the MAC/65 source code format, and\nnot all of them can be easily tweaked when\nnecessary. The output of this step is both an\nassembler output listing and an object file.\n\n3. The assembler output listing from step 2 is the\nfinished, formatted, reverse engineered STAR\nRAIDERS source code, containing the docu-\nmentation, the source code, and the object\ncode listing.\n\n4. The assembler output listing from step 2 is fed\ninto a symbol checker program, which I again\nwrote in Java. It searches the documenta-\ntion parts of the assembler output listing and\nchecks if every symbol, such as “GAMELOOP,” is\nfollowed by its correct hex value, “($A1F3).” It\nreports any symbol with missing or incorrect\nhex values. This ensures further consistency\nof the documentation.\n\n5. The object file of step 2 is converted by yet an-\nother program I wrote in Java from the Atari\nexecutable format into the final Atari ROM\ncartridge format.\n\n6. The output from step 5 is compared with a\nreference binary image of the original STAR\nRAIDERS 8 KB ROM cartridge. If both im-\nages are the same, then the entire build was\nsuccessful: The raw assembly language source\ncode really represents the exact image of the\nSTAR RAIDERS 8 KB ROM cartridge\n\n9git clone https://github.com/lwiest/Atari6502Assembler\nunzip pocorgtfo13.pdf Atari6502Assembler.zip\n\n19\n\n\n\nTypical build times on my not-so-recent Win-\ndows XP box (512 MB) were 15 seconds.\n\nFor some finishing touches, I ran a spell-checker\nover the documented assembly language source code\nfile from time to time, which also helped to improve\ndocumentation quality.\n\n2.8 Conclusion\nAfter quite some time, I achieved my goal to create a\nreverse engineered, complete, and fully documented\nassembly language source code of STAR RAIDERS.\nFor final verification, I successfully assembled it with\nMAC/65 on an Atari 800 XL with 64 KB RAM (em-\nulated with Atari800Win Plus). MAC/65 is able to\nassemble source code larger than the available RAM\nby reading the source code as several chained files.\nSo I split the source code (560 KB) into chunks of 32\nKB and simply had the emulator point to a hard disk\nfolder containing these files. The resulting assembler\noutput listing and the object file were written back\nto the same hard disk folder. The object file, after\nbeing transformed into the Atari cartridge format,\nexactly reproduced the original STAR RAIDERS 8 KB\nROM cartridge.\n\n2.9 Postscript\nI finished my reverse engineering effort in Septem-\nber 2015. I was absolutely thrilled to learn that in\nOctober 2015 scans of the original STAR RAIDERS\nsource code re-surfaced. To my delight, inspection\nof the original source code confirmed the findings of\nmy reverse engineered version and caused only a few\ntrivial corrections. Even more, the documentation\nof my reverse engineered version added a substan-\ntial amount of information – from overall theory of\noperation down to some tricky details – to the un-\nderstanding of the often sparsely commented origi-\nnal (quite expected for source code never meant for\npublication).\n\n20\n\n\n\n21\n\n00 7f 47 47 47 47 47 7f 00 30 10 10 10 38 38 38 00 78 08 08 78 40 40 78 00 78 08 08 7c 0c 0c 7c 00 60 60 60 6c 7c 0c 0c 00 78 40 40 78\n08 08 78 00 78 48 40 40 7e 42 7e 00 7c 44 04 1c 10 10 10 00 38 28 28 7c 6c 6c 7c 00 7c 44 44 7c 0c 0c 0c 00 00 00 00 00 00 00 00 38 38\n38 00 00 38 38 38 80 80 80 80 80 80 80 ff 00 3c 20 20 78 60 60 7c 00 66 99 99 99 66 00 00 00 00 00 7e 00 00 00 00 00 18 18 18 7e 18 18\n18 00 18 7e db 99 db 7e 18 66 66 66 66 66 2c 38 30 00 7c 44 44 7c 68 6c 6c 00 1c 3e 63 5d 63 3e 1c 00 46 46 44 7c 64 66 66 fe 92 10 18\n18 18 18 18 fc 8c 8c 80 80 80 84 fc 00 00 00 00 00 00 00 ff 80 80 80 80 80 80 80 80 00 00 00 00 00 00 00 80 80 aa 9c be 9c aa 80 ff 80\n98 80 b6 80 8c 80 ff 80 8e 80 b8 80 9c 80 ff 80 b0 98 be 98 b0 80 ff 00 00 6c 6f 6e 67 00 72 61 6e 67 65 00 73 63 61 6e 00 00 00 00 00\n00 61 66 74 00 76 69 65 77 00 00 00 00 00 00 67 61 6c 61 63 74 69 63 00 63 68 61 72 74 00 00 00 60 46 1a a1 f0 47 35 0d 07 07 07 07 07\n07 07 07 80 46 1f 0d 46 71 09 06 06 41 80 02 a9 00 8d 0f d2 85 66 85 62 85 63 a9 03 8d 0f d2 a0 2f a9 ff 84 65 85 64 a9 00 aa 9d 00 d0\n9d 00 d4 e0 0f b0 03 9d 00 d2 9d 00 d3 9d 67 00 e8 d0 ea ca 9a d8 a9 02 20 0f ae a9 51 8d 16 02 a9 a7 8d 17 02 a9 d1 8d 22 02 a9 18 8d\n00 02 a9 a6 8d 23 02 a9 a7 8d 01 02 a9 04 8d 02 d3 a9 11 8d 1b d0 a9 03 8d 1d d0 20 ba b3 a2 0a 20 45 b0 a5 64 29 80 a8 a2 5f a9 08 20\nf1 ad a9 20 85 71 a9 80 8d 02 d4 a9 02 8d 03 d4 a9 3e 8d 00 d4 a9 00 8d 07 d4 a9 10 85 79 a6 62 bc 0c bf 20 23 b2 a9 40 8d 0e d2 58 a9\nc0 8d 0e d4 a5 67 f0 fc a9 00 85 67 a5 7a f0 20 a2 04 e8 bc 5b 0c b9 00 08 85 68 b9 64 08 85 69 bc 8c 0c bd bd 0c 91 68 e4 7a 90 e6 a9\n00 85 7a a5 c0 30 2d a6 79 86 7a bd f9 0b 9d 5b 0c a8 b9 00 08 85 68 b9 64 08 85 69 bd 2a 0c 4a 4a 9d 8c 0c a8 b1 68 9d bd 0c 1d ee 0c\n91 68 ca e0 04 d0 d7 a5 66 10 0e a9 00 8d e3 17 8d e4 17 8d bc 17 8d bb 17 a9 00 ac 5f 0c ae c1 0c 99 00 03 c8 ca 10 f9 ac 5e 0c ae c0\n0c 99 00 07 c8 ca 10 f9 ac 5d 0c ae bf 0c 99 00 06 c8 ca 10 f9 ac 5c 0c ae be 0c 99 00 05 c8 ca 10 f9 ac 5b 0c ae bd 0c 99 00 04 c8 ca\n10 f9 ad 90 0c c9 01 a4 e8 ae fd 0b 8e 5f 0c ad f2 0c 85 6a 8d c1 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 03 c8 e8 c6 6a 10 ef ad 8f 0c c9 01\na4 e7 ae fc 0b 8e 5e 0c ad f1 0c 85 6a 8d c0 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 07 e8 c8 c6 6a 10 ef ad 8e 0c c9 01 a4 e6 ae fb 0b 8e 5d\n0c ad f0 0c 85 6a 8d bf 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 06 e8 c8 c6 6a 10 ef a4 e5 ae fa 0b 8e 5c 0c ad ef 0c 85 6a 8d be 0c b9 b1 b9\n9d 00 05 e8 c8 c6 6a 10 f4 a4 e4 ae f9 0b 8e 5b 0c ad ee 0c 85 6a 8d bd 0c b9 b1 b9 9d 00 04 e8 c8 c6 6a 10 f4 ad 2a 0c 8d 00 d0 ad 2b\n0c 8d 01 d0 ad 2c 0c 8d 02 d0 ad 2d 0c 8d 03 d0 ad 2e 0c 8d 07 d0 18 69 02 8d 06 d0 69 02 8d 05 d0 69 02 8d 04 d0 24 d0 30 3a a5 c8 f0\n19 85 6d a4 79 84 6e 18 98 aa 69 31 a8 20 9b b6 98 aa a4 6e 20 9b b6 88 10 eb a5 c9 f0 19 85 6d a4 79 84 6e 18 98 aa 69 62 a8 20 9b b6\n98 aa a4 6e 20 9b b6 88 10 eb a6 79 e0 05 b0 05 bd 8c 0c f0 19 38 bd d3 0a e5 70 9d d3 0a bd 40 0a e5 c1 9d 40 0a bd ad 09 e9 00 9d ad\n09 ca 10 db a6 79 e0 10 d0 02 a2 04 8a a8 a9 00 85 6b b9 66 0b 10 09 49 7f 18 69 01 b0 02 c6 6b 18 79 d3 0a 99 d3 0a b9 40 0a 65 6b 99\n40 0a b9 ad 09 65 6b 99 ad 09 98 18 69 31 c9 90 90 ce ca 10 c4 a0 04 98 aa a9 02 85 6a bd ad 09 c9 02 90 10 0a a9 00 9d ad 09 b0 05 fe\nad 09 49 ff 9d 40 0a 8a 18 69 31 aa c6 6a 10 e0 88 10 d7 a5 d0 c9 02 b0 5c a6 79 a9 ff bc ad 09 c4 d0 f0 4b bd 0f 0a d0 12 38 a9 00 fd\n35 0b 85 6a a9 00 fd a2 0a 85 6b 4c 7d a4 bd 35 0b 85 6a bd a2 0a 85 6b 20 21 aa 20 1e b7 bd de 09 d0 12 38 a9 00 fd 04 0b 85 6a a9 00\nfd 71 0a 85 6b 4c a4 a4 bd 04 0b 85 6a bd 71 0a 85 6b 20 21 aa 20 fb b6 ca 10 a6 20 62 b1 24 d0 50 31 a2 31 20 6f a7 2c 96 09 70 27 a6\n79 bd 40 0a bc ad 09 d0 02 49 ff a8 b9 e9 0d 20 1e b7 bd 71 0a bc de 09 d0 02 49 ff a8 b9 e9 0d 20 fb b6 ca 10 db a2 05 ca 10 03 4c 79\na5 a9 00 95 e4 9d ee 0c 24 d0 10 0b e0 03 90 eb ad 0a d2 a0 f2 30 2b d5 e9 f0 e0 70 f3 bc 40 0a 24 7b 50 1e e0 02 b0 16 ad 2c 0c 18 7d\ndb be 9d 2a 0c ad fb 0b 18 69 04 9d f9 0b ac 42 0a a5 76 29 0f 85 6b 98 bc f9 0b c0 cc b0 af a4 d0 f0 02 49 ff c9 20 b0 a5 c9 10 90 02\na9 0f 85 6a 1d 8c 0c 4a a8 b9 2f be 95 e4 b9 7f be 9d ee 0c 98 4a 4a 4a a8 b9 d1 bf c0 08 d0 03 4d 0a d2 a4 6a 59 db bf 45 6b bc df b8\n99 ee 00 4c e7 a4 a0 af a6 81 a5 8b f0 0c c6 8b a0 4f 29 20 f0 04 a2 42 a0 60 84 f4 86 f6 a6 79 bd 40 0a a4 d0 c0 01 d0 09 c9 f0 b0 03\n20 64 b7 49 ff c9 10 90 02 a9 0f 0a 29 1c 05 72 a8 b9 90 ba 85 6a bd 2a 0c 29 03 a8 b9 b0 ba 25 6a 9d ee 0c ca e0 05 b0 ca 24 64 50 03\n4c 9b a6 20 fe af ad 00 d3 a8 29 03 aa bd f5 ba 85 c9 98 4a 4a 29 03 aa bd f5 ba 85 c8 20 3d af 20 29 ae 2c 95 09 70 40 a5 7e f0 3c a5\nd0 d0 03 20 bf a7 ae 5c 09 a5 bf 30 05 aa 09 80 85 bf b5 e9 d0 0b 8a 49 01 aa b5 e9 d0 03 ae 5c 09 8e 5c 09 a5 7c f0 13 a5 d0 c9 02 b0\n0d 49 01 dd ad 09 f0 06 aa bd cf be 85 ca 20 e6 ac 20 79 aa a5 7b d0 5c a5 eb f0 58 ac 42 0a c8 c0 02 b0 50 ac 73 0a c8 c0 02 b0 48 ac\na4 0a c8 c0 02 b0 40 20 e1 ae a0 02 20 6b ac a2 7f a5 81 d0 1e a2 0a 20 45 b0 a0 23 a2 08 20 0a b1 a2 5f a0 80 a9 08 20 f1 ad 20 0d ae\na2 40 86 e3 a2 ff 86 8a a9 00 85 eb a9 02 85 be a2 01 20 6f b8 a2 0a 20 a8 ae a4 63 ad 1f d0 49 ff 29 03 85 63 f0 1a 88 10 17 85 66 c9\n02 b0 06 a9 00 a8 4c 5e a1 e6 62 a5 62 29 03 85 62 4c 5a a1 20 04 b8 20 9b a8 20 16 b2 20 e4 b4 4c f3 a1 a9 ff 85 67 a9 e0 8d 09 d4 a6\nf6 ad 0a d2 24 8a 50 07 30 04 29 72 09 40 aa a5 d0 c9 03 90 02 a2 a0 86 f6 a2 08 b5 ee 9d 12 d0 ca 10 f8 8d 1e d0 20 ab b2 e6 77 d0 0d\na5 66 30 09 e6 66 10 05 a0 00 4c 5c a1 4c 4b a7 48 8a 48 98 48 a9 e0 ac 0b d4 c0 60 f0 02 a9 a0 8d 09 d4 a2 04 8d 0a d4 b5 f7 9d 16 d0\nca 10 f8 ad 08 d0 0d 09 d0 0d 0a d0 0d 0b d0 85 83 ad 0f d0 85 82 68 a8 68 aa 68 40 48 a9 00 8d 0e d2 a9 40 8d 0e d2 ad 09 d2 09 c0 85\nca 68 40 99 a4 00 e8 88 10 0e 20 82 a7 a9 05 85 a2 2c 95 09 70 09 a0 02 bd f9 ba c9 fe d0 e4 60 a9 55 85 6b a5 a4 85 6e 29 7f 85 a4 a4\na5 b9 00 08 85 68 b9 64 08 85 69 a5 a6 4a 4a 85 6a a5 a6 29 03 a8 b9 b0 ba 25 6b a4 6a 11 68 91 68 24 6e 10 04 e6 a5 d0 02 e6 a6 c6 a4\nd0 d0 60 ae 5c 09 a4 a2 c0 05 b0 24 a5 a0 85 a6 b9 6e bf 0a 85 6c 90 0d a9 81 85 a4 a5 a1 85 a5 a9 aa 20 84 a7 e6 a6 a5 6c d0 e8 e6 a1\ne6 a2 60 c0 0a 90 f9 b5 e9 f0 3c bd 71 0a bc de 09 f0 08 c9 0c 90 0a a9 0b 10 06 c9 f5 b0 02 a9 f5 18 69 83 85 a0 bd a2 0a 49 ff bc 0f\n0a d0 08 c9 05 90 0a a9 04 10 06 c9 fa b0 02 a9 fa 18 69 4d 85 a1 a9 00 85 a2 a9 36 85 68 a9 1b 85 69 a2 0e a0 06 b1 68 29 55 91 68 88\n10 f7 18 a5 68 69 28 85 68 90 02 e6 69 ca 10 e7 ae 5c 09 c8 a5 88 f0 04 c6 88 d0 39 a5 a0 c9 81 90 33 c9 85 b0 2f a9 aa 8d fe 1b 8d 04\n1c a5 a1 c9 4b 90 21 c9 4f b0 1d a9 aa 8d 9e 1c 8d a4 1c bd 40 0a c9 0c b0 0e a0 a0 8c 40 1d 8c 68 1d 8c 42 1d 8c 6a 1d 84 a3 60 a4 c0\nf0 61 a5 70 c9 fe b0 5c c9 80 90 03 20 b4 a9 a9 03 8d 5c 09 a9 90 8d 8f 0c 85 ec a9 1f 8d 43 0a 38 ad fc 0b e9 77 18 65 c5 29 7f 85 8e\n38 ad 2d 0c e9 7d 18 65 c4 29 7f 85 8f a5 62 f0 11 ad 0a d2 a4 d0 f0 06 8d 2d 0c 8d fc 0b c9 10 b0 14 ad 0a d2 09 10 25 c6 8d 9a 0b ad\n0a d2 09 10 25 c6 8d cb 0b 60 98 30 11 a9 ff 85 c0 a2 00 20 a6 b3 20 a7 b1 a0 1b 4c 8d a9 c6 91 f0 05 a2 02 4c 6f b8 a0 19 20 87 a9 a5\n8f 85 8d a5 8e 85 8c 4a 29 07 aa bd b3 bf 85 c7 a4 92 84 90 a9 00 85 7b be c9 08 10 2e a9 ff 85 7b a0 00 a9 00 99 68 0b a9 01 99 af 09\nad 0a d2 25 c7 99 42 0a 98 18 69 31 a8 c9 93 90 e5 ad 42 0a 09 71 8d 42 0a a2 02 4c be b7 f0 0e a9 ff 85 8b a2 06 20 a6 b3 a0 75 20 23\nb2 60 a2 01 20 6f b8 a0 17 a9 00 85 71 85 c0 a9 10 85 79 a9 00 85 c1 85 73 85 8a 8d 8f 0c 85 80 c0 17 f0 04 85 e9 85 ea 85 eb 85 ec 85\ned 85 75 8d 5c 09 4c 23 b2 c6 c2 10 68 a9 01 85 c1 a9 30 85 79 a9 03 85 c2 a6 c3 a9 12 85 69 ad 0a d2 29 03 a8 b9 3a bb 9d 71 0a b9 3e\nbb 9d a2 0a 20 be b7 8a a8 a9 05 85 6e 18 a5 68 69 50 85 68 9d d3 0a a5 69 69 00 85 69 9d 40 0a a9 00 9d 66 0b 9d 97 0b 9d c8 0b a9 01\n9d ad 09 a9 63 9d f9 0b 9d 2a 0c 20 c1 ac ca e0 11 b0 02 a2 30 c6 6e 10 c7 86 c3 60 a9 00 85 6d a9 07 85 6e 46 6b 66 6a a5 d0 d0 0f bd\n40 0a 4a 85 69 bd d3 0a 6a 85 68 4c 52 aa 38 a9 00 fd d3 0a 85 68 a9 00 fd 40 0a 4a 85 69 66 68 06 6d 38 a5 6a e5 68 a8 a5 6b e5 69 90\n06 85 6b 84 6a e6 6d 06 6a 26 6b 90 03 a9 ff 60 c6 6e 10 df a4 6d b9 e9 0d 60 a5 c0 05 7b d0 f9 a5 86 f0 30 a6 89 38 bd f9 0b ed fc 0b\n90 02 a9 00 20 ca ae 8d cb 0b 8d cc 0b 38 ad 2d 0c fd 2a 0c 20 ca ae 8d 9a 0b 38 ad 2e 0c fd 2a 0c 20 ca ae 8d 9b 0b a2 03 d6 ba 10 27\n8a 4a a8 b9 c8 00 a4 d0 f0 05 49 ff 18 69 01 18 75 b4 10 02 a9 00 c9 10 90 02 a9 0f 95 b4 c9 08 90 02 49 0f 0a 95 ba ca 10 d2 ad 8e 0c\nd0 1b a4 62 b9 85 bf ae a4 0a 10 02 29 7f 8d ca 0b 09 80 ae 73 0a 10 02 29 7f 8d 99 0b a5 76 29 03 f0 2e a5 e6 f0 04 a5 eb d0 25 ad 0a\nd2 c9 04 b0 1e a9 60 8d 8e 0c a2 02 20 64 b7 a9 3c 85 eb a9 88 8d 68 0b a9 00 8d 2c 0c 8d 99 0b 8d ca 0b 60 a5 a7 49 01 85 a7 aa b5 e9\nd0 42 a5 e9 05 ea 29 01 a4 90 d9 c9 08 b0 ba a9 ff 95 e9 ad 0a d2 29 07 a8 b9 89 bf 9d 8c 0c a5 62 f0 03 b9 91 bf 95 a8 a9 01 95 aa 9d\nad 09 ad 0a d2 25 c7 9d a2 0a 69 13 9d 71 0a 09 71 9d 40 0a 20 be b7 bd 40 0a c9 20 b0 11 bd ad 09 f0 08 b5 e4 f0 08 c9 29 f0 04 a9 00\n95 a8 d6 aa 10 24 a9 78 95 aa a5 62 ac 0a d2 c0 30 90 01 4a 4a 95 b8 b5 a8 2c 0a d2 10 02 49 0f 95 ac e8 e8 e0 06 90 f1 a6 a7 b5 a8 d0\n32 a4 a7 c0 31 b0 13 b9 b8 00 4a b9 40 0a b0 06 c9 0a 90 0e b0 04 c9 f5 b0 04 b9 ad 09 4a a9 0f b0 02 a9 00 95 ac 18 98 69 31 a8 e8 e8\ne0 06 90 d2 a6 a7 a4 a7 b5 b2 d5 ac f0 08 b0 04 f6 b2 90 02 d6 b2 86 6a aa bd 99 bf a6 6a 99 66 0b 98 18 69 31 a8 e8 e8 e0 06 90 dc a6\na7 ad 8e 0c d0 0b a5 eb d0 06 a5 be f0 03 c6 be 60 18 bd a2 0a 69 02 c9 05 b0 f5 a0 d0 bd ad 09 4a bd 40 0a b0 08 49 ff a4 62 f0 e4 a0\n50 c9 20 b0 de 8c 68 0b a9 00 8d 8e 0c 8d 2c 0c a9 3e 85 eb a2 02 a4 a7 84 bf 4c af ac a9 80 85 73 a2 30 86 79 ad 0a d2 29 0f 79 2a 0c\ne9 30 9d 2a 0c ad 0a d2 29 0f 79 f9 0b 4a e9 10 9d f9 0b 20 af ac ad 0a d2 29 87 9d 66 0b ad 0a d2 29 87 9d 97 0b ad 0a d2 29 87 9d c8\n0b ca e0 10 d0 c5 60 b9 ad 09 9d ad 09 b9 40 0a 9d 40 0a b9 d3 0a 9d d3 0a b9 de 09 9d de 09 b9 71 0a 9d 71 0a b9 0f 0a 9d 0f 0a b9 a2\n0a 9d a2 0a b9 04 0b 9d 04 0b b9 35 0b 9d 35 0b 60 a5 7b f0 fb a5 d0 d0 05 a9 14 8d 1b d0 a9 02 8d 5c 09 a9 30 8d 8e 0c a9 20 8d 8d 0c\na9 40 8d 8c 0c a9 ff a6 90 bc c9 08 30 02 a9 00 85 e9 85 ea 85 eb 85 7b 30 0a a0 02 20 6b ac a2 0a 4c a8 ae ad 42 0a d0 0a ad d5 0a c9\n20 b0 03 ee d5 0a ad 2c 0c 38 e9 78 c9 10 b0 22 ad fb 0b 38 e9 68 c9 10 b0 18 ad 42 0a c9 02 b0 11 ad af 09 2d 11 0a 49 01 05 70 0d a4\n0a 05 71 f0 10 a5 75 c9 02 90 05 a0 1f 20 23 b2 a9 00 85 75 60 24 75 70 0d 30 42 a5 75 d0 f5 c6 75 a0 1c 4c 23 b2 a2 00 86 65 a4 d1 d0\ne6 a9 50 8d 90 0c a9 01 8d b1 09 8d e2 09 8d 13 0a 8d a6 0a 8d 9b 0b a9 10 8d 44 0a a9 00 8d 75 0a a9 87 8d 6a 0b a9 81 85 75 8d cc 0b\n85 ed 60 ad b1 09 d0 fa a2 0c 20 a6 b3 a0 21 20 23 b2 a2 05 bd 8b bb 9d 92 09 ca 10 f7 a9 89 a2 03 9d 55 09 ca 10 fa a9 07 8d 6a 0b a9\n81 8d 9b 0b a9 01 8d cc 0b 85 75 4c 7b b0 78 85 6a ad 0b d4 c9 7c 90 f9 b9 62 ba c8 10 02 a9 0d 9d 80 02 e8 c6 6a d0 f0 58 60 a9 10 85\n69 a9 00 a8 85 68 85 a3 85 7a 91 68 c8 d0 fb e6 69 a4 69 c0 20 a8 90 f2 60 a5 84 ac 10 d0 84 84 d0 0e 84 66 a6 c0 d0 08 a6 87 c9 01 f0\n03 b0 18 60 b5 ec c9 e8 b0 f9 ac 5c 09 84 89 a9 0c a4 a3 84 86 f0 02 a9 00 85 88 84 84 2c 92 09 70 e1 30 05 8a 49 01 85 87 8a 9d e1 09\nbd 73 bf 9d 74 0a a9 ff 95 ec 9d a5 0a a9 00 9d 8f 0c 9d 43 0a 9d 07 0b 9d 12 0a 9d 38 0b a9 01 9d b0 09 9d d6 0a a5 d0 4a 6a 09 66 9d\n69 0b a9 00 9d 9a 0b 9d cb 0b a2 02 20 6f b8 a2 00 8a d0 06 a5 e1 c9 18 b0 18 a0 07 bd 20 bf 99 da 00 e8 88 10 f6 bd 20 bf 8d 08 d2 bd\n21 bf 8d 04 d2 60 a0 80 b0 04 49 ff a0 00 84 6a c9 08 90 02 a9 07 a8 a5 6a 19 c9 bf 60 24 64 30 57 a6 62 ad 0a d2 dd 10 bf b0 4d 29 07\nc9 06 b0 47 aa bd 92 09 0a 30 eb a5 eb c9 1e a9 80 bc 14 bf 90 17 e0 03 d0 05 2c 96 09 70 0e e0 04 d0 05 2c 95 09 70 05 a9 c0 bc 1a bf\n1d 92 09 9d 92 09 84 65 2c 95 09 50 07 a9 00 85 7e 20 0d ae a0 52 20 23 b2 a2 12 20 a6 b3 60 a2 02 ca 10 01 60 bd 8f 0c d0 f7 b5 ec f0\nf3 b5 82 29 07 f0 ed 4a c9 03 d0 01 4a a8 b9 e9 00 f0 e1 a5 d0 f0 02 a9 ff 85 6c 59 40 0a c9 10 90 02 a9 0f 4a 84 6b a8 a5 6c 5d 43 0a\nd9 75 bf b0 c2 d9 7d bf 90 bd a4 6b 38 a9 ff f5 ec 85 e2 c9 0f 90 05 b9 8c 0c c9 80 a9 00 85 88 95 ec b0 4b 99 e9 00 b9 8c 0c f0 43 c9\n60 f0 3f a9 00 85 86 a6 90 de c9 08 10 13 a9 00 9d c9 08 38 a5 cb e9 03 85 cb a5 cc e9 00 85 cc 60 18 a5 cb 69 06 85 cb a5 cc 69 00 85\n\n00 7f 47 47 47 47 47 7f 00 30 10 10 10 38 38 38 00 78 08 08 78 40 40 78 00 78 08 08 7c 0c 0c 7c 00 60 60 60 6c 7c 0c 0c 00 78 40 40 78\n08 08 78 00 78 48 40 40 7e 42 7e 00 7c 44 04 1c 10 10 10 00 38 28 28 7c 6c 6c 7c 00 7c 44 44 7c 0c 0c 0c 00 00 00 00 00 00 00 00 38 38\n38 00 00 38 38 38 80 80 80 80 80 80 80 ff 00 3c 20 20 78 60 60 7c 00 66 99 99 99 66 00 00 00 00 00 7e 00 00 00 00 00 18 18 18 7e 18 18\n18 00 18 7e db 99 db 7e 18 66 66 66 66 66 2c 38 30 00 7c 44 44 7c 68 6c 6c 00 1c 3e 63 5d 63 3e 1c 00 46 46 44 7c 64 66 66 fe 92 10 18\n18 18 18 18 fc 8c 8c 80 80 80 84 fc 00 00 00 00 00 00 00 ff 80 80 80 80 80 80 80 80 00 00 00 00 00 00 00 80 80 aa 9c be 9c aa 80 ff 80\n98 80 b6 80 8c 80 ff 80 8e 80 b8 80 9c 80 ff 80 b0 98 be 98 b0 80 ff 00 00 6c 6f 6e 67 00 72 61 6e 67 65 00 73 63 61 6e 00 00 00 00 00\n00 61 66 74 00 76 69 65 77 00 00 00 00 00 00 67 61 6c 61 63 74 69 63 00 63 68 61 72 74 00 00 00 60 46 1a a1 f0 47 35 0d 07 07 07 07 07\n07 07 07 80 46 1f 0d 46 71 09 06 06 41 80 02 a9 00 8d 0f d2 85 66 85 62 85 63 a9 03 8d 0f d2 a0 2f a9 ff 84 65 85 64 a9 00 aa 9d 00 d0\n9d 00 d4 e0 0f b0 03 9d 00 d2 9d 00 d3 9d 67 00 e8 d0 ea ca 9a d8 a9 02 20 0f ae a9 51 8d 16 02 a9 a7 8d 17 02 a9 d1 8d 22 02 a9 18 8d\n00 02 a9 a6 8d 23 02 a9 a7 8d 01 02 a9 04 8d 02 d3 a9 11 8d 1b d0 a9 03 8d 1d d0 20 ba b3 a2 0a 20 45 b0 a5 64 29 80 a8 a2 5f a9 08 20\nf1 ad a9 20 85 71 a9 80 8d 02 d4 a9 02 8d 03 d4 a9 3e 8d 00 d4 a9 00 8d 07 d4 a9 10 85 79 a6 62 bc 0c bf 20 23 b2 a9 40 8d 0e d2 58 a9\nc0 8d 0e d4 a5 67 f0 fc a9 00 85 67 a5 7a f0 20 a2 04 e8 bc 5b 0c b9 00 08 85 68 b9 64 08 85 69 bc 8c 0c bd bd 0c 91 68 e4 7a 90 e6 a9\n00 85 7a a5 c0 30 2d a6 79 86 7a bd f9 0b 9d 5b 0c a8 b9 00 08 85 68 b9 64 08 85 69 bd 2a 0c 4a 4a 9d 8c 0c a8 b1 68 9d bd 0c 1d ee 0c\n91 68 ca e0 04 d0 d7 a5 66 10 0e a9 00 8d e3 17 8d e4 17 8d bc 17 8d bb 17 a9 00 ac 5f 0c ae c1 0c 99 00 03 c8 ca 10 f9 ac 5e 0c ae c0\n0c 99 00 07 c8 ca 10 f9 ac 5d 0c ae bf 0c 99 00 06 c8 ca 10 f9 ac 5c 0c ae be 0c 99 00 05 c8 ca 10 f9 ac 5b 0c ae bd 0c 99 00 04 c8 ca\n10 f9 ad 90 0c c9 01 a4 e8 ae fd 0b 8e 5f 0c ad f2 0c 85 6a 8d c1 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 03 c8 e8 c6 6a 10 ef ad 8f 0c c9 01\na4 e7 ae fc 0b 8e 5e 0c ad f1 0c 85 6a 8d c0 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 07 e8 c8 c6 6a 10 ef ad 8e 0c c9 01 a4 e6 ae fb 0b 8e 5d\n0c ad f0 0c 85 6a 8d bf 0c b9 e4 b8 b0 03 2d 0a d2 9d 00 06 e8 c8 c6 6a 10 ef a4 e5 ae fa 0b 8e 5c 0c ad ef 0c 85 6a 8d be 0c b9 b1 b9\n9d 00 05 e8 c8 c6 6a 10 f4 a4 e4 ae f9 0b 8e 5b 0c ad ee 0c 85 6a 8d bd 0c b9 b1 b9 9d 00 04 e8 c8 c6 6a 10 f4 ad 2a 0c 8d 00 d0 ad 2b\n0c 8d 01 d0 ad 2c 0c 8d 02 d0 ad 2d 0c 8d 03 d0 ad 2e 0c 8d 07 d0 18 69 02 8d 06 d0 69 02 8d 05 d0 69 02 8d 04 d0 24 d0 30 3a a5 c8 f0\n19 85 6d a4 79 84 6e 18 98 aa 69 31 a8 20 9b b6 98 aa a4 6e 20 9b b6 88 10 eb a5 c9 f0 19 85 6d a4 79 84 6e 18 98 aa 69 62 a8 20 9b b6\n98 aa a4 6e 20 9b b6 88 10 eb a6 79 e0 05 b0 05 bd 8c 0c f0 19 38 bd d3 0a e5 70 9d d3 0a bd 40 0a e5 c1 9d 40 0a bd ad 09 e9 00 9d ad\n09 ca 10 db a6 79 e0 10 d0 02 a2 04 8a a8 a9 00 85 6b b9 66 0b 10 09 49 7f 18 69 01 b0 02 c6 6b 18 79 d3 0a 99 d3 0a b9 40 0a 65 6b 99\n40 0a b9 ad 09 65 6b 99 ad 09 98 18 69 31 c9 90 90 ce ca 10 c4 a0 04 98 aa a9 02 85 6a bd ad 09 c9 02 90 10 0a a9 00 9d ad 09 b0 05 fe\nad 09 49 ff 9d 40 0a 8a 18 69 31 aa c6 6a 10 e0 88 10 d7 a5 d0 c9 02 b0 5c a6 79 a9 ff bc ad 09 c4 d0 f0 4b bd 0f 0a d0 12 38 a9 00 fd\n35 0b 85 6a a9 00 fd a2 0a 85 6b 4c 7d a4 bd 35 0b 85 6a bd a2 0a 85 6b 20 21 aa 20 1e b7 bd de 09 d0 12 38 a9 00 fd 04 0b 85 6a a9 00\nfd 71 0a 85 6b 4c a4 a4 bd 04 0b 85 6a bd 71 0a 85 6b 20 21 aa 20 fb b6 ca 10 a6 20 62 b1 24 d0 50 31 a2 31 20 6f a7 2c 96 09 70 27 a6\n79 bd 40 0a bc ad 09 d0 02 49 ff a8 b9 e9 0d 20 1e b7 bd 71 0a bc de 09 d0 02 49 ff a8 b9 e9 0d 20 fb b6 ca 10 db a2 05 ca 10 03 4c 79\na5 a9 00 95 e4 9d ee 0c 24 d0 10 0b e0 03 90 eb ad 0a d2 a0 f2 30 2b d5 e9 f0 e0 70 f3 bc 40 0a 24 7b 50 1e e0 02 b0 16 ad 2c 0c 18 7d\ndb be 9d 2a 0c ad fb 0b 18 69 04 9d f9 0b ac 42 0a a5 76 29 0f 85 6b 98 bc f9 0b c0 cc b0 af a4 d0 f0 02 49 ff c9 20 b0 a5 c9 10 90 02\na9 0f 85 6a 1d 8c 0c 4a a8 b9 2f be 95 e4 b9 7f be 9d ee 0c 98 4a 4a 4a a8 b9 d1 bf c0 08 d0 03 4d 0a d2 a4 6a 59 db bf 45 6b bc df b8\n99 ee 00 4c e7 a4 a0 af a6 81 a5 8b f0 0c c6 8b a0 4f 29 20 f0 04 a2 42 a0 60 84 f4 86 f6 a6 79 bd 40 0a a4 d0 c0 01 d0 09 c9 f0 b0 03\n20 64 b7 49 ff c9 10 90 02 a9 0f 0a 29 1c 05 72 a8 b9 90 ba 85 6a bd 2a 0c 29 03 a8 b9 b0 ba 25 6a 9d ee 0c ca e0 05 b0 ca 24 64 50 03\n4c 9b a6 20 fe af ad 00 d3 a8 29 03 aa bd f5 ba 85 c9 98 4a 4a 29 03 aa bd f5 ba 85 c8 20 3d af 20 29 ae 2c 95 09 70 40 a5 7e f0 3c a5\nd0 d0 03 20 bf a7 ae 5c 09 a5 bf 30 05 aa 09 80 85 bf b5 e9 d0 0b 8a 49 01 aa b5 e9 d0 03 ae 5c 09 8e 5c 09 a5 7c f0 13 a5 d0 c9 02 b0\n0d 49 01 dd ad 09 f0 06 aa bd cf be 85 ca 20 e6 ac 20 79 aa a5 7b d0 5c a5 eb f0 58 ac 42 0a c8 c0 02 b0 50 ac 73 0a c8 c0 02 b0 48 ac\na4 0a c8 c0 02 b0 40 20 e1 ae a0 02 20 6b ac a2 7f a5 81 d0 1e a2 0a 20 45 b0 a0 23 a2 08 20 0a b1 a2 5f a0 80 a9 08 20 f1 ad 20 0d ae\na2 40 86 e3 a2 ff 86 8a a9 00 85 eb a9 02 85 be a2 01 20 6f b8 a2 0a 20 a8 ae a4 63 ad 1f d0 49 ff 29 03 85 63 f0 1a 88 10 17 85 66 c9\n02 b0 06 a9 00 a8 4c 5e a1 e6 62 a5 62 29 03 85 62 4c 5a a1 20 04 b8 20 9b a8 20 16 b2 20 e4 b4 4c f3 a1 a9 ff 85 67 a9 e0 8d 09 d4 a6\nf6 ad 0a d2 24 8a 50 07 30 04 29 72 09 40 aa a5 d0 c9 03 90 02 a2 a0 86 f6 a2 08 b5 ee 9d 12 d0 ca 10 f8 8d 1e d0 20 ab b2 e6 77 d0 0d\na5 66 30 09 e6 66 10 05 a0 00 4c 5c a1 4c 4b a7 48 8a 48 98 48 a9 e0 ac 0b d4 c0 60 f0 02 a9 a0 8d 09 d4 a2 04 8d 0a d4 b5 f7 9d 16 d0\nca 10 f8 ad 08 d0 0d 09 d0 0d 0a d0 0d 0b d0 85 83 ad 0f d0 85 82 68 a8 68 aa 68 40 48 a9 00 8d 0e d2 a9 40 8d 0e d2 ad 09 d2 09 c0 85\nca 68 40 99 a4 00 e8 88 10 0e 20 82 a7 a9 05 85 a2 2c 95 09 70 09 a0 02 bd f9 ba c9 fe d0 e4 60 a9 55 85 6b a5 a4 85 6e 29 7f 85 a4 a4\na5 b9 00 08 85 68 b9 64 08 85 69 a5 a6 4a 4a 85 6a a5 a6 29 03 a8 b9 b0 ba 25 6b a4 6a 11 68 91 68 24 6e 10 04 e6 a5 d0 02 e6 a6 c6 a4\nd0 d0 60 ae 5c 09 a4 a2 c0 05 b0 24 a5 a0 85 a6 b9 6e bf 0a 85 6c 90 0d a9 81 85 a4 a5 a1 85 a5 a9 aa 20 84 a7 e6 a6 a5 6c d0 e8 e6 a1\ne6 a2 60 c0 0a 90 f9 b5 e9 f0 3c bd 71 0a bc de 09 f0 08 c9 0c 90 0a a9 0b 10 06 c9 f5 b0 02 a9 f5 18 69 83 85 a0 bd a2 0a 49 ff bc 0f\n0a d0 08 c9 05 90 0a a9 04 10 06 c9 fa b0 02 a9 fa 18 69 4d 85 a1 a9 00 85 a2 a9 36 85 68 a9 1b 85 69 a2 0e a0 06 b1 68 29 55 91 68 88\n10 f7 18 a5 68 69 28 85 68 90 02 e6 69 ca 10 e7 ae 5c 09 c8 a5 88 f0 04 c6 88 d0 39 a5 a0 c9 81 90 33 c9 85 b0 2f a9 aa 8d fe 1b 8d 04\n1c a5 a1 c9 4b 90 21 c9 4f b0 1d a9 aa 8d 9e 1c 8d a4 1c bd 40 0a c9 0c b0 0e a0 a0 8c 40 1d 8c 68 1d 8c 42 1d 8c 6a 1d 84 a3 60 a4 c0\nf0 61 a5 70 c9 fe b0 5c c9 80 90 03 20 b4 a9 a9 03 8d 5c 09 a9 90 8d 8f 0c 85 ec a9 1f 8d 43 0a 38 ad fc 0b e9 77 18 65 c5 29 7f 85 8e\n38 ad 2d 0c e9 7d 18 65 c4 29 7f 85 8f a5 62 f0 11 ad 0a d2 a4 d0 f0 06 8d 2d 0c 8d fc 0b c9 10 b0 14 ad 0a d2 09 10 25 c6 8d 9a 0b ad\n0a d2 09 10 25 c6 8d cb 0b 60 98 30 11 a9 ff 85 c0 a2 00 20 a6 b3 20 a7 b1 a0 1b 4c 8d a9 c6 91 f0 05 a2 02 4c 6f b8 a0 19 20 87 a9 a5\n8f 85 8d a5 8e 85 8c 4a 29 07 aa bd b3 bf 85 c7 a4 92 84 90 a9 00 85 7b be c9 08 10 2e a9 ff 85 7b a0 00 a9 00 99 68 0b a9 01 99 af 09\nad 0a d2 25 c7 99 42 0a 98 18 69 31 a8 c9 93 90 e5 ad 42 0a 09 71 8d 42 0a a2 02 4c be b7 f0 0e a9 ff 85 8b a2 06 20 a6 b3 a0 75 20 23\nb2 60 a2 01 20 6f b8 a0 17 a9 00 85 71 85 c0 a9 10 85 79 a9 00 85 c1 85 73 85 8a 8d 8f 0c 85 80 c0 17 f0 04 85 e9 85 ea 85 eb 85 ec 85\ned 85 75 8d 5c 09 4c 23 b2 c6 c2 10 68 a9 01 85 c1 a9 30 85 79 a9 03 85 c2 a6 c3 a9 12 85 69 ad 0a d2 29 03 a8 b9 3a bb 9d 71 0a b9 3e\nbb 9d a2 0a 20 be b7 8a a8 a9 05 85 6e 18 a5 68 69 50 85 68 9d d3 0a a5 69 69 00 85 69 9d 40 0a a9 00 9d 66 0b 9d 97 0b 9d c8 0b a9 01\n9d ad 09 a9 63 9d f9 0b 9d 2a 0c 20 c1 ac ca e0 11 b0 02 a2 30 c6 6e 10 c7 86 c3 60 a9 00 85 6d a9 07 85 6e 46 6b 66 6a a5 d0 d0 0f bd\n40 0a 4a 85 69 bd d3 0a 6a 85 68 4c 52 aa 38 a9 00 fd d3 0a 85 68 a9 00 fd 40 0a 4a 85 69 66 68 06 6d 38 a5 6a e5 68 a8 a5 6b e5 69 90\n06 85 6b 84 6a e6 6d 06 6a 26 6b 90 03 a9 ff 60 c6 6e 10 df a4 6d b9 e9 0d 60 a5 c0 05 7b d0 f9 a5 86 f0 30 a6 89 38 bd f9 0b ed fc 0b\n90 02 a9 00 20 ca ae 8d cb 0b 8d cc 0b 38 ad 2d 0c fd 2a 0c 20 ca ae 8d 9a 0b 38 ad 2e 0c fd 2a 0c 20 ca ae 8d 9b 0b a2 03 d6 ba 10 27\n8a 4a a8 b9 c8 00 a4 d0 f0 05 49 ff 18 69 01 18 75 b4 10 02 a9 00 c9 10 90 02 a9 0f 95 b4 c9 08 90 02 49 0f 0a 95 ba ca 10 d2 ad 8e 0c\nd0 1b a4 62 b9 85 bf ae a4 0a 10 02 29 7f 8d ca 0b 09 80 ae 73 0a 10 02 29 7f 8d 99 0b a5 76 29 03 f0 2e a5 e6 f0 04 a5 eb d0 25 ad 0a\nd2 c9 04 b0 1e a9 60 8d 8e 0c a2 02 20 64 b7 a9 3c 85 eb a9 88 8d 68 0b a9 00 8d 2c 0c 8d 99 0b 8d ca 0b 60 a5 a7 49 01 85 a7 aa b5 e9\nd0 42 a5 e9 05 ea 29 01 a4 90 d9 c9 08 b0 ba a9 ff 95 e9 ad 0a d2 29 07 a8 b9 89 bf 9d 8c 0c a5 62 f0 03 b9 91 bf 95 a8 a9 01 95 aa 9d\nad 09 ad 0a d2 25 c7 9d a2 0a 69 13 9d 71 0a 09 71 9d 40 0a 20 be b7 bd 40 0a c9 20 b0 11 bd ad 09 f0 08 b5 e4 f0 08 c9 29 f0 04 a9 00\n95 a8 d6 aa 10 24 a9 78 95 aa a5 62 ac 0a d2 c0 30 90 01 4a 4a 95 b8 b5 a8 2c 0a d2 10 02 49 0f 95 ac e8 e8 e0 06 90 f1 a6 a7 b5 a8 d0\n32 a4 a7 c0 31 b0 13 b9 b8 00 4a b9 40 0a b0 06 c9 0a 90 0e b0 04 c9 f5 b0 04 b9 ad 09 4a a9 0f b0 02 a9 00 95 ac 18 98 69 31 a8 e8 e8\ne0 06 90 d2 a6 a7 a4 a7 b5 b2 d5 ac f0 08 b0 04 f6 b2 90 02 d6 b2 86 6a aa bd 99 bf a6 6a 99 66 0b 98 18 69 31 a8 e8 e8 e0 06 90 dc a6\na7 ad 8e 0c d0 0b a5 eb d0 06 a5 be f0 03 c6 be 60 18 bd a2 0a 69 02 c9 05 b0 f5 a0 d0 bd ad 09 4a bd 40 0a b0 08 49 ff a4 62 f0 e4 a0\n50 c9 20 b0 de 8c 68 0b a9 00 8d 8e 0c 8d 2c 0c a9 3e 85 eb a2 02 a4 a7 84 bf 4c af ac a9 80 85 73 a2 30 86 79 ad 0a d2 29 0f 79 2a 0c\ne9 30 9d 2a 0c ad 0a d2 29 0f 79 f9 0b 4a e9 10 9d f9 0b 20 af ac ad 0a d2 29 87 9d 66 0b ad 0a d2 29 87 9d 97 0b ad 0a d2 29 87 9d c8\n0b ca e0 10 d0 c5 60 b9 ad 09 9d ad 09 b9 40 0a 9d 40 0a b9 d3 0a 9d d3 0a b9 de 09 9d de 09 b9 71 0a 9d 71 0a b9 0f 0a 9d 0f 0a b9 a2\n0a 9d a2 0a b9 04 0b 9d 04 0b b9 35 0b 9d 35 0b 60 a5 7b f0 fb a5 d0 d0 05 a9 14 8d 1b d0 a9 02 8d 5c 09 a9 30 8d 8e 0c a9 20 8d 8d 0c\na9 40 8d 8c 0c a9 ff a6 90 bc c9 08 30 02 a9 00 85 e9 85 ea 85 eb 85 7b 30 0a a0 02 20 6b ac a2 0a 4c a8 ae ad 42 0a d0 0a ad d5 0a c9\n20 b0 03 ee d5 0a ad 2c 0c 38 e9 78 c9 10 b0 22 ad fb 0b 38 e9 68 c9 10 b0 18 ad 42 0a c9 02 b0 11 ad af 09 2d 11 0a 49 01 05 70 0d a4\n0a 05 71 f0 10 a5 75 c9 02 90 05 a0 1f 20 23 b2 a9 00 85 75 60 24 75 70 0d 30 42 a5 75 d0 f5 c6 75 a0 1c 4c 23 b2 a2 00 86 65 a4 d1 d0\ne6 a9 50 8d 90 0c a9 01 8d b1 09 8d e2 09 8d 13 0a 8d a6 0a 8d 9b 0b a9 10 8d 44 0a a9 00 8d 75 0a a9 87 8d 6a 0b a9 81 85 75 8d cc 0b\n85 ed 60 ad b1 09 d0 fa a2 0c 20 a6 b3 a0 21 20 23 b2 a2 05 bd 8b bb 9d 92 09 ca 10 f7 a9 89 a2 03 9d 55 09 ca 10 fa a9 07 8d 6a 0b a9\n81 8d 9b 0b a9 01 8d cc 0b 85 75 4c 7b b0 78 85 6a ad 0b d4 c9 7c 90 f9 b9 62 ba c8 10 02 a9 0d 9d 80 02 e8 c6 6a d0 f0 58 60 a9 10 85\n69 a9 00 a8 85 68 85 a3 85 7a 91 68 c8 d0 fb e6 69 a4 69 c0 20 a8 90 f2 60 a5 84 ac 10 d0 84 84 d0 0e 84 66 a6 c0 d0 08 a6 87 c9 01 f0\n03 b0 18 60 b5 ec c9 e8 b0 f9 ac 5c 09 84 89 a9 0c a4 a3 84 86 f0 02 a9 00 85 88 84 84 2c 92 09 70 e1 30 05 8a 49 01 85 87 8a 9d e1 09\nbd 73 bf 9d 74 0a a9 ff 95 ec 9d a5 0a a9 00 9d 8f 0c 9d 43 0a 9d 07 0b 9d 12 0a 9d 38 0b a9 01 9d b0 09 9d d6 0a a5 d0 4a 6a 09 66 9d\n69 0b a9 00 9d 9a 0b 9d cb 0b a2 02 20 6f b8 a2 00 8a d0 06 a5 e1 c9 18 b0 18 a0 07 bd 20 bf 99 da 00 e8 88 10 f6 bd 20 bf 8d 08 d2 bd\n21 bf 8d 04 d2 60 a0 80 b0 04 49 ff a0 00 84 6a c9 08 90 02 a9 07 a8 a5 6a 19 c9 bf 60 24 64 30 57 a6 62 ad 0a d2 dd 10 bf b0 4d 29 07\nc9 06 b0 47 aa bd 92 09 0a 30 eb a5 eb c9 1e a9 80 bc 14 bf 90 17 e0 03 d0 05 2c 96 09 70 0e e0 04 d0 05 2c 95 09 70 05 a9 c0 bc 1a bf\n1d 92 09 9d 92 09 84 65 2c 95 09 50 07 a9 00 85 7e 20 0d ae a0 52 20 23 b2 a2 12 20 a6 b3 60 a2 02 ca 10 01 60 bd 8f 0c d0 f7 b5 ec f0\nf3 b5 82 29 07 f0 ed 4a c9 03 d0 01 4a a8 b9 e9 00 f0 e1 a5 d0 f0 02 a9 ff 85 6c 59 40 0a c9 10 90 02 a9 0f 4a 84 6b a8 a5 6c 5d 43 0a\nd9 75 bf b0 c2 d9 7d bf 90 bd a4 6b 38 a9 ff f5 ec 85 e2 c9 0f 90 05 b9 8c 0c c9 80 a9 00 85 88 95 ec b0 4b 99 e9 00 b9 8c 0c f0 43 c9\n60 f0 3f a9 00 85 86 a6 90 de c9 08 10 13 a9 00 9d c9 08 38 a5 cb e9 03 85 cb a5 cc e9 00 85 cc 60 18 a5 cb 69 06 85 cb a5 cc 69 00 85\n\n3\n\nPoC GTFO\n\nСамиздат\n\na b\n\nc\n\n# #\nCut Here if Printing on A4 Cut Here if Printing on A4\n\n\n\n9 6\n\ncc\na2\n\n01\nfe\n\n50\n09\n\nbd\n50\n\n09\nc9\n\n4a\n90\n\n08\na9\n\n40\n9d\n\n50\n09\n\nca\n10\n\nee\n20\n\n6b\nac\n\na2\n7f\n\nbd\nc9\n\n08\n30\n\n02\nd0\n\n0a\nca\n\n10\nf6\n\na0\n3f\n\na2\n00\n\n20\n21\n\nb1\n60\n\na5\nca\n\nf0\n3e\n\na2\n14\n\n85\n6a\n\na9\n00\n\n85\n66\n\n85\nca\n\na9\n11\n\n8d\n1b\n\nd0\nbd\n\nbe\nba\n\nc5\n6a\n\nf0\n08\n\nca\n10\n\nf6\na0\n\n10\n4c\n\n23\nb2\n\ne0\n0a\n\nb0\n1d\n\na5\nc0\n\nf0\n03\n\n4c\n80\n\na9\n2c\n\n93\n09\n\n50\n06\n\ne0\n06\n\n90\n02\n\na2\n05\n\nbd\nd3\n\nba\n85\n\n80\nbd\n\nb4\nba\n\n85\n71\n\n60\ne0\n\n0e\nb0\n\n1b\nbd\n\n18\nbe\n\n85\nd0\n\nbc\n82\n\nba\na2\n\n02\na9\n\n08\n20\n\nf1\nad\n\na2\n10\n\n20\n64\n\nb7\nca\n\ne0\n05\n\nb0\nf8\n\n90\n1b\n\ne0\n11\n\nb0\n35\n\nbc\n18\n\nbe\nb5\n\n6e\n5d\n\n1b\nbe\n\n95\n6e\n\nf0\n03\n\nbc\n1e\n\nbe\n20\n\n23\nb2\n\na2\n0c\n\n20\na6\n\nb3\na2\n\n16\na4\n\n7c\nf0\n\n01\ne8\n\n8e\n5a\n\n09\n20\n\n0d\nae\n\na5\n7e\n\nf0\nb4\n\na6\nd0\n\nf0\n06\n\ne0\n01\n\nd0\nac\n\na2\n2a\n\n4c\n6f\n\na7\ne0\n\n11\nd0\n\n50\na5\n\nc0\nd0\n\n5a\na9\n\n7f\n85\n\nc0\na9\n\nff\n85\n\n71\na9\n\n1e\n85\n\n80\na9\n\n30\n85\n\nc3\na9\n\n00\n85\n\nc2\n8d\n\n74\n0a\n\n8d\n07\n\n0b\n8d\n\n38\n0b\n\n8d\n69\n\n0b\na9\n\n01\n8d\n\nb0\n09\n\n8d\ne1\n\n09\n8d\n\n12\n0a\n\n8d\na5\n\n0a\na5\n\n8f\n85\n\nc4\na5\n\n8e\n85\n\nc5\na5\n\n62\nf0\n\n0b\na5\n\n91\n2a\n\n2a\n2a\n\n29\n03\n\na8\nb9\n\nd7\nbe\n\n85\nc6\n\na0\n11\n\n4c\n23\n\nb2\ne0\n\n13\nb0\n\n0b\nad\n\n5c\n09\n\n49\n01\n\n29\n01\n\n8d\n5c\n\n09\n60\n\nd0\n08\n\nad\n00\n\nd3\nc9\n\nff\nf0\n\nf7\n60\n\na0\n76\n\na2\n04\n\na9\n00\n\n85\nec\n\n85\nd6\n\n85\nd1\n\n85\n8b\n\n8d\n07\n\nd2\n85\n\n71\n85\n\n81\n85\n\n7d\n85\n\nc0\n85\n\nc1\na9\n\nff\n85\n\n64\n84\n\n65\n8a\n\n05\n62\n\naa\nbd\n\ndd\nbe\n\n18\n65\n\ncb\naa\n\na9\n00\n\n85\nc9\n\n85\nc8\n\n65\ncc\n\n30\n25\n\n4a\n8a\n\n6a\n4a\n\n4a\n4a\n\nc9\n13\n\n90\n04\n\na9\n12\n\na2\n0f\n\n85\ncd\n\na8\n8a\n\nc0\n00\n\nf0\n0b\n\nc0\n0b\n\n90\n04\n\nc0\n0f\n\n90\n03\n\n4a\n49\n\n08\n29\n\n0f\n85\n\nce\n60\n\na5\nc0\n\nd0\n04\n\na5\nd0\n\n30\n01\n\n60\n2c\n\n97\n09\n\n30\n03\n\n20\nb9\n\nb4\na5\n\n72\n29\n\n01\nd0\n\n2e\n18\n\na5\n8f\n\n65\nc8\n\n29\n7f\n\n85\n8f\n\n18\n69\n\n3d\n8d\n\n2e\n0c\n\n18\na5\n\n8e\n65\n\nc9\n29\n\n7f\n85\n\n8e\n18\n\n69\n3f\n\n8d\nfd\n\n0b\na5\n\n8c\n18\n\n69\n3f\n\n8d\nfc\n\n0b\na5\n\n8d\n18\n\n69\n3d\n\n8d\n2d\n\n0c\na5\n\n8f\n4a\n\n4a\n4a\n\n85\n6a\n\na5\n8e\n\n29\n70\n\n05\n6a\n\n85\n92\n\naa\nbd\n\nc9\n08\n\n10\n02\n\na9\n00\n\n09\n90\n\n2c\n97\n\n09\n70\n\n03\n8d\n\n8d\n09\n\n38\na5\n\n8f\ne5\n\n8d\nb0\n\n04\n49\n\nff\n69\n\n01\n85\n\n6a\n38\n\na5\n8e\n\ne5\n8c\n\nb0\n04\n\n49\nff\n\n69\n01\n\n4a\n18\n\n65\n6a\n\na8\n4a\n\n4a\n4a\n\naa\n98\n\n29\n03\n\n18\n7d\n\ndd\nba\n\n85\n91\n\na8\na9\n\n10\n8d\n\n7d\n09\n\n8d\n7e\n\n09\n8d\n\n7f\n09\n\na2\n02\n\nfe\n7d\n\n09\nbd\n\n7d\n09\n\nc9\n1a\n\n90\n08\n\na9\n10\n\n9d\n7d\n\n09\nca\n\n10\nee\n\n88\nd0\n\ne9\n60\n\na5\nd1\n\nf0\n05\n\nc6\ncf\n\nf0\n10\n\n60\na4\n\n65\nf0\n\nfb\n84\n\nd1\na0\n\n23\na2\n\n0f\na9\n\n07\n20\n\nf1\nad\n\na2\n13\n\na9\n00\n\n85\n6b\n\n9d\n1f\n\n0d\nca\n\n10\nfa\n\na6\nd1\n\ne6\nd1\n\nd0\n09\n\na2\n0f\n\na0\n80\n\na9\n07\n\n4c\nf1\n\nad\nbd\n\naa\nbb\n\nc9\nfc\n\nd0\n0f\n\na4\nce\n\nb9\nfc\n\nbe\na6\n\n6b\n9d\n\n1f\n0d\n\na9\n3c\n\n85\ncf\n\n60\nc9\n\nfd\nd0\n\n05\na4\n\ncd\nb9\n\ne9\nbe\n\n85\n6c\n\n29\n3f\n\n85\n6a\n\na9\n2a\n\n85\n68\n\na9\nbc\n\n85\n69\n\ne6\n68\n\nd0\n02\n\ne6\n69\n\na0\n00\n\nb1\n68\n\n10\nf4\n\nc6\n6a\n\nd0\nf0\n\n29\n3f\n\n49\na0\n\na6\n6b\n\ne6\n6b\n\n9d\n1f\n\n0d\nc8\n\nb1\n68\n\n10\nf0\n\ne6\n6b\n\na9\n3c\n\n24\n6c\n\n10\n04\n\n50\n08\n\na9\nfe\n\n50\n96\n\na0\nff\n\n84\nd1\n\n85\ncf\n\n60\na5\n\nd6\nf0\n\n37\nc6\n\nd8\n10\n\n33\na5\n\nd9\nf0\n\n0a\na5\n\nd5\n30\n\n06\n85\n\nd8\na0\n\n00\nf0\n\n20\na5\n\nd4\n85\n\nd8\na6\n\nd2\ne6\n\nd2\nbd\n\n5c\nbf\n\n8d\n06\n\nd2\na0\n\na8\nc9\n\nff\nd0\n\n0c\na5\n\nd7\n85\n\nd2\nc6\n\nd3\n10\n\ne4\na0\n\n00\n84\n\nd6\n8c\n\n07\nd2\n\n84\nd9\n\na5\ne2\n\nf0\n09\n\nc6\ne2\n\nd0\n05\n\na2\n14\n\n20\na8\n\nae\na6\n\n70\n8a\n\n4a\n4a\n\n4a\n4a\n\n4a\nc5\n\ne1\n90\n\n2c\na9\n\n00\n85\n\ne1\ne8\n\n8a\n49\n\nff\n8d\n\n04\nd2\n\naa\n0a\n\n0a\n0a\n\n0a\n0a\n\n8d\n00\n\nd2\n8a\n\n4a\n4a\n\n4a\n8d\n\n02\nd2\n\n4a\n49\n\n8f\n8d\n\n03\nd2\n\n29\n87\n\n8d\n05\n\nd2\na9\n\n70\n8d\n\n08\nd2\n\n60\na5\n\ndb\nf0\n\n08\nc6\n\ndb\nd0\n\n04\na9\n\n8f\n85\n\ndc\na6\n\nda\nf0\n\n1c\nc6\n\nda\nd0\n\n0a\na9\n\naf\n85\n\ndc\na9\n\n02\n85\n\nde\n85\n\ndf\nbd\n\nea\nbf\n\n85\ndd\n\nbd\nf2\n\nbf\n8d\n\n04\nd2\n\n8d\n09\n\nd2\na5\n\ne3\nf0\n\n0e\nc6\n\ne3\nad\n\n0a\nd2\n\n8d\n04\n\nd2\n29\n\n20\n45\n\ndd\n85\n\ndd\n18\n\na5\nde\n\n65\ne0\n\n85\nde\n\n8d\n00\n\nd2\na5\n\ndf\n69\n\n00\n85\n\ndf\n8d\n\n02\nd2\n\na6\ndc\n\na4\ndd\n\na5\n72\n\n4a\n90\n\n1a\na5\n\ne1\nf0\n\n16\nc6\n\ne1\nc9\n\n11\nb0\n\n10\n8a\n\n29\n0f\n\nf0\n03\n\nca\n86\n\ndc\n98\n\n29\n0f\n\nf0\n03\n\n88\n84\n\ndd\n8e\n\n03\nd2\n\n8c\n05\n\nd2\n60\n\nbd\n3e\n\nbf\nc5\n\nd6\n90\n\n0c\na0\n\n05\nbd\n\n3e\nbf\n\n99\nd2\n\n00\ne8\n\n88\n10\n\nf6\n60\n\na2\n59\n\na9\n0d\n\n9d\n85\n\n02\ne0\n\n0a\nb0\n\n05\nbd\n\na9\nbf\n\n95\nf2\n\nca\n10\n\nef\na9\n\n70\n8d\n\n80\n02\n\n8d\n81\n\n02\na9\n\n41\n8d\n\ne7\n02\n\na9\n80\n\n8d\ne8\n\n02\na9\n\n02\n8d\n\ne9\n02\n\na2\n00\n\n86\n68\n\n86\n69\n\n86\n6a\n\n86\n6b\n\n18\na5\n\n68\n69\n\n51\n85\n\n68\na5\n\n69\n9d\n\ne9\n0d\n\n69\n00\n\n85\n69\n\n18\na5\n\n6a\n69\n\n64\n85\n\n6a\na5\n\n6b\n9d\n\ne9\n0e\n\nf8\n69\n\n00\nd8\n\n85\n6b\n\ne8\nd0\n\ndb\na2\n\n00\n86\n\n68\na9\n\n10\n85\n\n69\n18\n\na5\n68\n\n9d\n00\n\n08\n69\n\n28\n85\n\n68\na5\n\n69\n9d\n\n64\n08\n\n69\n00\n\n85\n69\n\nbd\n42\n\nbb\n9d\n\n49\n09\n\ne8\ne0\n\n64\n90\n\ne2\nca\n\n86\n78\n\na2\n03\n\n8e\n11\n\n09\nbd\n\na6\nbb\n\n85\n6a\n\na4\n62\n\nc8\nc8\n\n84\n6b\n\nad\n0a\n\nd2\n29\n\n7f\na8\n\nb9\nc9\n\n08\nd0\n\nf5\na5\n\n6a\n10\n\n21\nc0\n\n10\n90\n\ned\nc0\n\n70\nb0\n\ne9\n98\n\n29\n0f\n\nf0\ne4\n\nc9\n0f\n\nf0\ne0\n\nb9\nc8\n\n08\n19\n\nca\n08\n\n19\nd9\n\n08\n19\n\nb9\n08\n\nd0\nd2\n\na5\n6a\n\n99\nc9\n\n08\nc6\n\n6b\n10\n\nc9\nca\n\n10\nbb\n\na2\nb4\n\na9\n0a\n\n9d\n34\n\n0d\nca\n\nd0\nf8\n\na2\n0f\n\na9\n18\n\n9d\n37\n\n0d\nca\n\n10\nf8\n\na9\n1a\n\n8d\n47\n\n0d\na9\n\n00\n8d\n\n11\n09\n\na9\n48\n\n85\n90\n\na9\n43\n\n85\n8d\n\n85\n8f\n\na9\n47\n\n85\n8e\n\n85\n8c\n\na9\nea\n\n8d\ne8\n\n0f\na0\n\n00\n84\n\n6a\na6\n\n6a\nbd\n\nc9\n08\n\n10\n02\n\na9\n05\n\naa\nbd\n\nd1\nbe\n\n99\n4b\n\n0d\nc8\n\ne6\n6a\n\na5\n6a\n\n29\n0f\n\nd0\ne7\n\na9\n19\n\n99\n4b\n\n0d\nc8\n\nc8\nc8\n\nc8\nc0\n\na0\n90\n\nda\n60\n\ne6\n76\n\na2\n90\n\na5\n76\n\n10\n09\n\nac\n55\n\n09\nc0\n\n80\nd0\n\n02\na2\n\n44\n29\n\n03\n85\n\n72\nd0\n\n1f\na4\n\n7d\nf0\n\n17\na0\n\na0\n2c\n\n94\n09\n\n10\n0b\n\n70\n07\n\nad\n0a\n\nd2\nc9\n\nc8\n90\n\n07\na0\n\n00\n98\n\nd0\n02\n\na2\n26\n\n84\n81\n\n86\nfb\n\na2\n02\n\nbd\n8e\n\n0c\nd0\n\n06\nb5\n\neb\nf0\n\n02\nd6\n\neb\nca\n\n10\nf2\n\na5\n73\n\nf0\n16\n\nc6\n73\n\nd0\n04\n\na2\n11\n\n86\n79\n\nc9\n70\n\nb0\n04\n\na2\n00\n\n86\n8a\n\nc9\n18\n\nb0\n02\n\nc6\n79\n\nc6\n74\n\n10\n21\n\na9\n28\n\n85\n74\n\na2\n04\n\nfe\na3\n\n09\nbd\n\na3\n09\n\nc9\nda\n\n90\n0d\n\na9\nd0\n\n9d\na3\n\n09\ne0\n\n03\nd0\n\n01\nca\n\nca\n10\n\ne9\nc6\n\n78\n30\n\n01\n60\n\na9\n31\n\n85\n78\n\na5\ncb\n\nd0\n02\n\nc6\ncc\n\nc6\ncb\n\na6\n64\n\nd0\nef\n\n86\n6a\n\nbd\nc9\n\n08\n10\n\n19\n20\n\nf1\nb7\n\nf0\n14\n\na9\n02\n\n9d\nc9\n\n08\n85\n\n6a\n38\n\na5\ncb\n\ne9\n12\n\n85\ncb\n\na5\ncc\n\ne9\n00\n\n85\ncc\n\ne8\n10\n\ndf\na5\n\n6a\nf0\n\n0f\n2c\n\n97\n09\n\n70\n0a\n\na0\n15\n\n20\n23\n\nb2\na2\n\n18\n20\n\na6\nb3\n\nc6\n9f\n\n30\n07\n\na6\n93\n\nbd\nc9\n\n08\n30\n\n1f\na9\n\n07\n85\n\n9f\na0\n\n7f\nad\n\n0a\nd2\n\n29\n7f\n\naa\nbd\n\nc9\n08\n\n30\n0e\n\n88\n10\n\nf2\na2\n\n7f\nbd\n\nc9\n08\n\n30\n04\n\nca\n10\n\nf8\n60\n\n86\n93\n\n8a\n29\n\n0f\n85\n\n94\n8a\n\n4a\n4a\n\n4a\n4a\n\n85\n95\n\na2\nff\n\ne8\n10\n\n30\na2\n\n00\nbd\n\nc9\n08\n\n29\ndf\n\n9d\nc9\n\n08\ne8\n\n10\nf5\n\n2c\n97\n\n09\n70\n\n1d\na2\n\n00\nbd\n\nc9\n08\n\n10\n13\n\n20\nf1\n\nb7\nf0\n\n0e\na9\n\n63\n85\n\n78\na0\n\n13\n20\n\n23\nb2\n\na2\n18\n\n4c\na6\n\nb3\ne8\n\n10\ne5\n\n60\nbc\n\nc9\n08\n\nc0\n0a\n\nb0\nc6\n\nad\n0a\n\nd2\nd9\n\nbb\nbf\n\nb0\nbe\n\ne4\n90\n\nf0\nba\n\na0\n08\n\n18\n8a\n\n79\nc0\n\nbf\n85\n\n6a\n29\n\n0f\n38\n\ne5\n94\n\nb0\n04\n\n49\nff\n\n69\n01\n\n85\n6b\n\na5\n6a\n\n4a\n4a\n\n4a\n4a\n\n38\ne5\n\n95\nb0\n\n04\n49\n\nff\n69\n\n01\n18\n\n65\n6b\n\n99\n96\n\n00\n88\n\n10\nd4\n\na9\n01\n\n85\n6b\n\na0\n07\n\nb9\n96\n\n00\nc5\n\n9e\nb0\n\n24\n18\n\n8a\n79\n\nc0\nbf\n\n30\n1d\n\n84\n6a\n\na8\nb9\n\nc9\n08\n\nd0\n13\n\nbd\nc9\n\n08\nc4\n\n90\nf0\n\n0c\n09\n\n20\n99\n\nc9\n08\n\na9\n00\n\n9d\nc9\n\n08\nf0\n\n0b\na4\n\n6a\n88\n\n10\nd2\n\ne6\n9e\n\nc6\n6b\n\n10\nca\n\n4c\nea\n\nb5\nbd\n\nad\n09\n\n49\n01\n\nf0\n02\n\na9\nff\n\n85\n6b\n\n85\n6c\n\nbd\n40\n\n0a\n85\n\n6a\nad\n\n0a\nd2\n\n09\nbf\n\n5d\nd3\n\n0a\n0a\n\n26\n6a\n\n26\n6b\n\n0a\n26\n\n6a\n26\n\n6b\na5\n\n6d\n49\n\nff\n85\n\n6d\n30\n\n1a\n18\n\nb9\nd3\n\n0a\n65\n\n6a\n99\n\nd3\n0a\n\nb9\n40\n\n0a\n65\n\n6b\n99\n\n40\n0a\n\nb9\nad\n\n09\n65\n\n6c\n99\n\nad\n09\n\n60\n38\n\nb9\nd3\n\n0a\ne5\n\n6a\n99\n\nd3\n0a\n\nb9\n40\n\n0a\ne5\n\n6b\n99\n\n40\n0a\n\nb9\nad\n\n09\ne5\n\n6c\n99\n\nad\n09\n\n60\nc9\n\n50\nb0\n\n5b\n85\n\n6d\na9\n\n50\ne0\n\n05\nb0\n\n02\na9\n\n7d\nbc\n\nde\n09\n\nd0\n09\n\n38\ne6\n\n6d\ne5\n\n6d\n9d\n\n2a\n0c\n\n60\n18\n\n65\n6d\n\n9d\n2a\n\n0c\n60\n\nc9\n32\n\nb0\n38\n\n85\n6d\n\na9\n32\n\ne0\n05\n\nb0\n04\n\n06\n6d\n\na9\n7a\n\n24\nd0\n\n50\n13\n\n2c\n96\n\n09\n10\n\n07\n2c\n\n0a\nd2\n\n50\n0e\n\n70\n15\n\nbc\nad\n\n09\nd0\n\n07\nf0\n\n0e\nbc\n\n0f\n0a\n\nf0\n09\n\n38\ne6\n\n6d\ne5\n\n6d\n9d\n\nf9\n0b\n\n60\n18\n\n65\n6d\n\n9d\nf9\n\n0b\n60\n\ne0\n05\n\nb0\n06\n\na9\nfb\n\n9d\nf9\n\n0b\n60\n\na9\n63\n\n9d\nf9\n\n0b\n9d\n\n2a\n0c\n\ne0\n11\n\nb0\nf3\n\nad\n0a\n\nd2\n29\n\n0f\n85\n\n6a\n9d\n\na2\n0a\n\nad\n0a\n\nd2\n29\n\n0f\nc5\n\n6a\n90\n\n02\n85\n\n6a\n9d\n\n71\n0a\n\na9\n0f\n\n9d\n40\n\n0a\na5\n\nd0\n49\n\n01\n29\n\n01\n9d\n\nad\n09\n\nd0\n11\n\n9d\n04\n\n0b\n9d\n\n35\n0b\n\n38\ne5\n\n6a\n9d\n\n40\n0a\n\na9\n80\n\n9d\nd3\n\n0a\n24\n\nd0\n50\n\n11\nad\n\n0a\nd2\n\n9d\n71\n\n0a\nad\n\n0a\nd2\n\n9d\n40\n\n0a\n29\n\n01\n9d\n\nad\n09\n\nad\n0a\n\nd2\n29\n\n01\n9d\n\n0f\n0a\n\nd0\n0f\n\n38\nfd\n\n35\n0b\n\n9d\n35\n\n0b\na9\n\n00\nfd\n\na2\n0a\n\n9d\na2\n\n0a\nad\n\n0a\nd2\n\n29\n01\n\n9d\nde\n\n09\nd0\n\n0f\n38\n\nfd\n04\n\n0b\n9d\n\n04\n0b\n\na9\n00\n\nfd\n71\n\n0a\n9d\n\n71\n0a\n\n60\nbd\n\nc8\n08\n\nf0\n0d\n\nbd\n\nca\n08\n\nf0\n08\n\nbd\nb9\n\n08\nf0\n\n03\nbd\n\nd9\n08\n\n60\na6\n\n70\ne4\n\n71\nf0\n\n08\n90\n\n04\nc6\n\n70\nb0\n\n12\ne6\n\n70\na5\n\nc0\nd0\n\n0c\n2c\n\n93\n09\n\n10\n07\n\na5\n71\n\n2d\n0a\n\nd2\n85\n\n70\na0\n\n01\n20\n\ncd\nb8\n\n2c\n95\n\n09\n30\n\n30\na9\n\n31\na0\n\n17\n20\n\na7\nb8\n\na9\n62\n\na0\n1d\n\n20\na7\n\nb8\na9\n\n00\na0\n\n23\n20\n\na7\nb8\n\nad\n6e\n\n09\n8d\n\n6f\n09\n\nc9\n0a\n\nb0\n11\n\nae\n5c\n\n09\nbd\n\nd3\n0a\n\n4a\n4a\n\n4a\n4a\n\naa\nbd\n\ne9\n0e\n\n8d\n6f\n\n09\n18\n\na5\n7f\n\n65\n7d\n\n65\n80\n\n65\n7e\n\n69\n01\n\nc5\n7f\n\n85\n7f\n\nb0\n39\n\na2\n03\n\n24\n64\n\n70\n33\n\nde\n55\n\n09\nbd\n\n55\n09\n\nc9\n80\n\nb0\n29\n\na9\n89\n\n9d\n55\n\n09\ne0\n\n02\nd0\n\n08\na5\n\ncb\nd0\n\n02\nc6\n\ncc\nc6\n\ncb\nca\n\n10\nde\n\na2\n0a\n\n8a\na0\n\n03\n99\n\n55\n09\n\n88\n10\n\nfa\n20\n\n45\nb0\n\na0\n31\n\na2\n04\n\n20\n0a\n\nb1\n60\n\n18\n6d\n\n5c\n09\n\naa\na9\n\n10\n85\n\n6a\nbd\n\nad\n09\n\n4a\nbd\n\n40\n0a\n\nb0\n04\n\n49\nff\n\nc6\n6a\n\naa\na5\n\n6a\n99\n\n49\n09\n\n98\n29\n\n10\nf0\n\n05\ne0\n\nff\nd0\n\n01\nca\n\nbd\ne9\n\n0e\naa\n\n29\n0f\n\n99\n4b\n\n09\n8a\n\n4a\n4a\n\n4a\n4a\n\n99\n4a\n\n09\n60\n\n00\n01\n\n02\n03\n\n07\n00\n\n18\n3c\n\n7e\n7e\n\n76\nf7\n\ndf\ndf\n\nff\nff\n\nf7\n76\n\n7e\n7e\n\n3c\n18\n\n10\n38\n\n7c\n7c\n\nfe\nde\n\nda\nfa\n\nee\nee\n\n7c\n7c\n\n38\n10\n\n18\n3c\n\n3c\n7e\n\n6e\n7a\n\n7e\n76\n\n7e\n3c\n\n3c\n18\n\n10\n38\n\n38\n7c\n\n74\n7c\n\n6c\n38\n\n38\n10\n\n10\n18\n\n3c\n2c\n\n3c\n3c\n\n18\n08\n\n10\n38\n\n38\n28\n\n38\n10\n\n3c\n3c\n\n24\n3c\n\n7e\n7e\n\n7e\n5a\n\nff\nff\n\n42\n42\n\n42\n42\n\n42\n42\n\n1c\n1c\n\n14\n3e\n\n3e\n3e\n\n2a\n7f\n\n7f\n22\n\n22\n22\n\n22\n22\n\n18\n18\n\n3c\n3c\n\n3c\n3c\n\n7e\n24\n\n24\n24\n\n24\n10\n\n10\n38\n\n38\n38\n\n7c\n28\n\n28\n28\n\n18\n18\n\n3c\n18\n\n18\n10\n\n10\n38\n\n10\n18\n\n7e\nff\n\nff\nff\n\nff\nff\n\ne7\ne7\n\nff\nff\n\nff\nff\n\nff\n7e\n\n7e\n00\n\n18\n3c\n\n7e\nff\n\nff\nff\n\ne7\n66\n\nff\nff\n\nff\nff\n\n7e\n7e\n\n00\n18\n\n3c\n7e\n\nff\nff\n\ne7\n66\n\nff\nff\n\nff\nff\n\n3c\n18\n\n3c\nff\n\nff\ne7\n\n66\nff\n\nff\n7e\n\n3c\n00\n\n18\n3c\n\nff\nff\n\nff\n3c\n\n18\n18\n\n3c\nff\n\n3c\n18\n\n28\n28\n\n28\n28\n\nee\n00\n\n00\nee\n\n28\n28\n\n28\n28\n\n00\n81\n\n81\n81\n\n81\nbd\n\nff\nff\n\nbd\n81\n\n81\n81\n\n81\n82\n\n82\nba\n\nfe\nfe\n\nba\n82\n\n82\n42\n\n5a\n7e\n\n7e\n5a\n\n42\n44\n\n54\n7c\n\n7c\n54\n\n44\n24\n\n3c\n3c\n\n24\n28\n\n38\n38\n\n28\n18\n\n18\n10\n\n10\ne0\n\nf8\nf8\n\nfe\n57\n\nfe\nf8\n\nf8\nc0\n\nc0\nf0\n\nc0\nf0\n\nf0\nfc\n\nbe\nfc\n\nf0\n80\n\n80\nc0\n\nc0\nf0\n\nbc\nf0\n\nc0\n07\n\n1f\n1f\n\n7f\nea\n\n7f\n1f\n\n1f\n03\n\n03\n0f\n\n03\n0f\n\n0f\n3f\n\n7d\n3f\n\n0f\n01\n\n01\n03\n\n03\n0f\n\n3d\n0f\n\n03\n18\n\n3c\n7e\n\n7e\ndb\n\nc3\n81\n\n81\n81\n\n10\n38\n\n7c\n7c\n\nd6\nc6\n\n82\n82\n\n18\n3c\n\n3c\n66\n\n66\n42\n\n42\n10\n\n38\n38\n\n6c\n44\n\n44\n18\n\n3c\n24\n\n24\n10\n\n38\n28\n\n18\n3c\n\n7e\nff\n\n18\n18\n\nff\n7e\n\n3c\n18\n\n10\n38\n\n7c\nfe\n\n38\n38\n\nfe\n7c\n\n38\n10\n\n18\n3c\n\n7e\n18\n\n7e\n3c\n\n18\n10\n\n38\n7c\n\n10\n7c\n\n38\n10\n\n18\n3c\n\n18\n3c\n\n18\n10\n\n38\n38\n\n10\n8d\n\n00\n46\n\n49\n09\n\n20\n06\n\n00\n01\n\n2e\na1\n\n00\n00\n\n46\nf8\n\na0\n4d\n\nc8\n10\n\n00\n00\n\n46\n09\n\na1\n4d\n\nc8\n10\n\n4d\n00\n\n10\n0d\n\n0d\n0d\n\n0d\n0d\n\n30\n46\n\n1f\n0d\n\n4d\na8\n\n12\n1b\n\n13\n0b\n\n08\nff\n\nff\nff\n\nff\naa\n\nff\naa\n\nff\naa\n\naa\naa\n\nff\naa\n\naa\naa\n\naa\naa\n\naa\naa\n\n55\n55\n\naa\n55\n\naa\n55\n\n55\n55\n\naa\n55\n\n55\n55\n\n55\nc0\n\n30\n0c\n\n03\n00\n\n01\n02\n\n04\n08\n\n10\n20\n\n40\n60\n\n70\nf2\n\ndf\nde\n\nda\nd8\n\ndd\ndb\n\nf3\nf5\n\nf0\nf8\n\nff\nc0\n\nfd\ned\n\nfe\nd2\n\nf9\ne5\n\nca\ne7\n\n00\n04\n\n06\n08\n\n0a\n0c\n\n0e\n1e\n\n2d\n3c\n\n0a\n0d\n\n10\n14\n\n17\n32\n\n46\n50\n\n5a\n78\n\n7d\n82\n\n87\n8c\n\n9b\naa\n\nb8\nc8\n\nd0\nd8\n\ndf\ne8\n\nf1\nfa\n\n00\n01\n\nff\n00\n\n50\n28\n\n87\n50\n\n36\n87\n\n77\n46\n\n1e\n77\n\n56\n1e\n\n77\n46\n\n91\n94\n\n46\n91\n\n78\n4e\n\n06\n7e\n\n4b\n0f\n\n7e\n51\n\n0f\n8d\n\n4e\n07\n\n85\n47\n\n84\n7e\n\n4c\n85\n\n8c\n4c\n\n85\n85\n\n52\n84\n\n3e\n32\n\n0f\n54\n\n32\n0f\n\nfe\n4e\n\n35\n82\n\n4f\n34\n\n82\n50\n\n32\n85\n\n51\n34\n\n82\n52\n\n35\n82\n\nfe\n04\n\n04\n03\n\n02\n02\n\n03\n04\n\n04\n12\n\n0b\n00\n\n00\n0a\n\n55\n4b\n\n40\n40\n\n0a\n8d\n\n8b\n89\n\n89\n89\n\n89\n0a\n\n16\n0b\n\n00\n0a\n\n14\n0b\n\n0f\n00\n\n00\n0a\n\n51\n4b\n\n0f\n00\n\n00\n0a\n\n93\n8b\n\n0f\n00\n\n00\n00\n\n0a\n37\n\n21\n32\n\n30\n00\n\n25\n2e\n\n25\n32\n\n27\n39\n\n1a\n00\n\n00\n00\n\n10\n00\n\n00\n00\n\n00\nb4\n\na1\nb2\n\na7\na5\n\nb4\nb3\n\n9a\n00\n\n00\n24\n\n23\n1a\n\n30\n25\n\n33\n23\n\n2c\n32\n\n00\nf3\n\nf4\ne1\n\nf2\n00\n\ne4\ne1\n\nf4\ne5\n\nda\nd0\n\nd0\nce\n\nd0\nd0\n\n00\n00\n\n00\n00\n\n00\ncf\n\n04\n03\n\n02\n00\n\n05\n06\n\n42\n05\n\n06\n43\n\n04\n42\n\n04\n43\n\n06\n07\n\n42\n07\n\n43\n48\n\n09\n4a\n\n0b\ncd\n\n0b\ncc\n\n09\n4e\n\n09\n4f\n\nd0\n11\n\n92\n56\n\n13\n4e\n\n15\n4f\n\nb8\n97\n\n99\n98\n\n8c\n9d\n\n1e\n9f\n\nfd\n25\n\nfc\n78\n\n9b\n60\n\nb8\n97\n\n98\n1a\n\n8e\n1c\n\n94\n24\n\n9f\nfd\n\n25\nfc\n\na7\n68\n\nb8\n97\n\n98\n1a\n\n8f\n24\n\n9f\nfd\n\n25\nfc\n\n66\n2c\n\n5a\n2e\n\n5a\n31\n\n5a\n33\n\n5a\nb8\n\n34\n76\n\n37\nb5\n\n78\n37\n\n8c\n78\n\n23\nb5\n\n78\n23\n\n8c\n78\n\n04\nb5\n\n78\n04\n\n8c\n78\n\n06\nb5\n\n78\n06\n\n8c\n78\n\na2\n75\n\na2\n4c\n\na1\n75\n\na1\n4c\n\nc1\nb8\n\n97\n98\n\n1a\n8e\n\n24\n9f\n\nfd\n25\n\nfc\n66\n\na0\n20\n\n20\n20\n\n20\n52\n\n45\n44\n\n20\n41\n\n4c\n45\n\n52\n54\n\ncf\n4e\n\ncf\n46\n\n46\nd3\n\n48\n49\n\n45\n4c\n\n44\n53\n\nc1\n54\n\n54\n41\n\n43\n4b\n\nc3\n4f\n\n4d\n50\n\n55\n54\n\n45\n52\n\nd4\n52\n\n41\n43\n\n4b\n49\n\n4e\n47\n\nd7\n48\n\n41\n54\n\n53\n20\n\n57\n52\n\n4f\n4e\n\n47\n3f\n\nc8\n59\n\n50\n45\n\n52\n57\n\n41\n52\n\n50\nc5\n\n4e\n47\n\n41\n47\n\n45\n44\n\nd3\n54\n\n41\n52\n\n42\n41\n\n53\n45\n\nc4\n45\n\n53\n54\n\n52\n4f\n\n59\n45\n\n44\nd3\n\n55\n52\n\n52\n4f\n\n55\n4e\n\n44\n45\n\n44\nc1\n\n42\n4f\n\n52\n54\n\n45\n44\n\nc3\n4f\n\n4d\n50\n\n4c\n45\n\n54\n45\n\nc8\n59\n\n50\n45\n\n52\n53\n\n50\n41\n\n43\n45\n\ncf\n52\n\n42\n49\n\n54\nc5\n\n53\n54\n\n41\n42\n\n4c\n49\n\n53\n48\n\n45\n44\n\nc4\n4f\n\n43\n4b\n\n49\n4e\n\n47\nc5\n\n4e\n45\n\n52\n47\n\n59\nd4\n\n52\n41\n\n4e\n53\n\n46\n45\n\n52\nd3\n\n54\n41\n\n4e\n44\n\n42\n59\n\nd3\n54\n\n41\n52\n\n20\n46\n\n4c\n45\n\n45\n54\n\n20\n54\n\n4f\nd3\n\n54\n41\n\n52\n20\n\n43\n52\n\n55\n49\n\n53\n45\n\n52\n20\n\n37\nc1\n\n4c\n4c\n\n20\n55\n\n4e\n49\n\n54\n53\n\ncd\n49\n\n53\n53\n\n49\n4f\n\n4e\na0\n\n20\n20\n\n20\n53\n\n54\n41\n\n52\n20\n\n52\n41\n\n49\n44\n\n45\n52\n\n53\nda\n\n45\n52\n\n4f\nc2\n\n59\n20\n\n5a\n59\n\n4c\n4f\n\n4e\n20\n\n46\n49\n\n52\n45\n\nd0\n4f\n\n53\n54\n\n48\n55\n\n4d\n4f\n\n55\n53\n\nd2\n41\n\n4e\n4b\n\n20\n49\n\n53\n3a\n\nc3\n4f\n\n50\n59\n\n52\n49\n\n47\n48\n\n54\n20\n\n41\n54\n\n41\n52\n\n49\n20\n\n31\n39\n\n37\n39\n\nd3\n55\n\n42\n2d\n\n53\n50\n\n41\n43\n\n45\n20\n\n52\n41\n\n44\n49\n\n4f\nd3\n\n45\n43\n\n54\n4f\n\n52\n20\n\n53\n43\n\n41\n4e\n\nc5\n4e\n\n47\n49\n\n4e\n45\n\n53\nce\n\n45\n57\n\nc3\n4c\n\n41\n53\n\n53\nc3\n\n4f\n4e\n\n47\n52\n\n41\n54\n\n55\n4c\n\n41\n54\n\n49\n4f\n\n4e\n53\n\nd2\n45\n\n50\n4f\n\n52\n54\n\n20\n54\n\n4f\n20\n\n42\n41\n\n53\n45\n\nc6\n4f\n\n52\n20\n\n54\n52\n\n41\n49\n\n4e\n49\n\n4e\n47\n\nc7\n41\n\n4c\n41\n\n43\n54\n\n49\n43\n\n20\n43\n\n4f\n4f\n\n4b\nc7\n\n41\n52\n\n42\n41\n\n47\n45\n\n20\n53\n\n43\n4f\n\n57\n20\n\n43\n41\n\n50\n54\n\n41\n49\n\n4e\nd2\n\n4f\n4f\n\n4b\n49\n\n45\nce\n\n4f\n56\n\n49\n43\n\n45\nc5\n\n4e\n53\n\n49\n47\n\n4e\nd0\n\n49\n4c\n\n4f\n54\n\nc1\n43\n\n45\ncc\n\n49\n45\n\n55\n54\n\n45\n4e\n\n41\n4e\n\n54\nd7\n\n41\n52\n\n52\n49\n\n4f\n52\n\nc3\n41\n\n50\n54\n\n41\n49\n\n4e\nc3\n\n4f\n4d\n\n4d\n41\n\n4e\n44\n\n45\n52\n\nc4\n41\n\n4d\n41\n\n47\n45\n\nc4\n41\n\n4d\n41\n\n47\n45\n\n44\nc3\n\n4f\n4e\n\n54\n52\n\n4f\n4c\n\nd0\n48\n\n4f\n54\n\n4f\n4e\n\n53\na0\n\nd3\n54\n\n41\n52\n\n20\n43\n\n4f\n4d\n\n4d\n41\n\n4e\n44\n\n45\n52\n\n80\n00\n\n01\n40\n\n80\n0e\n\n09\n04\n\nff\n08\n\n02\n0b\n\n07\n01\n\n01\n11\n\n1f\n2b\n\n35\n3d\n\n75\n7a\n\n01\n0d\n\n15\n1b\n\n21\n25\n\n29\n2b\n\n2d\n38\n\n41\n36\n\n36\n00\n\n00\n00\n\n7e\n8e\n\n9d\naa\n\nb4\nbc\n\n7b\n7a\n\n47\n52\n\n5b\n50\n\n50\n00\n\n00\n00\n\n43\n53\n\n61\n6c\n\n75\n7a\n\n75\n7a\n\n01\n11\n\n1f\n2b\n\n35\n3d\n\n75\n7a\n\n61\n6a\n\n72\n79\n\n7f\n83\n\n29\n2b\n\n86\n90\n\n9a\na1\n\na8\nad\n\n29\n2b\n\nc1\nc1\n\nc1\nc1\n\nc1\nc1\n\n75\nc1\n\n0f\n0d\n\n0b\n09\n\n07\n05\n\n01\n01\n\n0b\n07\n\n05\n05\n\n03\n03\n\n01\n01\n\n09\n08\n\n05\n02\n\n00\n00\n\n00\n00\n\n0f\n0e\n\n0c\n09\n\n07\n04\n\n02\n01\n\n09\n08\n\n05\n02\n\n00\n00\n\n00\n00\n\n0f\n0d\n\n0a\n08\n\n04\n03\n\n01\n01\n\n0f\n0d\n\n0b\n09\n\n07\n05\n\n01\n01\n\n08\n07\n\n06\n05\n\n03\n02\n\n01\n01\n\n09\n09\n\n06\n06\n\n04\n03\n\n01\n01\n\n0b\n0b\n\n0b\n0b\n\n0b\n0b\n\n01\n0b\n\nf8\nff\n\n0c\n1e\n\n1e\n1d\n\n1c\n1b\n\n9f\nbf\n\ndf\nff\n\nf8\n08\n\n50\n4c\n\n3c\n6f\n\n3c\n3c\n\n32\n64\n\n28\n32\n\n28\n5a\n\na9\naa\n\naa\nab\n\nab\nac\n\nac\nad\n\nad\nae\n\nae\naf\n\nb0\nb1\n\nb2\nb3\n\nb3\nb9\n\nb9\n95\n\n95\n95\n\n94\n94\n\n94\n94\n\n93\n93\n\n93\n92\n\n92\n92\n\n91\n91\n\n91\n4a\n\n4c\n4e\n\n50\n00\n\n50\nb4\n\nfe\n55\n\n5b\n61\n\n67\n6d\n\n71\n58\n\n5e\n64\n\n6a\n6f\n\n73\n18\n\nff\n02\n\n00\n8a\n\na0\n00\n\n08\n50\n\n00\n40\n\n40\n01\n\n03\n88\n\naf\n08\n\n00\n50\n\n04\n30\n\n40\n01\n\n03\n84\n\na8\n04\n\n00\n50\n\n04\n02\n\n02\n02\n\n03\n0c\n\n02\n04\n\n03\nff\n\n10\n07\n\n04\n07\n\n04\n02\n\n02\n00\n\n07\n0b\n\n05\nff\n\n20\n02\n\n0b\n0e\n\n06\n08\n\n20\n00\n\n0e\n10\n\nff\n18\n\nff\n40\n\n60\nff\n\n10\n10\n\n10\nff\n\n40\n20\n\nff\n48\n\n40\n51\n\nff\n84\n\nb4\nfc\n\nb4\n84\n\nff\n01\n\n0c\n0c\n\n0c\n0c\n\n0e\n0e\n\n0e\n20\n\n00\n00\n\n00\n02\n\n04\n06\n\n08\n0c\n\n81\n84\n\n88\n94\n\n80\n10\n\n10\n10\n\n70\n70\n\n70\n10\n\n04\n04\n\n00\n00\n\n00\n01\n\n00\n00\n\n3e\n1e\n\n10\n08\n\n04\n02\n\n01\n00\n\n00\n81\n\n82\n84\n\n88\n90\n\n9e\nbe\n\na6\naa\n\naf\n00\n\n00\nb8\n\n5a\nfc\n\n5e\n90\n\nff\nff\n\n3f\n0f\n\n3f\n7f\n\nff\nff\n\n00\nff\n\nff\nc0\n\n20\nf0\n\nef\nff\n\n0f\n10\n\n11\n01\n\nf1\n00\n\n00\n08\n\n10\n18\n\n28\n30\n\n38\n40\n\n50\n00\n\n20\n20\n\n20\n00\n\na0\n00\n\n00\n9f\n\n0e\n0e\n\n0e\n0c\n\n0c\n0c\n\n0a\n0a\n\n0a\n08\n\n08\n08\n\n06\n06\n\n04\n04\n\n8a\n8f\n\n8d\n8b\n\n89\n87\n\n85\n83\n\n00\n04\n\n01\n04\n\n01\n04\n\n01\n04\n\n07\n00\n\n80\n4a\n\na1\n\n!7 # 8\n\nGTFO\n\n!\n\n5\n\n#\n\n4PoC\n\n\n\n23\n\nManhattan Punch Line Theatre\n\nSteve Kaplan Mitch McGuire Richard Erickson Jerry Heymann\nProducing Directors\npresents\n\na new play\nby\nMike Eisenberg\n\nHACKERS\n\nDirected by Jerry Heymann\n\n} The Story of\na Boy\n\nand\nhis Machine\n\nManhattan Punch Line\nat the Lion Theatre\nYce West Yend Street\non theatre Row\n\n23\n\n\n\n\n3 How Slow Can You Go?\nby James Forshaw\n\nWhile doing my research into Windows, I tend to\nfind quite a few race condition vulnerabilities. Al-\nthough these vulnerabilities can be exploited, you\ntypically only get a tiny window of time in which\nto do it. A fairly typical sequence of actions looks\nsomething like this:\n\n1. Do some security check.\n\n2. Access some resource.\n\n3. Perform secure action.\n\nIn this case the race condition is between the\nsecurity check and the action. If we can modify\nthe state of the system in between those actions,\nit might be possible to elevate privileges or do un-\nexpected things. The time window is typically very\nsmall, but if the code is accessing some controllable\nresource in between the check and the action, we\nmight still be able to create a very reliable exploit.\n\nI wanted to find a way of increasing the time win-\ndow to win the race in cases where the code accesses\na resource we control. The following is an overview\nof the thought process I went through to come up\nwith a working solution.\n\n3.1 Investigating Object Manager\nLookup Performance\n\nHidden under the hood of Windows NT is the Ob-\nject Manager Namespace (OMN). You wouldn’t typ-\nically interact with it directly as the Win32 API for\nthe most part hides it away. The NT kernel defines a\nset of objects, such as Files, Events, Registry Keys,\nthat can all have a name associated with them. The\nOMN provides the means to lookup these named\nobjects. It acts like a file system; for example, you\ncan specify a path to an NT system call such as\n\\BaseNamedObjects\\MyEvent, and an event can be\nthus looked up.\n\nThere are two special object types for use in the\nOMN: Object Directories and Symbolic Links. Ob-\nject Directories act as named containers for other\nobjects, whereas Symbolic Links allow a name to be\nredirected to another OMN path. Symbolic Links\nare used quite a lot; for example, the Windows drive\nletters are really symbolic links to the real storage\ndevice. When we call an NT system call, the kernel\nmust lookup the entire path, following any symbolic\nlinks until it either reaches the named object or fails\nto find a match.\n\nIn this exploit we want to make the process of\nlooking up a resource we control as slow as possible.\nFor example, if we could make it take 1 or 2 seconds,\nthen we’ve got a massive window of opportunity to\nwin the race condition. Therefore I want to find\na way of manipulating the Object Manager lookup\nprocess in such a way that we achieve this goal. I\nam going to present my approach to achieving the\nrequired result.\n\nA note about my setup: for my testing I am go-\ning to open a named Event object. All testing is\ndone on my 2.8GHz Xeon Workstation. Although it\nhas 20 physical cores, the lookup process won’t be\nparallelized, and therefore that shouldn’t be an is-\nsue. Xeons tend to have more L2/L3 cache than con-\nsumer processors, but if anything this should only\nmake our timings faster. If I can get a long lookup\ntime on my Workstation, it should be possible on\npretty much anything else running Windows. Fi-\nnally, this is all tested on an up-to-date Windows 10;\nhowever, not much has changed since Windows 7\nthat might affect the results.\n\nFirst let’s just measure the time it takes to do\n\n24\n\n\n\na normal lookup. We’ll repeat the lookup a 1, 000\ntimes and take the average. The results are prob-\nably what we’d expect: the lookup process for a\nsimple named Event is roughly 3µs. That includes\nthe system call transition, lookup process, and the\naccess check on the Event object. Although in the-\nory you could win a race, it seems pretty unlikely,\neven on a multi-core processor. So let’s think about\na way of improving the lookup time (and when I say\n“improve”, I mean making the lookup time slower).\n\nAn Object Manager path is limited to the\nmaximum string size afforded by the UNI-\nCODE_STRING structure.\n\nstruct UNICODE_STRING {\n2 USHORT Length ;\n\nUSHORT MaximumLength ;\n4 PWSTR Buf f e r ;\n\n}\n\nWe can see that the Length member is an un-\nsigned 16 bit integer, limiting the maximum length\nto 216 − 1. This, however, is a byte count, so in\nfact this limits us to 215 − 1 or 32767 characters.\nFrom this result, there are two obvious possible ap-\nproaches we can take:\n\n1. Make a path that contains one very long name.\nThe lookup process would have to compare the\nentire name using a typical string comparison\noperation to verify it’s accessing the correct\nobject. This should take linear time relative\nto the length of the string.\n\n2. Make multiple small named directories and re-\npeat. E.g., \\A\\A\\A\\A\\...\\EventName. The\nassumption here is that each lookup takes a\nfixed amount of time to complete. The oper-\nation will again be linear time relative to the\ndepth of recursion of the directories.\n\nNow it would seem likely that the cost of the en-\ntire operation of a single lookup will be worse than\na string comparison, a primitive that is typically op-\ntimized quite heavily. At this point we have not had\nto look at any actual kernel code, and we won’t start\nquite yet, so instead empirical testing seems the way\nto go.\n\nLet’s start with the first approach, making a\nlong string and performing a lookup on it. Our\nname limit is around 32767, although we’ll need\nto be able to make the object in a writable direc-\ntory such as \\BaseNamedObject, which reduces the\n\nlength slightly, but not enough to make significant\nimpact. Therefore, we’ll perform the Event opening\non names between 1 character and 32,000 characters\nin length. The results are shown below:\n\n0 8000 16000 24000 32000\n0\n\n0.025\n\n0.05\n\n0.075\n\n0.1\n\nName Length in Characters\n\nL\noo\n\nku\np \n\nT\nim\n\ne \nA\nve\n\nra\nge\n\n (\nm\n\ns)\n\nAlthough this is a little noisy, our assumption\nof a linear lookup time seems correct. The longer\nthe string, the longer it takes to look it up. For a\n32,000 character long string, this seems to top out\nat roughly 90µs – still not enough in my opinion for\na useful primitive, but certainly a start.\n\nNow let’s instead look at the recursive directory\napproach. In this case the upper bound is around\n16,000 directories. This is because each path compo-\nnent must contain a backslash and a single charac-\nter name (i.e. \\A\\A\\A...). Therefore our maximum\npath limit is halved. Of course we’d make the as-\nsumption that the time to go through the lookup\nprocess is going to be greater than the time it takes\nto compare 4 Unicode characters, but let’s test to\nmake sure. The results are shown below:\n\n0 4000 8000 12000 16000\n0\n\n1\n\n2\n\n3\n\n4\n\nDirectory Count\n\nL\noo\n\nku\np \n\nT\nim\n\ne \nA\nve\n\nra\nge\n\n (\nm\n\ns)\n\nWell, I think that’s unequivocal. For 16,000 re-\ncursive depth, the average lookup time is around\n3700µs, or around 40 times larger than the long path\nname lookup result. Now, of course, this comes with\ndownsides. For a start, you need to create 16,000 or\nso directory objects in the kernel. At least on a mod-\n\n25\n\n\n\nern 64 bit Windows this isn’t likely to be too taxing,\nhowever it’s still worth bearing in mind. Also the\nprocess must maintain a handle to each of those di-\nrectories, because otherwise they’d be deleted (as a\nnormal user cannot make kernel objects permanent).\nFortunately our handle limit for a single process is\nof the order of 16 million, so we’re a couple of orders\nof magnitude below the limit of that.\n\nNow, is 3700µs going to be enough for us?\nMaybe, it’s certainly orders of magnitude greater\nthan 3µs. But can we do better? We’ve now run\nout of path space, we’ve filled the absolute maxi-\nmum allowed string length with recursive directory\nnames. What we could do with is a method of mul-\ntiplying that effect without requiring a longer path.\nWe can do this by using Object Manager symbolic\nlinks. By placing the symbolic link as the last com-\nponent of the long path we can force the kernel to\nreparse, and start the lookup all over again. On the\nfinal lookup we’ll just point the symbolic link to the\ntarget.\n\nUltimately though we can only do this 64 times.\nWhy, can’t we do this indefinitely? Well, no—for\na fairly obvious reason: each time a symbolic link\nis encountered the kernel restarts the parsing pro-\ncesses; if you pointed a symbolic link at itself, you’d\nend up in an infinite loop. The reparse limit of 64\nprevents that from becoming a problem. The re-\nsults are as we expected, the time taken to lookup\nour event is proportional to both the number of sym-\nbolic links and the number of recursive directories.\nFor 64 symbolic links and 16,000 directories it takes\napproximately 200ms (note I’ve had to change the\norder of the result now to milliseconds). At around\n1\n5 of a second that should be enough, right? Sure,\nbut I’m greedy; I want more. How can we make the\nlookup time even worse?\n\nAt this point it’s time to break out the disassem-\nbler and see how the lookup process works under the\nhood in the kernel. First off, let’s see what an object\ndirectory structure looks like. We can dump it from\na kernel debugging session using WinDBG with the\n\n26\n\n\n\ncommand dt nt!_OBJECT_DIRECTORY. Converted\nback to a C-style structure, it looks something like\nthe following:\n\n1 struct OBJECT_DIRECTORY\n{\n\n3 POBJECT_DIRECTORY_ENTRY HashBuckets [ 3 7 ] ;\nEX_PUSH_LOCK Lock ;\n\n5 PDEVICE_MAP DeviceMap ;\nULONG Ses s i on Id ;\n\n7 PVOID NamespaceEntry ;\nULONG Flags ;\n\n9 POBJECT_DIRECTORY ShadowDirectory ;\n}\n\nBased on the presence of the HashBucket field,\nit’s safe to assume that the kernel is using a hash\ntable to store directory entries. This makes some\nsense, because if the kernel just maintained a list\nof directory entries, this would be pretty poor for\nperformance. With a hash table the lookup time\nis much reduced as long as the hashing algorithm\ndoes a good job of reducing collisions. This is only\nthe case though if the algorithm isn’t being actively\nexploited. As we’re trying to increase the cost of\nlookups, we can intentionally add entries with col-\nlisions to make the lookup process take the worst\ncase time, which is linear relative to the number of\nentries in a directory. This again provides us with\nanother scaling factor, and in this case the number\nof entries is only going to be limited by available\nmemory, as we are never going to need to put the\nname into the path.\n\nSo what’s the algorithm for the hash? The\nmain function of interest is ObpLookupObject-\nName, which is referenced by functions such as Ob-\nReferenceObjectByName. The directory entry logic\nis buried somewhere in this large function; however,\nfortunately there’s a helper function ObpLookup-\nDirectoryEntryEx, which has the same logic (it\nisn’t actually called by ObpLookupObjectName, but\nit doesn’t matter) that is smaller and easier to re-\nverse (Figure 10).\n\nSo the hashing algorithm is pretty simple; it re-\npeatedly mixes the bits of the current hash value\nand then adds the uppercase Unicode character to\nthe hash. We could work out a clever way of getting\nhash collisions from this, but actually it’s pretty sim-\nple. The object manager allows us to specify names\ncontaining NULL characters, therefore if we take our\ntarget name, say ‘A’, and prefix it with increasing\nlength strings containing only NULL, we get both\nHash and Bucket collisions. This does limit us to\n\ncreating only 32,000 or so colliding entries before we\nrun out of strings to create them, but, as we’ll see\nin a minute, that’s not a problem. Let’s look at the\nresults of doing this for a single directory:\n\n0 4000 8000 12000 16000\n0\n\n0.15\n\n0.3\n\n0.45\n\n0.6\n\nCollisions\n\nL\noo\n\nku\np \n\nT\nim\n\ne \nA\nve\n\nra\nge\n\n (\nm\n\ns)\n\nYet again, a nice linear graph. For a given col-\nlision count it’s nowhere near as good as the recur-\nsive directory approach, but it is a multiplicative\nfactor in the lookup time, which we can abuse. So\nyou’d think we can now easily apply this to all our\n16,000 recursive directories, add in symbolic links,\nand probably get an insane lookup time. Yes, we\nwould, however there’s a problem, insertion time.\nEvery time we add a new entry to a directory, the\nkernel must do a lookup to check that the entry\ndoesn’t already exist. This means that, for every\nentry we add, we must do (n − 1)2 checks in the\nhash bucket just to find that we don’t have the en-\ntry before we insert it. This means that the time\nto add a new entry is approximately proportional to\nthe square of the number of entries. Sure it’s not\na cubic or exponential increase, but that’s hardly a\nconsolation. To prove that this is the case we can\njust measure the insertion time:\n\n0 4000 8000 12000 16000\n0\n\n1500\n\n3000\n\n4500\n\n6000\n\nDirectory Count\n\nIn\nse\n\nrt\nio\n\nn \nT\n\nim\ne \n\n(m\ns)\n\nThat graph shows a pretty clear n2 trend for the\ninsertion time. If, say, we wanted to create a direc-\ntory entry with 16,000 collisions, it takes close to 5.5\nseconds. If we wanted to then do that for all 16,000\n\n27\n\n\n\nPOBJECT_DIRECTORY ObpLookupDirectoryEntryEx (POBJECT_DIRECTORY Directory ,\n2 PUNICODE_STRING Name,\n\nULONG Attr ibuteF lags ) {\n4 BOOLEAN Case InSens i t i v e = ( Att r ibuteF lags & OBJ_CASE_INSENSITIVE) != 0 ;\n\nSIZE_T CharCount = Name−>Length / s izeof (WCHAR) ;\n6 WCHAR∗ Buf f e r = Name−>Buf f e r ;\n\nULONG Hash = 0 ;\n8 while (CharCount ) {\n\nHash = (Hash / 2) + 3 ∗ Hash ;\n10 Hash += RtlUpcaseUnicodeChar (∗ Buf f e r ) ;\n\nBu f f e r++;\n12 CharCount−−;\n\n}\n14\n\nOBJECT_DIRECTORY_ENTRY∗ Entry = Directory−>HashBuckets [ Hash % 3 7 ] ;\n16 while ( Entry ) {\n\ni f ( Entry−>HashValue == Hash ) {\n18 i f ( RtlEqualUnicodeStr ing (Name,\n\nObpGetObjectName (Entry−>Object ) , Case InSens i t i v e ) ) {\n20 ObReferenceObject ( Entry−>Object ) ;\n\nreturn Entry−>Object ;\n22 }\n\n}\n24 Entry = Entry−>ChainLink ;\n\n}\n26\n\nreturn NULL;\n28 }\n\nFigure 10. ObpLookupDirectoryEntryEx()\n\n28\n\n\n\nrecursive directory entries, it would take around 24\nhours! Now, I think we’re going a bit over the top\nhere, and by fiddling with the values we can get\nsomething that doesn’t take too long to set up and\ngives us a long lookup time. But I’m still greedy; I\nwant to see how far I can push the lookup time. Is\nthere any way we can get the best of all worlds?\n\nThe final piece of the puzzle is to bring in Shadow\ndirectories, which allow the Object Manager a fall-\nback path if it can’t find an entry in a directory.\nYou can use almost any other Object Manager direc-\ntory as a shadow, which will allow us to control the\nlookup behavior. A Shadow Directory has a crucial\ndifference from symbolic links, as it doesn’t cause a\nreparse to occur in the lookup process. This means\nthey’re not restricted to the 64 reparse limit. As\neach lookup consumes a path component, eventually\nthere will be no more paths to lookup. If we put to-\ngether two directories in the following arrangement,\nwe can pass a similar path to our recursive directory\nlookup, without actually creating all the directories.\n\nShadow Directory\nLookup\n\nPath: \\A\\A\\A\\A\\A ...\n\nLookup\n\nAA\n\nSo how does this actually work? If we open a\npath of the form \\A\\A\\A\\A\\A..., the kernel will first\nlookup the initial ‘A’ directory. This is the directory\non the left of the diagram. It will then try to open\nthe next ‘A’ directory, which is on the right, which\nagain it will find. Next the kernel again looks up\n‘A’, but in this case it doesn’t exist. As the direc-\ntory has a shadow link to its parent, it looks there\ninstead, finds the same ‘A’ directory, and repeats\nthe process. This will continue until we run out of\npath elements to lookup.\n\nSo let’s determine the performance of this ap-\nproach. We’d perhaps expect it to be less perfor-\n\nmant relative to actually creating all those directo-\nries if only because of the cache effects of the pro-\ncessor. But hopefully it won’t be too far behind.\n\n0 4000 8000 12000 160000\n\n1\n\n2\n\n3\n\n4\n\nDirectory Count\n\nL\noo\n\nku\np \n\nT\nim\n\ne \nA\nve\n\nra\nge\n\n (\nm\n\ns) Linear Sub\nDirectory\n\nLinear\nShadow\nDirectory\n\nLooks good. Yes, the performance is lower than\nactually creating the directories, but once we bring\ncollisions into the mix, that’s not really going to\nmatter much. So the final result is that instead of\ncreating 16,000 directories with 16,000 collisions we\ncan do it with just 2 directories, which is far more\nmanageable and only takes around 11 seconds on\nmy workstation. So, to sign off, let’s combine every-\nthing together.\n\n1. 16,000 path components using 2 object direc-\ntories in a shadow configuration\n\n2. 16,000 collisions per directory\n\n3. 64 symbolic link reparses\n\nAnd the resulting time for a single lookup on\nmy workstation is *drum roll please* 19 minutes! I\nthink we might just be able to win the race condition\nwith that.\n\nCode examples can be found attached to this\ndocument.10\n\n3.2 Conclusion\n\nSo after all that effort we can make the kernel take\naround 19 minutes to lookup a single controlled re-\nsource path. That’s pretty impressive. We have\nmany options to get the kernel to start the lookup\nprocess, allowing us to use not just files and registry\nkeys but almost any named event. It’s a typical tale\nof unexpected behavior when facing pathological in-\nput, and it’s not really surprising Microsoft wouldn’t\noptimize for this use case.\n\n10unzip pocorgtfo13.pdf object_manager_lookup_poc.cs\n\n29\n\n\n\n4 The FaceWhisperer for USB Glitching; or,\nReading RFID with ROP and a Wacom Tablet\n\nby Micah Elizabeth Scott\n\nGreetings, neighbors!\nToday, like most days, I would like to celebrate\n\nthe diversity of tiny machines around us. This time\nI’ve prepared a USB magic trick of sorts, incorpo-\nrating techniques from the analog and the digital\ndomains.\n\nRegular readers will be well aware that computer\nperipherals are typically general-purpose computers\nthemselves, and the operating system often trusts\nthem a little too much. Devices attached to Thun-\nderbolt (PCI Express) are trusted as much as the\nCPU. Devices attached to USB, at best, are as privi-\nleged as the user, who can typically do anything they\nwant albeit slowly and using interfaces designed for\nmeat.11 If that USB device can exploit a bug in lit-\nerally any available driver, the device could achieve\neven more direct levels of control.\n\nNot only are these peripherals small computers\nwith storage and vulnerabilities and secrets, they\ntypically have very direct access to their own hard-\nware. It’s often firmware’s responsibility to set up\nclocks, program power converters, and process ana-\nlog signals. Projects like BadUSB have focused on\nreprogramming a USB device to attack the com-\nputer they’re attached to. What about using the\navailable low-level peripherals in ways they weren’t\nintended?\n\nI recently made a video, a “Graphics Tablet\nPrimer for Hackers,” going into some detail on how a\npen tablet input device actually works. I compared\nthe electromagnetic power and data transfer to the\nlow-frequency RFID cards still used by many door\naccess control systems. At the time this was just a\nconvenient didactic tool, but it did start me won-\ndering just how hard it would be to use a graphics\ntablet to read 125 kHz RFID cards.\n\nI had somewhat arbitrarily chosen a Wacom\nCTE-450 (Bamboo Fun) tablet for this experiment.\nI had one handy, and I’d already done a little pre-\nliminary reversing on its protocol and circuit design.\nIt’s old enough that it didn’t seem to use any cus-\ntom Wacom silicon, recent enough to be both cheap\nand plentiful on the second-hand market.\n\n4.1 A Very Descriptive Descriptor\n\nTypically you need firmware to analyze a device.\nDocumented interfaces are the tip of the iceberg. To\nreally see what a device is capable of, you need to\nsee everything the firmware knows how to do. Some-\ntimes this is easy to get. Back in PoC‖GTFO 7:3\nwhen I was reversing an optical drive, the firmware\nwas plainly available from the manufacturer’s web\nsite. Usually you won’t be so lucky. Manufactur-\ners often encrypt firmware to hide their crimes or\nslow down clones, and some devices don’t appear to\nsupport firmware updates at all.\n\nThis device seemed to be the latter kind. No\nfirmware updates online. No hints of a firmware up-\ndating process hidden in their drivers. The CPU\nwas something I didn’t recognize at first. I posted\n\n11unzip pocorgtfo13.pdf meat.txt\n\n30\n\n\n\nXM\nEG\n\nA1\n28\n\nD\n4\n\nM\nAX\n\n34\n21\n\nES\nM\n\nD\n\nC\nLK\n\n1\n\nC\nLK\n\n2\n\nN\nC\n\n7W\nZ1\n\n4\nN\n\nC\n7W\n\nZ1\n4\n\n.1\nuF\n\n49\n\nVU\nSB\n\n IN\n\nG\nN\n\nD\n\nG\nN\n\nD\n\nC\nLK\n\n3\n\n3.\n3V\n\n3.\n3V\n\n3.\n3V\n\nR\nES\n\nET\n\nG\nN\n\nD\n\nG\nN\n\nD\n\nG\nN\n\nD\n\n10\n0n\n\n10\n0n\n\n10\n0n\n\n10\n0n\n\n1u\n\nG\nN\n\nD\nG\n\nN\nD\n\n3.\n3V\n\n3.\n3V\n\n10\n010\nk\n\n3.\n3V\n\nR\nes\n\net\n\n1k\n\n10\n0\n\nG\nN\n\nD\n\n3.\n3V\n\nG\nN\n\nD\n\nPo\nw\n\ner\nGND\n\n1k\n\n3.3V\n\nVBUS\n1k\n\n33 33\n\nPA\n5\n\nPA\n6\n\n1k 1k\n\n3.\n3V\n\nPT\nC\n\n 2\nA\n\nG\nN\n\nD\n\nG\nN\n\nD\n\nSY\nN\n\nC\nIN\n\nG\nN\n\nD\n\nIC\n1 PE\n\n0\n28\n\nPE\n1\n\n29\nPE\n\n2\n32\n\nPE\n3\n\n33\n\nPD\n7\n\n27\nPD\n\n6\n26\n\nPD\n5\n\n25\nPD\n\n4\n24\n\nPD\n3\n\n23\nPD\n\n2\n22\n\nPD\n1\n\n21\nPD\n\n0\n20\n\nPC\n7\n\n17\nPC\n\n6\n16\n\nPC\n5\n\n15\nPC\n\n4\n14\n\nPC\n3\n\n13\nPC\n\n2\n12\n\nPC\n1\n\n11\nPC\n\n0\n10\n\nPB\n3\n\n7\nPB\n\n2\n6\n\nPB\n1\n\n5\nPB\n\n0\n4\n\nPA\n6\n\n2\nPA\n\n7\n3\n\nPA\n5\n\n1\nPA\n\n4\n44\n\nPA\n3\n\n43\nPA\n\n2\n42\n\nPA\n1\n\n41\nPA\n\n0\n40\n\nAV\nC\n\nC\n39 3831\n\nPR\n0(\n\nXT\n2)\n\n36\n\nPR\n1(\n\nXT\n1)\n\n3719\nVC\n\nC\n9 18\n\nG\nN\n\nD\n8\n\nPD\nI_\n\nD\nAT\n\nA\n34 30\n\nR\nES\n\nET\n/P\n\nD\nI_\n\nC\nLK\n\n35\n\nU\n1 VC\n\nC\n23\n\nVL\n2\n\nD\n+\n\n21\nD\n\n-\n20\n\nVB\nC\n\nO\nM\n\nP\n22\n\nX0\n25\n\nX1\n24\n\nIN\nT\n\n18\nR\n\nES\n12\n\nG\nPX\n\n17\nM\n\nO\nSI\n\n16\nM\n\nIS\nO\n\n15\nSC\n\nK\n13\n\nSS\n14\n\nG\nN\n\nD\n3\n\nG\nN\n\nD\n19\n\nG\nO\n\nU\nT7\n\n11\nG\n\nO\nU\n\nT6\n10\n\nG\nO\n\nU\nT5\n\n9\nG\n\nO\nU\n\nT4\n8\n\nG\nO\n\nU\nT3\n\n7\nG\n\nO\nU\n\nT2\n6\n\nG\nO\n\nU\nT1\n\n5\nG\n\nO\nU\n\nT0\n4\n\nG\nPI\n\nN\n7\n\n1\nG\n\nPI\nN\n\n6\n32\n\nG\nPI\n\nN\n5\n\n31\nG\n\nPI\nN\n\n4\n30\n\nG\nPI\n\nN\n3\n\n29\nG\n\nPI\nN\n\n2\n28\n\nG\nPI\n\nN\n1\n\n27\nG\n\nPI\nN\n\n0\n26\n\nX1X2\n\nD\n+ D\n-\n\nVB\nU\n\nS\nG\n\nN\nD\n\nGND@1\nGND@2\n\nQ\n1\n\nU\n2A\n\n1\n6\n\nU\n2B\n\n3\n4\n\nC\n1\n\nR\n1\n\nU\n2P GNDVCC\n\n25\n\nJ2\n\nJ5\n\n123\n\nPR\nST\n\n5\n3V\n\n3\n3\n\n3V\n3\n\n18\n\n5V\n1\n\n5V\n20\n\nFH\nS1\n\n4\nFH\n\nS2\n6\n\nFI\nO\n\n1\n10\n\nFI\nO\n\n2\n12\n\nFI\nO\n\n3\n14\n\nFI\nO\n\n4\n16\n\nG\nN\n\nD\n17\n\nG\nN\n\nD\n19\n\nG\nN\n\nD\n2\n\nPD\nIC\n\n13\nPD\n\nID\n15\n\nPM\nIS\n\nO\n7\n\nPM\nO\n\nSI\n9\n\nPS\nC\n\nK\n11\n\nVR\nEF\n\n8\n\nJ4\n\n1 2 3 4\n\nJ6\n\n123\n\nC\n2\n\nC\n3\n\nC\n4\n\nC\n5\n\nC\n6\n\nR\n2R\n\n3\n\nLE\nD\n\n2\n\nR4\n\nR\n5\n\nLE\nD\n\n1\n\nR\n6\n\nLED3\n\nR7\n\nR\n8\n\nR\n9\n\nLE\nD\n\n4\n\nLE\nD\n\n5\n\nR\n10 R\n11\n\nF1\n\nJ7\n\n123\n\nD\n+\n\nD\n+\n\nD\n-\n\nD\n-\n\nC\nLK\n\n12\n\nC\nLK\n\n12\n\nC\nLK\n\n12\n\nC\nLK\n\n12\n\nR\nES\n\nET\n_G\n\nAT\nE\n\nR\nES\n\nET\n_G\n\nAT\nE\n\nTI\nO\n\n1\n\nTI\nO\n\n1\n\nTI\nO\n\n2\n\nTI\nO\n\n2\n\nTI\nO\n\n3\n\nTI\nO\n\n3\n\nTI\nO\n\n4\n\nTI\nO\n\n4\n\nPD\nI_\n\nC\nLK\n\nPD\nI_\n\nC\nLK\n\nPD\nI_\n\nD\nAT\n\nA\nPD\n\nI_\nD\n\nAT\nA\n\nU\nSB\n\n_I\nR\n\nQ\n\nU\nSB\n\n_I\nR\n\nQ\n\nU\nSB\n\n_R\nES\n\nET\n\nU\nSB\n\n_R\nES\n\nET\n\nU\nSB\n\n_G\nPX\n\nU\nSB\n\n_G\nPX\n\nU\nSB\n\n_M\nO\n\nSI\nU\n\nSB\n_M\n\nO\nSI\n\nU\nSB\n\n_M\nIS\n\nO\n\nU\nSB\n\n_M\nIS\n\nO\n\nU\nSB\n\n_S\nC\n\nK\n\nU\nSB\n\n_S\nC\n\nK\n\nU\nSB\n\n_S\nS\n\nU\nSB\n\n_S\nSSY\n\nN\nC\n\n_I\nN\n\nSY\nN\n\nC\n_I\n\nN\n\ns\nc\na\nn\nl\ni\nm\ne\n\ng\ni\nt\n\nUSB\n\nD\n\nG\n\nS\n\nR\nel\n\nea\nse\n\nd \nun\n\nde\nr t\n\nhe\n C\n\nre\nat\n\niv\ne \n\nC\nom\n\nm\non\n\ns\nAt\n\ntri\nbu\n\ntio\nn \n\nSh\nar\n\ne-\nAl\n\nik\ne \n\n4.\n0 \n\nLi\nce\n\nns\ne\n\n h\nttp\n\ns:\n//c\n\nre\nat\n\niv\nec\n\nom\nm\n\non\ns.\n\nor\ng/\n\nlic\nen\n\nse\ns/\n\nby\n-s\n\na/\n4.\n\n0/\n\nD\nes\n\nig\nn \n\nby\n:\n\n31\n\n\n\nthe photo to Twitter, and Ladyada recognized it as\na Sanyo/ONsemi LC87, an 8-bit micro that seems\nto be mostly used in Japanese consumer electron-\nics. It comes in both flash and ROM versions, both\nof which I would later find in these tablets. Test\npoints were available for an on-chip debugger, but I\ncouldn’t find the debug adapter for sale anywhere\nnor could I find any documentation for the pro-\ntocol. I even found the firmware for this myste-\nrious TCB87-TypeC debug adapter, and a way to\ndisassemble it, but the actual debug port was im-\nplemented by a custom peripheral on the adapter’s\nCPU. I tried various bit twiddling and pulse pushing\nin hopes of getting a response from the debug port,\nbut my best guess is that it’s been disabled.\n\nAt this point, the remaining options are more di-\nrect. A sufficiently funded and motivated researcher\ncould certainly break out the micropositioners and\nacid, reading the data directly from on-chip busses.\nBut this is needlessly complex and expensive. This\nis a USB device after all, and we have a perfectly\ngood off-chip bus that can already do many things.\nIn fact, when you attach a USB device to your PC,\nit typically hands very small pieces of its firmware\nback to the PC in order to identify itself. We think of\nthese USB Descriptors as data tables, not part of the\nfirmware at all, but where else would they be stored?\nOn an embedded device where RAM is so precious,\nthe descriptor chunks will be copied directly from\nFlash or Mask ROM into the USB endpoint buffer.\nIt’s a tiny engine designed to read parts of firmware\nout over USB, and nearly every USB device has code\nlike this.\n\nIf this code is functioning properly, it will read\nback only the USB descriptor tables, and nothing\nelse. If there’s a bug in the size calculation, you\nmay be able to request more data. If there isn’t\nalready a bug, you can introduce one via clock or\npower glitching.\n\nIntroducing a bug at just the right time can be\ntricky, so this is where it helped to build a new tool.\nWell, a tiny add-on for a masterful existing tool:\nthe ChipWhisperer-Lite by Colin O’Flynn. The\nChipWhisperer is an open source platform for side-\nchannel power analysis and glitching. The joy of\nhaving both power analysis and glitching in the same\nplatform is that they can be on the same reference\nclock. With one oscillator, you can deterministically\nstep your target device through its paces, measure\nits activity via the power consumption waveform,\nand deliver glitches to specific clock cycles. By re-\n\nmoving as many sources of jitter as possible, glitches\ncan be delivered more reliably to the intended oper-\nation within the target’s firmware.\n\nMy humble addon is the FaceWhisperer, a\nUSB host controller based on the MAX3421E\nchip, inspired of course by Travis Goodspeed’s\nFacedancer21 tool. Whereas the USB host controller\nin your PC will be subject to many influences far\noutside your control, the USB host in the FaceWhis-\nperer can be precisely synchronized with both the\ntarget device and the ChipWhisperer itself.\n\nPutting everything on the same clock is neces-\nsary but not sufficient for cycle-accurate timing re-\npeatability. The LC87, like many microcontrollers,\nwill boot from a free-running RC oscillator before\nswitching to the external clock under software con-\ntrol. This means it’s necessary to synchronize with\nthe running firmware somehow before starting up\nthe USB host. In this case, I’m using a comparator\ninput on the FaceWhisperer to precisely wait on a\ndebug signal that indicates the beginning of a tablet\nscanning cycle.\n\nThe GET_DESCRIPTOR request we’re interested in\ncomes in several parts: a SETUP token that describes\nwhat descriptor we’d like to read, some IN tokens\nthat each ask the device to send back one more\npacket, and finally an OUT for acknowledgment.\nThese phases each drive a forgetful state machine\nthat wakes up on each interrupt and leaves notes to\nitself for what needs to be done to the next packet.\nUnlike antique asynchronous serial ports, USB de-\nvices can never speak to the host unless they’re of-\nfered a timeslot with an IN token, so no matter how\nbadly we glitch the firmware we do need to follow\nthis flow in order to read back data from the device.\n\nThis firmware extraction glitch works by disrupt-\ning the calculation and/or storage of the descriptor\nlength, between that SETUP and the first IN. To ex-\ntract as much data as possible, the SETUP can have\na length limit of 0xFFFF and the FaceWhisperer can\ncontinue spamming IN tokens until something fails.\nWith this infrastructure in place, the ChipWhis-\nperer’s Glitch Explorer can hone in on timing off-\nsets and glitch parameters that give us longer than\nusual descriptor responses. By briefly interrupting\npower at slightly different timing offsets after the\nSETUP packet, a variety of glitched behavior can be\nobserved.\n\nThe descriptor we’ll be reading is the USB Con-\nfiguration Descriptor, typically one of the longest\ndescriptors a device will provide. This device has a\n\n32\n\n\n\n33\n\nCEEEEE CocceEe CEEEEE COEECECE CEOCECE COEEEe COCECE COOLED CLOEECE CoCCEe CoLECEE CoKGEE\n\ne°coe\n\naues +8 9.\nGOaarars ¢\n><)\n20x( ‘ 5\n\nBSu[seb,o\n0\n\n© cccoo o\n\n2\nLunes\n\necoce © cocee\n\n© eccce 0\n\neoccee cfoccce\n\n¢\necococe ccecce ceocece cococee cocece ccecoe CeCCoee CoCece Ceoecee cacceo cocecc occoo\n\n33\n\n\n\n\n34-byte descriptor that we’ll be trying to glitch into\nsomething much longer. Usually the whole thing\ncomes back in one packet:\n\nIN\n2 09022200010100801 E0904000001030102000921\n\n0001000122920007058103090004\n4 rcode 5 t o t a l 34\n\nSometimes our glitches occur while copying the\nIN data itself. These aren’t useful on their own, but\nthey can give some feedback on how well the glitch\nis working:\n\nIN\n2 09022200010100801 E0904000001030102000921\n\n21FFFFFFFF20D227FFFFFFFFFF20\n4 rcode 5 t o t a l 34\n\nWhen you’re getting close, you start to see non-\ncorrupted descriptors that have a longer than ex-\npected length:\n\nIN\n2 09022200010100801 E0904000001030102000921\n\n0001000122920007058103090004090222000101\n4 0080160904000001030102000921000100012292\n\n000705810309000409023B000201008016090400\n6 0001030102000921000100012292000705810309\n\n0004090401000103000000092100010001220F00\n8 07058203400004040309041E035700610063006F\n\n006D00200043006F002E002C004C00740064002E\n10 0010034300540045002D00340035003000100343\n\n00540045002D0036003500300010034D00540045\n12 002D0034003500300010034D00540045002D0036\n\n00350030006802680168026801680268006803F0\n14 00F001F003F00270017002700070037000700370\n\n00B801B800B801B8\n16 rcode 5 t o t a l 268\n\nOnly a little more of that, and we find a glitched\nconfiguration descriptor that’s 65,534 bytes long,\nmore than enough to reconstruct the entire 32 kB\nfirmware ROM. You only get the memory prior to\nthe descriptor if the address space wraps, but fortu-\nnately for us this was the case. All that’s left is to\ndetermine the address offset by looking for clues like\nan IVT at the beginning or unused memory near the\nend of the image, and correctly align the resulting\n32 kB image.\n\nIf you’d like to try this technique on your own\ndevices with the ChipWhisperer, you can grab the\n\nPCB design and source for FaceWhisperer and play\nalong.12\n\nThis sort of side-channel analysis still requires a\nbit of PCB surgery in order to set up the device’s\npower rails and clock for glitching and monitoring.\nIt also helps to have a reset signal and some sort\nof GPIO that can be used as a timing reference. It\nwould be interesting future work to see how far this\nsetup could be reduced. Could the glitching be per-\nformed solely via the USB port, even through what-\never power regulation and conditioning the device\nincludes?\n\n4.2 Coding in Disappearing Ink\n\nThe documentation for the LC87 architecture is\nsparse. I eventually found an instruction encoding\ntable buried in some product-line-specific appendix,\nbut for a while the only resource I could find was\na freeware toolchain, including a compiler and an\non-chip debugger. I had already taken a look at this\ndebugger in an attempt to awaken the debug port on\nmy tablet. It wouldn’t do much without this myste-\nrious TCB87-TypeC dongle, but I tried simulating\nthe TCB87 with a GreatFET that mostly just pre-\ntends things are okay and tells this RD87 debugger\nwhatever it wants to hear. When I get the debugger\nto start up, it begins populating the hex views with\nzeroes. After a quick look with the USB analyzer, I\neasily find the requests that are the same size as the\ndevice’s memory and begin answering those with my\nfirmware dump. Now I have a debugger that I can\nuse for static analysis!\n\nI was looking for some kind of update mech-\nanism. I would later discover that this tablet\n(firmware 1.16) used mask ROM whereas many ear-\nlier tablets (1.13) used flash memory. Those 1.13\ntablets do seem to have a bootloader of some kind\navailable, but I haven’t looked into it yet. With the\n1.16 tablet I had been analyzing, though, I became\nfairly certain there was no intended way to modify\nthe device’s program memory. This gave me a new\nconstraint, which turns out to be interesting any-\nway: Turn the tablet into an RFID reader without\nmodifying its firmware. We’ll do this entirely via\nRAM and return-oriented programming.\n\nThe next step was much easier than expected.\nThere was plenty of hidden functionality in the\nfirmware. These are things that aren’t part of any\n\n12git clone https://github.com/scanlime/facewhisperer\nunzip pocorgtfo13.pdf facewhisperer.tar.bz2\n\n34\n\n\n\nstandard and aren’t used by the official drivers, but\npresumably exist for factory test purposes. There’s\na mode you can put the tablet in which enables\nan additional USB endpoint that returns loads of\ntimers and internal debug info. Oh, and there’s a\nHID request that will just write exactly 16 bytes\ninto RAM anywhere you like!\n\nI think this was used in conjunction with another\nroutine that isn’t called anywhere, which tests the\ncustom silicon Sanyo added for Wacom. Oh, custom\nsilicon. I was hoping not to find that here. Newer\ntablets have chips that are obviously designed by\nWacom to be complete analog frontends. I wanted\nto start with an older tablet that would have fewer\ncustom parts. But perhaps the “W” in LC871W32\nstands for Wacom. The analog frontend is made\nfrom discrete components in this tablet; multiplex-\ners to select from an array of coils, op-amps to inte-\ngrate the received signals, a buffer to excite the coils\nwith a carrier wave. When I first looked at the cir-\ncuit, it seemed like the 750 kHz carrier wave itself as\nwell as the other timing signals would be generated\nusing general-purpose peripherals on the micro. But\nwhen I look for the corresponding GPIO pins, noth-\ning. More reverse engineering, and it was clear that\nI was facing custom hardware. I’ve been calling it\nFEB0h, after its I/O address. At first I thought it\nwas a serial engine of some sort that was being mis-\nused to run the tablet, but now it’s clear that this\nhardware is purpose-built. More on that later. For\nnow, it’s enough to know that the hardware or the\nmask ROM itself had enough engineering risk that\nthey thought it prudent to include such a powerful\ntest feature.\n\nThis is enough to start testing the waters and\nbuilding up more and more complex ROP code. The\nROM is only 32kB, and barely half full, but there are\nsome useful gadgets. We can make function calls, do\nmemcpy, RAM-to-RAM and ROM-to-RAM. Inter-\nrupts are tricky. I tried coexisting with them for a\nwhile, but had to give up on that due to USB packet\ncorruption issues I couldn’t track down. Write an\narbitrary byte? Look up where we’d find that in\nROM and do a memcpy. Loops are the slowest.\nThese ROP stack frames can only execute once be-\nfore they’re corrupted, so we must copy the code\neach time it’s run. It’s slow, but we’re doing arbi-\ntrary things to this peripheral that we haven’t even\nwritten any code to. We can even return it to nor-\nmal operation if we like, by jumping back to the\nmain loop and restoring a normal stack.\n\nThis is not typically the sort of operation your\nOS requires elevated privileges for. The underly-\ning Send Feature Report operation is typically as-\nsociated with harmless device-specific features like\ntoggling your keyboard LEDs, not with writing ar-\nbitrary instructions to a Turing-complete processor\nthat is trusted by the OS just as much as you are.\nApplications can typically reserve access to any HID\ndevice that doesn’t already have a driver loaded.\nIt’s easy to imagine some desktop malware that un-\nloads or subverts the default driver long enough to\nload some malware into a peripheral’s RAM with-\nout subsequent detection by either the user or the\ndriver.\n\n4.3 Amplitude Modulation Alchemy\n\nWacom pens and passive RFID cards are broadly\nsimilar, in that they both use a resonant LC circuit\nto pick up some energy from the reader’s chang-\ning magnetic field, then they send back data bits\nwith backscatter modulation, selectively shorting\nout the coil. The specific mechanism is a bit dif-\nferent though, and it will make our job harder. A\ntypical 125 kHz RFID reader is sending out either a\ncontinuous carrier, or perhaps sending long bursts a\nfew times a second to save energy. During this burst,\nthe reader is continuously listening for a modulated\nresponse, with hardware filters specifically tuned to\nthis job.\n\n35\n\n\n\nWacom tablets, by contrast, are all about se-\nquentially scanning an array of coils. This CTE-450\ntablet has 12 short and wide horizontal coils on the\nfront side (Y00 through Y11) and 17 tall and thin\nvertical coils on the back side (X00 to X16). When it\nhas no idea where the pen might be, it has to scan\neverywhere. After locating the pen, it can adjust\nthe scanning pattern to take differential measure-\nments from the tablet coils nearest the pen coil. In-\nstead of transmitting and receiving simultaneously,\nthe filtering can be simplified by toggling between\ntwo modes. When transmitting, a 74HC125 buffer\ndrives the coil with the tablet’s carrier wave. During\nthis time, the analog integrator is zeroed. Then the\ntablet switches modes, and begins integrating the\nreceived signal.\n\nThese resonant LC circuits are like electromag-\nnetic tuning forks. An RFID tag or a Wacom\npen have a tuning fork at a specific frequency, and\nsome circuitry that communicates each bit by either\ndamping the oscillations or letting them ring. The\nWacom tablet shouts at the tuning fork’s frequency,\nquickly and abruptly, and immediately listens for\nthe reverberation. The whole protocol is designed\naround this mode switch. Gaps in the carrier in-\ndicate the bit boundaries, and longer bursts divide\npackets.\n\nThe trick here is to use this mechanism to read\nsome common RFID access card. Between the slow\nreturn-oriented programming and the limited ana-\nlog frontend, I picked an easy target for the PoC.\nThe EM4100 is a common 125 kHz tag with a fixed\n40-bit ID. It’s no more secure than a pin tumbler\nlock for sure, but it isn’t too far from the tags used\nin many access control systems.\n\nThe EM4100 pads the 40-bit code out to a 64-bit\nrepeating pattern with the addition of a 9-bit header\nand a matrix of parity bits. Each bit is Manchester\nencoded; 0 becomes 10, 1 becomes 01. Each half-bit\nlasts 32 clock cycles, giving us a conveniently slow\ndata rate.\n\nThe pulsed carrier is a problem. The RFID card\ndoes have its little tuning fork, and it keeps ringing\na little bit, but not as much as you might think, es-\npecially when the EM4100 chip is trying to power\nitself from this stored energy and the external car-\nrier has disappeared. A clock cycle or two, but not\nnearly as long as the tablet’s A/D conversion takes.\nThis little bit of unpredictability, though, has so far\nfoiled every plan of mine to stay in sync with the\nsignal in order to sample it at or below the bit rate.\nMy workaround has been to use a short enough car-\nrier pulse in order to have multiple samples per bit,\nallowing me to occasionally use a pile of filters and\nheuristics to recover the correct bits with appropri-\nate deference to Nyquist. The problem with using\na shorter carrier pulse is that it lowers our carrier\nduty cycle, delivering less power to the RFID card.\nSo, there’s a delicate balance: long enough to power\nthe card, short enough for the resulting data to be\nintelligible through this intermittent sampling.\n\nThe returned signal is quite weak, since the\ntablet’s filters are looking for resonance at a very\ndifferent frequency. This is an area where I’ve seen\nmuch difference between individual RFID tags. Un-\nder unrealistic conditions, with the RFID tag placed\ndirectly on the tablet circuit board, many tags read\nsuccessfully without much trouble. With an unmod-\nified and fully assembled tablet, I’ve had very diffi-\ncult to reproduce results, occasionally reading only\none of the several tags I tried the setup with.\n\nIf you want to try this experiment or others, you\ncan find my simple ROP toolkit and signal process-\ning for the CTE-450 and try your luck with the\nreturn-oriented analog hacking.13\n\n4.4 More to do\n\nAlthough so far I’ve only managed to transform this\ntablet into an extremely bad RFID reader, I think\nthis shows that the overall approach may lead some-\nwhere. The main limitations here are in the reliance\non slow ROP, and the relatively low quality A/D\nconverter on the LC871. I’ve done my best to try\n\n13git clone https://github.com/scanlime/cte450-homebrew/\nunzip pocorgtfo13.pdf cte450-homebrew.tar.bz2\n\n36\n\n\n\nand separate the signal from the noise, but I’m no\nDSP guru. It’s possible that a signal processing ex-\npert could be snooping tags with a better success\nrate than I’ve been seeing. As a proof of concept,\nthis shows that the transformation from tablet to\nRFID reader is theoretically doable, though with-\nout a significant improvement in range it’s hard to\nimagine this approach succeeding at reading access\ncards casually left against a victim’s graphics tablet.\n\nIt could be interesting to examine newer tablets.\nThe custom silicon in FEB0h turned out to be one of\nthe best things about the CTE-450 tablet, making it\nrelatively easy to change the timing and carrier fre-\nquency. If newer tablets have a nicer A/D converter\nand a programmable filter on the receive path, they\ncould make a decent RFID reader indeed. A brief\nlook at my newer Intuos Pro tablet shows a Renesas\nprocessor that likely has reprogrammable flash.\n\nThere’s certainly more work to do in discov-\nering the scope of devices vulnerable to glitched\n\nGET_DESCRIPTOR requests. What other devices that\nwe usually think of as black-box peripherals might\nhave firmware that can be read out, or RAM that\nwe can temporarily hide code in?\n\nIt may be possible to mitigate these glitched\nGET_DESCRIPTOR firmware readouts by adding ad-\nditional verification steps in the device’s USB stack,\nwhich would each also need to be glitched. Reducing\nthe number of invalid states that eventually result\nin spilling data will make the glitching process much\nmore tedious.\n\nIn practice, though, I would argue that the best\nsecurity is not to rely on secret firmware at all. Al-\ngorithms shouldn’t need secrecy to keep them se-\ncure. Debug features that are too dangerous to\nleave should be disabled, not hidden. If any sensitive\ndata must be reachable from the CPU, it should be\nunmapped whenever possible, especially when some\nUSB controller asks for your life story.\n\n37\n\n\n\n5 Decoding AMBE+2 in MD380 Firmware in Linux\nby Travis Goodspeed KK4VCZ\n\nwith kind thanks to DD4CR, DF8AV, and AB3TL\n\nHowdy y’all,\nIn PoC‖GTFO 10:8, I shared with you fine folks\n\na method for extracting a cleartext firmware dump\nfrom the Tytera MD380. Since then, a rag-tag gang\nof neighbors has joined me in hacking this device,\nand hundreds of amateur radio operators around\nthe world are using our enhanced firmware for DMR\ncommunications.\n\nAMBE+2 is a fixed bit-rate audio compression\ncodec under some rather strict patents, for which\nthe anonymously-authored Digital Speech Decoder\n(DSD) project14 is the only open source decoder. It\ndoesn’t do encoding, so if for example you’d like to\nconvert your favorite Rick Astley tunes to AMBE\nframes, you’ll have to resort to expensive hardware\nconverters.\n\nIn this article, I’ll show you how I threw to-\ngether a quick and dirty AMBE audio decompressor\nfor Linux by wrapping the firmware into a 32-bit\nARM executable, then running that executable ei-\nther natively or through Qemu. The same tricks\ncould be used to make an AMBE encoder, or to\nconvert nifty libraries from other firmware images\ninto handy command-line tools.\n\nThis article will use an MD380 firmware image\nversion 2.032 for specific examples, but in the spirit\nof building our own bird feeders, the techniques\nought to apply just as well to your own firmware\nimages from other devices.\n\n– — — – — — — — – — –\nSuppose that you are reverse engineering a\n\nfirmware image, and you’ve begun to make good\nprogress. You know where plenty of useful func-\ntions are, and you’ve begun to hook them, but now\nyou are ready to start implementing unit tests and\ndebugging chunks of code. Wouldn’t it be nicer to\ndo that in Unix than inside of an embedded system?\n\nAs luck would have it, I’m writing this article\non an aarch64 Linux machine with eight cores and\na few gigs of RAM, but any old Raspberry Pi or\nAndroid phone has more than enough power to run\nthis code natively.\n\nBe sure to build statically, targeting\narm-linux-gnueabi. The resulting binary will run\non armel and aarch64 devices, as well as damned\n\nnear any Linux platform through Qemu’s userland\ncompatibility layer.\n\n5.1 Dynamic Firmware Loading\nFirst, we need to load the code into our process.\nWhile you can certainly link it into the executable,\nluck would have it that GCC puts its code sections\nvery low in the executable, and we can politely ask\nmmap(2) to load the unpacked firmware image to\nthe appropriate address. The first 48kB of Flash\nare used for a recovery bootloader, which we can\nconveniently skip without consequences, so the load\naddress will be 0x0800c000.\n\ns i ze_t l ength =994304;\n2 int fd=open ( \" experiment . img\" ,0 ) ;\n\nvoid ∗ f i rmware=mmap(\n4 (void ∗) 0x0800c000 , length ,\n\nPROT_EXEC|PROT_READ|PROT_WRITE,\n6 MAP_PRIVATE, // f l a g s\n\nfd , // f i l e\n8 0 // o f f s e t\n\n) ;\n\nAdditionally, we need the 128kB of RAM at\n0x20000000 and 64kB of TCRAM at 0x10000000\nthat the firmware expects on this platform. Since\nwe’d like to have initialized variables, it’s usually\nbetter go with dumps of live memory from a running\nsystem, but /dev/zero works for many functions if\nyou’re in a rush.\n\n14git clone https://github.com/szechyjs/dsd\n\n38\n\n\n\n1 //Load an SRAM image .\nint fdram=open ( \"ram . bin \" ,0 ) ;\n\n3 void ∗sram=mmap(\n(void ∗) 0x20000000 ,\n\n5 ( s i ze_t ) 0x20000 ,\nPROT_EXEC|PROT_READ|PROT_WRITE,\n\n7 MAP_PRIVATE, // f l a g s\nfdram , // f i l e\n\n9 0 // o f f s e t\n) ;\n\n11\n//Create an empty TCRAM region .\n\n13 int fdtcram=open ( \"/dev/ zero \" ,0 ) ;\nvoid ∗ tcram=mmap(\n\n15 (void ∗) 0x10000000 ,\n( s i z e_t ) 0x10000 ,\n\n17 PROT_READ|PROT_WRITE, // p ro t e c t i on s\nMAP_PRIVATE, // f l a g s\n\n19 fdtcram , // f i l e\n0 // o f f s e t\n\n21 ) ;\n\n5.2 Symbol Imports\n\nNow that we’ve got the code loaded, calling it is as\nsimple as calling any other function, except that our\nC program doesn’t yet know the symbol addresses.\nThere are two ways around this:\n\nThe quick but dirty solution is to simply cast a\ndata or function pointer. For a concrete example,\nthere is a null function at 0x08098e14 that sim-\nply returns without doing anything. Because it’s\na Thumb function and not an ARM function, we’ll\nhave to add one to that address before calling it at\n0x08098e15.\n\nvoid (∗ nu l l sub ) ( )=(void ∗) 0x08098e15 ;\n2\n\np r i n t f ( \"Trying to c a l l nu l l sub ( ) . \\ n\" ) ;\n4 nu l l sub ( ) ;\n\np r i n t f ( \" Success ! \\ n\" ) ;\n\nSimilarly, you can access data that’s in Flash or\nRAM.\n\n1 p r i n t f ( \"Manufacturer i s : ’%s ’\\n\" ,\n0 x080f9e4c ) ;\n\nCasting function pointers gets us part of the way,\nbut it’s rather tedious and wastes a bit of memory.\nInstead, it’s more efficient to pass a textfile of sym-\nbols to the linker. Because this is just a textfile, you\n\ncan easily export symbols by script from IDA Pro\nor Radare2.\n\nThe symbol file is just a collection of assignments\nof names to addresses in roughly C syntax.\n/∗ Populates the audio b u f f e r ∗/\n\n2 ambe_decode_wav = 0x08051249 ;\n/∗ Just re turns . ∗/\n\n4 nu l l sub = 0x08098e15 ;\n\nYou can include it in the executable by passing\nGCC parameters to the linker, or by calling ld di-\nrectly.\nCC=arm−l inux−gnueabi−gcc−6 −s t a t i c −g\n\n2 $ (CC) −o test test . c \\\n−Xl inker −−ju s t−symbols=symbols\n\nNow that we can load the firmware into process\nmemory and call its functions, let’s take a step back\nand see a second way to do the linking, by rewrit-\ning the firmware dump into an ELF object and then\nlinking it. After that, we’ll get along to decoding\nsome audio.\n\n5.3 Static Firmware Linking\nWhile it’s nice and easy to load firmware with\nmmap(2) at runtime, it would be nice and correct\nto convert the firmware dump into an object file for\nstatic linking, so that our resulting executable has\nno external dependencies at all. This requires both\na bit of objcopy wizardry and a custom script for\nld.\n\nFirst, let’s convert our firmware image dump to\nan ELF that loads at the proper address.\n\n1 arm−l inux−gnueabi−objcopy \\\n−I b inary experiment . img \\\n\n3 −−change−addre s s e s=0x0800C000 \\\n−−rename−s e c t i o n . data=. experiment \\\n\n5 −O e l f 32−l i t t l e a rm −B arm experiment . o\n\nSadly, ld will ignore our polite request\nto load this image at 0x08000C000, be-\ncause load addresses in Unix are just po-\nlite suggestions, to be thrown away by the\nlinker. We can fix this by passing -Xlinker\n–section-start=.experiment=0x0800C000 to gcc\nat compile time, so ld knows to place the section at\nthe right address.\n\nSimilarly, the SRAM image can be embedded at\nits own load address.\n\n39\n\n\n\n40\n\ncay\n\n|\n\nFor the past 35 years radio amateurs throughout the world have been purchasing equipment\nand supplies from me. Their friendship and loyalty have been the determining factors in\nour success. For this we are grateful and it is time that we made an effort to express our\nappreciation in a material way.\n\nMany amateur radio clubs need financial aid. Many others can use extra funds if these\nfunds can be obtained without assessing their members. We have a plan which will\ngreatly assist all amateur radio clubs.\nFor every order received until March 1, 1955, we will send our check for 15% of your\norder — to your radio club for deposit in their treasury. When you place your order, be\nsure to include the name and address of your club and treasurer.\nMy best wishes for a healthy, happy and prosperous New Year.\n\n73 — CUL\n\nUncledave, W2APF\n\nRADIO. DISTRIBUTING COMPANY\n904 BROADWAY, ALBANY, N. Y.\n“tou TELEPHONE ALBANY 5-1594\n\n40\n\n\n\n\n\n5.4 Decoding the Audio\nTo decode the audio, I decided to begin with the\nsame .amb format that DSD uses. This way, I could\nwork from their reference files and compare my de-\ncoding to theirs.\n\nThe .amb format consists of a four byte header\n(2e 61 6d 62) followed by eight-byte frames. Each\nframe begins with a zero byte and is followed by\n49 bits of data, stored most significant bit first with\nthe final bit in the least significant bit of its own\nbyte.\n\nTo have as few surprises as possible, I take the\neight packed bytes and extract them into an array of\n49 shorts located at 0x20011c8e, because this is the\naddress that the firmware uses to store its buffer.\nShorts are used for convenience in addressing dur-\ning computation, even if they are a bit more verbose\nthan they would be in a convenient calling conven-\ntion.\n\n1 //Re−use the firmware ’ s own AMBE bu f f e r .\nshort ∗ambe=(short ∗) 0 x20011c8e ;\n\n3\nint ambei=0;\n\n5 for ( int i =1; i <7; i++){// Skip f i r s t by te .\nfor ( int j =0; j <8; j++){\n\n7 //MSBit f i r s t\nambe [ ambei++]=(packed [ i ]>>(7− j ) )&1;\n\n9 }\n}\n\n11 //Final b i t in i t s own frame as LSBit .\nambe [ ambei++]=packed [ 7 ]&1 ;\n\nAdditionally, I re-use the output buffers to store\nthe resulting WAV audio. In the MD380, there are\ntwo buffers of audio produced from each frame of\nAMBE.\n\n//80 samples f o r each audio b u f f e r\n2 short ∗ outbuf0=(short ∗) 0x20011aa8 ;\n\nshort ∗ outbuf1=(short ∗) 0x20011b48 ;\n\nThe thread that does the decoding in firmware is\ntied into the MicroC/OS-II realtime operating sys-\ntem of the MD380. Since I don’t have the timers and\ninterrupts to call that thread, nor the I/O ports to\nsupport it, I’ll instead just call the decoding routines\nthat it calls.\n\n1 //Placed at 0x08051249\nint ambe_decode_wav(\n\n3 signed short ∗wavbuffer ,\nsigned int e ighty , // always 80\n\n5 short ∗ b i t bu f f e r , //0x20011c8e\nint a4 , //0\n\n7 short a5 , //0\nshort a6 , // t imes l o t , 0 or 1\n\n9 int a7 //0x20011224\n) ;\n\nFor any parameter that I don’t understand, I\njust copy the value that I’ve seen called through my\nhooks in the firmware running on real hardware. For\nexample, 0x20011224 is some structure used by the\nAMBE code, but I can simply re-use it thanks to\nmy handy RAM dump.\n\nSince everything is now in the right position, we\ncan decode a frame of AMBE to two audio frames\nin quick succession.\n\n//One AMBE frame becomes two audio frames .\n2 ambe_decode_wav(\n\noutbuf0 , 80 , ambe ,\n4 0 , 0 , 0 ,\n\n0x20011224\n6 ) ;\n\nambe_decode_wav(\n8 outbuf1 , 80 , ambe ,\n\n0 , 0 , 1 ,\n10 0x20011224\n\n) ;\n\nAfter dumping these to disk and converting to\na .wav file with sox -r 8000 -e signed-integer\n-L -b 16 -c 1 out.raw out.wav, a proper audio\nfile is produced that is easily played. We can now\ndecode AMBE in Linux!\n\n41\n\n\n\n5.5 Runtime Hooks\n\nSo now we’re able to decode audio frames, but this is\nfirmware, and damned near everything of value ex-\ncept the audio routines will eventually call a function\nthat deals with I/O—a function we’d better replace\nif we don’t want to implement all of the STM32’s\nI/O devices.\n\nLuckily, hooking a function is nice and easy. We\ncan simply scan through the entire image, replac-\ning all BX (Branch and eXchange) instructions to\nthe old functions with ones that direct to the new\nfunctions. False positives are a possibility, but we’ll\nignore them for now, as the alternative would be to\nlist every branch that must be hooked.\n\nThe BL instruction in Thumb is actually two ad-\njacent 16-bit instructions, which load a low and high\nhalf of the address difference into the link register,\nthen BX against that register. (This clobbers the\nlink register, but so does any BL, so the register use\nis effectively free.)\n\n1 /∗ Ca l cu l a t e s Thumb code to branch from\none address to another . ∗/\n\n3 int c a l c b l ( int adr , int t a r g e t ) {\n/∗ Begin with the d i f f e r e n c e o f the t a r g e t\n\n5 and the PC, which po in t s to j u s t a f t e r\nthe current i n s t r u c t i o n . ∗/\n\n7 int o f f s e t=target−adr−4;\n//LSBit doesn ’ t count .\n\n9 o f f s e t =( o f f s e t >>1) ;\n\n11 /∗ The BL in s t r u c t i on i s a c t u a l l y two\nThumb in s t r u c t i on s , wi th one s e t t i n g\n\n13 the h igh par t o f the LR and the other\ns e t t i n g the low part wh i l e swapping\n\n15 LR and PC. ∗/\nint hi=0xF000 | ( ( o f f s e t&0xFFF800)>>11) ;\n\n17 int l o=0xF800 | ( o f f s e t&0x7FF) ;\n\n19 //Return the pa i r as a s i n g l e 32− b i t word .\nreturn ( lo <<16) | h i ;\n\n21 }\n\nNow that we can calculate function call instruc-\ntions, a simple loop can patch all calls from one ad-\ndress into calls to a second address. You can use this\nto hook the I/O functions live, rather than trapping\nthem.\n\n5.6 I/O Traps\nWhat about those I/O functions that we’ve forgot-\nten to hook, or ones that have been inlined to a\ndozen places that we’d rather not hook? Wouldn’t\nit sometimes be easier to trap the access and fake\nthe result, rather than hooking the same function?\n\nYou’re in luck! Because this is Unix, we can sim-\nply create a handler for SIGSEGV, much as Jeffball\ndid in PoC‖GTFO 8:8. Your segfault handler can\nthen fake the action of the I/O device and return.\n\nAlternately, you might not bother with a proper\nhandler. Instead, you can use GDB to debug the\nprocess, printing a backtrace when the I/O region\nat 0x40000000 is accessed. While GDB in Qemu\ndoesn’t support ptrace(2), it has no trouble trap-\nping out the segmentation fault and letting you\nknow which function attempted to perform I/O.\n\n5.7 Conclusion\nThank you kindly for reading my ramblings about\nARM firmware. I hope that you will find them\nhandy in your own work, whenever you need to work\nwith reverse engineered firmware away from its own\nhardware.\n\nIf you’d like to similarly instrument Linux ap-\nplications, take a look at Jonathan Brossard’s\nWitchcraft Compiler Collection,15 an interactive\nELF shell that makes it nice and easy to turn an\nexecutable into a linkable library.\n\nThe emulator from this article has now been in-\ncorporated into my md380tools16 project, for use in\nLinux.\n\nCheers from Varaždin, Croatia,\n–Travis 6A/KK4VCZ\n\n15git clone https://github.com/endrazine/wcc\nunzip pocorgtfo13.pdf wcc.tar.bz2\n\n16git clone https://github.com/travisgoodspeed/md380tools\n\n42\n\n\n\n6 Password Weaknesses in Physical Security:\nSilliness in Three Acts\n\nby Evan Sultanik\n\nDramatis Personæ\nDisembodied Voice of Pastor Manul Laphroaig . . . . . . . . . . . . . . . . . . Bard\n\nAlice Feynman . . . . . . . . . . . . . Disciple of the Church of Weird Machines\n\nBob Schrute . . . . . . . . . . . . . . . . . Assistant to the Facility Security Officer\n\nHavva al-Kindi . . . . . . . . . . . . . . . . . . . . . . Alice’s Old and Wise Officemate\n\nThe Ghost of Paul Erdős . . . . . . . . . . . . . . . . . . . . . . . . Keeper of The Book\n\nAct I: Memorize, Don’t Compromise\n\nPastor: In the windowless bowels of a nonde-\nscript, Class A office building entrenched in-\nside the Washington, D.C. beltway, we meet\nour heroine, Alice Feynman, lost on her way\nto a meeting with the Facility Security Officer.\n\nAlice: Excuse me, which way is it to the secu-\nrity office?\n\nBob: You must be the new hire. Bob Schrute,\nassistant FSO. I can take you there right after\nI finish with this. . .\n\nAlice: Alice. Nice to meet you. What’re you\ndoing?\n\nBob: Kaba Mas X-09 high security spin-lock.\nIt’s DSS-approved for use in our SCIFs. I’m\nresetting this one’s passcode.\n\nAlice: [Blank Stare]\n\nBob: U.S. Department of Defense (DoD) De-\nfense Security Service (DSS). Sensitive Com-\npartmented Information Facilities (SCIFs).\nThe rooms where we are allowed to store and\nprocess classified information?\n\nAlice: I see. I noticed those things all over this\nbuilding.\n\nBob: They’re ubiquitous. You’ll see them any-\nwhere in the country there’s classified work go-\ning on. One on each door, and another on each\nsafe. Super secure, too. Security in this office\nis no joke.\n\nAlice: How do they work?\n\nBob: [Throwing Alice the lock’s manual.] They\nrun off of the electricity generated from spin-\nning them, so you need to spin them a bit to\nget started. You see? The LCD on top shows\nyou the current number. You enter three two-\ndigit numbers. First one clockwise, second\ncounter-clockwise, third clockwise, and then\na final spin counter-clockwise to open. That’s\nthe passcode.\n\nAlice: [Flipping through the manual.] Does\neach lock get a different passcode?\n\nBob: Yes. That’s why we have this [handing\nAlice a magnet stuck to the side of the door ].\n\nAlice: Ah I see. It’s a phone keypad. So you\nuse a mnemonic to remember each passcode?\n\nBob: Exactly. [Pointing to a poster on the wall\nwith his own mugshot and memetic letters em-\nblazoning “MEMORIZE, DON’T COMPRO-\nMISE”, he sternly repeats that slogan:] Mem-\norize, don’t compromise.\n\nAlice: [“Is this guy serious?” face.]\n\nBob: You think you could crack it? FALSE.\n[Flamboyantly produces a pocket calculator\nthat had been hidden somewhere on his per-\nson.] Three two-digit numbers. That’s 100\ntimes 100 times 100, so . . . there are a mil-\nlion possible codes. I’ve set this to have a\ntimeout of four minutes after each failed at-\ntempt. So, trying all possible combinations\n\n43\n\n\n\nwould take . . . [furiously punching at the calcu-\nlator ] . . . almost eight years! We change each\ncode once every couple months, so even if you\ncould continuously try codes for eight hours\na day, you’d have . . . [more furious punching ]\n. . . about seven tenths of one percent chance\nof getting the code right.\n\nAlice: [Handing the manual back.] I didn’t see\nanything in here about an automatic lockout\nafter too many failed attempts.\n\nBob: [Pointing to his minuscule biceps.] These\nprovide the lockout.\n\nAlice: Are you ready to take me to the security\noffice now?\n\nBob: Fine.\n\nAct II: Surely You’re Joking\n\nPastor: Two weeks later, Alice has settled into\nher office, which she shares with Havva al-\nKindi. She hasn’t had a chance to play with\nthose nifty locks at all yet; her clearance is still\nbeing processed. Most of her time is spent\nidling or doing busy-work while she waits to\nbe approved to work on a real project.\n\nAlice: [On her desk phone] Yes. Yes, no prob-\nlem. By close of business today. No problem.\nBye.\n\nPastor: As Alice hangs up the phone, she no-\ntices something odd about the keypad, and\nimmediately remembers the magnet Bob had\nshowed her.\n\nAlice: [Gets up and starts drawing on her\nwhiteboard.]\n\n0\n\n8\ntuv\n\n5\njkl\n\n2\nabc\n\n1 3\ndef\n\n4\nghi\n\n6\nmno\n\n7\npqrs\n\n9\nwxyz\n\nHavva: What are you doing?\n\nAlice: Did you ever notice that the numbers\nzero and one don’t have any letters on the\nphone?\n\nHavva: Sure! You’re probably too young to\nhave ever used a rotary phone, right? Back\nwhen phone numbers were only seven dig-\nits long, the first two numbers represented\nthe exchange, and a mnemonic was given\nto each exchange. [Singing and tapping on\nher desk ] Bum-dah-bum bah-duh-bum bahhh\ndummm! PEnnsylvania Six Five Thousand!\nNo? It was a big Glenn Miller hit! My par-\nents used to play it all the time when I was a\nkid. That song is referring to the phone num-\nber for the Hotel Pennsylvania in New York,\nwhich to this day is still (212) PE6-5000.\n\nAlice: Oh yeah! I went there once for HOPE.\n\nHavva: Hope? Anyhow, for various reasons,\nthe numbers zero and one were never used in\nexchanges, which meant they never occurred\nat the beginning of phone numbers, which\nmeant they couldn’t have letters associated\nwith them.\n\n44\n\n\n\nAlice: Interesting! [Continuing on the white-\nboard ] 86 = . . . [a pause to consult her com-\nputer ] 262144. 1 − 262144 ÷ 1000000 =\n. . . 0.738. Wow! So, if there are only eight\nbuttons with letters, that reduces the number\nof possible phone numbers associated with six-\nletter mnemonics by 74% compared to if all the\nbuttons had letters!\n\nHavva: I guess that’s true. There are also cer-\ntain phone numbers you’ll never be able to\nhave English mnemonics for, because the but-\ntons for 5, 7, and 9 don’t have any vowels. So\nyou can’t make a mnemonic for a phone num-\nber that only uses those three numbers.\n\nAlice: Wow, yeah, that’s another 36 = . . .\n[quickly doing some math in her head this\ntime] 729 codes that don’t have mnemonics.\n\nHavva: Codes?\n\nAlice: Er, I mean “phone numbers.”\n\nHavva: I’ll bet there are certain “codes” that\ndon’t have any English words associated with\nthem. Plus, letters in English words don’t all\noccur at the same frequency: It’s much more\nlikely that a word will have the letter “e” than\nit will have the letter “x.”\n\nAlice: [Opens up a terminal on her computer.]\n$ grep ’^.\\{6\\}$’ /usr/share/dict/words | wc -l\n\n17706\n$ echo `!!` / 1000000 | bc -l\n.01770600000000000000\n\nPastor: And thus, Alice had discovered that\nfewer than 2% of the million possible codes\nactually map to English words.\n\nAlice: [Once again at the whiteboard.]\n\nHA CK ER\n42 25 34\n\n[Back at the computer.]\n$ grep -i ’^.\\{4\\}er$’ /usr/share/dict/words \\\n| wc -l\n1562\n\nAbout 10% of six-letter English words end\nwith the letters “ER”!\n[Back at the board, with long pauses.]\n\nDO SA GE\n36 72 43\nEN RA GE\n36 72 43\nFO RA GE\n36 72 43\nFO RB ID\n36 72 43\n\nPastor: And many words share the same code.\nIn fact, Alice quickly wrote a script to count\nthe number of unique codes possible from six-\nletter English words17.\n\nAlice: There are only 14684 possible codes to\ncheck! That would take . . . only about 40 days\nto brute-force crack!\n\nAct III: The Book\n\nPastor: Later that day, Alice is at her favorite\ndive, decompressing with some of her side\nprojects.\n\nPaul: [Sits down next to Alice at the bar. Wheel\nof Fortune is playing on an ancient CRT.]\nTelevision is something the Russians invented\nto destroy American education.\n\nAlice: [Tippling a brown liquor, neat, while\nworking on her laptop. Paul’s comment draws\nher attention to the TV. Alice notices that\nsome letters are given away “for free” and re-\nmembers what Havva had said about letter fre-\nquency. She quickly grabs her notebook and\njots down the letters as a reminder.] R, S, T,\nL, N, E.\n\nPaul: [Noticing Alice’s notebook.] Yes, these\nare very common letters in English. My native\nlanguage does not use “r” as much. But what\ndo I know about English? I learned it from\nmy father, who taught it to himself by reading\nEnglish novels in one of Joe’s Gulags. [Awk-\nward pause while Alice struggles with how to\nrespond.] Have you discovered anything beau-\ntiful? [Pointing into her notebook.]\n\nAlice: Oh that? I’ve been thinking about\nmnemonics for passcodes.\n\n17$ grep ’^.\\{6\\}$’ /usr/share/dict/words | tr ’[:upper:]’ ’[:lower:]’ | sed ’s/[abc]/2/g; s/[def]/3/g;\ns/[ghi]/4/g; s/[jkl]/5/g; s/[mno]/6/g; s/[pqrs]/7/g; s/[tuv]/8/g; s/[wxyz]/9/g’ | sort | uniq | wc -l\n\n45\n\n\n\nPaul: [Pointing to the drink:] That poison will\nnot help you. [Produces a small pill bottle out\nof his shirt pocket, raises it to eye level, drops\nit, and then catches it with the same hand be-\nfore it hits the bar.]\n\nAlice: Haven’t you heard? The Ballmer Peak\nis real! Or at least that’s what I read on Stack\nExchange.\n\nPaul: Pál Erdős. My brain is open.\n\nPastor: Alice introduces herself and proceeds\nto explain all of her findings to Paul.\n\nAlice: . . .and I just finished sorting the 14684\ndistinct codes by the number of words associ-\nated with them. That way, if I try the codes\nin order of decreasing word associations, then\nit will maximize my chances of cracking the\ncode sooner than later.\n\nPaul: Yes, if codewords are chosen uniformly\nfrom all six-letter English words. Can I see\nthe distribution of word frequency? [Grabbing\na napkin, stealing Alice’s pen, and scribbling\nsome notes.] Using your method, after fewer\nthan 250 attempts, there is a 5% probability\nthat you will have cracked the code. After\nabout 5700 attempts, there will be a 50% prob-\nability of success.\n\nAlice: [Typing on her computer.] That’s only\nabout 16 days!\n\nPastor: An adversary with intermittent access\nto the lock—for example, after hours—could\nquite conceivably crack the code in less than a\nmonth.\n\nPaul: If there exists a method that allows the\ncode-breaker to detect whether each succes-\nsive two-digit subcode is correct before enter-\ning the next two-digit subcode,. . .\n\nPastor: . . .otherwise known as a “vulnerability” . . .\n\nPaul: . . .[annoyed about having been inter-\nrupted, even if by the disembodied voice of\na narrator ] then the expected value for the\nlength of time required to crack the code is on\nthe order of minutes. [Mumbling toward the\nfourth wall:] That Pastor is more annoying\nthan the SF.\n\nAlice: What?\n\nPaul: SF means “Supreme Fascist.” This would\nshow that God is bad. I do not claim that\nthis is correct, or that God exists. It is just a\nsort of half-joke. There is an anecdote I once\nheard. Suppose Israel Gelfand and his advisor,\nAndrei Kolmogorov, were to both arrive in a\ncountry with a lot of mountains. Kolmogorov\nwould immediately try and climb the highest\nmountain. Gelfand would immediately start\nbuilding roads. What would you do?\n\nAlice: I would learn to fly an airplane so I could\ndiscover new mountain ranges. What about\nyou?\n\nPaul: Some might say that is what I do. My\nfriends might add that they pay for the fuel.\nBut really, I just try to keep the SF’s score\nlow. How can we create mnemonics that are\nnot vulnerable to your attack?\n\nAlice: Well, I guess the first thing to do is cre-\nate a keypad layout that uses zero and one.\n\nPaul: Yes, but my academic sibling Pólya\nwould say that we first need to understand\nthe problem. Ideally, we want a keypad lay-\nout that produces an injective mapping from\nthe six-letter English words into the natural\nnumbers from zero to one million.\n\nAlice: Injective?\n\nPaul: Such that no two words produce the same\ncode number.\n\nAlice: Is that even possible?\n\nPaul: I do not know. I believe this is an in-\nstance of the multiple subset sum problem, re-\nlated to the knapsack problem.\n\nAlice: Ah yeah, I remember that from my al-\ngorithms class. It’s NP-Complete, right?\n\nPaul: Yes, and likely intractable for problems\neven as small as this one. The total number\nof possible keypad mappings is 100 million bil-\nlion billion. But it is easy for us to check the\npigeons.\n\nAlice: Huh?\n\nPaul: The pigeonhole principle. For any subset\nof m letters within a word, there can be at\nmost 106−m words that have that pattern of\n\n46\n\n\n\nletters. If there are more, then there must be\na collision, no matter the mapping we choose.\n\nAlice: Ah, I see. That’s easy enough to check!\n[Typing.]\n\n1 for m in range ( 2 , 6 ) :\nh i t s = {}\n\n3 for word in words :\nfor i ndexes in i t e r t o o l s .\n\ncombinat ions (range ( len (word ) ) , m) :\n5 key = tuple ( ( word [ i ] , i )\n\nfor i in i ndexes )\ni f key not in h i t s :\n\n7 h i t s [ key ] = 1\nelse :\n\n9 h i t s [ key ] += 1\nmax_hits = 10∗∗(6−m)\n\n11 for key , h in h i t s . i t e r i t em s ( ) :\ni f h <= max_hits :\n\n13 continue\nk = [ ’ . ’ for i in range (6 ) ]\n\n15 for c , i in key :\nk [ i ] = c\n\n17 print \"\" . j o i n (k ) , h − max_hits\n\nSo, there are fourteen five-letter suffixes like\n“inder”, “aggle”, and “ingle” that will all pro-\nduce at least one collision. I guess there’s no\nway to make a perfect mapping.\n\nPaul: Gelfand advised Endre Szemerédi. This\nproblem is reminiscent of Szemerédi’s use of\nexpander graphs in pseudo-random number\ngeneration. What we want to do is take a rel-\natively small set of inputs (being the six-letter\nEnglish words) and use an expander graph as\nan embedding into the natural numbers be-\ntween one and a million, such that the result-\ning distribution mimics uniformity.\n\nAlice: That sounds . . . difficult.\n\nPaul: Constructing expander graphs is ex-\ntremely difficult. But I think Szemerédi would\nagree that interesting things rarely happen in\nfewer than five dimensions.\n\nAlice: I am a pragmatist. How about we use\na genetic algorithm to evolve a near optimal\nmapping?\n\nPaul: Such a solution would not be from The\nBook, but it would provide you with a map-\nping.\n\nAlice: What book?\n\nPaul: The Book in which the SF keeps all of the\nmost beautiful solutions.\n\nAlice: Well, I think I’ll try my hand at a scruffy\ngenetic algorithm. I need a decent mapping if\nI ever want to publish this in PoC‖GTFO!\n\nPaul: What is PoC‖GTFO?\n\nAlice: It’s. . . I guess it’s a sort of bible.\n\nPaul: Then the only difference between your\nBook and mine are the fascists who created\nthem. Maybe we will continue tomorrow . . . if\nI live.\n\nAlice: [Looking up from her keyboard.] Can I\nbuy you a drink? [Paul has vanished.]\n\nPastor: The moral of the story, dear neighbors,\nis not that these locks are inherently vulnera-\nble; if used properly, they are in fact incredibly\nsecure. We must remember that these locks\nare only as secure as the codes humans choose\nto assign to them. Using a phone keypad map-\nping on six-letter English dictionary words is\nthe physical security equivalent of a website\narbitrarily limiting passwords to eight charac-\nters.\n\n0\not\n\n8\njmuy\n\n5\nfn\n\n2\nbex\n\n1\navwz\n\n3\ncl\n\n4\ndhq\n\n6\ngs\n\n7\nip\n\n9\nkr\n\n‖PoC GTFO\n!\n\n!\n\n!\n\n!\n\nDon’t\nMemorize,\n\nCompromise\nСамиздат\n\n47\n\n\n\n7 Reverse Engineering the LoRa PHY\nby Matt Knight\n\nIt’s 2016, and everyone’s favorite inescapable buz-\nzword is IoT, or the “Internet of Things.” The mere\nmention of this phrase draws myriad reactions, de-\npending on who you ask. A marketing manager\nmay wax philosophical about swarms of connected\ncars eradicating gridlock forever, or the inevitability\nof connected rat traps intelligently coordinating to\neradicate vermin from midtown Manhattan,18 while\na security researcher may just grin and relish in the\nplethora of low-power stacks and new attack surfaces\nbeing applied to cyber-physical applications.\n\nIoT is marketing speak for connected embedded\ndevices. That is, inexpensive, low power, resource\nconstrained computers that talk to each other, possi-\nbly on the capital-I Internet, to exchange data and\ncommand and control information. These devices\nare often installed in hard to reach places and can\nbe expected to operate for years. Thus, easy to con-\nfigure communication interfaces and extreme power\nefficiency are crucial design requirements. While 2G\ncellular has been a popular mechanism for connect-\ning devices in scenarios where a PAN or wired tech-\nnology will not cut it, AT&T’s plans to sunset 2G\non January 1, 2017 and LTE-M Rel 13’s distance\nto widespread adoption presents an opportunity for\nnew wireless specifications to seize market share.\n\nLoRa is one such nascent wireless technology\nthat is poised to capture this opportunity. It is a\nLow Power Wide Area Network (LPWAN), a class of\nwireless communication technology designed to con-\nnect low power embedded devices over long ranges.\nLoRa implements a proprietary PHY layer; there-\nfore the details of its modulation are not published.\n\nThis paper presents a comprehensive blind sig-\nnal analysis and resulting details of LoRa’s PHY,\nchronicles the process and pitfalls encountered along\nthe way, and aspires to offer insight that may assist\nsecurity researchers as they approach their future\nunknowns.\n\n7.1 Casing the Job\n\nI first heard of LoRa in December 2015, when it\nand other LPWANs came up in conversation among\nneighbors. Collectively we were intrigued by its ad-\nvertised performance and unusual modulation, thus\nI was motivated to track it down and learn more.\nIn the following weeks, I occasionally scanned the\n900 MHz ISM spectrum for signs of its distinctive\nwaveform (more on that soon), however searches in\nthe New York metropolitan area, Boston, and a col-\nleague’s search in San Francisco yielded no results.\n\nSometime later I found myself at an IoT security\nmeetup in Cambridge, MA that featured representa-\ntives from Senet and SIGFOX, two major LPWAN\nplayers. Senet’s foray into LoRa started when they\nsought to remotely monitor fluid levels in home heat-\ning oil tank measurement sensors to improve the ex-\nisting process of sending a guy in a truck to read it\nmanually. Senet soon realized that the value of this\ninfrastructure extended far beyond the heating oil\nmarket and has expanded their scope to becoming\na IoT cellular data carrier of sorts. While following\nup on the company I happened upon one of their\nmarketing videos online. A brief segment featured a\ngrainy shot of a coverage map, which revealed just\nenough to suggest the presence of active infrastruc-\nture in Portsmouth, NH. After quick drive with my\nEttus B210 Software Defined Radio, I had my first\nLoRa captures.\n\n7.2 First Observations and OSINT\n\nLoRa’s proprietary PHY uses a unique chirp spread\nspectrum (CSS) modulation scheme, which encodes\ninformation into RF features called chirps. A chirp\n\n18LoRaWan in the IoT Industrial Panel, presentation by Jun Wen of Cisco.\n\n48\n\n\n\nFigure 11. Spectrogram of a LoRa packet.\n\nis a signal whose frequency is increasing or decreas-\ning at a constant rate, and they are unmistakable\nwithin the waterfall. A chirp-based PHY is shown\nin Figure 11.\n\nContrasted with FSK or OFDM, two common\nPHYs, the differences are immediately apparent.\n\nModulation aside, visually inspecting a spectro-\ngram of LoRa’s distinct chirps reveals a PHY struc-\nture that is similar to essentially all other digital\nradio systems: the preamble, start of frame delim-\niter, and then the data or payload.\n\nSince LoRa’s PHY is proprietary, no PHY layer\nspecifications or reference materials were available.\nHowever, thorough analysis of open source and read-\nily available documentation can greatly abbreviate\nreverse engineering processes. When I conducted\nthis investigation, a number of useful documents\nwere available.\n\nFirst, the Layer 2+ LoRaWAN stack is pub-\nlished, containing clues about the PHY.\n\nSecond, several application notes were available\nfor Semtech’s commercial LoRa modules.19 These\nwere not specs, but they did reference some PHY-\nlayer components and definitions.\n\nThird, a European patent filing from Semtech\ndescribed a CSS modulation that could very well be\nLoRa.\n\nFinally, neighbors who came before me had\nproduced open-source prior art in the form of\na partial rtl-sdrangelove implementation and\na wiki page,20 however in my experience the\nrtl-sdrangelove attempt was piecemeal and ne-\nglected and the wiki contained only high level ob-\nservations. These were not enough to decode the\npackets that I had captured in New Hampshire.\n\n7.3 Demodulation\n\nOSINT gathering revealed a number of key defi-\nnitions that informed the reverse engineering pro-\ncess. A crucial notion is that of the spreading fac-\ntor (SF): the spreading factor represents the num-\nber of bits packed into each symbol. A symbol,\nfor the unordained, is a discrete RF energy state\nthat represents some quantity of modulated infor-\nmation (more on this later.) The LoRaWAN spec\nrevealed that the chirp bandwidth, that is the width\nof the channel that the chirps traverse, is 125 kHz,\n\n19Semtech AN1200.18, AN1200.22.\n20Decoding LoRa on the RevSpace Wiki\n\n49\n\n\n\n250 kHz, or 500 kHz within American deployments.\nThe chirp rate, which is intuitively the first deriva-\ntive of the signal’s frequency, is a function of the\nspreading factor and the bandwidth: it is defined as\nbandwidth/2(spreading_factor). Additionally, the\nabsolute value of the downchirp rate is the same as\nthe upchirp rate.21\n\nBack to the crucial concept of symbols. In LoRa,\nsymbols are modulated onto chirps by changing the\ninstantaneous frequency of the signal – the first\nderivative of the frequency, the chirp rate, remains\nconstant, while the signal itself “jumps” through-\nout its channel to represent data. The best way\nto intuitively think of this is that the modulation\nis frequency-modulating an underlying chirp. This\nis analogous to the signal alternating between two\nfrequencies in a 2FSK system, where one frequency\nrepresents a 0 and the other represents a 1. The\nunderlying signal in that case is a signal of constant\nfrequency, rather than a chirp, and the number of\nbits per symbol is 1. How many data bits are en-\ncoded into each frequency jump within LoRa? This\nis determined by the spreading factor.\n\nThe first step to extracting the symbols is to de-\nchirp the received signal. This is done by channeliz-\ning the received signal to the chirp’s bandwidth and\nmultiplying the result against a locally-generated\ncomplex conjugate of whichever chirp is being ex-\ntracted.\n\nA locally generated chirp might look like this.\n\nSince both upchirps and downchirps are present\nin the modulation, the signal should be multiplied\nagainst both a local upchirp and downchirp, which\nproduces two separate IQ streams. Why this works\ncan be reasoned intuitively, since waves obey su-\nperposition, multiplying a signal with frequency f0\nagainst a signal with frequency −f0 results in a sig-\nnal with frequency 0, or DC. If a chirp is multiplied\nagainst a copy of itself, it will result in a signal of\n2 ∗ f0, which will spread its energy throughout the\nband. Thus, generating a local chirp at the nega-\ntive chirp rate of whichever chirp is being processed\n\n21See Semtech AN1200.22.\n\n50\n\n\n\nresults in RF features with constant frequency that\ncan be handled nicely.\n\nIn following examples, the left image shows de-\nchirped upchirps while the right shows de-chirped\ndownchirps:\n\nThis de-chirped signal may be treated similarly\nto MFSK, where the number of possible frequen-\ncies is M = 2(spreading_factor). The Fast Fourier\nTransform (FFT) is the tool used to perform the\nactual symbol measurement. Fourier analysis shows\nthat a signal can be modeled as a summed series of\nbasic periodic functions (i.e., a sine wave) at various\nfrequencies. A FFT decomposes a signal into the fre-\nquency components that comprise it, returning the\npower and phase of each component present. Each\ncomponent to be extracted is colloquially called a\n“bin;” the number of bins is specified as the “FFT\nsize” or “FFT width.”\n\nThus, by taking an M -bin wide FFT of each IQ\nstream, the symbols may be resolved by finding the\nargmax, which is the bin with the most powerful\ncomponent of each FFT. This works out nicely be-\ncause a de-chirped CSS symbol turns into a signal\nwith constant frequency; all of the symbol’s energy\nshould fall into a single bin.22\n\nWith the signal de-chirped, the remainder of\nthe demodulation process can be described in three\nsteps. These steps mimic the process required for\nessentially all digital radio receivers.\n\nFirst, we’ll identify the start of the packet by\nfinding a preamble. Then, we’ll synchronize with\nthe start of the packet, so that we may conclude in\ndemodulating the payload by measuring its aligned\nsymbols.\n\n7.3.1 Finding the Preamble\n\nA preamble is a feature included in modulation\nschemes to announce that a packet is soon to fol-\nlow. By visual inspection, we can infer that LoRa’s\npreamble is represented by a series of continuous\nupchirps. Once de-chirped and passed through an\nFFT, all of the preamble’s symbols wind up resid-\ning within the same FFT bin. Thus, a preamble is\ndetected if enough consecutive FFTs have the same\nargmax.\n\n7.3.2 Synchronizing with the SFD\n\nWith our receiver aware that it’s about to receive\na packet, the next step is to accurately synchronize\nwith it so that symbols can be resolved accurately.\nTo facilitate this, modern radio systems often adver-\ntise the start of the packet’s data unit with a Start of\n\n22It may be possible to do this using FM demodulation rather than FFTs, however using FFTs preserves power information\nthat is useful for framing the packet without knowing its definitive length.\n\n51\n\n\n\nFrame Delimiter, or SFD, which is a known symbol\ndistinct from the preamble that receivers are pro-\ngrammed to look for. For LoRa, this is where the\ndownchirps come in.\n\nThe SFD is composed of two and one quarter\ndownchirps, while all the other symbols are repre-\nsented by upchirps. With preamble having been\nfound, our receiver should look for two consecutive\ndownchirps to synchronize against. It looks some-\nthing like the following:\n\nAccurate synchronization is crucial to properly\nresolving symbols. If synchronization is off by\nenough samples, when FFTs are taken each sym-\nbol’s energy will be divided between two adjacent\nFFTs. Until now, the FFT process used to resolve\nthe symbols processed 2(spreading_factor) samples\nper FFT with each sample being processed exactly\nonce, however after a few trial runs it became evi-\ndent that this coarse synchronization would not be\nsufficiently accurate to guarantee good fidelity.\n\nIncreasing the time-based FFT resolution was\nfound to be a reliable method for achieving an ac-\ncurate sync. This is done by shifting the stream of\nde-chirped samples through the FFT input buffer,\nprocessing each sample multiple times, to “overlap”\nadjacent FFTs. This increases the time-based res-\nolution of the FFT process at the expense of be-\ning more computationally intensive. Thus, overlap-\nping FFTs are only used to frame the SFD; non-\noverlapped FFTs with each sample being processed\nexactly once are taken otherwise to balance accuracy\nand computational requirements.\n\nTechnically there’s also a sync word that pre-\ncedes the SFD, but my demodulation process de-\nscribed in this article does not rely on it.\n\n7.3.3 Demodulating the Payload\n\nNow synchronized against the SFD, we are able\nto efficiently demodulate the symbols in the pay-\nload by using the original non-overlapping FFT\nmethod. However, since our receiver’s locally gen-\nerated chirps are likely out of phase with the chirp\nused by the transmitter, the symbols appear offset\nwithin the set range [0 : 2(spreading_factor)−1] by\nsome constant. It was surmised that the preamble\nwould be a reliable element to represent symbol 0,\nespecially given that the aforementioned sync word’s\nvalue is always referenced from the preamble. A sim-\nple modulo operation to normalize the symbol value\nrelative to the preamble’s zero-valued bin produces\nthe true value of the symbols, and the demodulation\nprocess is complete.\n\n7.4 Decoding, and its Pitfalls\n\nOverall, demodulation proved to not be too difficult,\nespecially when you have someone like Balint See-\nber feeding you advice and sagely wisdom. However,\ndecoding is where the fun (and uncertainty) really\nbegan.\n\nFirst, why encode data? In order to increase\nover the air resiliency, data is encoded before it is\nsent. Thus, the received symbols must be decoded\nin order to extract the data they represent.\n\nThe documentation I was able to gather on LoRa\ncertainly suggested that figuring out the decoding\nwould be a snap. The patent application describ-\ning a LoRa-like modulation described four decoding\nsteps that were likely present. Between the patent\nand some of Semtech’s reference designs, there were\ndocumented algorithms or detailed descriptions of\nevery step. However, these documents slowly proved\nto be lies, and my optimism proved to be misplaced.\n\n7.4.1 OSINT Revisited\n\nPerhaps the richest source of overall hints was\nSemtech’s European patent application.23 The\npatent describes a CSS-based modulation with an\nuncanny resemblance to LoRa, and goes so far as\nto walk step-by-step through the encoding elements\npresent in the PHY. From the encoder’s perspec-\ntive, the patent describes an encoding pipeline of\nforward error correction, a diagonal interleaver, data\nwhitening, and gray indexing, followed by the just-\ndescribed modulation process. The reverse process\n\n23European Patent #13154071.8/EP20130154071\n\n52\n\n\n\nFigure 12. The top is pre-sync and non-overlapped, middle is pre-sync overlapped, bottom is synchronized\nand non-overlapped.\n\n53\n\n\n\nwould be performed by the decoder. The patent\neven defines an interleaver algorithm, and Semtech\ndocumentation includes several candidate whitening\nalgorithms.\n\nThe first thing to try, of course, was to imple-\nment a decoder exactly as described in the docu-\nmentation. This involved, in order:\n\n1. Undoing gray coding applied to the symbols.\n\n2. Dewhitening using the algorithms defined in\nSemtech’s documentation.\n\n3. Deinterleaving using the algorithm defined in\nSemtech’s patent.\n\n4. Processing the Hamming forward error correc-\ntion hinted at in Semtech’s documentation.\n\nFirst, let’s review what we have learned about\neach step listed above based on open-source re-\nsearch, and what would be attempted as a result.\n\nGray Indexing Given the nomenclature ambigu-\nity in the Semtech patent, I also decided to test no\ngray coding and reverse gray coding in addition to\nforward gray coding. These were done using stan-\ndard algorithms.\n\nData Whitening Data whitening was a colossal\nquestion mark while looking at the system. An ideal\nwhitening algorithm is pseudorandom, thus an effec-\ntive obfuscator for all following components of the\nsystem. Luckily, Semtech appeared to have pub-\nlished the algorithm candidates in Application Note\nAN1200.18. Entitled “Implementing Data Whiten-\ning and CRC Calculation in Software on SX12xx\nDevices,” it describes three different whitening algo-\nrithms that were relevant to the Semtech SX12xx-\nseries wireless transceiver ICs, some of which sup-\nport LoRa. The whitening document provided one\nCCITT whitening sequences and two IBM methods\nin C++. As with the gray indexing uncertainty, all\nthree were implemented and permuted.\n\nInterleaver Interleaving refers to methods of de-\nterministically scrambling bits within a packet. It\nimproves the effectiveness of Forward Error Correc-\ntion, and will be elaborated on later in this text.\nThe Semtech patent application defined a diago-\nnal interleaver as LoRa’s probable interleaver. It is\na block-style non-additive diagonal interleaver that\n\nshuffles bits within a block of a fixed size. The in-\nterleaver is defined as: Symbol(j, (i + j)%PPM) =\nCodeword(i, j) where 0 <= i < PPM, 0 <= j <\n4 + RDD In this case, PPM is set to the spreading\nfactor (or spreading_factor−2 for the PHY header\nand when in low data rate modes), and RDD is set\nto the number of parity bits used by the Forward\nError Correction scheme (ranging [1 : 4]).\n\nThere was only one candidate illustrated here,\nso no iteration was necessary.\n\nForward Error Correction The Semtech patent\napplication suggests that Hamming FEC be used.\nOther documentation appeared to confirm this. A\ncustom FEC decoder was implemented that orig-\ninally just extracted the data bits from their stan-\ndard positions within Hamming(8,4) codewords, but\nearly results were negative, so this was extended to\napply the parity bits to repair errors.\n\nUsing a Microchip RN2903 LoRa Mote, a transmit-\nter that was understood to be able to produce raw\nframes, a known payload was sent and decoded us-\ning this process. However, the output that resulted\nbore no resemblance to the expected payload. The\nnext step was to inspect and validate each of the\nalgorithms derived from documentation.\n\nAfter validating each component, attempting ev-\nery permutation of supplied algorithms, and inspect-\ning the produced binary data, I concluded that\nsomething in LoRa’s described encoding sequence\nwas not as advertised.\n\n7.5 Taking Nothing for Granted\nThe nature of analyzing systems like this is that\nbeneath a certain point they become a black box.\nData goes in, some math gets done, RF happens,\nsaid math gets undone, and data comes out. Sim-\nple enough, but when encapsulated as a totality it\nbecomes difficult to isolate and chase down bugs in\neach component. Thus, the place to start was at the\ntop.\n\n54\n\n\n\n7.5.1 How to Bound a Problem\n\nThe Semtech patent describes the first stage of de-\ncoding as “gray indexing.” Gray coding is a process\nthat maps bits in such a way that makes it resilient\nto off-by-one errors. Thus, if a symbol were to be\nmeasured within ±1 index of the correct bin, the\ngray coding would naturally correct the error. “Gray\nindexing,” ambiguously referring to either gray cod-\ning or its inverse process, was initially understood\nto mean forward gray coding.\n\nThe whitening sequence was next in line. Data\nwhitening is a process applied to transmitted data\nto induce randomness into it. To whiten data, the\ndata is XORed against a pseudorandom string that\nis known to both the transmitter and the receiver.\nThis does good things from an RF perspective, since\nit induces lots of features and transitions for a re-\nceiver to perform clock recovery against. This is\nfunctionally analogous to line coding schemes such\nas Manchester encoding, but whitening offers one\npro and one con relative to line coding: data whiten-\ning does not impact the effective bit rate as Manch-\nester encoding does,24 but this comes at the expense\nof legibility due to the pseudorandom string.\n\nAt this point, it is important to address some of\nthe assumptions and inferences that were made to\nframe the following approach. While the four de-\ncoding stages were thrown into question by virtue\nof the fact that at least one of the well-described\nalgorithms was not correct, certain implied proper-\nties could be generalized for each class of algorithm,\neven if the implementation did not match exactly.\n\nI made a number of assumptions at this point,\nwhich I’ll describe in turn.\n\nFirst, the interleaver in use is non-additive. This\nmeans that while it will reorder the bits within each\ninterleaving block, it will not cause any additional\nbits to be set or unset. This was a reasonable\n\nassumption because many block-based interleavers\nare non-additive, and the interleaver defined in the\npatent is non-additive as well. Even if the interleaver\nused a different algorithm, such as a standard block\ninterleaver or a different type of diagonal interleaver,\nit could still fit within this model.\n\nSecond, the forward error correction in use is\nHamming FEC, with 4 data bits and 1-4 parity bits\nper codeword. FEC can be thought of as super-\ncharged parity bits. A single parity bit can indicate\nthe presence of an error, but if you use enough of\nthem they can collectively identify and correct er-\nrors in place, without re-transmission. Hamming is\nspecifically called out by the European patent, and\nthe code rate parameter referenced throughout ref-\nerence designs fits nicely within this model. The use\nof Hamming codes, as opposed to some other FEC\nor a cyclic coding scheme, was fortuitous because\nof a property of the Hamming code words. Ham-\nming codeword mapping is deterministic based on\nthe nybble that is being encoded. Four bits of data\nprovide 16 possible codewords. When looking at\nHamming(8,4) (which is the inferred FEC for LoRa\ncode rate 4/8), 14 of the 16 codewords contain four\nset bits (1s) and four unset bits (0s). However, the\ncode words for 0b0000 and 0b1111 are 0b00000000\nand 0b11111111, respectively.\n\nThus, following on these two assumptions, if a\npayload containing all 0x00s or 0xFFs were sent,\nthen the interleaving and forward error correction\nshould cancel out and not affect the output at all.\nThis reduces our unknown stages in the decoding\nchain from four to just two, with the unknowns be-\ning gray indexing and whitening, and once those are\nresolved then the remaining two can be solved for!\n\nSince “gray indexing” likely refers to gray cod-\ning, reverse gray coding, or no coding should it be\nomitted, this leaves only three permutations to try\nwhile solving for the data whitening sequence.\n\nThe first step was to take a critical look at\nthe data whitening algorithms provided by Semtech\nAN1200.18. Given the detail and granularity in\nwhich they are described, plus the relevance of\nhaving come straight from a LoRa transceiver\ndatasheet, it was almost a given that one of the three\nalgorithms would be the solution. With the inter-\nleaver and FEC effectively zeroed out, and “gray in-\ndexing” reduced to three possible states, it became\npossible to test each of the whitening algorithms.\n\nTesting each whitening algorithm was fairly\n24Manchester’s effective bit rate is 1/2 baud rate.\n\n55\n\n\n\nstraightforward. A known payload of all 0x00s or\n0xFFs (to cancel out interleaving and FEC) was\ntransmitted from the Microchip LoRa Technology\nMote and then decoded using each whitening al-\ngorithm and each of the possible “gray indexing”\nstates. This resulted in 9 total permutations. A\nvisual diff of the decoded data versus the expected\npayload resulted in no close matches. This was re-\nplaced with a diff script with a configurable toler-\nance for bits that did not match. This also resulted\nin no matches as well. One final thought was to\nforward compute the whitening algorithms in case\nthere was a static offset or seed warm-up, as can\nbe the case with other PRNG algorithms. Likewise,\nthis did not reveal any close matches. This meant\nthat either none of the given whitening algorithms\nin the documentation were utilized, or the assump-\ntions that I made about the interleaver and FEC\nwere not correct.\n\nAfter writing off the provided whitening algo-\nrithms as fiction, the next course of action was to\nattempt to derive the real whitening algorithm from\nthe LoRa transmitter itself. This approach was\nbased on the previous observations about the FEC\nand interleaver and a fundamental understanding of\nhow data whitening works. In essence, whitening is\nas simple as XORing a payload against a static pseu-\ndorandom string, with the same string used by both\nthe transmitter and receiver. Since anything XORed\nwith zero is itself, passing in a string of zeroes causes\nthe transmitter to reveal a “gray indexed” version of\nits whitening sequence.\n\nThis payload was received, then transformed into\nthree different versions of itself: one gray-coded, one\nunmodified, and one reverse gray-coded. All three\nwere then tested by transmitting a set of 0xF data\nnybbles and using each of the three “gray indexing”\ncandidates and received whitening sequence to de-\ncode the payload. The gray coded and unmodified\nversions proved to be incorrect, but the reverse gray\ncoding version successfully produced the transmit-\nted nybbles, and thus in one fell swoop, I was able\nto both derive the whitening sequence and discern\nthat “gray indexing” actually referred to the reverse\ngray coding operation. With “gray indexing” and\nwhitening solved, I could turn my attention to the\nbiggest challenge: the interleaver.\n\n7.5.2 The Interleaver\n\nAt this point we’ve resolved two of the four signal\nprocessing stages, disproving their documentation\n\nin the process. Following on this, the validity of the\ninterleaver definition provided in Semtech’s patent\nwas immediately called into question.\n\nA quick test was conducted against a local im-\nplementation of said interleaver: a payload com-\nprised of a repeated data byte that would produce\na Hamming(8,4) codeword with four set and four\nunset bits was transmitted and the de-interleaved\nframe was inspected for signs of the expected code-\nword. A few other iterations were attempted, in-\ncluding reversing the diagonal offset mapping pat-\ntern described by the patent and using the inverse\nof the algorithm (i.e., interleaving the received pay-\nload rather than de-interleaving it). Indeed, I was\nable to conclude that the interleaver implemented by\nthe protocol is not the one suggested by the patent.\nThe next logical step is to attempt to reverse it.\n\nWithin a transmitter, interleaving is often ap-\nplied after forward error correction in order to make\nthe packet more resilient to burst interference. In-\nterleaving scrambles the FEC-encoded bits through-\nout the packet so that if interference occurs it is\nmore likely to damage one bit from many codewords\nrather than several bits from a single codeword. The\nformer error scenario would be recoverable through\nFEC, the latter would result in unrecoverable data\ncorruption.\n\nBlock-based interleavers, like the one described\nin the patent, are functionally straightforward.\nThe interleaver itself can be thought of as a two-\ndimensional array, where each row is as wide as the\nnumber of bits in each FEC codeword and the num-\nber of columns corresponds to the number of FEC\ncodewords in each interleaver block. The data is\nthen written in row-wise and read out column-wise;\nthus the first output “codeword” is comprised of the\nLSB (or MSB) of each FEC codeword. A diagonal\ninterleaver, as suggested in the patent, offsets the\ncolumn of the bit being read out as rows are tra-\nversed.\n\nUnderstanding the aforementioned fundamentals\nof what the interleaver was likely doing was essen-\ntial to approaching this challenge. Ultimately, given\nthat a row-column or row-diagonal relationship de-\nfines most block-based interleavers, I anticipated\nthat patterns that could be revealed if approached\nappropriately. Payloads were therefore constructed\nto reveal the relationship of each row or codeword\nwith a corresponding diagonal or column. In order\nto reveal said mapping, the Hamming(8,4) codeword\nfor 0xF was leveraged, since it would fill each row\n\n56\n\n\n\n0x0000000F 0x000000F0 0x00000F00 0x0000F000 0x000F0000 0x00F00000 0x0F000000 0xF0000000\n00100011 11000000 00001001 11010000 00000011 01000100 01000001 00001000\n00010011 00100101 00000111 00001001 00000011 00000011 10000010 01000101\n00001001 00010001 00000011 00000101 01000001 00000000 00100001 10000011\n00000111 00001101 00000011 00000110 10000010 01000101 00010010 00100011\n00000000 00001100 01000010 00001000 00100010 10001001 00001010 00010011\n00000100 00000000 10000001 01000010 00010001 00100010 00000111 00001011\n01000011 00000001 00100001 10000000 00001001 00010000 00000011 00000111\n10000101 01000111 00010000 00100101 00000000 00001111 00000101 00000111\n\nFigure 13. Symbol Tests\n\nwith eight contiguous bits at a time. Payloads con-\nsisting of seven 0x0 codewords and one 0xF code-\nword were generated, with the nybble position of\n0xF iterating through the payload. See Figure 13.\n\nAs one can see, by visualizing the results as they\nwould be generated by the block, patterns associ-\nated with each codeword’s diagonal mapping can be\nidentified. The diagonals are arbitrarily offset from\nthe corresponding row/codeword position. One im-\nportant oddity to note is that the most significant\nbits of each diagonal are flipped.\n\nWhile we now know how FEC codewords map\ninto block diagonals, we do not know where each\ncodeword starts and ends within the diagonals, or\nhow its bits are mapped. The next step is to map\nthe bit positions of each interleaver diagonal. This\nis done by transmitting a known payload comprised\nof FEC codewords with 4 set and 4 unset bits and\nlooking for patterns within the expected diagonal.\n\n1 Payload : 0xDEADBEEF\nb i t 76543210\n\n3 00110011\n10111110\n\n5 11111010\n11011101\n\n7 10000010\n10000111\n\n9 11000000\n10000010\n\nReading out the mapped diagonals results in the\nfollowing table.\n\nT Bot\nD 1 0 1 0 0 0 0 1\nE 0 1 1 1 0 1 0 0\nA 0 1 0 1 1 0 0 0\nD 1 0 1 1 0 0 0 0\nB 1 1 0 0 0 0 1 0\nE 0 1 1 1 0 1 0 0\nE 0 1 1 1 0 1 0 0\nF 1 1 1 1 1 1 1 1\nWhile no matches immediately leap off the page,\n\nmanipulating and shuffling through the data begins\n\nto reveal patterns. First, reverse the bit order of the\nextracted codewords:\n\nB Top\nD 1 0 0 0 0 1 0 1\nE 0 0 1 0 1 1 1 0\nA 0 0 0 1 1 0 1 0\nD 0 0 0 0 1 1 0 1\nB 0 1 0 0 0 0 1 1\nE 0 0 1 0 1 1 1 0\nE 0 0 1 0 1 1 1 0\nF 1 1 1 1 1 1 1 1\nAnd then have a look at the last nybble for each\n\nof the highlighted codewords:\nB Top\n\nD 1 0 0 0 0 1 0 1\nE 0 0 1 0 1 1 1 0\nA 0 0 0 1 1 0 1 0\nD 0 0 0 0 1 1 0 1\nB 0 1 0 0 0 0 1 1\nE 0 0 1 0 1 1 1 0\nE 0 0 1 0 1 1 1 0\nF 1 1 1 1 1 1 1 1\nSix of the eight diagonals resemble the data em-\n\nbedded into each of the expected FEC encoded code-\nwords! As for the first and fifth codewords, it is\npossible they were damaged during transmission, or\nthat the derived whitening sequence used for those\npositions is not exact. That is where FEC proves its\nmettle – applying Hamming(8,4) FEC would repair\nany single bit errors that occurred in transmission.\nThe Hamming parity bits that are expected with\neach codeword are calculated using the Hamming\nFEC algorithm, or can be looked up for standard\nschemes like Hamming(7,4) or Hamming(8,4).\n\nData (8 , 4 ) Par i ty Bi t s\n2 0xD 1101 1000\n\n0xE 1110 0001\n4 0xA 1010 1010\n\n0xD 1101 1000\n6 0xB 1011 0100\n\n0xE 1110 0001\n8 0xE 1110 0001\n\n0xF 1111 1111\n\n57\n\n\n\nWhile the most standard Hamming(8,4) bit or-\nder is: p1, p2, d1, p3, d2, d3, d4, p4 (where p are\nparity bits and d are data bits), after recognizing the\nabove data values we can infer that the parity bits\nare in a nonstandard order. Looking at the diago-\nnal codeword table and the expected Hamming(8,4)\nencodings together, we can map the actual bit posi-\ntions:\n\nBot Top\np1 p2 p4 p3 d1 d2 d3 d4\n\nD 1 0 0 0 0 1 0 1\nE 0 0 1 0 1 1 1 0\nA 0 0 0 1 1 0 1 0\nD 0 0 0 0 1 1 0 1\nB 0 1 0 0 0 0 1 1\nE 0 0 1 0 1 1 1 0\nE 0 0 1 0 1 1 1 0\nF 1 1 1 1 1 1 1 1\nNote that parity bits three and four are swapped.\n\nWith that resolved, we can use the parity bits to de-\ncode the forward error correction, resulting in four\nbits being corrected, as shown in Figure 14.\n\nThat’s LoRa!\n– — — – — — — — – — –\n\nHaving reversed the protocol, it is important to\nlook back and reflect on how and why this worked.\nAs it turned out, being able to make assumptions\nand inferences about certain goings-on was crucial\nfor bounding the problem and iteratively verify-\ning components and solving for unknowns. Recall\nthat by effectively canceling out interleaving and\nforward error correction, I was able to effectively\nsplit the problem in two. This enabled me to solve\nfor whitening, even though “gray indexing” was un-\nknown there were only three permutations, and with\nthat in hand, I was able to solve for the interleaver,\nsince FEC was understood to some extent. Just like\nalgebra or any other scientific inquiry, it comes down\nto controlling your variables. By stepping through\nthe problem methodically and making the right in-\nferences, we were able to reduce 4 independent vari-\nables to 1, solve for it, and then plug that back in\nand solve for the rest.\n\n7.6 Remaining Work\nWhile the aforementioned process represents a com-\nprehensive description of the PHY, there are a few\npieces that will be filled in over time.\n\nThe LoRa PHY contains an optional header with\nits own checksum. I have not yet reversed the\n\nheader, and the Microchip LoRa module I’ve used\nto generate LoRa traffic does not expose the option\nof disabling the header. Thus I cannot zero those\nbits out to calculate the whitening sequence applied\nto it. It should be straightforward to fill in with the\ncorrect hardware in hand.\n\nThe PHY header and service data unit/payload\nCRCs have not been investigated for the same rea-\nson. This should be easy to resolve through the use\nof a tool like CRC RevEng once the header is known.\n\nIn my experience, for demodulation purposes\nclock recovery has not been necessary beyond get-\nting an accurate initial sync on the SFD. However\nshould clock drift pose a problem, for example if\ntransmitting longer messages or using higher spread-\ning factors which have slower data rates/longer over-\nthe-air transmission times, clock recovery may be\ndesirable.\n\n7.7 Shameless Plug\n\nI recently published an open source GNU Radio\nOOT module that implements a transceiver based\non this derived version of the LoRa PHY. It is pre-\nsented to empower RF and security researchers to\ninvestigate this nascent protocol.25\n\n25git clone https://github.com/BastilleResearch/gr-lora\nunzip pocorgtfo13.pdf gr-lora.tar.bz2\n\n58\n\n\n\nTop\np1 p2 p4 p3 d1 d2 d3 d4\n\nD 1 0 0 0 1 1 0 1 1101 = 0xD\nE 0 0 1 0 1 1 1 0 1110 = 0xE\nA 1 0 0 1 1 0 1 0 1010 = 0xA\nD 1 0 0 0 1 1 0 1 1101 = 0xD\nB 0 1 0 0 1 0 1 1 1011 = 0xB\nE 0 0 1 0 1 1 1 0 1110 = 0xE\nE 0 0 1 0 1 1 1 0 1110 = 0xE\nF 1 1 1 1 1 1 1 1 1111 = 0xF\n\nFigure 14. Forward Error Corrected bits shown in bold\n\n7.8 Conclusions and Key Takeaways\nPresented here is the process that resulted in a com-\nprehensive deconstruction of the LoRa PHY layer,\nand the details one would need to implement the\nprotocol. Beyond that, however, is a testament to\nthe challenges posed by red herrings (or three of\nthem, all at once) encountered throughout the re-\nverse engineering process. While open source in-\ntelligence and documentation can be a boon to re-\nsearchers – and make no mistake, it was enormously\nhelpful in debunking LoRa – one must remember\nthat even the most authentic sources may sometimes\nlie!\n\nAnother point to take away from this is the im-\nportance of bounding problems as you solve them,\nincluding through making informed inferences in the\nabsence of perfect information. This of course must\nbe balanced with the first point about OSINT, is\nknowing when to walk away from a source. How-\never as illustrated above, drawing appropriate con-\nclusions proved integral to reducing and solving for\neach of the decoding elements within a black-box\nmethodology.\n\nThe final thought I will leave you with is that\nwireless doesn’t just mean Wi-Fi anymore - it in-\ncludes cellular, PANs, LPWANs, and everything in\nbetween. Accordingly, a friendly reminder that se-\ncurity monitoring and test tools don’t exist until\nsomeone creates them. Monitor mode and Wire-\nshark weren’t always a thing, so don’t take them\nfor granted: it’s time to make the next generation\nof wireless networks visible to researchers, because\nknow it or not it is already here and is here to stay.\n\n59\n\n\n\n8 Plumbing, not Popper;\nor, the Problem with STEP\n\nby Pastor Manul Laphroaig\n\nGather round, neighbors. We are going to a mag-\nical place. One that we hardly ever notice in our\nbusy lives, but which has a way of taking over your\nentire day when you are forced to visit it. We are\ngoing on a trip to the plumbing closet!26\n\nLook at the miracle that is the clump of pipes,\nlooking right back at you. Its message is clear: do\nnot approach without skill, unless you like wet, gi-\ngantic messes. This message is universal: it speaks\nto a politician, a professor, an NYT columnist, a\nmovie actor, and a hedge fund manager alike. It\ntranscends languages and beliefs.\n\nEven though these worthies and civic leaders\nmight agree the country could use more plumbers,\nit has not yet occurred to them to approach the\nproblem by putting a big P into some popular slo-\ngan like “STEP” (Science, Technology, Engineering,\nPlumbing), by setting up a federal Department of\nPlumbing, or by lionizing a professional coveralls-\nwearer TV personality who goes by “A Plumbing\nGuy,” despite never having fixed a pipe in his life.\n\nThey somehow know that these things will do\ndiddly squat to address the shortage of plumbers.\nThey know deep down that to learn plumbing—and\neven to not sound ridiculous about it—one needs to\n\nstudy with a plumber, attach oneself to a plumber,\nand do what a plumber does for a while. This, neigh-\nbors, is how deep the plumbing magic goes.\n\nScience, alas, has not been so lucky.\n– — — – — — — — – — –\n\nIt is fashionable to talk about how we need more\nscientists, and how we can direct and improve sci-\nence, quoting grand theories that explain science,\nwhile similarly educated people nod approvingly.\nAfter all, they all know what science is, as befits\nall forward-thinking people these days. No one feels\nawkward; everyone feels good.\n\nPerhaps this happens because our social betters\nall experienced helplessness at the sight of broken\nplumbing, but would not recognize broken science,\nmuch less a hopelessly broken science textbook. You\nsee, science lab equipment is OK with a patroniz-\ning, self-satisfied gaze, whereas plumbing has a way\nof glaring back contemptuously, daring you to use\nyour general theoretical understanding.\n\nWith plumbing, it’s either practical skill or\na huge mess in your basement. Messing with\nhow plumbers learn and teach this skill guarantees\nmesses in thousands of basements. If you value your\nplumbing, it’s wise to leave plumbers alone even if\nyou believe every word of every newspaper column\nyou’ve ever read on plumbing economy.\n\nIt may be a surprise to the readers of Karl Pop-\nper and Imre Lakatos27 that actual scientists are\nhelped by philosophy of science in exactly the same\nway as plumbers are helped by the Zen of Plumb-\ning. Although these very same people are likely to\nbelieve they understand plumbing too, they usually\nhave the sense to leave the plumbing profession well\nalone, and not apply their philosophical understand-\nings to it—being empirically familiar with the fact\nthat when you need plumbing done, philosophy is\nuseless; only the skill stands between the water in\nyour pipes and your expensive library.\n\n– — — – — — — — – — –\n26For those of you fortunate to own a house, it’s probably in the corner of your basement, an equally magical place, whence\n\nall science and innovation springs forth—but let us not digress.\n27Lakatos the philosopher is considered to be a great intellectual authority. For what it’s worth, you might also want to read\n\nabout how he applied his philosophy in real life: unzip pocorgtfo13 freudenthal.pdf\n\n60\n\n\n\n61\n\nMceAVITY’S PLUMBER S’\n\nPLUMBERS’ TOOLS\n\nPlate 2213\nShave Hook.\nPrice, per Doz... .$6.00\n\nPlate 2211\nTap Borer. Price, per Doz.$6.00\n\nPlate 2212 Plate 2215\nPlate 2214 Bibb reseating Tool with Cutters Bench Mallet\nPlumbers’ Snips For $6''-19\"-26\"-34\" Bibbs. Price, per Doz : $6.00\nNo. 5 3 % ” Cut Each. .$3.50 Price, Each................-- $5.00 2 es\nNo. 3.00 Extra Cutters, per set......... 2.50\nNo. 10 2 y \"\n\nPlate 2217\nLead Pipe Bending Spring\nSizes 1” 14%\" 1144” 2”\nPlate 2216 Price, Each....... $1.25 $1.50 $1.75 $2.00\n\n. Burner Pliers\nSizes a rr LE ; a\n\nPrice, Each.$ .75 $1.00 $1.25\n\nPlate 22110\n. . . Steel Bend Iron\n\nPlate 2219— Combination Pliers Price, Each.... ......... $ .75\nSizes 6” 8” — 10”\nNickel Plated..$ 1.50 $1.75 $2.00\n\nPlate 2218 Polished Steel.. 1.25 1.50 1.75\n\nBoxwood Lead Dresser Blue finished\nPrice, per Doz..........$15.00 Steel..... 1.00\n\nPlate 21111\n‘* Rivetting Hammer ”’\nSizes 1” 2” 3”\nPrice...... $1.50 $1.25 $1.00\n\nCold Chisel................20000- Yr 5\"\nPrice, Each................02005. $ .50° $.75\n\nPlate 22113—Capé Chisel\nPrice, Each, 34”...........0..0005 $ .50\n\nPlate 22114 Plate 22115 Plate 22116\nStraight Caulking Chisel Picking Chisel Regular Caulking Chisel\nPrice, Each............ $ .75 Price, Each........ $ .75 Size, 34’’ Price, Each. ...$ .75\n\nreo —r\nPlate 22118\nPlate 22117 Rand L Hand Caulking Chisel Plate 22119\nLong Packing Iron Price, Each........... 1.00 Round nose Pliers,\nSize, 18”. Price, Each.... $ .75 rey aE $ Stocked from 4” to 8”\n\n61\n\n\n\n\nBy far the worst hit to a profession is delivered\nwhen a part of the professionals actually welcomes\nphilosophers lauding it, politicians bearing gifts and\ngrants, and governments setting up departments to\npromote it. Forms to fill, ever-growing grant appli-\ncation paperwork, pervasive “performance metrics,”\nand having to explain basic fallacies to the well-\nmeaning but fundamentally ignorant and hugely\npowerful committees come later—and accumulate.\nIn the context of metrics, charlatans always win, be-\ncause they don’t get distracted by trying for actual\nresults.\n\nNot to mention that the money that goes to char-\nlatans is not net-neutral for actual plumbing (or sci-\nence); it is net-negative, because charlatans have a\nway of making the lives of professionals hard where\nit hurts the most. When Tim “the Tool Man” Tay-\nlor waves power tools around with a swagger, the\n\nresults are immediate and obvious. When learned\ncommittees do the professional equivalent thereof to\nmath textbooks and call it nice names like “Discov-\nery Math,” “Common Core,” or “Critical Thinking”\nit takes a generation to notice, and then we wonder—\nhow on earth did school math become unteachable\nand unlearnable?28\n\nPlumbers have wisely avoided it, perhaps due to\nsome secret wisdom passed from master to appren-\ntice through the ages. Scientists, I am sorry to say,\nwalked right into it around the middle of the twen-\ntieth century.\n\nSure enough, national agencies got us to the\nmoon—but it seems that all the good science school-\nbooks have been put on the rockets going there,\nnever to return. Have you met many scientists who\nare happy with what schools do to their sciences\nafter half a century of being improved by various\ngovernment offices?\n\nFunny how it worked out for scientists. Now hear\nthem complain about “publish or perish,” the rapidly\nrising age at which one finally succeeds in getting\none’s first grant, and the relentless race to rebrand\nand follow the current big-ticket grant programs.29\n\nBut don’t blame them, neighbors; it was their\nadvisors or their advisors’ advisors who fell for it.\nBetter to buy them a drink, and remember their\nlesson.\n\nBetter yet, find some plumbers, and buy them\ndrinks. Perhaps they’ll share with you some of their\nsecrets of how to keep the philosophers and their\neducated and benevolent readers interested in the\nresult, but at a safe distance from the actual plumb-\ning.\n\n28We sort of know the answer, neighbors: a roller coaster of reforms and unintelligible standards created a generation of math\nteachers for whom math did not have to make sense. unzip pocorgtfo13.pdf wu-preparing-teachers.pdf and read it. It may\napply to whatever else you hold dear.\n\n29According to Ronald J. Daniels, President of Baltimore’s Johns Hopkins University, no less than the whole generation\nis at risk: “A generation at risk: Young investigators and the future of the biomedical workforce.” (unzip pocorgtfo13.pdf\natrisk.pdf.) For more of this, read “Science in the Age of Selfies” by Donald Geman, Stuart Geman. (selfies.pdf.) It’s hard\nto make these things up, neighbors.\n\n62\n\n\n\n9 Where is ShimDBC.exe?\nby Geoff Chappell\n\nMicrosoft’s Shim Database Compiler might be a\nlegend . . . except that nobody seems ever to have\nmade any story of it. It might be mythical . . . ex-\ncept that it actually does exist. Indeed, it has been\naround for 15 years in more or less plain sight. Yet\nif you ask Google to search the Internet for occur-\nrences of shimdbc, and especially of “shimdbc.exe”\nin quotes, you get either remarkably little or a tan-\ntalising hint, depending on your perspective.\n\nMostly, you get those scam sites that have pre-\npared a page for seemingly every executable that\nhas ever existed and can fix it for you if only you\nwill please download their repair tool. But amongst\nthis dross is a page from Microsoft’s TechNet site.\nGoogle excerpts that “QFixApp uses the support\nutility ShimDBC.exe to test the group of selected\nfixes.” Follow the link and you get to one of those\nrelatively extensive pages that Microsoft sometimes\nwrites to sketch a new feature for system adminis-\ntrators and advanced users (if not also to pat them-\nselves on the back for the great new work). This\npage is from 2001 and is titled Windows XP Appli-\ncation Compatibility Technologies.30\n\n9.1 Application Compatibility?\n\nThere can’t be anything more boring in the whole\nof Windows, you may think. I certainly used to,\nand might still for applications if I cared enough,\nbut Windows 8 brought Application Compatibility\nto kernel mode in a whole new way, and this I do\ncare about.\n\nThe integrity of any kernel-mode driver that you\nor I write nowadays depends on what anyone else,\nwell-meaning or not, can get into the DRVMAIN.SDB\nfile in the AppPatch subdirectory of the Windows\ninstallation. This particular Shim Database file ex-\nists in earlier Windows versions too, but only to list\ndrivers that the kernel is not to load. If you’re the\nwriter of a driver, there’s nothing you can do at run-\ntime about your driver being blocked from loading,\nand in some sense you’re not even affected: you’re\nnot loaded and that’s that. Starting with Win-\ndows 8, however, the DRVMAIN.SDB file defines the\ninstalled shim providers and either the registry or\nthe file can associate your driver with one or more of\nthese defined shim providers. When your driver gets\nloaded, the applicable shim providers get loaded too,\nif they are not already, and before long your driver’s\nimage in memory has been patched, both for how it\ncalls out through its Import Address Table and how\nit gets called, e.g., to handle I/O requests.\n\nIn this brave new world, is your driver really\nyour driver? You might hope that Microsoft would\nat least give you the tools to find out, if only so\nthat you can establish that a reported problem with\nyour driver really is with your driver. After all,\nfor the analogous shimming, patching, and what-\never of applications, Microsoft has long provided an\nApplication Compatibility Toolkit (ACT), recently\nre-branded as the Windows Assessment and Deploy-\nment Kit (ADK). The plausible thoroughness of this\nkit’s Compatibility Administrator in presenting a\ntree view of the details is much of the reason that\nI, for one, regarded the topic as offering, at best,\nslim pickings for research. For the driver database,\nhowever, this kit does nothing—well, except to leave\nme thinking that the SDB file format and the API\nsupport through which SDB files get interpreted,\ncreated, and might be edited, are now questions I\nshould want to answer for myself rather than imag-\n\n30https://technet.microsoft.com/library/bb457032.aspx\n\n63\n\n\n\nine they’ve already been answered well by whoever\nmanaged somehow to care about Application Com-\npatibility all along.\n\n9.2 The SDB File Format\n\nRelax! I’m not taking you to the depths of Applica-\ntion Compatibility, not even just for what’s specific\nto driver shims. Our topic here is reverse engineer-\ning. Now that you know what these SDB files are\nand why we might care to know what’s in them,\nI expect that if you have no interest at all in Ap-\nplication Compatibility, you can treat this part of\nthis article as using SDB files just as an example\nfor some general concerns about how we present\nreverse-engineered file formats. (And please don’t\nskip ahead, but I promise that the final part is pretty\nmuch nothing but ugly hackery.)\n\nLet’s work even more specifically with just one\nexample of an SDB file, shown in Figure 15. It’s a\nlittle long, despite being nearly minimal. It defines\none driver shim but no drivers to which this shim is\nto be applied.\n\nAlthough Microsoft has not documented the\nSDB file format, Microsoft has documented a se-\nlection of API functions that work with SDB files,\nwhich is in some ways preferable. Perhaps by look-\ning at these functions researchers and reverse engi-\nneers have come to know at least something of the\nfile format, as evidenced by various tools they have\npublished which interpret SDB files one way or an-\nother, typically as XML.\n\nAs a rough summary, an SDB file has a 3-dword\nheader, for a major version, minor version, and sig-\nnature, and the rest of the file is a list of variable-size\ntags which each have three parts:\n\n1. a 16-bit TAG, whose numerical value tells of the\ntag’s type and purpose;\n\n2. a size in bytes, which can be given explicitly as\na dword or may be implied by the high 4 bits\nof the TAG;\n\n3. and then that many bytes of data, whose in-\nterpretation depends on the TAG.\n\nImportantly for the power of the file format, the\ndata for some tags (the ones whose high 4 bits are\n7) is itself a list of tags. From this summary and a\nfew details about the recognised TAG values, the im-\nplied sizes and the general interpretation of the data,\n\ne.g., as word, dword, binary, or Unicode string—\nall of which can be gleaned from Microsoft’s admit-\ntedly terse documentation of those API functions—\nyou might think to reorganise the raw dump so that\nit retains every byte but more conveniently shows\nthe hierarchy of tags, each with their TAG, size (if\nexplicit) and data (if present). A decoding of Fig-\nure 15 is shown in Figure 16.\n\nTo manually verify that everything in the file is\nexactly as it should be, there is perhaps no better\nrepresentation to work from than one that retains\nevery byte. In practice, though, you’ll want some\ninterpretation. Indeed, the dump above does this\nalready for the tags whose high 4 bits are 6. The\ndata for any such tag is a string reference, specifi-\ncally the offset of a 0x8801 tag within the 0x7801\ntag (at offset 0x0142 in this example), and an auto-\nmated dump can save you a little trouble by show-\ning the offset’s conversion to the string. Since those\nnumbers for tags soon become tedious, you may pre-\nfer to name them. The names that Microsoft uses\nin its programming are documented for the roughly\n100 tags that were defined ten years ago (for Win-\ndows Vista). All tags, documented or not (and now\nrunning to 260), have friendly names that can be ob-\ntained from the API function SdbTagToString. If\nyou haven’t suspected all along that Microsoft pre-\npares SDB files from XML input, then you’ll likely\ntake “tag” as a hint to represent an SDB file’s tags\nas XML tags. And this, give or take, is where some\nof the dumping tools you can find on the Internet\nleave things, such as in Figure 17.\n\nNotice already that choices are made about what\nto show and how. If you don’t show the offset in\nbytes that each XML tag has as an SDB tag in the\noriginal SDB file, then you risk complicating your\npresentation of data, as with the string references,\nwhose interpretation depends on those file offsets.\nBut show the offsets and your XML quickly looks\nmessy. Once your editorial choices go so far that you\ndon’t reproduce every byte but instead build more\nand more interpretation into the XML, why show\nevery tag? Notably, the string table that’s the data\nfor tag 0x7801 (TAG_STRINGTABLE) and the indexes\nthat are the data for tag 0x7802 (TAG_INDEXES)\nmust be generated automatically from the data for\ntag 0x7001 (TAG_DATABASE) such that the last may\nbe all you want to bother with. Observe that for any\ntag that has children, the subtags that don’t have\nchildren come first, and perhaps you’ll plumb for a\ndifferent style of XML in which each tag that has no\n\n64\n\n\n\n00000000: 02 00 00 00 01 00 00 00-73 64 62 66 02 78 CA 00 ........sdbf.x..\n00000010: 00 00 03 78 14 00 00 00-02 38 07 70 03 38 01 60 ...x.....8.p.8.‘\n00000020: 16 40 01 00 00 00 01 98-00 00 00 00 03 78 0E 00 .@...........x..\n00000030: 00 00 02 38 17 70 03 38-01 60 01 98 00 00 00 00 ...8.p.8.‘......\n00000040: 03 78 0E 00 00 00 02 38-07 70 03 38 04 90 01 98 .x.....8.p.8....\n00000050: 00 00 00 00 03 78 14 00-00 00 02 38 1C 70 03 38 .....x.....8.p.8\n00000060: 01 60 16 40 02 00 00 00-01 98 00 00 00 00 03 78 .‘.@...........x\n00000070: 14 00 00 00 02 38 1C 70-03 38 0B 60 16 40 02 00 .....8.p.8.‘.@..\n00000080: 00 00 01 98 00 00 00 00-03 78 14 00 00 00 02 38 .........x.....8\n00000090: 1A 70 03 38 01 60 16 40-02 00 00 00 01 98 00 00 .p.8.‘.@........\n000000A0: 00 00 03 78 14 00 00 00-02 38 1A 70 03 38 0B 60 ...x.....8.p.8.‘\n000000B0: 16 40 02 00 00 00 01 98-00 00 00 00 03 78 1A 00 .@...........x..\n000000C0: 00 00 02 38 25 70 03 38-01 60 01 98 0C 00 00 00 ...8%p.8.‘......\n000000D0: 00 00 52 45 4B 43 41 48-14 01 00 00 01 70 60 00 ..REKCAH.....p‘.\n000000E0: 00 00 01 50 D8 C1 31 3C-70 10 D2 01 22 60 06 00 ...P..1<p...\"‘..\n000000F0: 00 00 01 60 1C 00 00 00-23 40 01 00 00 00 07 90 ...‘....#@......\n00000100: 10 00 00 00 28 22 AB F9-12 33 73 4A B6 F9 93 6D ....(\"...3sJ...m\n00000110: 70 E1 12 EF 25 70 28 00-00 00 01 60 50 00 00 00 p...%p(....‘P...\n00000120: 10 90 10 00 00 00 C8 E4-9C 91 69 D0 21 45 A5 45 ..........i.!E.E\n00000130: 01 32 B0 63 94 ED 17 40-03 00 00 00 03 60 64 00 .2.c...@.....‘d.\n00000140: 00 00 01 78 7A 00 00 00-01 88 10 00 00 00 32 00 ...xz.........2.\n00000150: 2E 00 31 00 2E 00 30 00-2E 00 33 00 00 00 01 88 ..1...0...3.....\n00000160: 2E 00 00 00 48 00 61 00-63 00 6B 00 65 00 64 00 ....H.a.c.k.e.d.\n00000170: 20 00 44 00 72 00 69 00-76 00 65 00 72 00 20 00 .D.r.i.v.e.r. .\n00000180: 44 00 61 00 74 00 61 00-62 00 61 00 73 00 65 00 D.a.t.a.b.a.s.e.\n00000190: 00 00 01 88 0E 00 00 00-48 00 61 00 63 00 6B 00 ........H.a.c.k.\n000001A0: 65 00 72 00 00 00 01 88-16 00 00 00 68 00 61 00 e.r.........h.a.\n000001B0: 63 00 6B 00 65 00 72 00-2E 00 73 00 79 00 73 00 c.k.e.r...s.y.s.\n000001C0: 00 00 ..\n\nFigure 15. ShimDB File\n\nchild tags is represented as an attribute and value,\ne.g.,\n\n<DATABASE\n2 TIME=\"0x01D210703C31C1D8\"\n\nCOMPILER_VERSION=\" 2 . 1 . 0 . 3 \"\n4 NAME=\"Hacked Driver Database\"\n\nOS_PLATFORM=\"0x00000001\"\n6 DATABASE_ID=\"0x28 0x22 0xAB 0xF9 0x12 0x33\n\n0x73 0x4A 0xB6 0xF9 0x93 0x6D 0x70 0xE1 0\nx12 0xEF\">\n<KSHIM\n\n8 NAME=\"Hacker\"\nFIX_ID=\"0xC8 0xE4 0x9C 0x91 0x69 0xD0 0\n\nx21 0x45 0xA5 0x45 0x01 0x32 0xB0 0x63 0\nx94 0xED\"\n\n10 FLAGS=\"0x00000003\"\nMODULE=\"hacker . sys \" />\n\n12 </DATABASE>\n\nWhether you choose XML in this style or to have\nevery tag’s data between opening and closing tags,\nthere are any number of ways to represent the data\nfor each tag. For instance, once you know that\nthe binary data for tag 0x9007 (TAG_DATABASE_ID)\nor tag 0x9010 (TAG_FIX_ID) is always a GUID, you\nmight more conveniently represent it in the usual\nstring form. Instead of showing the data for tag\n0x5001 (TAG_TIME) as a raw qword, why not show\n\nthat you know it’s a Windows FILETIME and present\nit as 16/09/2016 23:15:37.944? Or, on the grounds\nthat it too must be generated automatically, you\nmight decide not to show it at all!\n\nIf I labour the presentation, it’s to make the\npoint that what’s produced by any number of dump-\ning tools inevitably varies according to purpose and\ntaste. Let’s say a hundred researchers want a tool\nfor the easy reading of SDB files. Yes, that’s doubt-\nful, but 100 is a good round number. Then ninety\nwill try to crib code from someone else—because,\nyou know, who wants to reinvent the wheel—and\nwhat you get from the others will each be different,\npossibly very different, not just for its output but\nespecially for what the source code shows of the file\nformat. Worse, because nine out of ten program-\nmers don’t bother much with commenting, even for\na tool they may intend as showing off their cod-\ning skills, you may have to pick through the source\ncode to extract the file format. That may be easier\nthan reverse-engineering Microsoft’s binaries that\nwork with the file, but not necessarily by much—and\nnot necessarily leaving you with the same confidence\nthat what you’ve learnt about the file format is cor-\n\n65\n\n\n\n00000000: Header: MajorVersion=0x00000002 MinorVersion=0x00000001 Magic=0x66626473\n0000000C: Tag=0x7802 Size=0x000000CA Data=\n00000012: Tag=0x7803 Size=0x00000014 Data=\n00000018: Tag=0x3802 Data=0x7007\n0000001C: Tag=0x3803 Data=0x6001\n00000020: Tag=0x4016 Data=0x00000001\n00000026: Tag=0x9801 Size=0x00000000\n0000002C: Tag=0x7803 Size=0x0000000E Data=\n00000032: Tag=0x3802 Data=0x7017\n00000036: Tag=0x3803 Data=0x6001\n0000003A: Tag=0x9801 Size=0x00000000\n00000040: Tag=0x7803 Size=0x0000000E Data=\n\n...\n\n000000BC: Tag=0x7803 Size=0x0000001A Data=\n000000C2: Tag=0x3802 Data=0x7025\n000000C6: Tag=0x3803 Data=0x6001\n000000CA: Tag=0x9801 Size=0x0000000C Data=0x00 0x00 0x52 0x45 0x4B 0x43 0x41 0x48 0x14 0x01 0x00 0x00\n000000DC: Tag=0x7001 Size=0x00000060\n000000E2: Tag=0x5001 Data=0x01D210703C31C1D8\n000000EC: Tag=0x6022 Data=0x00000006 => L\"2.1.0.3\"\n000000F2: Tag=0x6001 Data=0x0000001C => L\"Hacked Driver Database\"\n000000F8: Tag=0x4023 Data=0x00000001\n000000FE: Tag=0x9007 Size=0x00000010 Data=0x28 0x22 0xAB 0xF9 0x12 0x33 0x73 0x4A 0xB6 0xF9 0x93 0x6D\n\n0x70 0xE1 0x12 0xEF\n00000114: Tag=0x7025 Size=0x00000028\n0000011A: Tag=0x6001 Data=0x00000050 => L\"Hacker\"\n00000120: Tag=0x9010 Size=0x00000010 Data=0xC8 0xE4 0x9C 0x91 0x69 0xD0 0x21 0x45 0xA5 0x45 0x01 0x32\n\n0xB0 0x63 0x94 0xED\n00000136: Tag=0x4017 Data=0x00000003\n0000013A: Tag=0x6003 Data=0x00000064 => L\"hacker.sys\"\n00000142: Tag=0x7801 Size=0x0000007A Data=\n00000148: Tag=0x8801 Size=0x00000010 Data=L\"2.1.0.3\"\n0000015E: Tag=0x8801 Size=0x0000002E Data=L\"Hacked Driver Database\"\n00000192: Tag=0x8801 Size=0x0000000E Data=L\"Hacker\"\n000001A6: Tag=0x8801 Size=0x00000016 Data=L\"hacker.sys\"\n\nFigure 16. ShimDB File (Decoded from Figure 15)\n\n66\n\n\n\n1 <INDEXES>\n<INDEX>\n\n3 <INDEX_TAG>0x7007</INDEX_TAG>\n<INDEX_KEY>0x6001</INDEX_KEY>\n\n5 <INDEX_FLAGS>0x00000001</INDEX_FLAGS>\n<INDEX_BITS></INDEX_BITS>\n\n7 </INDEX>\n<INDEX>\n\n9 <INDEX_TAG>0x7017</INDEX_TAG>\n<INDEX_KEY>0x6001</INDEX_KEY>\n\n11 <INDEX_BITS></INDEX_BITS>\n</INDEX>\n\n13 . . .\n<INDEX>\n\n15 <INDEX_TAG>0x7025</INDEX_TAG>\n<INDEX_KEY>0x6001</INDEX_KEY>\n\n17 <INDEX_BITS>0x00 0x00 0x52 0x45 0x4B 0x43 0x41 0x48 0x14 0x01 0x00 0x00</INDEX_BITS>\n</INDEX>\n\n19 </INDEXES>\n<DATABASE>\n\n21 <TIME>0x01D210703C31C1D8</TIME>\n<COMPILER_VERSION>0x00000006</COMPILER_VERSION>\n\n23 <NAME>0x0000001C</NAME>\n<OS_PLATFORM>0x00000001</OS_PLATFORM>\n\n25 <DATABASE_ID>0x28 0x22 0xAB 0xF9 0x12 0x33 0x73 0x4A 0xB6 0xF9 0x93 0x6D 0x70 0xE1 0x12 0xEF</\nDATABASE_ID>\n\n<KSHIM>\n27 <NAME>0x00000050</NAME>\n\n<FIX_ID>0xC8 0xE4 0x9C 0x91 0x69 0xD0 0x21 0x45 0xA5 0x45 0x01 0x32 0xB0 0x63 0x94 0xED</\nFIX_ID>\n\n29 <FLAGS>0x00000003</FLAGS>\n<MODULE>0x00000064</MODULE>\n\n31 </KSHIM>\n</DATABASE>\n\n33 <STRINGTABLE>\n<STRINGTABLE_ITEM>2 . 1 . 0 . 3</STRINGTABLE_ITEM>\n\n35 <STRINGTABLE_ITEM>Hacked Driver Database</STRINGTABLE_ITEM>\n<STRINGTABLE_ITEM>Hacker</STRINGTABLE_ITEM>\n\n37 <STRINGTABLE_ITEM>hacker . sys</STRINGTABLE_ITEM>\n</STRINGTABLE>\n\nFigure 17. Illegible XML From a ShimDB Dumping Tool\n\n67\n\n\n\nrect and comprehensive. Writing a tool that dumps\nan undocumented file format may be more reward-\ning for you as a programmer but it is not nearly the\nsame as documenting the file format.\n\n9.3 Reversing XML to SDB\nBut is there really no definitive XML for repre-\nsenting SDB files? Of all the purposes that moti-\nvate anyone to work with SDB files closely enough\nto need to know the file format, one has special\nstanding: Microsoft’s creation of SDB files from\nXML input. If we had Microsoft’s tool for that,\nthen wouldn’t most researchers plumb for revers-\ning its work to recover the XML source? After\nall, most reverse engineers and certainly the popular\nreverse-engineering tools don’t take binary code and\nunassemble it just to what you see in the debugger.\nNo, they disassemble it into assembly language that\ncan be edited and re-assembled. Many go further\nand try to decompile it into C or C++ that can be\nedited and re-compiled (even if it doesn’t look re-\nmotely like anything you’d be pleased to have from\na human programmer). In this context, the SDB to\nXML conversion to want is something you could feed\nto Microsoft’s Shim Database Compiler for compila-\ntion back to SDB. Anything else is pseudo-code. It\nmay be fine in its way for understanding the content,\nand some may prefer it to a raw dump interpreted\nwith reference to documentation of the file format,\nbut however widely it gets accepted it is nonetheless\npseudo-code.\n\nThe existence of something that someone at\nMicrosoft refers to as a Shim Database Com-\npiler has been known for at least a decade be-\ncause Microsoft’s documentation of tag 0x6022\n(TAG_COMPILER_VERSION), apparently contempora-\nneous with Windows Vista, describes this tag’s data\nas the “Shim Database Compiler version.” And\nwhat, then, is the ShimDBC.exe from the even older\nTechNet article if it’s not this Shim Database Com-\npiler?\n\nBut has anyone outside Microsoft ever seen this\ncompiler? Dig out an installation disc for Win-\ndows XP from 2001, look in the Support Tools di-\nrectory, install the ACT version 2.0 from its self-\nextracting executable, and perhaps install the Sup-\nport Tools too in case that’s what the TechNet ar-\nticle means by “support utility.” For your troubles,\nwhich may include having to install Windows XP,\nyou’ll get the article’s QFixApp.exe, and the Com-\npatibility Administrator, as CompatAdmin.exe, and\n\nsome other possibly useful or at least instructive\ntools such as GrabMI.exe, but you don’t get any\nfile named ShimDBC.exe. I suspect that Shim-\nDBC.exe never has existed in public as any sort of\nself-standing utility or even as its own file. Even if\nit did once upon a time, we should want a modern\nversion that knows the modern tags such as 0x7025\n(TAG_KSHIM) for defining driver shims.\n\nFor some good news, look into either QFix-\nApp.exe or CompatAdmin.exe using whatever is\nyour tool of choice for inspecting executables. In-\nside each, not as resources but intermingled with the\ncode and data, are several instances of ShimDBC as\ntext. We’ve had Microsoft’s Shim Database Com-\npiler for 15 years since the release of Windows XP.\nAll along, the code and data for the console program\nShimDBC.exe, from its wmain function inwards, has\nbeen linked into the GUI programs QFixApp.exe\nand CompatAdmin.exe (of which only the latter sur-\nvives to modern versions of the ACT). Each of the\nGUI programs has a WinMain function that’s first to\nexecute after the C Run-Time (CRT) initialisation.\nWhenever either of the GUI programs wants to cre-\nate an SDB file, it composes the Unicode text of a\ncommand line for the fake ShimDBC.exe and calls a\nroutine that first parses this into the argc and argv\nthat are expected for a wmain function and which\nthen simply calls the wmain function. Where the\nTechNet article says QFixApp uses ShimDBC.exe,\nit is correct, but it doesn’t mean that QFixApp ex-\necutes ShimDBC.exe as a separate program, more\nthat QFixApp simulates such execution from the\nShimDBC code and data that’s built in.\n\nUnfortunately, CompatAdmin does not provide,\neven in secret, for passing a command line of our\nchoice through WinMain to wmain. But, c’mon, we’re\nhackers. You’ll already be ahead of me: we can\npatch the file. Make a copy of CompatAdmin.exe as\nShimDBC.exe, and use your favourite debugger or\ndisassembler to find three things:\n\n• the program’s WinMain function;\n\n• the routine the program passes the fake com-\nmand line to for parsing and for calling wmain;\n\n• the address of the Import Address Table entry\nfor calling the GetCommandLineW function.\n\n68\n\n\n\nIdeally, you might then assemble something like\nc a l l dword ptr [__imp__GetCommandLineW@0]\n\n2 mov ecx , eax\nc a l l SimulateShimDBCExecution\n\n4 r e t 10h\n\nover the very start of WinMain. In practice, you\nhave to allow for relocations. Our indirect call to\nGetCommandLineW will need a fixup if the program\ndoesn’t get loaded at its preferred address. Worse,\nif we overwrite any fixup sites in WinMain, then our\ncode will get corrupted if fixups get applied. But\nthese are small chores that are bread and butter for\npractised reverse engineers. For concreteness, I give\nthe patch details for the 32-bit CompatAdmin.exe\nfrom the ACT version 6.1 for Windows 8.1 in Ta-\nble 2.\n\nFor hardly any trouble, we get an executable\nthat still contains all its GUI material (except for\nthe 17 bytes we’ve changed) but never executes\nit and instead runs the console-application code\nwith the command line that we give when running\nthe patched program. Microsoft surely has Shim-\nDBC.exe as a self-standing console application, but\nwhat we get from patching CompatAdmin.exe must\nbe close to the next best thing, certainly for so little\neffort. It’s still a GUI program, however, so to see\nwhat it writes to standard output we must explicitly\ngive it a standard output. At a Command Prompt\nwith administrative privilege, enter\n\nshimdbc -? >help.txt\n\nto get the built-in ShimDBC program’s mostly accu-\nrate description of its command-line syntax, includ-\ning most of the recognised command-line options.\n\nTo produce the SDB file that is this article’s ex-\nample, write the following as a Unicode text file\nnamed test.xml:\n<?xml version=\" 1 .0 \" encoding=\"UTF−16\" ?>\n\n2 <DATABASE NAME=\"Hacked Driver Database\"\nID=\"{F9AB2228−3312−4A73−B6F9−936D70E112EF}\">\n\n4 <LIBRARY>\n<KSHIM NAME=\"Hacker\" FILE=\"hacker . sys \"\n\n6 ID=\"{919CE4C8−D069−4521−A545−0132B06394ED}\n\"\nLOGO=\"YES\" ONDEMAND=\"YES\" />\n\n8 </LIBRARY>\n</DATABASE>\n\nand feed it to the compiler via the command line\n1 shimdbc Driver t e s t . xml t e s t . sdb >t e s t . txt\n\nI may be alone in this, but if you’re going to\ntell me that I should know that you know the SDB\nfile format when all you have to show is a tool that\nconverts SDB to XML, then this would better be\nthe XML that your tool produces from this article’s\nexample of an SDB file. Otherwise, as far as I’m\nconcerned for studying any SDB file, I’m better off\nwith a raw dump in combination with actual docu-\nmentation of the file format.\n\nDo not let it go unnoticed, though, that the\nXML that works for Microsoft’s ShimDBC needs at-\ntributes that differ from the programmatic names\nthat Microsoft has documented for the tags or the\nfriendly names that can be obtained from the Sdb-\nTagToString function. For instance, the 0x6003 tag\n(TAG_MODULE) is compiled from an attribute named\nnot MODULE but FILE. The 0x4017 tag (TAG_FLAGS)\nis synthesised from two attributes. Even harder to\nhave guessed is that a LIBRARY tag is needed in the\nXML but does not show at all in the SDB file, i.e.,\nas a tag 0x7002 (TAG_LIBRARY). So, to know what\nXML is acceptable to Microsoft’s compiler for creat-\ning an SDB file, you’ll have to reverse-engineer the\ncompiler or do a lot of inspired guesswork.\n\nHappy hunting!\n\n69\n\n\n\nFile Offset Original Patched Remarks\n0x0002FB54 8B FF EB 08 jump to instruction that will use existing fixup site\n0x0002FB56 55\n0x0002FB57 8B EC\n0x0002FB59 81 EC 88 05 00 00\n0x0002FB5E FF 15 D0 30 49 00 incorporate existing fixup site at file offset 0x0002FB60\n0x0002FB5F A1 00 60 48 00\n0x0002FB64 33 C5 8B C8\n0x0002FB66 89 45 FC E8 55 87 01 00 no fixup required for this direct call within .text section\n0x0002FB69 8B 45 08\n0x0002FB6B C2 10 00\n0x0002FB6C 53\n0x0002FB6D 56\n\nTable 2. Patch details for the 32-bit CompatAdmin.exe from the ACT version 6.1 for Windows 8.1.\n\nba\nse\n\nd \non\n\n h\nttp\n\ns:/\n/d\n\niv\nisb\n\nyz\ner\n\no.c\nom\n\n/2\n01\n\n6/\n07\n\n/0\n6/\n\nm\nak\n\ne-a\n-su\n\ngih\nar\n\na-\ncir\n\ncle\nsq\n\nua\nre\n\n-o\npt\n\nica\nl-i\nllu\n\nsio\nn-\n\nou\nt-o\n\nf-p\nap\n\ner\n/\n\nAmbiguous Cylinder by Kokichi Sugihara\n\nresult\n\n杉原 厚吉 の 多義柱体\n\n70\n\n\n\n10 Post Scriptum: A Schizophrenic Ghost\nby Evan Sultanik and Philippe Teuwen\n\nA while back, we asked ourselves,\n\nWhat if PoC‖GTFO had completely dif-\nferent content depending on whether the\nfile was rendered by a PDF viewer versus\nbeing sent to a printer?\n\nA PostScript/PDF polyglot seemed inevitable. We\nhad already done MBR, ISO, TrueCrypt, HTML,\nRuby, . . . Surely PostScript would be simple, right?\nAs it turns out, it’s actually quite tricky.\n\n$ gv pocorgtfo13.pdf\n\nThere were two new challenges in getting this\npolyglot to work:\n\n1. The PDF format is a subset of the PostScript\nlanguage, meaning that we needed to devise\na way to get a PDF interpreter to ignore the\nPostScript code, and vice versa; and\n\n2. It’s almost impossible to find a PostScript\ninterpreter that doesn’t also support PDF.\nGhostscript is nearly ubiquitous in its use as a\nbackend library for desktop PostScript view-\ners (e.g., Ghostview), and it has PDF sup-\nport, too. Furthermore, it doesn’t have any\nconfiguration parameters to force it to use a\nspecific format, so we needed a way to force\nGhostscript to always interpret the polyglot\nas if it were PostScript.\n\nTo overcome the first challenge, we used a sim-\nilar technique to the Ruby polyglot from pocor-\ngtfo11.pdf, in which the PDF header is embed-\nded into a multi-line string (delimited by parenthesis\nin PostScript), so that it doesn’t get interpreted as\nPostScript commands. We halt the PostScript inter-\npreter at the end of the PostScript content by using\nthe handy stop command following the standard\n%%EOF “Document Structuring Conventions” (DSC)\ndirective.\n\nThis works, in that it produces a file that is\nboth a completely valid PDF as well as a completely\nvalid PostScript program. The trouble is that Adobe\nseems to have blacklisted any PDF that starts with\nan opening parenthesis. We resolved this by wrap-\nping the multi-line string containing the PDF header\ninto a PostScript function we called /pdfheader:\n\n/pdfheader\n{\n(\n%!PS-Adobe\n%PDF-1.5\n%<D0><D4><C5><D8>\n\n9999 0 obj\n<<\n/Length # bytes between “stream”\n\nand “endstream”\n>>\nstream\n)\n}\nPostScript Content\nstop\nendstream\nendobj\n\nRemainder of PDF Content\n\nMulti-Line PostScript String\n\nPostScript Function\n\nPDF Object\n\nTerminates\n\nPostScript\n\nInterpretation\n\nThe trick of starting the file with a PostScript\nfunction worked, and the PDF could be viewed\nin Adobe. That still leaves the second challenge,\nthough: We needed a way to trick Ghostscript into\nbeing “schizophrenic” (cf. PoC‖GTFO 7:6), vi&., to\ninsert a parser-specific inconsistency into the poly-\nglot that would force Ghostscript into thinking it is\nPostScript.\n\nGhostscript’s logic for auto-detecting file types\nseems to be in the dsc_scan_type function in-\nside /psi/dscparse.c. It is quite complex, since\nthis single function must differentiate between seven\ndifferent filetypes, including DSC/PostScript and\nPDF. It classifies a file as a PDF if it contains a\nline starting with “%PDF-”, and PostScript if it con-\ntains a line starting with “%!PS-Adobe”. Therefore,\nif we put %!PS-Adobe anywhere before %PDF-1.5,\nthen Ghostscript should be tricked into thinking it is\nPostScript! The only caveat is that Adobe blacklists\nany PDF that starts with “%!PS-Adobe”, so it can’t\nbe at the beginning of the file (which is typically\nwhere it occurs in DSC files). But that’s okay, be-\ncause Ghostscript only needs it to occur before the\n%PDF-1.5, regardless of where.\n\nThis article continues in the PostScript!\n\n71\n\n\n\n11 Tithe us your Alms of 0day!\nfrom the desk of Pastor Manul Laphroaig,\n\nInternational Church of the Weird Machines\n\nDearest neighbor,\nDo you remember what it was like when you first\n\nlearned to program a computer? Not when you first\nrealized that you could do it well, but when you first\nrealized that you could do it at all? How did it feel?\n\nAnd do you remember what it was like when you\nfirst learned how to use calculus? Not when you\nfirst learned how complicated differential equations\ncould become, but when you first realized that with\na handful of rules, you could bounce back and forth\nbetween position, velocity, acceleration, and jerk as\nif they were all the same thing? How did that feel?\n\nAnd do you remember what it was like when\nyou first learned how to use a screwdriver? Not\nwhen you first learned what to do after removing\nthe screw, but when you first realized that with a\nscrewdriver—with the right screwdriver—you could\ntake apart anything? How did that feel?\n\nWhen I was sixteen, I was a bit of an asshole,\nand I asked my automechanics teacher a question\nabout a distributor’s angular momentum. I don’t\nrecall my exact question, but I do recall that it was\nthe sort of thing no one could be expected to know,\nand that, being a jerk, I asked it in the vocabulary\nof calculus.\n\nCoach Crigger could’ve called me out for be-\ning rude, or he could’ve dodged the question. He\ncould’ve done any number of things that you might\nexpect. Instead, he walked out of the classroom\nwhile two and half dozen hooligans started a racket\naudible from the other side of the campus.\n\nTen minutes later, he returned to the classroom.\nHe walked right up to my desk and slammed a\n’72 Ford’s distributor onto my desk along with the\nscrewdriver to open it. It felt good!\n\nDo this: write an email telling our editors how\nto reproduce ONE clever, technical trick from your\nresearch. If you are uncertain of your English, we’ll\nhappily translate from French, Russian, Southern\nAppalachian, and German. If you don’t speak those\nlanguages, we’ll draft a translator from those poor\nsods who owe us favors.\n\nLike an email, keep it short. Like an email, you\nshould assume that we already know more than a\nbit about hacking, and that we’ll be insulted or—\nWORSE!—that we’ll be bored if you include a long\ntutorial where a quick reminder would do.\n\nJust use 7-bit ASCII if your language doesn’t\nrequire funny letters, as whenever we receive some-\nthing typeset in OpenOffice, we briefly mistake it\nfor a ransom note. Don’t try to make it thorough\nor broad. Don’t use bullet-points, as this isn’t a\ndamned Powerpoint deck. Keep your code samples\nshort and sweet; we can leave the long-form code as\nan attachment. Do not send us LATEX; it’s our job\nto do the typesetting!\n\nDon’t tell us that it’s possible; rather, teach us\nhow to do it ourselves with the absolute minimum\nof formality and bullshit.\n\nLike an email, we expect informal (or faux-\nbiblical) language and hand-sketched diagrams.\nWrite it in a single sitting, and leave any editing\nfor your poor preacherman to do over a bottle of\nfine scotch. Send this to pastor@phrack org and\nhope that the neighborly Phrack folks—praise be to\nthem!—aren’t man-in-the-middling our submission\nprocess.\n\nYours in PoC and Pwnage,\nPastor Manul Laphroaig, D D\n\n72\n\n\n\t0.0: \n\t0.1: \n\t0.2: \n\t0.3: \n\t0.4: \n\t0.5: \n\t0.6: \n\t0.7: \n\t0.8: \n\t0.9: \n\t0.10: \n\t0.11: \n\t0.12: \n\t0.13: \n\t0.14: \n\t0.15: \n\t0.16: \n\t0.17: \n\t0.18: \n\t0.19: \n\t0.20: \n\t0.21: \n\t0.22: \n\t0.23: \n\t0.24: \n\t0.25: \n\t0.26: \n\t0.27: \n\t0.28: \n\t0.29: \n\t0.30: \n\t0.31: \n\t0.32: \n\t0.33: \n\t0.34: \n\t0.35: \n\t0.36: \n\t0.37: \n\t0.38: \n\t0.39: \n\t0.40: \n\t0.41: \n\t0.42: \n\t0.43: \n\t0.44: \n\t0.45: \n\t0.46: \n\t0.47: \n\t0.48: \n\t0.49: \n\t0.50: \n\t0.51: \n\t0.52: \n\t0.53: \n\t0.54: \n\t0.55: \n\tanm0: \n\t1.0: \n\t1.1: \n\t1.2: \n\t1.3: \n\t1.4: \n\t1.5: \n\t1.6: \n\t1.7: \n\t1.8: \n\t1.9: \n\t1.10: \n\t1.11: \n\t1.12: \n\t1.13: \n\t1.14: \n\t1.15: \n\t1.16: \n\t1.17: \n\t1.18: \n\t1.19: \n\t1.20: \n\t1.21: \n\t1.22: \n\t1.23: \n\t1.24: \n\t1.25: \n\t1.26: \n\t1.27: \n\t1.28: \n\t1.29: \n\t1.30: \n\t1.31: \n\t1.32: \n\t1.33: \n\t1.34: \n\t1.35: \n\t1.36: \n\t1.37: \n\t1.38: \n\t1.39: \n\t1.40: \n\t1.41: \n\t1.42: \n\t1.43: \n\t1.44: \n\t1.45: \n\t1.46: \n\t1.47: \n\t1.48: \n\t1.49: \n\t1.50: \n\t1.51: \n\t1.52: \n\t1.53: \n\t1.54: \n\t1.55: \n\t1.56: \n\t1.57: \n\t1.58: \n\t1.59: \n\t1.60: \n\t1.61: \n\t1.62: \n\t1.63: \n\t1.64: \n\t1.65: \n\t1.66: \n\t1.67: \n\t1.68: \n\t1.69: \n\t1.70: \n\t1.71: \n\t1.72: \n\t1.73: \n\t1.74: \n\t1.75: \n\t1.76: \n\t1.77: \n\t1.78: \n\t1.79: \n\t1.80: \n\t1.81: \n\t1.82: \n\t1.83: \n\t1.84: \n\t1.85: \n\t1.86: \n\t1.87: \n\t1.88: \n\t1.89: \n\t1.90: \n\t1.91: \n\t1.92: \n\t1.93: \n\t1.94: \n\t1.95: \n\t1.96: \n\t1.97: \n\t1.98: \n\t1.99: \n\t1.100: \n\t1.101: \n\t1.102: \n\t1.103: \n\t1.104: \n\t1.105: \n\t1.106: \n\t1.107: \n\t1.108: \n\t1.109: \n\t1.110: \n\t1.111: \n\t1.112: \n\t1.113: \n\t1.114: \n\t1.115: \n\t1.116: \n\t1.117: \n\t1.118: \n\t1.119: \n\t1.120: \n\t1.121: \n\t1.122: \n\t1.123: \n\t1.124: \n\t1.125: \n\t1.126: \n\t1.127: \n\t1.128: \n\t1.129: \n\t1.130: \n\t1.131: \n\t1.132: \n\t1.133: \n\t1.134: \n\t1.135: \n\t1.136: \n\t1.137: \n\t1.138: \n\t1.139: \n\t1.140: \n\t1.141: \n\t1.142: \n\t1.143: \n\t1.144: \n\t1.145: \n\t1.146: \n\t1.147: \n\t1.148: \n\t1.149: \n\t1.150: \n\t1.151: \n\t1.152: \n\t1.153: \n\t1.154: \n\t1.155: \n\t1.156: \n\t1.157: \n\t1.158: \n\t1.159: \n\t1.160: \n\t1.161: \n\t1.162: \n\t1.163: \n\t1.164: \n\t1.165: \n\t1.166: \n\t1.167: \n\t1.168: \n\t1.169: \n\t1.170: \n\t1.171: \n\t1.172: \n\t1.173: \n\t1.174: \n\t1.175: \n\t1.176: \n\t1.177: \n\t1.178: \n\t1.179: \n\t1.180: \n\t1.181: \n\t1.182: \n\t1.183: \n\t1.184: \n\t1.185: \n\t1.186: \n\t1.187: \n\t1.188: \n\t1.189: \n\t1.190: \n\t1.191: \n\t1.192: \n\t1.193: \n\t1.194: \n\t1.195: \n\t1.196: \n\t1.197: \n\t1.198: \n\t1.199: \n\t1.200: \n\t1.201: \n\t1.202: \n\t1.203: \n\t1.204: \n\t1.205: \n\t1.206: \n\t1.207: \n\t1.208: \n\t1.209: \n\t1.210: \n\t1.211: \n\t1.212: \n\t1.213: \n\t1.214: \n\t1.215: \n\t1.216: \n\t1.217: \n\t1.218: \n\t1.219: \n\t1.220: \n\t1.221: \n\t1.222: \n\t1.223: \n\t1.224: \n\t1.225: \n\t1.226: \n\t1.227: \n\t1.228: \n\t1.229: \n\t1.230: \n\t1.231: \n\t1.232: \n\t1.233: \n\t1.234: \n\t1.235: \n\t1.236: \n\t1.237: \n\t1.238: \n\t1.239: \n\t1.240: \n\t1.241: \n\t1.242: \n\t1.243: \n\t1.244: \n\t1.245: \n\t1.246: \n\t1.247: \n\t1.248: \n\t1.249: \n\t1.250: \n\t1.251: \n\t1.252: \n\t1.253: \n\t1.254: \n\t1.255: \n\t1.256: \n\t1.257: \n\t1.258: \n\t1.259: \n\t1.260: \n\t1.261: \n\t1.262: \n\t1.263: \n\t1.264: \n\t1.265: \n\t1.266: \n\t1.267: \n\t1.268: \n\t1.269: \n\t1.270: \n\t1.271: \n\t1.272: \n\t1.273: \n\t1.274: \n\t1.275: \n\t1.276: \n\t1.277: \n\t1.278: \n\t1.279: \n\t1.280: \n\t1.281: \n\t1.282: \n\t1.283: \n\t1.284: \n\t1.285: \n\t1.286: \n\t1.287: \n\t1.288: \n\t1.289: \n\t1.290: \n\t1.291: \n\t1.292: \n\t1.293: \n\t1.294: \n\t1.295: \n\t1.296: \n\t1.297: \n\t1.298: \n\t1.299: \n\t1.300: \n\t1.301: \n\t1.302: \n\t1.303: \n\t1.304: \n\t1.305: \n\t1.306: \n\t1.307: \n\t1.308: \n\t1.309: \n\t1.310: \n\t1.311: \n\t1.312: \n\t1.313: \n\t1.314: \n\t1.315: \n\t1.316: \n\t1.317: \n\t1.318: \n\t1.319: \n\t1.320: \n\t1.321: \n\t1.322: \n\t1.323: \n\t1.324: \n\t1.325: \n\t1.326: \n\t1.327: \n\t1.328: \n\t1.329: \n\t1.330: \n\t1.331: \n\t1.332: \n\t1.333: \n\t1.334: \n\t1.335: \n\t1.336: \n\t1.337: \n\t1.338: \n\t1.339: \n\t1.340: \n\t1.341: \n\t1.342: \n\t1.343: \n\t1.344: \n\t1.345: \n\t1.346: \n\t1.347: \n\t1.348: \n\t1.349: \n\t1.350: \n\t1.351: \n\t1.352: \n\t1.353: \n\t1.354: \n\t1.355: \n\t1.356: \n\t1.357: \n\t1.358: \n\t1.359: \n\t1.360: \n\t1.361: \n\t1.362: \n\t1.363: \n\t1.364: \n\t1.365: \n\t1.366: \n\t1.367: \n\t1.368: \n\t1.369: \n\t1.370: \n\t1.371: \n\t1.372: \n\t1.373: \n\t1.374: \n\t1.375: \n\t1.376: \n\t1.377: \n\t1.378: \n\t1.379: \n\t1.380: \n\t1.381: \n\t1.382: \n\t1.383: \n\t1.384: \n\t1.385: \n\t1.386: \n\tanm1: \n\n\n","extracted_metadata":{"access_permission:extract_content":["true"],"access_permission:can_print_degraded":["true"],"access_permission:modify_annotations":["true"],"pdf:annotationTypes":["null"],"pdf:docinfo:title":["PoC||GTFO 13"],"pdf:encrypted":["false"],"dc:subject":["pocorgtfo,poc,gtfo"],"access_permission:extract_for_accessibility":["true"],"pdf:containsDamagedFont":["false"],"pdf:docinfo:trapped":["False"],"pdf:docinfo:modified":["2016-10-18T20:43:26Z"],"Content-Type":["application/pdf"],"pdf:overallPercentageUnmappedUnicodeChars":["2.1356227807700634E-4"],"access_permission:assemble_document":["true"],"pdf:hasXMP":["false"],"access_permission:can_print":["true"],"access_permission:fill_in_form":["true"],"pdf:docinfo:creator":["Pastor Manul Laphroaig"],"pdf:PDFVersion":["1.5"],"X-TIKA:Parsed-By-Full-Set":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser","org.apache.tika.parser.ocr.TesseractOCRParser"],"pdf:docinfo:custom:PTEX.Fullbanner":["This is pdfTeX, Version 3.14159265-2.6-1.40.15 (TeX Live 2014) kpathsea version 6.2.0"],"pdf:totalUnmappedUnicodeChars":["40"],"pdf:hasMarkedContent":["false"],"resourceName":["Proof of Concept or GTFO - v13 (October 18th, 2016).pdf"],"pdf:producer":["pdfTeX-1.40.15"],"pdf:docinfo:keywords":["pocorgtfo,poc,gtfo"],"pdf:charsPerPage":["894","1751","2239","2749","1246","5465","1630","2550","2390","2652","2815","2432","2347","3409","2526","2568","2258","899","3024","1419","16265","8301","2","2639","2908","1692","3068","686","2771","2438","1230","4119","2","3459","3159","3391","1588","2632","2584","2","2164","2728","2318","1797","2624","2922","2095","3045","1827","1737","2047","3251","110","3183","3650","4119","2578","2570","1493","2959","2","2582","2917","3787","3393","1520","1118","3757","2622","621","2879","2685"],"X-TIKA:Parsed-By":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"PTEX.Fullbanner":["This is pdfTeX, Version 3.14159265-2.6-1.40.15 (TeX Live 2014) kpathsea version 6.2.0"],"pdf:hasXFA":["false"],"access_permission:can_modify":["true"],"xmp:CreatorTool":["ace02468bdf13579"],"dc:creator":["Pastor Manul Laphroaig"],"pdf:docinfo:created":["2016-06-23T02:46:00Z"],"pdf:num3DAnnotations":["0"],"pdf:docinfo:producer":["pdfTeX-1.40.15"],"pdf:annotationSubtypes":["Widget"],"dc:format":["application/pdf; version=1.5"],"pdf:docinfo:creator_tool":["ace02468bdf13579"],"dcterms:modified":["2016-10-18T20:43:26Z"],"pdf:hasCollection":["false"],"dc:title":["PoC||GTFO 13"],"pdf:unmappedUnicodeCharsPerPage":["0","2","0","1","0","0","0","0","0","8","0","11","0","0","0","0","0","0","0","0","2","4","0","0","0","0","0","0","0","1","0","0","0","0","0","0","0","1","0","0","0","1","0","0","0","0","7","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","2","0"],"xmpTPg:NPages":["72"],"pdf:hasAcroFormFields":["true"],"dcterms:created":["2016-06-23T02:46:00Z"],"pdf:containsNonEmbeddedFont":["false"],"Content-Length":["62061798"]},"metadata_field_count":48,"attempts":1,"timestamp":1754064933.1023655,"platform":"Linux","python_version":"3.13.5"},{"file_path":"test_documents/pdfs/Intel 64 and IA-32 Architectures Software Developer's Manual - Combined Volumes 1-4 - June 2021 (325462-sdm-vol-1-2abcd-3abcd).pdf","file_size":52916900,"file_type":"pdf","category":"huge","framework":"extractous","iteration":2,"extraction_time":7.358031988143921,"startup_time":null,"peak_memory_mb":720.1640625,"avg_memory_mb":675.41953125,"peak_cpu_percent":99.8,"avg_cpu_percent":38.839999999999996,"total_io_mb":null,"status":"success","character_count":500000,"word_count":125052,"error_type":null,"error_message":null,"quality_metrics":{"char_count":500000,"word_count":125052,"sentence_count":6292,"paragraph_count":2207,"avg_word_length":2.9588731087867446,"avg_sentence_length":8.662746344564527,"extraction_completeness":1.0,"text_coherence":0.04993781568060103,"noise_ratio":0.37750000000000006,"gibberish_ratio":0.038461538461538464,"flesch_reading_ease":42.27549675631161,"gunning_fog_index":14.564634416928994,"has_proper_formatting":true,"maintains_line_breaks":true,"preserves_whitespace":true,"table_structure_preserved":true,"format_specific_score":0.8,"expected_content_preserved":false,"has_encoding_issues":false,"has_ocr_artifacts":true,"preserves_pdf_formatting":true},"overall_quality_score":0.45001632486553983,"extracted_text":"\nIntel® 64 and IA-32 Architectures\nSoftware Developer’s Manual\n\nCombined Volumes:\n1, 2A, 2B, 2C, 2D, 3A, 3B, 3C, 3D and 4\n\nNOTE: This document contains all four volumes of the Intel 64 and IA-32 Architectures Software\nDeveloper's Manual: Basic Architecture, Order Number 253665; Instruction Set Reference A-Z, Order\nNumber 325383; System Programming Guide, Order Number 325384; Model-Specific Registers, Order\nNumber 335592. Refer to all four volumes when evaluating your design needs.\n\nOrder Number:  325462-075US\nJune 2021\n\n\n\nIntel technologies features and benefits depend on system configuration and may require enabled hardware, software, or service activation. Learn\nmore at intel.com, or from the OEM or retailer.\n\nNo computer system can be absolutely secure. Intel does not assume any liability for lost or stolen data or systems or any damages resulting\nfrom such losses.\n\nYou may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products\ndescribed herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject\nmatter disclosed herein.\n\nNo license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document.\n\nThe products described may contain design defects or errors known as errata which may cause the product to deviate from published specifica-\ntions. Current characterized errata are available on request.\n\nThis document contains information on products, services and/or processes in development. All information provided here is subject to change\nwithout notice. Contact your Intel representative to obtain the latest Intel product specifications and roadmaps \n\nCopies of documents which have an order number and are referenced in this document, or other Intel literature, may be obtained by calling 1-\n800-548-4725, or by visiting http://www.intel.com/design/literature.htm.\n\nIntel, the Intel logo, Intel Atom, Intel Core, Intel SpeedStep, MMX, Pentium, VTune, and Xeon are trademarks of Intel Corporation in the U.S.\nand/or other countries.\n\n*Other names and brands may be claimed as the property of others.\n\nCopyright © 1997-2021, Intel Corporation. All Rights Reserved.\n\nhttp://www.intel.com/design/literature.htm\nhttp://www.intel.com/design/literature.htm\n\n\nIntel® 64 and IA-32 Architectures\nSoftware Developer’s Manual\n\nVolume 1:\nBasic Architecture\n\nNOTE: The Intel 64 and IA-32 Architectures Software Developer's Manual consists of four volumes:\nBasic Architecture, Order Number 253665; Instruction Set Reference A-Z, Order Number 325383;\nSystem Programming Guide, Order Number 325384; Model-Specific Registers, Order Number\n335592. Refer to all four volumes when evaluating your design needs.\n\nOrder Number:  253665-075US\nJune 2021\n\n\n\nIntel technologies features and benefits depend on system configuration and may require enabled hardware, software, or service activation. Learn\nmore at intel.com, or from the OEM or retailer.\n\nNo computer system can be absolutely secure. Intel does not assume any liability for lost or stolen data or systems or any damages resulting\nfrom such losses.\n\nYou may not use or facilitate the use of this document in connection with any infringement or other legal analysis concerning Intel products\ndescribed herein. You agree to grant Intel a non-exclusive, royalty-free license to any patent claim thereafter drafted which includes subject\nmatter disclosed herein.\n\nNo license (express or implied, by estoppel or otherwise) to any intellectual property rights is granted by this document.\n\nThe products described may contain design defects or errors known as errata which may cause the product to deviate from published specifica-\ntions. Current characterized errata are available on request.\n\nThis document contains information on products, services and/or processes in development. All information provided here is subject to change\nwithout notice. Contact your Intel representative to obtain the latest Intel product specifications and roadmaps \n\nCopies of documents which have an order number and are referenced in this document, or other Intel literature, may be obtained by calling 1-\n800-548-4725, or by visiting http://www.intel.com/design/literature.htm.\n\nIntel, the Intel logo, Intel Atom, Intel Core, Intel SpeedStep, MMX, Pentium, VTune, and Xeon are trademarks of Intel Corporation in the U.S.\nand/or other countries.\n\n*Other names and brands may be claimed as the property of others.\n\nCopyright © 1997-2021, Intel Corporation. All Rights Reserved.\n\nhttp://www.intel.com/design/literature.htm\nhttp://www.intel.com/design/literature.htm\n\n\nCONTENTS\nPAGE\nCHAPTER 1\nABOUT THIS MANUAL\n1.1 INTEL® 64 AND IA-32 PROCESSORS COVERED IN THIS MANUAL  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1-1\n1.2 OVERVIEW OF VOLUME 1: BASIC ARCHITECTURE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1-4\n1.3 NOTATIONAL CONVENTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1-5\n1.3.1 Bit and Byte Order . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-5\n1.3.2 Reserved Bits and Software Compatibility  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-6\n1.3.2.1 Instruction Operands. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-6\n1.3.3 Hexadecimal and Binary Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-7\n1.3.4 Segmented Addressing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-7\n1.3.5 A New Syntax for CPUID, CR, and MSR Values . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-7\n1.3.6 Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .1-8\n1.4 RELATED LITERATURE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  1-9\n\nCHAPTER 2\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.1 BRIEF HISTORY OF INTEL® 64 AND IA-32 ARCHITECTURE  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2-1\n2.1.1 16-bit Processors and Segmentation (1978) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-1\n2.1.2 The Intel® 286 Processor (1982) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-1\n2.1.3 The Intel386™ Processor (1985) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-1\n2.1.4 The Intel486™ Processor (1989) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-1\n2.1.5 The Intel® Pentium® Processor (1993). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-2\n2.1.6 The P6 Family of Processors (1995-1999) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-2\n2.1.7 The Intel® Pentium® 4 Processor Family (2000-2006). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-3\n2.1.8 The Intel® Xeon® Processor (2001- 2007) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-3\n2.1.9 The Intel® Pentium® M Processor (2003-2006) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-3\n2.1.10 The Intel® Pentium® Processor Extreme Edition (2005)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-4\n2.1.11 The Intel® Core™ Duo and Intel® Core™ Solo Processors (2006-2007)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-4\n2.1.12 The Intel® Xeon® Processor 5100, 5300 Series and Intel® Core™2 Processor Family (2006) . . . . . . . . . . . . . . . . . . . . . . . .2-4\n2.1.13 The Intel® Xeon® Processor 5200, 5400, 7400 Series and Intel® Core™2 Processor Family (2007) . . . . . . . . . . . . . . . . . .2-4\n2.1.14 The Intel® Atom™ Processor Family (2008) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\n2.1.15 The Intel® Atom™ Processor Family Based on Silvermont Microarchitecture (2013) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\n2.1.16 The Intel® Core™i7 Processor Family (2008) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\n2.1.17 The Intel® Xeon® Processor 7500 Series (2010) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-5\n2.1.18 2010 Intel® Core™ Processor Family (2010) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\n2.1.19 The Intel® Xeon® Processor 5600 Series (2010) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\n2.1.20 The Second Generation Intel® Core™ Processor Family (2011) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\n2.1.21 The Third Generation Intel® Core™ Processor Family (2012) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-6\n2.1.22 The Fourth Generation Intel® Core™ Processor Family (2013)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-7\n2.2 MORE ON SPECIFIC ADVANCES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2-7\n2.2.1 P6 Family Microarchitecture. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-7\n2.2.2 Intel NetBurst® Microarchitecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-8\n2.2.2.1 The Front End Pipeline . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .2-9\n2.2.2.2 Out-Of-Order Execution Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\n2.2.2.3 Retirement Unit . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\n2.2.3 Intel® Core™ Microarchitecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-10\n2.2.3.1 The Front End . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\n2.2.3.2 Execution Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12\n2.2.4 Intel® Atom™ Microarchitecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-12\n2.2.5 Intel® Microarchitecture Code Name Nehalem . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-13\n2.2.6 Intel® Microarchitecture Code Name Sandy Bridge. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-13\n2.2.7 SIMD Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-14\n2.2.8 Intel® Hyper-Threading Technology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-16\nVol. 1 iii\n\n\n\nCONTENTS\n\nPAGE\n2.2.8.1 Some Implementation Notes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-17\n2.2.9 Multi-Core Technology . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-18\n2.2.10 Intel® 64 Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-20\n2.2.11 Intel® Virtualization Technology (Intel® VT) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-20\n2.3 INTEL® 64 AND IA-32 PROCESSOR GENERATIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2-20\n2.4 PROPOSED REMOVAL OF INTEL INSTRUCTION SET ARCHITECTURE AND FEATURES FROM UPCOMING PRODUCTS . . . . .  2-28\n2.5 INTEL INSTRUCTION SET ARCHITECTURE AND FEATURES REMOVED . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  2-28\n\nCHAPTER 3\nBASIC EXECUTION ENVIRONMENT\n3.1 MODES OF OPERATION. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-1\n3.1.1 Intel® 64 Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-1\n3.2 OVERVIEW OF THE BASIC EXECUTION ENVIRONMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-2\n3.2.1 64-Bit Mode Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-5\n3.3 MEMORY ORGANIZATION  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-6\n3.3.1 IA-32 Memory Models. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-7\n3.3.2 Paging and Virtual Memory. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-8\n3.3.3 Memory Organization in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-8\n3.3.4 Modes of Operation vs. Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-9\n3.3.5 32-Bit and 16-Bit Address and Operand Sizes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-9\n3.3.6 Extended Physical Addressing in Protected Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .3-9\n3.3.7 Address Calculations in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-10\n3.3.7.1 Canonical Addressing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-10\n3.4 BASIC PROGRAM EXECUTION REGISTERS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-10\n3.4.1 General-Purpose Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-11\n3.4.1.1 General-Purpose Registers in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-12\n3.4.2 Segment Registers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-13\n3.4.2.1 Segment Registers in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-15\n3.4.3 EFLAGS Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-15\n3.4.3.1 Status Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-16\n3.4.3.2 DF Flag. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-17\n3.4.3.3 System Flags and IOPL Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-17\n3.4.3.4 RFLAGS Register in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-18\n3.5 INSTRUCTION POINTER . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-18\n3.5.1 Instruction Pointer in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-18\n3.6 OPERAND-SIZE AND ADDRESS-SIZE ATTRIBUTES  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-18\n3.6.1 Operand Size and Address Size in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19\n3.7 OPERAND ADDRESSING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  3-19\n3.7.1 Immediate Operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-20\n3.7.2 Register Operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-20\n3.7.2.1 Register Operands in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\n3.7.3 Memory Operands . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\n3.7.3.1 Memory Operands in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\n3.7.4 Specifying a Segment Selector  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\n3.7.4.1 Segmentation in 64-Bit Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-22\n3.7.5 Specifying an Offset . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-22\n3.7.5.1 Specifying an Offset in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-24\n3.7.6 Assembler and Compiler Addressing Modes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-24\n3.7.7 I/O Port Addressing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-24\n\nCHAPTER 4\nDATA TYPES\n4.1 FUNDAMENTAL DATA TYPES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-1\n4.1.1 Alignment of Words, Doublewords, Quadwords, and Double Quadwords  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-2\n4.2 NUMERIC DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-2\n4.2.1 Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-3\n4.2.1.1 Unsigned Integers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-3\n4.2.1.2 Signed Integers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-4\n4.2.2 Floating-Point Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .4-4\niv Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n4.3 POINTER DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-6\n4.3.1 Pointer Data Types in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\n4.4 BIT FIELD DATA TYPE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-7\n4.5 STRING DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-8\n4.6 PACKED SIMD DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-8\n4.6.1 64-Bit SIMD Packed Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\n4.6.2 128-Bit Packed SIMD Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\n4.7 BCD AND PACKED BCD INTEGERS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-9\n4.8 REAL NUMBERS AND FLOATING-POINT FORMATS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-11\n4.8.1 Real Number System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-11\n4.8.2 Floating-Point Format  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-11\n4.8.2.1 Normalized Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\n4.8.2.2 Biased Exponent . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\n4.8.3 Real Number and Non-number Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-13\n4.8.3.1 Signed Zeros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14\n4.8.3.2 Normalized and Denormalized Finite Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14\n4.8.3.3 Signed Infinities . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\n4.8.3.4 NaNs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\n4.8.3.5 Operating on SNaNs and QNaNs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\n4.8.3.6 Using SNaNs and QNaNs in Applications  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\n4.8.3.7 QNaN Floating-Point Indefinite . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-17\n4.8.3.8 Half-Precision Floating-Point Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-17\n4.8.4 Rounding  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-17\n4.8.4.1 Rounding Control (RC) Fields . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\n4.8.4.2 Truncation with SSE and SSE2 Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\n4.9 OVERVIEW OF FLOATING-POINT EXCEPTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  4-18\n4.9.1 Floating-Point Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\n4.9.1.1 Invalid Operation Exception (#I) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\n4.9.1.2 Denormal Operand Exception (#D). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\n4.9.1.3 Divide-By-Zero Exception (#Z) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-20\n4.9.1.4 Numeric Overflow Exception (#O) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\n4.9.1.5 Numeric Underflow Exception (#U) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\n4.9.1.6 Inexact-Result (Precision) Exception (#P) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-22\n4.9.2 Floating-Point Exception Priority . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-23\n4.9.3 Typical Actions of a Floating-Point Exception Handler . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-23\n\nCHAPTER 5\nINSTRUCTION SET SUMMARY\n5.1 GENERAL-PURPOSE INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-4\n5.1.1 Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-4\n5.1.2 Binary Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-5\n5.1.3 Decimal Arithmetic Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\n5.1.4 Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\n5.1.5 Shift and Rotate Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\n5.1.6 Bit and Byte Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-6\n5.1.7 Control Transfer Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-7\n5.1.8 String Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-8\n5.1.9 I/O Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-8\n5.1.10 Enter and Leave Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9\n5.1.11 Flag Control (EFLAG) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9\n5.1.12 Segment Register Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9\n5.1.13 Miscellaneous Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-9\n5.1.14 User Mode Extended Sate Save/Restore Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10\n5.1.15 Random Number Generator Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10\n5.1.16 BMI1, BMI2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10\n5.1.16.1 Detection of VEX-encoded GPR Instructions, LZCNT and TZCNT, PREFETCHW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-10\n5.2 X87 FPU INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-11\n5.2.1 x87 FPU Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-11\n5.2.2 x87 FPU Basic Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-11\nVol. 1 v\n\n\n\nCONTENTS\n\nPAGE\n5.2.3 x87 FPU Comparison Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-12\n5.2.4 x87 FPU Transcendental Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-12\n5.2.5 x87 FPU Load Constants Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-12\n5.2.6 x87 FPU Control Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-13\n5.3 X87 FPU AND SIMD STATE MANAGEMENT INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-13\n5.4 MMX™ INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-13\n5.4.1 MMX Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-14\n5.4.2 MMX Conversion Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-14\n5.4.3 MMX Packed Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-14\n5.4.4 MMX Comparison Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\n5.4.5 MMX Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\n5.4.6 MMX Shift and Rotate Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\n5.4.7 MMX State Management Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-15\n5.5 SSE INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-15\n5.5.1 SSE SIMD Single-Precision Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-16\n5.5.1.1 SSE Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-16\n5.5.1.2 SSE Packed Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-16\n5.5.1.3 SSE Comparison Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\n5.5.1.4 SSE Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\n5.5.1.5 SSE Shuffle and Unpack Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\n5.5.1.6 SSE Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-17\n5.5.2 SSE MXCSR State Management Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-18\n5.5.3 SSE 64-Bit SIMD Integer Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-18\n5.5.4 SSE Cacheability Control, Prefetch, and Instruction Ordering Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-18\n5.6 SSE2 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-18\n5.6.1 SSE2 Packed and Scalar Double-Precision Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-19\n5.6.1.1 SSE2 Data Movement Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-19\n5.6.1.2 SSE2 Packed Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-19\n5.6.1.3 SSE2 Logical Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\n5.6.1.4 SSE2 Compare Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\n5.6.1.5 SSE2 Shuffle and Unpack Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\n5.6.1.6 SSE2 Conversion Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-20\n5.6.2 SSE2 Packed Single-Precision Floating-Point Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-21\n5.6.3 SSE2 128-Bit SIMD Integer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-21\n5.6.4 SSE2 Cacheability Control and Ordering Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-21\n5.7 SSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-22\n5.7.1 SSE3 x87-FP Integer Conversion Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\n5.7.2 SSE3 Specialized 128-bit Unaligned Data Load Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\n5.7.3 SSE3 SIMD Floating-Point Packed ADD/SUB Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\n5.7.4 SSE3 SIMD Floating-Point Horizontal ADD/SUB Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-22\n5.7.5 SSE3 SIMD Floating-Point LOAD/MOVE/DUPLICATE Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-23\n5.7.6 SSE3 Agent Synchronization Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-23\n5.8 SUPPLEMENTAL STREAMING SIMD EXTENSIONS 3 (SSSE3) INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-23\n5.8.1 Horizontal Addition/Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-23\n5.8.2 Packed Absolute Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.3 Multiply and Add Packed Signed and Unsigned Bytes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.4 Packed Multiply High with Round and Scale  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.5 Packed Shuffle Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.6 Packed Sign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.8.7 Packed Align Right . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-24\n5.9 SSE4 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-25\n5.10 SSE4.1 INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-25\n5.10.1 Dword Multiply Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-25\n5.10.2 Floating-Point Dot Product Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-25\n5.10.3 Streaming Load Hint Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-25\n5.10.4 Packed Blending Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-26\n5.10.5 Packed Integer MIN/MAX Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-26\n5.10.6 Floating-Point Round Instructions with Selectable Rounding Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-26\n5.10.7 Insertion and Extractions from XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-26\nvi Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n5.10.8 Packed Integer Format Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-27\n5.10.9 Improved Sums of Absolute Differences (SAD) for 4-Byte Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-27\n5.10.10 Horizontal Search  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-27\n5.10.11 Packed Test. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.10.12 Packed Qword Equality Comparisons  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.10.13 Dword Packing With Unsigned Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.11 SSE4.2 INSTRUCTION SET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-28\n5.11.1 String and Text Processing Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.11.2 Packed Comparison SIMD integer Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-28\n5.12 INTEL® AES-NI AND PCLMULQDQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-28\n5.13 INTEL® ADVANCED VECTOR EXTENSIONS (INTEL® AVX). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-29\n5.14 16-BIT FLOATING-POINT CONVERSION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-29\n5.15 FUSED-MULTIPLY-ADD (FMA)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-29\n5.16 INTEL® ADVANCED VECTOR EXTENSIONS 2 (INTEL® AVX2)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-29\n5.17 INTEL® TRANSACTIONAL SYNCHRONIZATION EXTENSIONS (INTEL® TSX) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-30\n5.18 INTEL® SHA EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-30\n5.19 INTEL® ADVANCED VECTOR EXTENSIONS 512 (INTEL® AVX-512)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-30\n5.20 SYSTEM INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-34\n5.21 64-BIT MODE INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-35\n5.22 VIRTUAL-MACHINE EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-35\n5.23 SAFER MODE EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-36\n5.24 INTEL® MEMORY PROTECTION EXTENSIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-36\n5.25 INTEL® SOFTWARE GUARD EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-37\n5.26 SHADOW STACK MANAGEMENT INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-37\n5.27 CONTROL TRANSFER TERMINATING INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  5-37\n\nCHAPTER 6\nPROCEDURE CALLS, INTERRUPTS, AND EXCEPTIONS\n6.1 PROCEDURE CALL TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-1\n6.2 STACKS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-1\n6.2.1 Setting Up a Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-2\n6.2.2 Stack Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-2\n6.2.3 Address-Size Attributes for Stack Accesses . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3\n6.2.4 Procedure Linking Information  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3\n6.2.4.1 Stack-Frame Base Pointer  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3\n6.2.4.2 Return Instruction Pointer . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-3\n6.2.5 Stack Behavior in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-4\n6.3 SHADOW STACKS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-4\n6.4 CALLING PROCEDURES USING CALL AND RET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-4\n6.4.1 Near CALL and RET Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-4\n6.4.2 Far CALL and RET Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-5\n6.4.3 Parameter Passing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.3.1 Passing Parameters Through the General-Purpose Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.3.2 Passing Parameters on the Stack. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.3.3 Passing Parameters in an Argument List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.4 Saving Procedure State Information . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.5 Calls to Other Privilege Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-7\n6.4.6 CALL and RET Operation Between Privilege Levels . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-8\n6.4.7 Branch Functions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-12\n6.5 INTERRUPTS AND EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-12\n6.5.1 Call and Return Operation for Interrupt or Exception Handling Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-13\n6.5.2 Calls to Interrupt or Exception Handler Tasks  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-18\n6.5.3 Interrupt and Exception Handling in Real-Address Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-18\n6.5.4 INT n, INTO, INT3, INT1, and BOUND Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-18\n6.5.5 Handling Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-19\n6.5.6 Interrupt and Exception Behavior in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-19\n6.6 PROCEDURE CALLS FOR BLOCK-STRUCTURED LANGUAGES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  6-20\n6.6.1 ENTER Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-20\n6.6.2 LEAVE Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-24\nVol. 1 vii\n\n\n\nCONTENTS\n\nPAGE\nCHAPTER 7\nPROGRAMMING WITH GENERAL-PURPOSE INSTRUCTIONS\n7.1 PROGRAMMING ENVIRONMENT FOR GP INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  7-1\n7.2 PROGRAMMING ENVIRONMENT FOR GP INSTRUCTIONS IN 64-BIT MODE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  7-1\n7.3 SUMMARY OF GP INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  7-2\n7.3.1 Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-2\n7.3.1.1 General Data Movement Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-3\n7.3.1.2 Exchange Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-4\n7.3.1.3 Exchange Instructions in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-5\n7.3.1.4 Stack Manipulation Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-5\n7.3.1.5 Stack Manipulation Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-7\n7.3.1.6 Type Conversion Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-7\n7.3.1.7 Type Conversion Instructions in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2 Binary Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.1 Addition and Subtraction Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.2 Increment and Decrement Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.3 Increment and Decrement Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.4 Comparison and Sign Change Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-8\n7.3.2.5 Multiplication and Division Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-9\n7.3.3 Decimal Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-9\n7.3.3.1 Packed BCD Adjustment Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-9\n7.3.3.2 Unpacked BCD Adjustment Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .7-9\n7.3.4 Decimal Arithmetic Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-10\n7.3.5 Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-10\n7.3.6 Shift and Rotate Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-10\n7.3.6.1 Shift Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-10\n7.3.6.2 Double-Shift Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-12\n7.3.6.3 Rotate Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-13\n7.3.7 Bit and Byte Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-13\n7.3.7.1 Bit Test and Modify Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.7.2 Bit Scan Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.7.3 Byte Set on Condition Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.7.4 Test Instruction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.8 Control Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.8.1 Unconditional Transfer Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\n7.3.8.2 Conditional Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-15\n7.3.8.3 Control Transfer Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-17\n7.3.8.4 Software Interrupt Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-17\n7.3.8.5 Software Interrupt Instructions in 64-bit Mode and Compatibility Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-18\n7.3.9 String Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-18\n7.3.9.1 String Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-18\n7.3.9.2 Repeated String Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-19\n7.3.9.3 Fast-String Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-19\n7.3.9.4 String Operations in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-20\n7.3.10 I/O Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-20\n7.3.11 I/O Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-20\n7.3.12 Enter and Leave Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\n7.3.13 Flag Control (EFLAG) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\n7.3.13.1 Carry and Direction Flag Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\n7.3.13.2 EFLAGS Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\n7.3.13.3 Interrupt Flag Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.14 Flag Control (RFLAG) Instructions in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.15 Segment Register Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.15.1 Segment-Register Load and Store Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.15.2 Far Control Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-22\n7.3.15.3 Software Interrupt Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.15.4 Load Far Pointer Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.16 Miscellaneous Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.16.1 Address Computation Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\nviii Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n7.3.16.2 Table Lookup Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.16.3 Processor Identification Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.16.4 No-Operation and Undefined Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-23\n7.3.17 Random Number Generator Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-24\n7.3.17.1 RDRAND . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-24\n7.3.17.2 RDSEED. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-24\n\nCHAPTER 8\nPROGRAMMING WITH THE X87 FPU \n8.1 X87 FPU EXECUTION ENVIRONMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-1\n8.1.1 x87 FPU in 64-Bit Mode and Compatibility Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-1\n8.1.2 x87 FPU Data Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-1\n8.1.2.1 Parameter Passing With the x87 FPU Register Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-3\n8.1.3 x87 FPU Status Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-4\n8.1.3.1 Top of Stack (TOP) Pointer. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-4\n8.1.3.2 Condition Code Flags  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-4\n8.1.3.3 x87 FPU Floating-Point Exception Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-5\n8.1.3.4 Stack Fault Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-6\n8.1.4 Branching and Conditional Moves on Condition Codes. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-6\n8.1.5 x87 FPU Control Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-7\n8.1.5.1 x87 FPU Floating-Point Exception Mask Bits . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-7\n8.1.5.2 Precision Control Field . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-7\n8.1.5.3 Rounding Control Field. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\n8.1.6 Infinity Control Flag. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\n8.1.7 x87 FPU Tag Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\n8.1.8 x87 FPU Instruction and Data (Operand) Pointers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-9\n8.1.9 Last Instruction Opcode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-10\n8.1.9.1 Fopcode Compatibility Sub-mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-10\n8.1.10 Saving the x87 FPU’s State with FSTENV/FNSTENV and FSAVE/FNSAVE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-11\n8.1.11 Saving the x87 FPU’s State with FXSAVE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12\n8.2 X87 FPU DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-13\n8.2.1 Indefinites . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-14\n8.2.2 Unsupported Double Extended-Precision Floating-Point Encodings and Pseudo-Denormals . . . . . . . . . . . . . . . . . . . . . . . . 8-14\n8.3 X87 FPU INSTRUCTION SET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-15\n8.3.1 Escape (ESC) Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-15\n8.3.2 x87 FPU Instruction Operands  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-15\n8.3.3 Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-16\n8.3.4 Load Constant Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-17\n8.3.5 Basic Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-17\n8.3.6 Comparison and Classification Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-18\n8.3.6.1 Branching on the x87 FPU Condition Codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-20\n8.3.7 Trigonometric Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-20\n8.3.8 Approximation of Pi  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-21\n8.3.9 Logarithmic, Exponential, and Scale. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-21\n8.3.10 Transcendental Instruction Accuracy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-22\n8.3.11 x87 FPU Control Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-23\n8.3.12 Waiting vs. Non-waiting Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-24\n8.3.13 Unsupported x87 FPU Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-24\n8.4 X87 FPU FLOATING-POINT EXCEPTION HANDLING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-24\n8.4.1 Arithmetic vs. Non-arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-25\n8.5 X87 FPU FLOATING-POINT EXCEPTION CONDITIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-26\n8.5.1 Invalid Operation Exception . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-26\n8.5.1.1 Stack Overflow or Underflow Exception (#IS) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-26\n8.5.1.2 Invalid Arithmetic Operand Exception (#IA)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-27\n8.5.2 Denormal Operand Exception (#D). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-28\n8.5.3 Divide-By-Zero Exception (#Z) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-28\n8.5.4 Numeric Overflow Exception (#O) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-28\n8.5.5 Numeric Underflow Exception (#U) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-29\n8.5.6 Inexact-Result (Precision) Exception (#P) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-30\nVol. 1 ix\n\n\n\nCONTENTS\n\nPAGE\n8.6 X87 FPU EXCEPTION SYNCHRONIZATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-31\n8.7 HANDLING X87 FPU EXCEPTIONS IN SOFTWARE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  8-32\n8.7.1 Native Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-32\n8.7.2 MS-DOS* Compatibility Sub-mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-32\n8.7.3 Handling x87 FPU Exceptions in Software  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-33\n\nCHAPTER 9 \nPROGRAMMING WITH INTEL® MMX™ TECHNOLOGY\n9.1 OVERVIEW OF MMX TECHNOLOGY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-1\n9.2 THE MMX TECHNOLOGY PROGRAMMING ENVIRONMENT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-1\n9.2.1 MMX Technology in 64-Bit Mode and Compatibility Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-2\n9.2.2 MMX Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-2\n9.2.3 MMX Data Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-3\n9.2.4 Memory Data Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-3\n9.2.5 Single Instruction, Multiple Data (SIMD) Execution Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-4\n9.3 SATURATION AND WRAPAROUND MODES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-4\n9.4 MMX INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-5\n9.4.1 Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-6\n9.4.2 Arithmetic Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-6\n9.4.3 Comparison Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-7\n9.4.4 Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-7\n9.4.5 Unpack Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-7\n9.4.6 Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-7\n9.4.7 Shift Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-8\n9.4.8 EMMS Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-8\n9.5 COMPATIBILITY WITH X87 FPU ARCHITECTURE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-8\n9.5.1 MMX Instructions and the x87 FPU Tag Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-8\n9.6 WRITING APPLICATIONS WITH MMX CODE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  9-8\n9.6.1 Checking for MMX Technology Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-8\n9.6.2 Transitions Between x87 FPU and MMX Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-9\n9.6.3 Using the EMMS Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .9-9\n9.6.4 Mixing MMX and x87 FPU Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-10\n9.6.5 Interfacing with MMX Code. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-10\n9.6.6 Using MMX Code in a Multitasking Operating System Environment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-10\n9.6.7 Exception Handling in MMX Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-11\n9.6.8 Register Mapping . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-11\n9.6.9 Effect of Instruction Prefixes on MMX Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-11\n\nCHAPTER 10\nPROGRAMMING WITH INTEL® STREAMING SIMD EXTENSIONS (INTEL® SSE)\n10.1 OVERVIEW OF SSE EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10-1\n10.2 SSE PROGRAMMING ENVIRONMENT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10-2\n10.2.1 SSE in 64-Bit Mode and Compatibility Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-3\n10.2.2 XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-3\n10.2.3 MXCSR Control and Status Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-3\n10.2.3.1 SIMD Floating-Point Mask and Flag Bits  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-4\n10.2.3.2 SIMD Floating-Point Rounding Control Field  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-4\n10.2.3.3 Flush-To-Zero . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-4\n10.2.3.4 Denormals-Are-Zeros . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-5\n10.2.4 Compatibility of SSE Extensions with SSE2/SSE3/MMX and the x87 FPU. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-5\n10.3 SSE DATA TYPES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10-5\n10.4 SSE INSTRUCTION SET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  10-6\n10.4.1 SSE Packed and Scalar Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-6\n10.4.1.1 SSE Data Movement Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-7\n10.4.1.2 SSE Arithmetic Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-8\n10.4.2 SSE Logical Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-9\n10.4.2.1 SSE Comparison Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-9\n10.4.2.2 SSE Shuffle and Unpack Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-9\n10.4.3 SSE Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-11\nx Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n10.4.4 SSE 64-Bit SIMD Integer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-11\n10.4.5 MXCSR State Management Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-12\n10.4.6 Cacheability Control, Prefetch, and Memory Ordering Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-12\n10.4.6.1 Cacheability Control Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-12\n10.4.6.2 Caching of Temporal vs. Non-Temporal Data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-12\n10.4.6.3 PREFETCHh Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-13\n10.4.6.4 SFENCE Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-14\n10.5 FXSAVE AND FXRSTOR INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-14\n10.5.1 FXSAVE Area  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-14\n10.5.1.1 x87 State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-15\n10.5.1.2 SSE State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-16\n10.5.2 Operation of FXSAVE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-16\n10.5.3 Operation of FXRSTOR  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-17\n10.6 HANDLING SSE INSTRUCTION EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-17\n10.7 WRITING APPLICATIONS WITH THE SSE EXTENSIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-17\n\nCHAPTER 11\nPROGRAMMING WITH INTEL® STREAMING SIMD EXTENSIONS 2 (INTEL® SSE2)\n11.1 OVERVIEW OF SSE2 EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11-1\n11.2 SSE2 PROGRAMMING ENVIRONMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11-2\n11.2.1 SSE2 in 64-Bit Mode and Compatibility Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-3\n11.2.2 Compatibility of SSE2 Extensions with SSE, MMX Technology and x87 FPU Programming Environment  . . . . . . . . . . . . 11-3\n11.2.3 Denormals-Are-Zeros Flag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-3\n11.3 SSE2 DATA TYPES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11-3\n11.4 SSE2 INSTRUCTIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11-4\n11.4.1 Packed and Scalar Double-Precision Floating-Point Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-4\n11.4.1.1 Data Movement Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-5\n11.4.1.2 SSE2 Arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-6\n11.4.1.3 SSE2 Logical Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-7\n11.4.1.4 SSE2 Comparison Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-7\n11.4.1.5 SSE2 Shuffle and Unpack Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-7\n11.4.1.6 SSE2 Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-9\n11.4.2 SSE2 64-Bit and 128-Bit SIMD Integer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-10\n11.4.3 128-Bit SIMD Integer Instruction Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-11\n11.4.4 Cacheability Control and Memory Ordering Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.4.1 FLUSH Cache Line . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.4.2 Cacheability Control Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.4.3 Memory Ordering Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.4.4 Pause. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-12\n11.4.5 Branch Hints . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-13\n11.5 SSE, SSE2, AND SSE3 EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-13\n11.5.1 SIMD Floating-Point Exceptions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-13\n11.5.2 SIMD Floating-Point Exception Conditions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-14\n11.5.2.1 Invalid Operation Exception (#I) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-14\n11.5.2.2 Denormal-Operand Exception (#D)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-15\n11.5.2.3 Divide-By-Zero Exception (#Z) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-15\n11.5.2.4 Numeric Overflow Exception (#O) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-15\n11.5.2.5 Numeric Underflow Exception (#U) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-16\n11.5.2.6 Inexact-Result (Precision) Exception (#P) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-16\n11.5.3 Generating SIMD Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-16\n11.5.3.1 Handling Masked Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-16\n11.5.3.2 Handling Unmasked Exceptions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-17\n11.5.3.3 Handling Combinations of Masked and Unmasked Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-18\n11.5.4 Handling SIMD Floating-Point Exceptions in Software. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-18\n11.5.5 Interaction of SIMD and x87 FPU Floating-Point Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-18\n11.6 WRITING APPLICATIONS WITH SSE/SSE2 EXTENSIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-19\n11.6.1 General Guidelines for Using SSE/SSE2 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-19\n11.6.2 Checking for SSE/SSE2 Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-19\n11.6.3 Checking for the DAZ Flag in the MXCSR Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-20\nVol. 1 xi\n\n\n\nCONTENTS\n\nPAGE\n11.6.4 Initialization of SSE/SSE2 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-20\n11.6.5 Saving and Restoring the SSE/SSE2 State. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-20\n11.6.6 Guidelines for Writing to the MXCSR Register  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-21\n11.6.7 Interaction of SSE/SSE2 Instructions with x87 FPU and MMX Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-21\n11.6.8 Compatibility of SIMD and x87 FPU Floating-Point Data Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-22\n11.6.9 Mixing Packed and Scalar Floating-Point and 128-Bit SIMD Integer Instructions and Data . . . . . . . . . . . . . . . . . . . . . . . . . 11-22\n11.6.10 Interfacing with SSE/SSE2 Procedures and Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-23\n11.6.10.1 Passing Parameters in XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-23\n11.6.10.2 Saving XMM Register State on a Procedure or Function Call . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-23\n11.6.10.3 Caller-Save Recommendation for Procedure and Function Calls. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-24\n11.6.11 Updating Existing MMX Technology Routines Using 128-Bit SIMD Integer Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-24\n11.6.12 Branching on Arithmetic Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-24\n11.6.13 Cacheability Hint Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-25\n11.6.14 Effect of Instruction Prefixes on the SSE/SSE2 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-25\n\nCHAPTER 12\nPROGRAMMING WITH INTEL® SSE3, SSSE3, INTEL® SSE4 AND INTEL® AESNI\n12.1 PROGRAMMING ENVIRONMENT AND DATA TYPES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-1\n12.1.1 SSE3, SSSE3, SSE4 in 64-Bit Mode and Compatibility Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-1\n12.1.2 Compatibility of SSE3/SSSE3 with MMX Technology, the x87 FPU Environment, and SSE/SSE2 Extensions . . . . . . . . . 12-1\n12.1.3 Horizontal and Asymmetric Processing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-1\n12.2 OVERVIEW OF SSE3 INSTRUCTIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-2\n12.3 SSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-2\n12.3.1 x87 FPU Instruction for Integer Conversion . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-3\n12.3.2 SIMD Integer Instruction for Specialized 128-bit Unaligned Data Load  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-3\n12.3.3 SIMD Floating-Point Instructions That Enhance LOAD/MOVE/DUPLICATE Performance. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-3\n12.3.4 SIMD Floating-Point Instructions Provide Packed Addition/Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-4\n12.3.5 SIMD Floating-Point Instructions Provide Horizontal Addition/Subtraction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-4\n12.3.6 Two Thread Synchronization Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-5\n12.4 WRITING APPLICATIONS WITH SSE3 EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-5\n12.4.1 Guidelines for Using SSE3 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-5\n12.4.2 Checking for SSE3 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-5\n12.4.3 Enable FTZ and DAZ for SIMD Floating-Point Computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-6\n12.4.4 Programming SSE3 with SSE/SSE2 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-6\n12.5 OVERVIEW OF SSSE3 INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-6\n12.6 SSSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-6\n12.6.1 Horizontal Addition/Subtraction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-7\n12.6.2 Packed Absolute Values. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-7\n12.6.3 Multiply and Add Packed Signed and Unsigned Bytes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.6.4 Packed Multiply High with Round and Scale  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.6.5 Packed Shuffle Bytes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.6.6 Packed Sign . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.6.7 Packed Align Right . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-8\n12.7 WRITING APPLICATIONS WITH SSSE3 EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-9\n12.7.1 Guidelines for Using SSSE3 Extensions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-9\n12.7.2 Checking for SSSE3 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-9\n12.8 SSE3/SSSE3 AND SSE4 EXCEPTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-9\n12.8.1 Device Not Available (DNA) Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-9\n12.8.2 Numeric Error flag and IGNNE# . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-9\n12.8.3 Emulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-10\n12.8.4 IEEE 754 Compliance of SSE4.1 Floating-Point Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-10\n12.9 SSE4 OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-10\n12.10 SSE4.1 INSTRUCTION SET . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  12-11\n12.10.1 Dword Multiply Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-11\n12.10.2 Floating-Point Dot Product Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-11\n12.10.3 Streaming Load Hint Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-12\n12.10.4 Packed Blending Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\n12.10.5 Packed Integer MIN/MAX Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\n12.10.6 Floating-Point Round Instructions with Selectable Rounding Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\nxii Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n12.10.7 Insertion and Extractions from XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-15\n12.10.8 Packed Integer Format Conversions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-15\n12.10.9 Improved Sums of Absolute Differences (SAD) for 4-Byte Blocks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-16\n12.10.10 Horizontal Search  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-16\n12.10.11 Packed Test. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.10.12 Packed Qword Equality Comparisons  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.10.13 Dword Packing With Unsigned Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.11 SSE4.2 INSTRUCTION SET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.11.1 String and Text Processing Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\n12.11.1.1 Memory Operand Alignment  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-18\n12.11.2 Packed Comparison SIMD Integer Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-18\n12.12 WRITING APPLICATIONS WITH SSE4 EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-18\n12.12.1 Guidelines for Using SSE4 Extensions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-18\n12.12.2 Checking for SSE4.1 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-19\n12.12.3 Checking for SSE4.2 Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-19\n12.13 AESNI OVERVIEW. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-19\n12.13.1 Little-Endian Architecture and Big-Endian Specification (FIPS 197) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-19\n12.13.1.1 AES Data Structure in Intel 64 Architecture. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-20\n12.13.2 AES Transformations and Functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-21\n12.13.3 PCLMULQDQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-24\n12.13.4 Checking for AESNI Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-24\n\nCHAPTER 13\nMANAGING STATE USING THE XSAVE FEATURE SET\n13.1 XSAVE-SUPPORTED FEATURES AND STATE-COMPONENT BITMAPS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13-1\n13.2 ENUMERATION OF CPU SUPPORT FOR XSAVE INSTRUCTIONS AND XSAVE-SUPPORTED FEATURES  . . . . . . . . . . . . . . . . . .  13-3\n13.3 ENABLING THE XSAVE FEATURE SET AND XSAVE-ENABLED FEATURES. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13-4\n13.4 XSAVE AREA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13-6\n13.4.1 Legacy Region of an XSAVE Area  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-7\n13.4.2 XSAVE Header . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-8\n13.4.3 Extended Region of an XSAVE Area . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-8\n13.5 XSAVE-MANAGED STATE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  13-9\n13.5.1 x87 State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-9\n13.5.2 SSE State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-10\n13.5.3 AVX State  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-10\n13.5.4 MPX State  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-11\n13.5.5 AVX-512 State. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-11\n13.5.6 PT State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-12\n13.5.7 PKRU State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-13\n13.5.8 CET State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-13\n13.5.9 HDC State. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-13\n13.5.10 HWP State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-14\n13.6 PROCESSOR TRACKING OF XSAVE-MANAGED STATE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-14\n13.7 OPERATION OF XSAVE. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-15\n13.8 OPERATION OF XRSTOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-16\n13.8.1 Standard Form of XRSTOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-16\n13.8.2 Compacted Form of XRSTOR . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-17\n13.8.3 XRSTOR and the Init and Modified Optimizations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-17\n13.9 OPERATION OF XSAVEOPT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-18\n13.10 OPERATION OF XSAVEC  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-19\n13.11 OPERATION OF XSAVES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-20\n13.12 OPERATION OF XRSTORS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-21\n13.13 MEMORY ACCESSES BY THE XSAVE FEATURE SET  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-23\n\nCHAPTER 14\nPROGRAMMING WITH AVX, FMA AND AVX2\n14.1 INTEL AVX OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-1\n14.1.1 256-Bit Wide SIMD Register Support  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-1\n14.1.2 Instruction Syntax Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-2\nVol. 1 xiii\n\n\n\nCONTENTS\n\nPAGE\n14.1.3 VEX Prefix Instruction Encoding Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-2\n14.2 FUNCTIONAL OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-3\n14.2.1 256-bit Floating-Point Arithmetic Processing Enhancements . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-9\n14.2.2 256-bit Non-Arithmetic Instruction Enhancements  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-9\n14.2.3 Arithmetic Primitives for 128-bit Vector and Scalar processing. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-11\n14.2.4 Non-Arithmetic Primitives for 128-bit Vector and Scalar Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-13\n14.3 DETECTION OF AVX INSTRUCTIONS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-15\n14.3.1 Detection of VEX-Encoded AES and VPCLMULQDQ  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-17\n14.4 HALF-PRECISION FLOATING-POINT CONVERSION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-18\n14.4.1 Detection of F16C Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-20\n14.5 FUSED-MULTIPLY-ADD (FMA) EXTENSIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-21\n14.5.1 FMA Instruction Operand Order and Arithmetic Behavior. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-22\n14.5.2 Fused-Multiply-ADD (FMA) Numeric Behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-22\n14.5.3 Detection of FMA . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-24\n14.6 OVERVIEW OF INTEL® ADVANCED VECTOR EXTENSIONS 2 (INTEL® AVX2)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-25\n14.6.1 AVX2 and 256-bit Vector Integer Processing  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-25\n14.7 PROMOTED VECTOR INTEGER INSTRUCTIONS IN AVX2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-26\n14.7.1 Detection of AVX2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-31\n14.8 ACCESSING YMM REGISTERS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-32\n14.9 MEMORY ALIGNMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-32\n14.10 SIMD FLOATING-POINT EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-34\n14.11 EMULATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-34\n14.12 WRITING AVX FLOATING-POINT EXCEPTION HANDLERS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-34\n14.13 GENERAL PURPOSE INSTRUCTION SET ENHANCEMENTS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  14-35\n\nCHAPTER 15\nPROGRAMMING WITH INTEL® AVX-512\n15.1 OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-1\n15.1.1 512-Bit Wide SIMD Register Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-1\n15.1.2 32 SIMD Register Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-1\n15.1.3 Eight Opmask Register Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-1\n15.1.4 Instruction Syntax Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-2\n15.1.5 EVEX Instruction Encoding Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-3\n15.2 DETECTION OF AVX-512 FOUNDATION INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-3\n15.2.1 Additional 512-bit Instruction Extensions of the Intel AVX-512 Family . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-4\n15.3 DETECTION OF 512-BIT INSTRUCTION GROUPS OF INTEL® AVX-512 FAMILY. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-5\n15.4 DETECTION OF INTEL AVX-512 INSTRUCTION GROUPS OPERATING AT 256 AND 128-BIT VECTOR LENGTHS  . . . . . . . . .  15-6\n15.5 ACCESSING XMM, YMM AND ZMM REGISTERS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-8\n15.6 ENHANCED VECTOR PROGRAMMING ENVIRONMENT USING EVEX ENCODING  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-8\n15.6.1 OPMASK Register to Predicate Vector Data Processing . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-9\n15.6.1.1 Opmask Register K0 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-9\n15.6.1.2 Example of Opmask Usages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-10\n15.6.2 OpMask Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-11\n15.6.3 Broadcast . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-11\n15.6.4 Static Rounding Mode and Suppress All Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-12\n15.6.5 Compressed Disp8*N Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-13\n15.7 MEMORY ALIGNMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-13\n15.8 SIMD FLOATING-POINT EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-14\n15.9 INSTRUCTION EXCEPTION SPECIFICATION. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-15\n15.10 EMULATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-15\n15.11 WRITING FLOATING-POINT EXCEPTION HANDLERS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  15-15\n\nCHAPTER 16\nPROGRAMMING WITH INTEL® TRANSACTIONAL SYNCHRONIZATION EXTENSIONS\n16.1 OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  16-1\n16.2 INTEL® TRANSACTIONAL SYNCHRONIZATION EXTENSIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  16-1\n16.2.1 HLE Software Interface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-2\n16.2.2 RTM Software Interface  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3 INTEL® TSX APPLICATION PROGRAMMING MODEL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  16-3\nxiv Vol. 1\n\n\n\nCONTENTS\n\nPAGE\n16.3.1 Detection of Transactional Synchronization Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3.1.1 Detection of HLE Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3.1.2 Detection of RTM Support . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3.1.3 Detection of XTEST Instruction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-3\n16.3.2 Querying Transactional Execution Status . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-4\n16.3.3 Requirements for HLE Locks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-4\n16.3.4 Transactional Nesting  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-4\n16.3.4.1 HLE Nesting and Elision . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-4\n16.3.4.2 RTM Nesting . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\n16.3.4.3 Nesting HLE and RTM. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\n16.3.5 RTM Abort Status Definition . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\n16.3.6 RTM Memory Ordering . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\n16.3.7 RTM-Enabled Debugger Support. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-6\n16.3.8 Programming Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-6\n16.3.8.1 Instruction Based Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-6\n16.3.8.2 Runtime Considerations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-7\n\nCHAPTER 17\nINTEL® MEMORY PROTECTION EXTENSIONS\n17.1 INTEL® MEMORY PROTECTION EXTENSIONS (INTEL® MPX) . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-1\n17.2 INTRODUCTION. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-1\n17.3 INTEL MPX PROGRAMMING ENVIRONMENT . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-2\n17.3.1 Detection and Enumeration of Intel MPX Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-2\n17.3.2 Bounds Registers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-2\n17.3.3 Configuration and Status Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-3\n17.3.4 Read and Write of IA32_BNDCFGS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-4\n17.4 INTEL MPX INSTRUCTION SUMMARY . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-4\n17.4.1 Instruction Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-5\n17.4.2 Usage and Examples. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-5\n17.4.3 Loading and Storing Bounds in Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-6\n17.4.3.1 BNDLDX and BNDSTX in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-7\n17.4.3.2 BNDLDX and BNDSTX Outside 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-8\n17.5 INTERACTIONS WITH INTEL MPX . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  17-9\n17.5.1 Intel MPX and Operating Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-9\n17.5.2 Intel MPX Support for Pointer Operations with Branching. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-10\n17.5.3 CALL, RET, JMP and All Jcc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-10\n17.5.4 BOUND Instruction and Intel MPX  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\n17.5.5 Programming Considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\n17.5.6 Intel MPX and System Management Mode  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\n17.5.7 Support of Intel MPX in VMCS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\n17.5.8 Support of Intel MPX in Intel TSX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-12\n\nCHAPTER 18\nCONTROL-FLOW ENFORCEMENT TECHNOLOGY (CET)\n18.1 INTRODUCTION. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18-1\n18.1.1 Shadow Stack . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-1\n18.1.2 Indirect Branch Tracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-1\n18.1.3 Speculative Behavior when CET is Enabled. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-2\n18.2 SHADOW STACKS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18-2\n18.2.1 Shadow Stack Pointer and its Operand and Address Size Attributes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-2\n18.2.2 Terminology  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-2\n18.2.3 Supervisor Shadow Stack Token  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-3\n18.2.4 Shadow Stack Usage on Task Switch . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-5\n18.2.5 Switching Shadow Stacks . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-5\n18.2.6 Constraining Execution at Targets of RET. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-7\n18.3 INDIRECT BRANCH TRACKING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18-7\n18.3.1 No-track Prefix for Near Indirect CALL/JMP  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-8\n18.3.2 Terminology  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-9\n18.3.3 Indirect Branch Tracking . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-10\nVol. 1 xv\n\n\n\nCONTENTS\n\nPAGE\n18.3.3.1 Control Transfers between CPL 3 and CPL < 3  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-10\n18.3.3.2 Control Transfers within CPL 3 or CPL < 3  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-10\n18.3.4 Indirect Branch Tracking State Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-11\n18.3.5 INT3 Treatment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-12\n18.3.6 Legacy Compatibility Treatment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-12\n18.3.6.1 Legacy Code Page Bitmap Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.7 Other Considerations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.7.1 Intel® Transactional Synchronization Extensions (Intel® TSX) Interactions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.7.2 #CP(ENDBRANCH) Priority w.r.t #NM and #UD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.7.3 #CP(ENDBRANCH) Priority w.r.t #BP and #DB . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-13\n18.3.8 Constraining Speculation after Missing ENDBRANCH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-14\n18.4 INTEL® TRUSTED EXECUTION TECHNOLOGY (INTEL® TXT) INTERACTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  18-14\n\nCHAPTER 19\nINPUT/OUTPUT\n19.1 I/O PORT ADDRESSING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-1\n19.2 I/O PORT HARDWARE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-1\n19.3 I/O ADDRESS SPACE . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-1\n19.3.1 Memory-Mapped I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-2\n19.4 I/O INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-3\n19.5 PROTECTED-MODE I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-3\n19.5.1 I/O Privilege Level  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-3\n19.5.2 I/O Permission Bit Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-4\n19.6 ORDERING I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  19-5\n\nCHAPTER 20 \nPROCESSOR IDENTIFICATION AND FEATURE DETERMINATION\n20.1 USING THE CPUID INSTRUCTION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  20-1\n20.1.1 Notes on Where to Start . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20-1\n20.1.2 Identification of Earlier IA-32 Processors. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 20-1\n\nAPPENDIX A\nEFLAGS CROSS-REFERENCE\nA.1 EFLAGS AND INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  A-1\n\nAPPENDIX B\nEFLAGS CONDITION CODES\nB.1 CONDITION CODES . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  B-1\n\nAPPENDIX C\nFLOATING-POINT EXCEPTIONS SUMMARY\nC.1 OVERVIEW . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-1\nC.2 X87 FPU INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-1\nC.3 SSE INSTRUCTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-3\nC.4 SSE2 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-5\nC.5 SSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-7\nC.6 SSSE3 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-7\nC.7 SSE4 INSTRUCTIONS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  C-7\n\nAPPENDIX D\nGUIDELINES FOR WRITING SIMD FLOATING-POINT EXCEPTION HANDLERS\nD.1 TWO OPTIONS FOR HANDLING FLOATING-POINT EXCEPTIONS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-1\nD.2 SOFTWARE EXCEPTION HANDLING . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-1\nD.3 EXCEPTION SYNCHRONIZATION . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-3\nD.4 SIMD FLOATING-POINT EXCEPTIONS AND THE IEEE STANDARD 754  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  D-3\nD.4.1 Floating-Point Emulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-3\nD.4.2 SSE/SSE2/SSE3 Response To Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-4\nD.4.2.1 Numeric Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-5\nxvi Vol. 1\n\n\n\nCONTENTS\n\nPAGE\nD.4.2.2 Results of Operations with NaN Operands or a NaN Result for SSE/SSE2/SSE3 Numeric Instructions. . . . . . . . . . . . . .D-5\nD.4.2.3 Condition Codes, Exception Flags, and Response for Masked and Unmasked Numeric Exceptions. . . . . . . . . . . . . . . . . .D-9\nD.4.3 Example SIMD Floating-Point Emulation Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-15\nVol. 1 xvii\n\n\n\nCONTENTS\n\nPAGE\nFIGURES\n\nFigure 1-1. Bit and Byte Order. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-6\nFigure 1-2. Syntax for CPUID, CR, and MSR Data Presentation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1-8\nFigure 2-1. The P6 Processor Microarchitecture with Advanced Transfer Cache Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-7\nFigure 2-2. The Intel NetBurst Microarchitecture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-9\nFigure 2-3. The Intel Core Microarchitecture Pipeline Functionality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-11\nFigure 2-4. SIMD Extensions, Register Layouts, and Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-16\nFigure 2-5. Comparison of an IA-32 Processor Supporting Hyper-Threading Technology and a Traditional Dual Processor \n\nSystem  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-17\nFigure 2-6. Intel 64 and IA-32 Processors that Support Dual-Core . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-18\nFigure 2-7. Intel 64 Processors that Support Quad-Core  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-19\nFigure 2-8. Intel Core i7 Processor . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-19\nFigure 3-1. IA-32 Basic Execution Environment for Non-64-bit Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-3\nFigure 3-2. 64-Bit Mode Execution Environment. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-6\nFigure 3-3. Three Memory Management Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-8\nFigure 3-4. General System and Application Programming Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-11\nFigure 3-5. Alternate General-Purpose Register Names . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-12\nFigure 3-6. Use of Segment Registers for Flat Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-14\nFigure 3-7. Use of Segment Registers in Segmented Memory Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-14\nFigure 3-8. EFLAGS Register  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-16\nFigure 3-9. Memory Operand Address. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\nFigure 3-10. Memory Operand Address in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-21\nFigure 3-11. Offset (or Effective Address) Computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-23\nFigure 4-1. Fundamental Data Types. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-1\nFigure 4-2. Bytes, Words, Doublewords, Quadwords, and Double Quadwords in Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-2\nFigure 4-3. Numeric Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-3\nFigure 4-4. Pointer Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-6\nFigure 4-5. Pointers in 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\nFigure 4-6. Bit Field Data Type  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-7\nFigure 4-7. 64-Bit Packed SIMD Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-8\nFigure 4-8. 128-Bit Packed SIMD Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-9\nFigure 4-9. BCD Data Types . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10\nFigure 4-10. Binary Real Number System. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-12\nFigure 4-11. Binary Floating-Point Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-12\nFigure 4-12. Real Numbers and NaNs  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-14\nFigure 6-1. Stack Structure. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-2\nFigure 6-2. Stack on Near and Far Calls  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-6\nFigure 6-3. Shadow Stack on Near and Far Calls . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-6\nFigure 6-4. Protection Rings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-8\nFigure 6-5. Stack Switch on a Call to a Different Privilege Level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-9\nFigure 6-6. Shadow Stack Switch on a Call to a Different Privilege Level . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-10\nFigure 6-7. Stack Usage on Transfers to Interrupt and Exception Handling Routines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-15\nFigure 6-8. Shadow Stack Usage on Transfers to Interrupt and Exception Handling Routines  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-16\nFigure 6-9. Nested Procedures . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-21\nFigure 6-10. Stack Frame After Entering the MAIN Procedure . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-22\nFigure 6-11. Stack Frame After Entering Procedure A. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-22\nFigure 6-12. Stack Frame After Entering Procedure B . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-23\nFigure 6-13. Stack Frame After Entering Procedure C . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-24\nFigure 7-1. Operation of the PUSH Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-5\nFigure 7-2. Operation of the PUSHA Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-6\nFigure 7-3. Operation of the POP Instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-6\nFigure 7-4. Operation of the POPA Instruction. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-7\nFigure 7-5. Sign Extension  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-7\nFigure 7-6. SHL/SAL Instruction Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-11\nFigure 7-7. SHR Instruction Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-11\nFigure 7-8. SAR Instruction Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-12\nFigure 7-9. SHLD and SHRD Instruction Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-12\nFigure 7-10. ROL, ROR, RCL, and RCR Instruction Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-13\nxviii Vol. 1\n\n\n\nCONTENTS\n\nPAGE\nFigure 7-11. Flags Affected by the PUSHF, POPF, PUSHFD, and POPFD Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-21\nFigure 8-1. x87 FPU Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-2\nFigure 8-2. x87 FPU Data Register Stack  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-2\nFigure 8-3. Example x87 FPU Dot Product Computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-3\nFigure 8-4. x87 FPU Status Word. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-4\nFigure 8-5. Moving the Condition Codes to the EFLAGS Register  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-6\nFigure 8-6. x87 FPU Control Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-7\nFigure 8-7. x87 FPU Tag Word . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\nFigure 8-8. Contents of x87 FPU Opcode Registers. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-11\nFigure 8-9. Protected Mode x87 FPU State Image in Memory, 32-Bit Format  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-11\nFigure 8-10. Real Mode x87 FPU State Image in Memory, 32-Bit Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12\nFigure 8-11. Protected Mode x87 FPU State Image in Memory, 16-Bit Format  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12\nFigure 8-12. Real Mode x87 FPU State Image in Memory, 16-Bit Format . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-12\nFigure 8-13. x87 FPU Data Type Formats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-13\nFigure 9-1. MMX Technology Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-2\nFigure 9-2. MMX Register Set . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-3\nFigure 9-3. Data Types Introduced with the MMX Technology. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-3\nFigure 9-4. SIMD Execution Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-4\nFigure 10-1. SSE Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-2\nFigure 10-2. XMM Registers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-3\nFigure 10-3. MXCSR Control/Status Register . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-4\nFigure 10-4. 128-Bit Packed Single-Precision Floating-Point Data Type . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-6\nFigure 10-5. Packed Single-Precision Floating-Point Operation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-7\nFigure 10-6. Scalar Single-Precision Floating-Point Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-7\nFigure 10-7. SHUFPS Instruction, Packed Shuffle Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10-10\nFigure 10-8. UNPCKHPS Instruction, High Unpack and Interleave Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10-10\nFigure 10-9. UNPCKLPS Instruction, Low Unpack and Interleave Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .10-10\nFigure 11-1. Steaming SIMD Extensions 2 Execution Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-2\nFigure 11-2. Data Types Introduced with the SSE2 Extensions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-4\nFigure 11-3. Packed Double-Precision Floating-Point Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-5\nFigure 11-4. Scalar Double-Precision Floating-Point Operations. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-5\nFigure 11-5. SHUFPD Instruction, Packed Shuffle Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-8\nFigure 11-6. UNPCKHPD Instruction, High Unpack and Interleave Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-8\nFigure 11-7. UNPCKLPD Instruction, Low Unpack and Interleave Operation  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-8\nFigure 11-8. SSE and SSE2 Conversion Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-9\nFigure 11-9. Example Masked Response for Packed Operations  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .11-17\nFigure 12-1. Asymmetric Processing in ADDSUBPD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-2\nFigure 12-2. Horizontal Data Movement in HADDPD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-2\nFigure 12-3. Horizontal Data Movement in PHADDD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-7\nFigure 12-4. MPSADBW Operation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .12-16\nFigure 12-5. AES State Flow. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .12-19\nFigure 14-1. 256-Bit Wide SIMD Register. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-2\nFigure 14-2. General Procedural Flow of Application Detection of AVX. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .14-15\nFigure 14-3. General Procedural Flow of Application Detection of Float-16. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .14-20\nFigure 15-1. 512-Bit Wide Vectors and SIMD Register Set. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-2\nFigure 15-2. Procedural Flow for Application Detection of AVX-512 Foundation Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-4\nFigure 15-3. Procedural Flow for Application Detection of 512-bit Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-5\nFigure 15-4. Procedural Flow for Application Detection of 512-bit Instruction Groups  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-6\nFigure 15-5. Procedural Flow for Detection of Intel AVX-512 Instructions Operating at Vector Lengths < 512. . . . . . . . . . . . . . . 15-7\nFigure 17-1. Layout of the Bounds Registers BND0-BND3  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-3\nFigure 17-2. Common Layout of the Bound Configuration Registers BNDCFGU and BNDCFGS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-3\nFigure 17-3. Layout of the Bound Status Registers BNDSTATUS . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-4\nFigure 17-4. Bound Paging Structure and Address Translation in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-7\nFigure 17-5. Bound Paging Structure and Address Translation Outside 64-Bit Mode . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-9\nFigure 18-1. Supervisor Shadow Stack with a Supervisor Shadow Stack Token. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-4\nFigure 18-2. RSTORSSP to Switch to New Shadow Stack. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-6\nFigure 18-3. SAVEPREVSSP to Save a Restore Point. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-6\nFigure 18-4. Priority of Control Protection Exception on Missing ENDBRANCH. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-8\nFigure 19-1. Memory-Mapped I/O . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-2\nVol. 1 xix\n\n\n\nCONTENTS\n\nPAGE\nFigure 19-2. I/O Permission Bit Map . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-4\nFigure D-1. Control Flow for Handling Unmasked Floating-Point Exceptions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-4\nxx Vol. 1\n\n\n\nCONTENTS\n\nPAGE\nTABLES\n\nTable 2-1. Key Features of Most Recent IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21\nTable 2-2. Key Features of Most Recent Intel 64 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-21\nTable 2-3. Key Features of Previous Generations of IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-27\nTable 2-4. Proposed Intel ISA and Features Removal List  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-28\nTable 2-5. Intel ISA and Features Removal List . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2-28\nTable 3-1. Instruction Pointer Sizes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-10\nTable 3-2. Addressable General Purpose Registers  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-13\nTable 3-3. Effective Operand- and Address-Size Attributes  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19\nTable 3-4. Effective Operand- and Address-Size Attributes in 64-Bit Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-19\nTable 3-5. Default Segment Selection Rules . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3-22\nTable 4-1. Signed Integer Encodings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-4\nTable 4-2. Length, Precision, and Range of Floating-Point Data Types  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\nTable 4-3. Floating-Point Number and NaN Encodings. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-5\nTable 4-4. Packed Decimal Integer Encodings  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-10\nTable 4-5. Real and Floating-Point Number Notation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-12\nTable 4-6. Denormalization Process. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-15\nTable 4-7. Rules for Handling NaNs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-16\nTable 4-8. Rounding Modes and Encoding of Rounding Control (RC) Field . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-18\nTable 4-9. Numeric Overflow Thresholds. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\nTable 4-10. Masked Responses to Numeric Overflow  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-21\nTable 4-11. Numeric Underflow (Normalized) Thresholds . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4-22\nTable 5-1. Instruction Groups in Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-1\nTable 5-2. Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 5-2\nTable 5-3. Supervisor and User Mode Enclave Instruction Leaf Functions in Long-Form of SGX1  . . . . . . . . . . . . . . . . . . . . . . . . . . 5-37\nTable 6-1. Exceptions and Interrupts. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 6-13\nTable 7-1. Move Instruction Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-3\nTable 7-2. Conditional Move Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-4\nTable 7-3. Bit Test and Modify Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-14\nTable 7-4. Conditional Jump Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7-16\nTable 8-1. Condition Code Interpretation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-5\nTable 8-2. Precision Control Field (PC). . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-8\nTable 8-3. Unsupported Double Extended-Precision Floating-Point Encodings and Pseudo-Denormals . . . . . . . . . . . . . . . . . . . . . 8-14\nTable 8-4. Data Transfer Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-16\nTable 8-5. Floating-Point Conditional Move Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-16\nTable 8-6. Setting of x87 FPU Condition Code Flags for Floating-Point Number Comparisons. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-19\nTable 8-7. Setting of EFLAGS Status Flags for Floating-Point Number Comparisons. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-19\nTable 8-8. TEST Instruction Constants for Conditional Branching . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-20\nTable 8-9. Arithmetic and Non-arithmetic Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-25\nTable 8-10. Invalid Arithmetic Operations and the Masked Responses to Them  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-27\nTable 8-11. Divide-By-Zero Conditions and the Masked Responses to Them . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 8-28\nTable 9-1. Data Range Limits for Saturation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-5\nTable 9-2. MMX Instruction Set Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-6\nTable 9-3. Effect of Prefixes on MMX Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 9-11\nTable 10-1. PREFETCHh Instructions Caching Hints  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-13\nTable 10-2. Format of an FXSAVE Area  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10-15\nTable 11-1. Masked Responses of SSE/SSE2/SSE3 Instructions to Invalid Arithmetic Operations . . . . . . . . . . . . . . . . . . . . . . . . . . 11-14\nTable 11-2. SSE and SSE2 State Following a Power-up/Reset or INIT  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-20\nTable 11-3. Effect of Prefixes on SSE, SSE2, and SSE3 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11-26\nTable 12-1. SIMD numeric exceptions signaled by SSE4.1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-10\nTable 12-2. Enhanced 32-bit SIMD Multiply Supported by SSE4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-11\nTable 12-3. Blend Field Size and Control Modes Supported by SSE4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\nTable 12-4. Enhanced SIMD Integer MIN/MAX Instructions Supported by SSE4.1. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-14\nTable 12-5. New SIMD Integer conversions supported by SSE4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-15\nTable 12-6. New SIMD Integer Conversions Supported by SSE4.1 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-16\nTable 12-7. Enhanced SIMD Pack support by SSE4.1  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-17\nTable 12-8. Byte and 32-bit Word Representation of a 128-bit State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-20\nTable 12-9. Matrix Representation of a 128-bit State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-20\nVol. 1 xxi\n\n\n\nCONTENTS\n\nPAGE\nTable 12-10. Little Endian Representation of a 128-bit State . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-21\nTable 12-11. Little Endian Representation of a 4x4 Byte Matrix  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-21\nTable 12-12. The ShiftRows Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-22\nTable 12-13. Look-up Table Associated with S-Box Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-22\nTable 12-14. The InvShiftRows Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-23\nTable 12-15. Look-up Table Associated with InvS-Box Transformation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 12-24\nTable 13-1. Format of the Legacy Region of an XSAVE Area. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13-7\nTable 14-1. Promoted SSE/SSE2/SSE3/SSSE3/SSE4 Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-3\nTable 14-2. Promoted 256-Bit and 128-bit Arithmetic AVX Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-9\nTable 14-3. Promoted 256-bit and 128-bit Data Movement AVX Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-9\nTable 14-4. 256-bit AVX Instruction Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-10\nTable 14-5. Promotion of Legacy SIMD ISA to 128-bit Arithmetic AVX instruction  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-11\nTable 14-6. 128-bit AVX Instruction Enhancement . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-13\nTable 14-7. Promotion of Legacy SIMD ISA to 128-bit Non-Arithmetic AVX instruction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-14\nTable 14-8. Immediate Byte Encoding for 16-bit Floating-Point Conversion Instructions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-18\nTable 14-9. Non-Numerical Behavior for VCVTPH2PS, VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-18\nTable 14-10. Invalid Operation for VCVTPH2PS, VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-18\nTable 14-12. Underflow Condition for VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19\nTable 14-13. Overflow Condition for VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19\nTable 14-14. Inexact Condition for VCVTPS2PH . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19\nTable 14-11. Denormal Condition Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-19\nTable 14-15. FMA Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-21\nTable 14-16. Rounding Behavior of Zero Result in FMA Operation. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-23\nTable 14-17. FMA Numeric Behavior. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-23\nTable 14-18. Promoted Vector Integer SIMD Instructions in AVX2. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-26\nTable 14-19.  VEX-Only SIMD Instructions in AVX and AVX2 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-29\nTable 14-20. New Primitive in AVX2 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-30\nTable 14-21. Alignment Faulting Conditions when Memory Access is Not Aligned . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-33\nTable 14-22. Instructions Requiring Explicitly Aligned Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-33\nTable 14-23. Instructions Not Requiring Explicit Memory Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 14-34\nTable 15-1. 512-bit Instruction Groups in the Intel AVX-512 Family. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-6\nTable 15-2. Feature flag Collection Required of 256/128 Bit Vector Lengths for Each Instruction Group . . . . . . . . . . . . . . . . . . . . 15-7\nTable 15-3. Instruction Mnemonics That Do Not Support EVEX.128 Encoding . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-8\nTable 15-4. Characteristics of Three Rounding Control Interfaces . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-12\nTable 15-5. Static Rounding Mode. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-12\nTable 15-6.  SIMD Instructions Requiring Explicitly Aligned Memory . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-14\nTable 15-7. Instructions Not Requiring Explicit Memory Alignment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15-14\nTable 16-1. RTM Abort Status Definition  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 16-5\nTable 17-1.  Error Code Definition of BNDSTATUS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-4\nTable 17-2.  Intel MPX Instruction Summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-5\nTable 17-3.  Effective Address Size of Intel MPX Instructions with 67H Prefix . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-10\nTable 17-4.  Bounds Register INIT Behavior Due to BND Prefix with Branch Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 17-11\nTable 18-1. Indirect Branch Tracking State Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18-11\nTable 19-1. I/O Instruction Serialization. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 19-6\nTable A-1. Codes Describing Flags . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .A-1\nTable A-2. EFLAGS Cross-Reference. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .A-1\nTable B-1. EFLAGS Condition Codes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .B-1\nTable C-1. x87 FPU and SIMD Floating-Point Exceptions. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-1\nTable C-2. Exceptions Generated with x87 FPU Floating-Point Instructions  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-1\nTable C-3. Exceptions Generated with SSE Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-3\nTable C-4. Exceptions Generated with SSE2 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-5\nTable C-5. Exceptions Generated with SSE3 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-7\nTable C-6. Exceptions Generated with SSE4 Instructions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .C-8\nTable D-1. ADDPS, ADDSS, SUBPS, SUBSS, MULPS, MULSS, DIVPS, DIVSS, ADDPD, ADDSD, SUBPD, SUBSD, MULPD, MULSD, \n\nDIVPD, DIVSD, ADDSUBPS, ADDSUBPD, HADDPS, HADDPD, HSUBPS, HSUBPD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-5\nTable D-2. CMPPS.EQ, CMPSS.EQ, CMPPS.ORD, CMPSS.ORD, CMPPD.EQ, CMPSD.EQ, CMPPD.ORD, CMPSD.ORD  . . . . . . . . . . . . . . . . .D-6\nTable D-3. CMPPS.NEQ, CMPSS.NEQ, CMPPS.UNORD, CMPSS.UNORD, CMPPD.NEQ, CMPSD.NEQ, CMPPD.UNORD, CMPSD.\n\nUNORD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-6\nTable D-4. CMPPS.LT, CMPSS.LT, CMPPS.LE, CMPSS.LE, CMPPD.LT, CMPSD.LT, CMPPD.LE, CMPSD.LE . . . . . . . . . . . . . . . . . . . . . . . . . .D-6\nxxii Vol. 1\n\n\n\nCONTENTS\n\nPAGE\nTable D-5. CMPPS.NLT, CMPSS.NLT, CMPPS.NLE, CMPSS.NLE, CMPPD.NLT, CMPSD.NLT, CMPPD.NLE, CMPSD.NLE . . . . . . . . . . . . . .D-7\nTable D-6. COMISS, COMISD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-7\nTable D-7. UCOMISS, UCOMISD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-7\nTable D-8. CVTPS2PI, CVTSS2SI, CVTTPS2PI, CVTTSS2SI, CVTPD2PI, CVTSD2SI, CVTTPD2PI, CVTTSD2SI, CVTPS2DQ, \n\nCVTTPS2DQ, CVTPD2DQ, CVTTPD2DQ . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-7\nTable D-9. MAXPS, MAXSS, MINPS, MINSS, MAXPD, MAXSD, MINPD, MINSD . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-8\nTable D-10. SQRTPS, SQRTSS, SQRTPD, SQRTSD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-8\nTable D-11. CVTPS2PD, CVTSS2SD. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-8\nTable D-12. CVTPD2PS, CVTSD2SS. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-8\nTable D-13. #I - Invalid Operations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .D-9\nTable D-14. #Z - Divide-by-Zero. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-11\nTable D-15. #D - Denormal Operand . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-12\nTable D-16. #O - Numeric Overflow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-13\nTable D-17. #U - Numeric Underflow . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-14\nTable D-18. #P - Inexact Result (Precision)  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . D-15\nVol. 1 xxiii\n\n\n\nCONTENTS\n\nPAGE\nxxiv Vol. 1\n\n\n\nCHAPTER 1\nABOUT THIS MANUAL\n\nThe Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1: Basic Architecture (order number \n253665) is part of a set that describes the architecture and programming environment of Intel® 64 and IA-32 \narchitecture processors. Other volumes in this set are:\n• The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 2A, 2B, 2C & 2D: Instruction Set \n\nReference (order numbers 253666, 253667, 326018 and 334569).\n• The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 3A, 3B, 3C & 3D: System \n\nProgramming Guide (order numbers 253668, 253669, 326019 and 332831).\n• The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 4: Model-Specific Registers \n\n(order number 335592).\n\nThe Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 1, describes the basic architecture \nand programming environment of Intel 64 and IA-32 processors. The Intel® 64 and IA-32 Architectures Software \nDeveloper’s Manual, Volumes 2A, 2B, 2C & 2D, describe the instruction set of the processor and the opcode struc-\nture. These volumes apply to application programmers and to programmers who write operating systems or exec-\nutives. The Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 3A, 3B, 3C & 3D, describe \nthe operating-system support environment of Intel 64 and IA-32 processors. These volumes target operating-\nsystem and BIOS designers. In addition, the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 3B, addresses the programming environment for classes of software that host operating systems. The \nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 4, describes the model-specific registers \nof Intel 64 and IA-32 processors.\n\n1.1 INTEL® 64 AND IA-32 PROCESSORS COVERED IN THIS MANUAL\nThis manual set includes information pertaining primarily to the most recent Intel 64 and IA-32 processors, which \ninclude: \n• Pentium® processors\n• P6 family processors\n• Pentium® 4 processors\n• Pentium® M processors\n• Intel® Xeon® processors\n• Pentium® D processors\n• Pentium® processor Extreme Editions\n• 64-bit Intel® Xeon® processors\n• Intel® Core™ Duo processor\n• Intel® Core™ Solo processor\n• Dual-Core Intel® Xeon® processor LV\n• Intel® Core™2 Duo processor\n• Intel® Core™2 Quad processor Q6000 series\n• Intel® Xeon® processor 3000, 3200 series\n• Intel® Xeon® processor 5000 series\n• Intel® Xeon® processor 5100, 5300 series\n• Intel® Core™2 Extreme processor X7000 and X6800 series\n• Intel® Core™2 Extreme processor QX6000 series\n• Intel® Xeon® processor 7100 series\nVol. 1 1-1\n\n\n\nABOUT THIS MANUAL\n• Intel® Pentium® Dual-Core processor\n• Intel® Xeon® processor 7200, 7300 series\n• Intel® Xeon® processor 5200, 5400, 7400 series\n• Intel® Core™2 Extreme processor QX9000 and X9000 series\n• Intel® Core™2 Quad processor Q9000 series\n• Intel® Core™2 Duo processor E8000, T9000 series\n• Intel® Atom™ processor family\n• Intel® Atom™ processors 200, 300, D400, D500, D2000, N200, N400, N2000, E2000, Z500, Z600, Z2000, \n\nC1000 series are built from 45 nm and 32 nm processes\n• Intel® Core™ i7 processor\n• Intel® Core™ i5 processor\n• Intel® Xeon® processor E7-8800/4800/2800 product families \n• Intel® Core™ i7-3930K processor\n• 2nd generation Intel® Core™ i7-2xxx, Intel® Core™ i5-2xxx, Intel® Core™ i3-2xxx processor series\n• Intel® Xeon® processor E3-1200 product family\n• Intel® Xeon® processor E5-2400/1400 product family\n• Intel® Xeon® processor E5-4600/2600/1600 product family\n• 3rd generation Intel® Core™ processors\n• Intel® Xeon® processor E3-1200 v2 product family\n• Intel® Xeon® processor E5-2400/1400 v2 product families\n• Intel® Xeon® processor E5-4600/2600/1600 v2 product families\n• Intel® Xeon® processor E7-8800/4800/2800 v2 product families\n• 4th generation Intel® Core™ processors\n• The Intel® Core™ M processor family \n• Intel® Core™ i7-59xx Processor Extreme Edition\n• Intel® Core™ i7-49xx Processor Extreme Edition\n• Intel® Xeon® processor E3-1200 v3 product family\n• Intel® Xeon® processor E5-2600/1600 v3 product families\n• 5th generation Intel® Core™ processors\n• Intel® Xeon® processor D-1500 product family\n• Intel® Xeon® processor E5 v4 family\n• Intel® Atom™ processor X7-Z8000 and X5-Z8000 series\n• Intel® Atom™ processor Z3400 series\n• Intel® Atom™ processor Z3500 series\n• 6th generation Intel® Core™ processors\n• Intel® Xeon® processor E3-1500m v5 product family\n• 7th generation Intel® Core™ processors\n• Intel® Xeon Phi™ Processor 3200, 5200, 7200 Series \n• Intel® Xeon® Processor Scalable Family \n• 8th generation Intel® Core™ processors\n• Intel® Xeon Phi™ Processor 7215, 7285, 7295 Series\n• Intel® Xeon® E processors\n• 9th generation Intel® Core™ processors\n• 2nd generation Intel® Xeon® Processor Scalable Family \n1-2 Vol. 1\n\n\n\nABOUT THIS MANUAL\n• 10th generation Intel® Core™ processors\n• 11th generation Intel® Core™ processors\n• 3rd generation Intel® Xeon® Processor Scalable Family\n\nP6 family processors are IA-32 processors based on the P6 family microarchitecture. This includes the Pentium® \nPro, Pentium® II, Pentium® III, and Pentium® III Xeon® processors.\n\nThe Pentium® 4, Pentium® D, and Pentium® processor Extreme Editions are based on the Intel NetBurst® micro-\narchitecture. Most early Intel® Xeon® processors are based on the Intel NetBurst® microarchitecture. Intel Xeon \nprocessor 5000, 7100 series are based on the Intel NetBurst® microarchitecture.\n\nThe Intel® Core™ Duo, Intel® Core™ Solo and dual-core Intel® Xeon® processor LV are based on an improved \nPentium® M processor microarchitecture. \n\nThe Intel® Xeon® processor 3000, 3200, 5100, 5300, 7200, and 7300 series, Intel® Pentium® dual-core, Intel® \nCore™2 Duo, Intel® Core™2 Quad, and Intel® Core™2 Extreme processors are based on Intel® Core™ microarchi-\ntecture.\n\nThe Intel® Xeon® processor 5200, 5400, 7400 series, Intel® Core™2 Quad processor Q9000 series, and Intel® \nCore™2 Extreme processors QX9000, X9000 series, Intel® Core™2 processor E8000 series are based on Enhanced \nIntel® Core™ microarchitecture.\n\nThe Intel® Atom™ processors 200, 300, D400, D500, D2000, N200, N400, N2000, E2000, Z500, Z600, Z2000, \nC1000 series are based on the Intel® Atom™ microarchitecture and supports Intel 64 architecture.\n\nP6 family, Pentium® M, Intel® Core™ Solo, Intel® Core™ Duo processors, dual-core Intel® Xeon® processor LV, \nand early generations of Pentium 4 and Intel Xeon processors support IA-32 architecture. The Intel® AtomTM \nprocessor Z5xx series support IA-32 architecture.\n\nThe Intel® Xeon® processor 3000, 3200, 5000, 5100, 5200, 5300, 5400, 7100, 7200, 7300, 7400 series, Intel® \nCore™2 Duo, Intel® Core™2 Extreme, Intel® Core™2 Quad processors, Pentium® D processors, Pentium® Dual-\nCore processor, newer generations of Pentium 4 and Intel Xeon processor family support Intel® 64 architecture.\n\nThe Intel® Core™ i7 processor and Intel® Xeon® processor 3400, 5500, 7500 series are based on 45 nm Nehalem \nmicroarchitecture. Westmere microarchitecture is a 32 nm version of the Nehalem microarchitecture. Intel® \nXeon® processor 5600 series, Intel Xeon processor E7 and various Intel Core i7, i5, i3 processors are based on the \nWestmere microarchitecture. These processors support Intel 64 architecture.\n\nThe Intel® Xeon® processor E5 family, Intel® Xeon® processor E3-1200 family, Intel® Xeon® processor E7-\n8800/4800/2800 product families, Intel® Core™ i7-3930K processor, and 2nd generation Intel® Core™ i7-2xxx, \nIntel® CoreTM i5-2xxx, Intel® Core™ i3-2xxx processor series are based on the Sandy Bridge microarchitecture and \nsupport Intel 64 architecture.\n\nThe Intel® Xeon® processor E7-8800/4800/2800 v2 product families, Intel® Xeon® processor E3-1200 v2 product \nfamily and 3rd generation Intel® Core™ processors are based on the Ivy Bridge microarchitecture and support \nIntel 64 architecture.\n\nThe Intel® Xeon® processor E5-4600/2600/1600 v2 product families, Intel® Xeon® processor E5-2400/1400 v2 \nproduct families and Intel® Core™ i7-49xx Processor Extreme Edition are based on the Ivy Bridge-E microarchitec-\nture and support Intel 64 architecture.\n\nThe Intel® Xeon® processor E3-1200 v3 product family and 4th Generation Intel® Core™ processors are based on \nthe Haswell microarchitecture and support Intel 64 architecture.\n\nThe Intel® Xeon® processor E5-2600/1600 v3 product families and the Intel® Core™ i7-59xx Processor Extreme \nEdition are based on the Haswell-E microarchitecture and support Intel 64 architecture.\n\nThe Intel® Atom™ processor Z8000 series is based on the Airmont microarchitecture.\n\nThe Intel® Atom™ processor Z3400 series and the Intel® Atom™ processor Z3500 series are based on the Silver-\nmont microarchitecture.\n\nThe Intel® Core™ M processor family, 5th generation Intel® Core™ processors, Intel® Xeon® processor D-1500 \nproduct family and the Intel® Xeon® processor E5 v4 family are based on the Broadwell microarchitecture and \nsupport Intel 64 architecture. \n\nThe Intel® Xeon® Processor Scalable Family, Intel® Xeon® processor E3-1500m v5 product family and 6th gener-\nation Intel® Core™ processors are based on the Skylake microarchitecture and support Intel 64 architecture.\nVol. 1 1-3\n\n\n\nABOUT THIS MANUAL\nThe 7th generation Intel® Core™ processors are based on the Kaby Lake microarchitecture and support Intel 64 \narchitecture.\n\nThe Intel® Atom™ processor C series, the Intel® Atom™ processor X series, the Intel® Pentium® processor J \nseries, the Intel® Celeron® processor J series, and the Intel® Celeron® processor N series are based on the Gold-\nmont microarchitecture.\n\nThe Intel® Xeon Phi™ Processor 3200, 5200, 7200 Series is based on the Knights Landing microarchitecture and \nsupports Intel 64 architecture.\n\nThe Intel® Pentium® Silver processor series, the Intel® Celeron® processor J series, and the Intel® Celeron® \nprocessor N series are based on the Goldmont Plus microarchitecture.\n\nThe 8th generation Intel® Core™ processors, 9th generation Intel® Core™ processors, and Intel® Xeon® E proces-\nsors are based on the Coffee Lake microarchitecture and support Intel 64 architecture.\n\nThe Intel® Xeon Phi™ Processor 7215, 7285, 7295 Series is based on the Knights Mill microarchitecture and \nsupports Intel 64 architecture.\n\nThe 2nd generation Intel® Xeon® Processor Scalable Family is based on the Cascade Lake product and supports \nIntel 64 architecture.\n\nSome 10th generation Intel® Core™ processors are based on the Ice Lake microarchitecture, and some are based \non the Comet Lake microarchitecture; both support Intel 64 architecture.\n\nSome 11th generation Intel® Core™ processors are based on the Tiger Lake microarchitecture, and some are \nbased on the Rocket Lake microarchitecture; both support Intel 64 architecture.\n\nSome 3rd generation Intel® Xeon® Processor Scalable Family processors are based on the Cooper Lake product, \nand some are based on the Ice Lake microarchitecture; both support Intel 64 architecture.\n\nIA-32 architecture is the instruction set architecture and programming environment for Intel's 32-bit microproces-\nsors. Intel® 64 architecture is the instruction set architecture and programming environment which is the superset \nof Intel’s 32-bit and 64-bit architectures. It is compatible with the IA-32 architecture.\n\n1.2 OVERVIEW OF VOLUME 1: BASIC ARCHITECTURE\nA description of this manual’s content follows:\n\nChapter 1 — About This Manual. Gives an overview of all five volumes of the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual. It also describes the notational conventions in these manuals and lists related Intel \nmanuals and documentation of interest to programmers and hardware designers.\n\nChapter 2 — Intel® 64 and IA-32 Architectures. Introduces the Intel 64 and IA-32 architectures along with the \nfamilies of Intel processors that are based on these architectures. It also gives an overview of the common features \nfound in these processors and brief history of the Intel 64 and IA-32 architectures.\n\nChapter 3 — Basic Execution Environment. Introduces the models of memory organization and describes the \nregister set used by applications.\n\nChapter 4 — Data Types. Describes the data types and addressing modes recognized by the processor; provides \nan overview of real numbers and floating-point formats and of floating-point exceptions.\n\nChapter 5 — Instruction Set Summary. Lists all Intel 64 and IA-32 instructions, divided into technology groups.\n\nChapter 6 — Procedure Calls, Interrupts, and Exceptions. Describes the procedure stack and mechanisms \nprovided for making procedure calls and for servicing interrupts and exceptions.\n\nChapter 7 — Programming with General-Purpose Instructions. Describes basic load and store, program \ncontrol, arithmetic, and string instructions that operate on basic data types, general-purpose and segment regis-\nters; also describes system instructions that are executed in protected mode.\n\nChapter 8 — Programming with the x87 FPU. Describes the x87 floating-point unit (FPU), including floating-\npoint registers and data types; gives an overview of the floating-point instruction set and describes the processor's \nfloating-point exception conditions.\n\nChapter 9 — Programming with Intel® MMX™ Technology. Describes Intel MMX technology, including MMX \nregisters and data types; also provides an overview of the MMX instruction set. \n1-4 Vol. 1\n\n\n\nABOUT THIS MANUAL\nChapter 10 — Programming with Intel® Streaming SIMD Extensions (Intel® SSE). Describes SSE exten-\nsions, including XMM registers, the MXCSR register, and packed single-precision floating-point data types; provides \nan overview of the SSE instruction set and gives guidelines for writing code that accesses the SSE extensions. \n\nChapter 11 — Programming with Intel® Streaming SIMD Extensions 2 (Intel® SSE2). Describes SSE2 \nextensions, including XMM registers and packed double-precision floating-point data types; provides an overview \nof the SSE2 instruction set and gives guidelines for writing code that accesses SSE2 extensions. This chapter also \ndescribes SIMD floating-point exceptions that can be generated with SSE and SSE2 instructions. It also provides \ngeneral guidelines for incorporating support for SSE and SSE2 extensions into operating system and applications \ncode.\n\nChapter 12 — Programming with Intel® Streaming SIMD Extensions 3 (Intel® SSE3), Supplemental \nStreaming SIMD Extensions 3 (SSSE3), Intel® Streaming SIMD Extensions 4 (Intel® SSE4) and Intel® \nAES New Instructions (Intel® AES-NI). Provides an overview of the SSE3 instruction set, Supplemental SSE3, \nSSE4, AESNI instructions, and guidelines for writing code that access these extensions.\n\nChapter 13 — Managing State Using the XSAVE Feature Set. Describes the XSAVE feature set instructions \nand explains how software can enable the XSAVE feature set and XSAVE-enabled features.\n\nChapter 14 — Programming with AVX, FMA and AVX2. Provides an overview of the Intel® AVX instruction set, \nFMA and Intel AVX2 extensions and gives guidelines for writing code that access these extensions.\n\nChapter 15 — Programming with Intel® AVX-512. Provides an overview of the Intel® AVX-512 instruction set \nextensions and gives guidelines for writing code that access these extensions.\n\nChapter 16 — Programming with Intel Transactional Synchronization Extensions. Describes the instruc-\ntion extensions that support lock elision techniques to improve the performance of multi-threaded software with \ncontended locks.\n\nChapter 17 — Intel® Memory Protection Extensions. Provides an overview of the Intel® Memory Protection \nExtensions and gives guidelines for writing code that access these extensions.\n\nChapter 18 — Control-flow Enforcement Technology. Provides an overview of the Control-flow Enforcement \nTechnology (CET) and gives guidelines for writing code that access these extensions.\n\nChapter 19 — Input/Output. Describes the processor’s I/O mechanism, including I/O port addressing, I/O \ninstructions, and I/O protection mechanisms.\n\nChapter 20 — Processor Identification and Feature Determination. Describes how to determine the CPU \ntype and features available in the processor.\n\nAppendix A — EFLAGS Cross-Reference. Summarizes how the IA-32 instructions affect the flags in the EFLAGS \nregister.\n\nAppendix B — EFLAGS Condition Codes. Summarizes how conditional jump, move, and ‘byte set on condition \ncode’ instructions use condition code flags (OF, CF, ZF, SF, and PF) in the EFLAGS register.\n\nAppendix C — Floating-Point Exceptions Summary. Summarizes exceptions raised by the x87 FPU floating-\npoint and SSE/SSE2/SSE3 floating-point instructions.\n\nAppendix D — Guidelines for Writing SIMD Floating-Point Exception Handlers. Gives guidelines for writing \nexception handlers for exceptions generated by SSE/SSE2/SSE3 floating-point instructions.\n\n1.3 NOTATIONAL CONVENTIONS\nThis manual uses specific notation for data-structure formats, for symbolic representation of instructions, and for \nhexadecimal and binary numbers. This notation is described below.\n\n1.3.1 Bit and Byte Order\nIn illustrations of data structures in memory, smaller addresses appear toward the bottom of the figure; addresses \nincrease toward the top. Bit positions are numbered from right to left. The numerical value of a set bit is equal to \ntwo raised to the power of the bit position. Intel 64 and IA-32 processors are “little endian” machines; this means \nthe bytes of a word are numbered starting from the least significant byte. See Figure 1-1.\nVol. 1 1-5\n\n\n\nABOUT THIS MANUAL\n1.3.2 Reserved Bits and Software Compatibility\nIn many register and memory layout descriptions, certain bits are marked as reserved. When bits are marked as \nreserved, it is essential for compatibility with future processors that software treat these bits as having a future, \nthough unknown, effect. The behavior of reserved bits should be regarded as not only undefined, but unpredict-\nable. \n\nSoftware should follow these guidelines in dealing with reserved bits:\n• Do not depend on the states of any reserved bits when testing the values of registers that contain such bits. \n\nMask out the reserved bits before testing.\n• Do not depend on the states of any reserved bits when storing to memory or to a register.\n• Do not depend on the ability to retain information written into any reserved bits.\n• When loading a register, always load the reserved bits with the values indicated in the documentation, if any, or \n\nreload them with values previously read from the same register.\n\nNOTE\nAvoid any software dependence upon the state of reserved bits in Intel 64 and IA-32 registers. \nDepending upon the values of reserved register bits will make software dependent upon the \nunspecified manner in which the processor handles these bits. Programs that depend upon \nreserved values risk incompatibility with future processors.\n\n1.3.2.1  Instruction Operands\nWhen instructions are represented symbolically, a subset of the IA-32 assembly language is used. In this subset, \nan instruction has the following format:\n\nlabel: mnemonic argument1, argument2, argument3\n\nwhere:\n• A label is an identifier which is followed by a colon.\n• A mnemonic is a reserved name for a class of instruction opcodes which have the same function.\n• The operands argument1, argument2, and argument3 are optional. There may be from zero to three \n\noperands, depending on the opcode. When present, they take the form of either literals or identifiers for data \nitems. Operand identifiers are either reserved names of registers or are assumed to be assigned to data items \ndeclared in another part of the program (which may not be shown in the example).\n\nWhen two operands are present in an arithmetic or logical instruction, the right operand is the source and the left \noperand is the destination. \n\nFigure 1-1.  Bit and Byte Order\n\nByte 3\n\nData Structure \n\nByte 1Byte 2 Byte 0\nLowest\n\nBit offset\n\n28\n24\n20\n16\n12\n8\n4\n0\n\nAddress\n\nByte Offset\n\nHighest\nAddress 32 24 23 16 15 8 7 0\n1-6 Vol. 1\n\n\n\nABOUT THIS MANUAL\nFor example:\n\nLOADREG: MOV EAX, SUBTOTAL\n\nIn this example, LOADREG is a label, MOV is the mnemonic identifier of an opcode, EAX is the destination operand, \nand SUBTOTAL is the source operand. Some assembly languages put the source and destination in reverse order.\n\n1.3.3 Hexadecimal and Binary Numbers\nBase 16 (hexadecimal) numbers are represented by a string of hexadecimal digits followed by the character H (for \nexample, 0F82EH). A hexadecimal digit is a character from the following set: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, \nE, and F.\n\nBase 2 (binary) numbers are represented by a string of 1s and 0s, sometimes followed by the character B (for \nexample, 1010B). The “B” designation is only used in situations where confusion as to the type of number might \narise.\n\n1.3.4 Segmented Addressing\nThe processor uses byte addressing. This means memory is organized and accessed as a sequence of bytes. \nWhether one or more bytes are being accessed, a byte address is used to locate the byte or bytes memory. The \nrange of memory that can be addressed is called an address space.\n\nThe processor also supports segmented addressing. This is a form of addressing where a program may have many \nindependent address spaces, called segments. For example, a program can keep its code (instructions) and stack \nin separate segments. Code addresses would always refer to the code space, and stack addresses would always \nrefer to the stack space. The following notation is used to specify a byte address within a segment: \n\nSegment-register:Byte-address\n\nFor example, the following segment address identifies the byte at address FF79H in the segment pointed by the DS \nregister:\n\nDS:FF79H\n\nThe following segment address identifies an instruction address in the code segment. The CS register points to the \ncode segment and the EIP register contains the address of the instruction.\n\nCS:EIP\n\n1.3.5 A New Syntax for CPUID, CR, and MSR Values\nObtain feature flags, status, and system information by using the CPUID instruction, by checking control register \nbits, and by reading model-specific registers. We are moving toward a new syntax to represent this information. \nSee Figure 1-2.\nVol. 1 1-7\n\n\n\nABOUT THIS MANUAL\n1.3.6 Exceptions\nAn exception is an event that typically occurs when an instruction causes an error. For example, an attempt to \ndivide by zero generates an exception. However, some exceptions, such as breakpoints, occur under other condi-\ntions. Some types of exceptions may provide error codes. An error code reports additional information about the \nerror. An example of the notation used to show an exception and error code is shown below:\n\n#PF(fault code)\n\nThis example refers to a page-fault exception under conditions where an error code naming a type of fault is \nreported. Under some conditions, exceptions that produce error codes may not be able to report an accurate code. \nIn this case, the error code is zero, as shown below for a general-protection exception:\n\n#GP(0)\n\nFigure 1-2.  Syntax for CPUID, CR, and MSR Data Presentation\n\nInput value for EAX register\n\nOutput register and feature flag or field \nname with bit position(s)\n\nValue (or range) of output\n\nCPUID.01H:EDX.SSE[bit 25] = 1\n\nCR4.OSFXSR[bit 9] = 1\n\nIA32_MISC_ENABLE.ENABLEFOPCODE[bit 2] = 1\n\nCPUID Input and Output\n\nControl Register Values\n\nModel-Specific Register Values\n\nExample CR name\n\nFeature flag or field name \nwith bit position(s)\n\nValue (or range) of output\n\nExample MSR name\n\nFeature flag or field name with bit position(s)\n\nValue (or range) of output\n\nSDM29002\n1-8 Vol. 1\n\n\n\nABOUT THIS MANUAL\n1.4 RELATED LITERATURE\nLiterature related to Intel 64 and IA-32 processors is listed and viewable on-line at: \nhttps://software.intel.com/en-us/articles/intel-sdm\n\nSee also: \n• The latest security information on Intel® products:\n\nhttps://www.intel.com/content/www/us/en/security-center/default.html\n• Software developer resources, guidance and insights for security advisories:\n\nhttps://software.intel.com/security-software-guidance/\n• The data sheet for a particular Intel 64 or IA-32 processor\n• The specification update for a particular Intel 64 or IA-32 processor\n• Intel® C++ Compiler documentation and online help:\n\nhttp://software.intel.com/en-us/articles/intel-compilers/\n• Intel® Fortran Compiler documentation and online help:\n\nhttp://software.intel.com/en-us/articles/intel-compilers/\n• Intel® Software Development Tools:\n\nhttps://software.intel.com/en-us/intel-sdp-home\n• Intel® 64 and IA-32 Architectures Software Developer’s Manual (in one, four or ten volumes):\n\nhttps://software.intel.com/en-us/articles/intel-sdm\n• Intel® 64 and IA-32 Architectures Optimization Reference Manual: \n\nhttps://software.intel.com/en-us/articles/intel-sdm#optimization\n• Intel® Trusted Execution Technology Measured Launched Environment Programming Guide:\n\nhttp://www.intel.com/content/www/us/en/software-developers/intel-txt-software-development-guide.html\n• Intel® Software Guard Extensions (Intel® SGX) Information\n\nhttps://software.intel.com/en-us/isa-extensions/intel-sgx\n• Developing Multi-threaded Applications: A Platform Consistent Approach:\n\nhttps://software.intel.com/sites/default/files/article/147714/51534-developing-multithreaded-applica-\ntions.pdf\n\n• Using Spin-Loops on Intel® Pentium® 4 Processor and Intel® Xeon® Processor:\nhttps://software.intel.com/sites/default/files/22/30/25602\n\n• Performance Monitoring Unit Sharing Guide\nhttp://software.intel.com/file/30388\n\nLiterature related to select features in future Intel processors are available at:\n• Intel® Architecture Instruction Set Extensions Programming Reference\n\nhttps://software.intel.com/en-us/isa-extensions\n\nMore relevant links are:\n• Intel® Developer Zone:\n\nhttps://software.intel.com/en-us\n• Developer centers:\n\nhttp://www.intel.com/content/www/us/en/hardware-developers/developer-centers.html\n• Processor support general link:\n\nhttp://www.intel.com/support/processors/\n• Intel® Hyper-Threading Technology (Intel® HT Technology):\n\nhttp://www.intel.com/technology/platform-technology/hyper-threading/index.htm\nVol. 1 1-9\n\nhttp://www.intel.com/cd/software/products/asmo-na/eng/index.htm\nhttps://software.intel.com/en-us/isa-extensions/intel-sgx\nhttp://www.intel.com/cd/software/products/asmo-na/eng/index.htm\nhttp://www.intel.com/cd/software/products/asmo-na/eng/index.htm\nhttp://developer.intel.com/products/processor/manuals/index.htm\nhttp://developer.intel.com/products/processor/manuals/index.htm\nhttp://www.intel.com/content/www/us/en/processors/architectures-software-developer-manuals.html\n\nhttp://developer.intel.com/products/processor/manuals/index.htm\nhttp://www.intel.com/support/processors/sb/cs-009861.htm\nhttp://www.intel.com/content/www/us/en/software-developers/intel-txt-software-development-guide.html\nhttp://www3.intel.com/cd/ids/developer/asmo-na/eng/dc/threading/knowledgebase/19083.htm\nhttps://software.intel.com/en-us\nhttp://www.intel.com/cd/ids/developer/asmo-na/eng/dc/index.htm\nhttp://www.intel.com/content/www/us/en/hardware-developers/developer-centers.html\nhttp://www.intel.com/support/processors/\nhttp://www.intel.com/technology/platform-technology/hyper-threading/index.htm\nhttp://developer.intel.com/technology/hyperthread/\nhttps://software.intel.com/en-us\nhttps://software.intel.com/en-us/articles/resource-center/\nhttp://software.intel.com/en-us/articles/intel-compilers/\nhttp://software.intel.com/en-us/articles/intel-compilers/\nhttps://software.intel.com/en-us/isa-extensions\nhttps://software.intel.com/sites/default/files/article/147714/51534-developing-multithreaded-applications.pdf\nhttps://software.intel.com/en-us/intel-sdp-home\nhttps://software.intel.com/en-us/articles/intel-sdm\nhttps://software.intel.com/en-us/articles/intel-sdm#optimization\nhttps://www.intel.com/content/www/us/en/security-center/default.html\nhttps://software.intel.com/sites/default/files/22/30/25602\nhttps://software.intel.com/security-software-guidance/\n\n\nABOUT THIS MANUAL\n1-10 Vol. 1\n\n\n\nCHAPTER 2\nINTEL® 64 AND IA-32 ARCHITECTURES\n\n2.1 BRIEF HISTORY OF INTEL® 64 AND IA-32 ARCHITECTURE\nThe following sections provide a summary of the major technical evolutions from IA-32 to Intel 64 architecture: \nstarting from the Intel 8086 processor to the latest Intel® Core® 2 Duo, Core 2 Quad and Intel Xeon processor \n5300 and 7300 series. Object code created for processors released as early as 1978 still executes on the latest \nprocessors in the Intel 64 and IA-32 architecture families.\n\n2.1.1 16-bit Processors and Segmentation (1978)\nThe IA-32 architecture family was preceded by 16-bit processors, the 8086 and 8088. The 8086 has 16-bit regis-\nters and a 16-bit external data bus, with 20-bit addressing giving a 1-MByte address space. The 8088 is similar to \nthe 8086 except it has an 8-bit external data bus. \n\nThe 8086/8088 introduced segmentation to the IA-32 architecture. With segmentation, a 16-bit segment register \ncontains a pointer to a memory segment of up to 64 KBytes. Using four segment registers at a time, 8086/8088 \nprocessors are able to address up to 256 KBytes without switching between segments. The 20-bit addresses that \ncan be formed using a segment register and an additional 16-bit pointer provide a total address range of 1 MByte.\n\n2.1.2 The Intel® 286 Processor (1982)\nThe Intel 286 processor introduced protected mode operation into the IA-32 architecture. Protected mode uses the \nsegment register content as selectors or pointers into descriptor tables. Descriptors provide 24-bit base addresses \nwith a physical memory size of up to 16 MBytes, support for virtual memory management on a segment swapping \nbasis, and a number of protection mechanisms. These mechanisms include: \n• Segment limit checking\n• Read-only and execute-only segment options\n• Four privilege levels \n\n2.1.3 The Intel386™ Processor (1985)\nThe Intel386 processor was the first 32-bit processor in the IA-32 architecture family. It introduced 32-bit registers \nfor use both to hold operands and for addressing. The lower half of each 32-bit Intel386 register retains the prop-\nerties of the 16-bit registers of earlier generations, permitting backward compatibility. The processor also provides \na virtual-8086 mode that allows for even greater efficiency when executing programs created for 8086/8088 \nprocessors. \n\nIn addition, the Intel386 processor has support for:\n• A 32-bit address bus that supports up to 4-GBytes of physical memory\n• A segmented-memory model and a flat memory model\n• Paging, with a fixed 4-KByte page size providing a method for virtual memory management\n• Support for parallel stages\n\n2.1.4 The Intel486™ Processor (1989)\nThe Intel486™ processor added more parallel execution capability by expanding the Intel386 processor’s instruc-\ntion decode and execution units into five pipelined stages. Each stage operates in parallel with the others on up to \nfive instructions in different stages of execution. \nVol. 1 2-1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIn addition, the processor added:\n• An 8-KByte on-chip first-level cache that increased the percent of instructions that could execute at the scalar \n\nrate of one per clock\n• An integrated x87 FPU\n• Power saving and system management capabilities\n\n2.1.5 The Intel® Pentium® Processor (1993)\nThe introduction of the Intel Pentium processor added a second execution pipeline to achieve superscalar perfor-\nmance (two pipelines, known as u and v, together can execute two instructions per clock). The on-chip first-level \ncache doubled, with 8 KBytes devoted to code and another 8 KBytes devoted to data. The data cache uses the MESI \nprotocol to support more efficient write-back cache in addition to the write-through cache previously used by the \nIntel486 processor. Branch prediction with an on-chip branch table was added to increase performance in looping \nconstructs. \n\nIn addition, the processor added:\n• Extensions to make the virtual-8086 mode more efficient and allow for 4-MByte as well as 4-KByte pages\n• Internal data paths of 128 and 256 bits add speed to internal data transfers\n• Burstable external data bus was increased to 64 bits\n• An APIC to support systems with multiple processors\n• A dual processor mode to support glueless two processor systems\n\nA subsequent stepping of the Pentium family introduced Intel MMX technology (the Pentium Processor with MMX \ntechnology). Intel MMX technology uses the single-instruction, multiple-data (SIMD) execution model to perform \nparallel computations on packed integer data contained in 64-bit registers. \n\nSee Section 2.2.7, “SIMD Instructions.”\n\n2.1.6 The P6 Family of Processors (1995-1999)\nThe P6 family of processors was based on a superscalar microarchitecture that set new performance standards; see \nalso Section 2.2.1, “P6 Family Microarchitecture.” One of the goals in the design of the P6 family microarchitecture \nwas to exceed the performance of the Pentium processor significantly while using the same 0.6-micrometer, four-\nlayer, metal BICMOS manufacturing process. Members of this family include the following: \n• The Intel Pentium Pro processor is three-way superscalar. Using parallel processing techniques, the \n\nprocessor is able on average to decode, dispatch, and complete execution of (retire) three instructions per \nclock cycle. The Pentium Pro introduced the dynamic execution (micro-data flow analysis, out-of-order \nexecution, superior branch prediction, and speculative execution) in a superscalar implementation. The \nprocessor was further enhanced by its caches. It has the same two on-chip 8-KByte 1st-Level caches as the \nPentium processor and an additional 256-KByte Level 2 cache in the same package as the processor.\n\n• The Intel Pentium II processor added Intel MMX technology to the P6 family processors along with new \npackaging and several hardware enhancements. The processor core is packaged in the single edge contact \ncartridge (SECC). The Level l data and instruction caches were enlarged to 16 KBytes each, and Level 2 cache \nsizes of 256 KBytes, 512 KBytes, and 1 MByte are supported. A half-frequency backside bus connects the Level \n2 cache to the processor. Multiple low-power states such as AutoHALT, Stop-Grant, Sleep, and Deep Sleep are \nsupported to conserve power when idling.\n\n• The Pentium II Xeon processor combined the premium characteristics of previous generations of Intel \nprocessors. This includes: 4-way, 8-way (and up) scalability and a 2 MByte 2nd-Level cache running on a full-\nfrequency backside bus.\n\n• The Intel Celeron processor family focused on the value PC market segment. Its introduction offers an \nintegrated 128 KBytes of Level 2 cache and a plastic pin grid array (P.P.G.A.) form factor to lower system design \ncost.\n\n• The Intel Pentium III processor introduced the Streaming SIMD Extensions (SSE) to the IA-32 architecture. \nSSE extensions expand the SIMD execution model introduced with the Intel MMX technology by providing a \n2-2 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nnew set of 128-bit registers and the ability to perform SIMD operations on packed single-precision floating-\npoint values. See Section 2.2.7, “SIMD Instructions.”\n\n• The Pentium III Xeon processor extended the performance levels of the IA-32 processors with the \nenhancement of a full-speed, on-die, and Advanced Transfer Cache.\n\n2.1.7 The Intel® Pentium® 4 Processor Family (2000-2006) \nThe Intel Pentium 4 processor family is based on Intel NetBurst microarchitecture; see Section 2.2.2, “Intel \nNetBurst® Microarchitecture.”\n\nThe Intel Pentium 4 processor introduced Streaming SIMD Extensions 2 (SSE2); see Section 2.2.7, “SIMD Instruc-\ntions.” The Intel Pentium 4 processor 3.40 GHz, supporting Hyper-Threading Technology introduced Streaming \nSIMD Extensions 3 (SSE3); see Section 2.2.7, “SIMD Instructions.”\n\nIntel 64 architecture was introduced in the Intel Pentium 4 Processor Extreme Edition supporting Hyper-Threading \nTechnology and in the Intel Pentium 4 Processor 6xx and 5xx sequences.\n\nIntel® Virtualization Technology (Intel® VT) was introduced in the Intel Pentium 4 processor 672 and 662.\n\n2.1.8 The Intel® Xeon® Processor (2001- 2007)\nIntel Xeon processors (with exception for dual-core Intel Xeon processor LV, Intel Xeon processor 5100 series) are \nbased on the Intel NetBurst microarchitecture; see Section 2.2.2, “Intel NetBurst® Microarchitecture.” As a family, \nthis group of IA-32 processors (more recently Intel 64 processors) is designed for use in multi-processor server \nsystems and high-performance workstations. \n\nThe Intel Xeon processor MP introduced support for Intel® Hyper-Threading Technology; see Section 2.2.8, “Intel® \nHyper-Threading Technology.”\n\nThe 64-bit Intel Xeon processor 3.60 GHz (with an 800 MHz System Bus) was used to introduce Intel 64 architec-\nture. The Dual-Core Intel Xeon processor includes dual core technology. The Intel Xeon processor 70xx series \nincludes Intel Virtualization Technology.\n\nThe Intel Xeon processor 5100 series introduces power-efficient, high performance Intel Core microarchitecture. \nThis processor is based on Intel 64 architecture; it includes Intel Virtualization Technology and dual-core tech-\nnology. The Intel Xeon processor 3000 series are also based on Intel Core microarchitecture. The Intel Xeon \nprocessor 5300 series introduces four processor cores in a physical package, they are also based on Intel Core \nmicroarchitecture. \n\n2.1.9 The Intel® Pentium® M Processor (2003-2006)\nThe Intel Pentium M processor family is a high performance, low power mobile processor family with microarchitec-\ntural enhancements over previous generations of IA-32 Intel mobile processors. This family is designed for \nextending battery life and seamless integration with platform innovations that enable new usage models (such as \nextended mobility, ultra thin form-factors, and integrated wireless networking).\n\nIts enhanced microarchitecture includes:\n• Support for Intel Architecture with Dynamic Execution\n• A high performance, low-power core manufactured using Intel’s advanced process technology with copper \n\ninterconnect\n• On-die, primary 32-KByte instruction cache and 32-KByte write-back data cache\n• On-die, second-level cache (up to 2 MByte) with Advanced Transfer Cache Architecture\n• Advanced Branch Prediction and Data Prefetch Logic\n• Support for MMX technology, Streaming SIMD instructions, and the SSE2 instruction set\n• A 400 or 533 MHz, Source-Synchronous Processor System Bus\n• Advanced power management using Enhanced Intel SpeedStep® technology\nVol. 1 2-3\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.1.10 The Intel® Pentium® Processor Extreme Edition (2005) \nThe Intel Pentium processor Extreme Edition introduced dual-core technology. This technology provides advanced \nhardware multi-threading support. The processor is based on Intel NetBurst microarchitecture and supports SSE, \nSSE2, SSE3, Hyper-Threading Technology, and Intel 64 architecture.\n\nSee also:\n• Section 2.2.2, “Intel NetBurst® Microarchitecture”\n• Section 2.2.3, “Intel® Core™ Microarchitecture”\n• Section 2.2.7, “SIMD Instructions”\n• Section 2.2.8, “Intel® Hyper-Threading Technology”\n• Section 2.2.9, “Multi-Core Technology”\n• Section 2.2.10, “Intel® 64 Architecture”\n\n2.1.11 The Intel® Core™ Duo and Intel® Core™ Solo Processors (2006-2007)\nThe Intel Core Duo processor offers power-efficient, dual-core performance with a low-power design that extends \nbattery life. This family and the single-core Intel Core Solo processor offer microarchitectural enhancements over \nPentium M processor family.\n\nIts enhanced microarchitecture includes:\n• Intel® Smart Cache which allows for efficient data sharing between two processor cores\n• Improved decoding and SIMD execution\n• Intel® Dynamic Power Coordination and Enhanced Intel® Deeper Sleep to reduce power consumption\n• Intel® Advanced Thermal Manager which features digital thermal sensor interfaces\n• Support for power-optimized 667 MHz bus\n\nThe dual-core Intel Xeon processor LV is based on the same microarchitecture as Intel Core Duo processor, and \nsupports IA-32 architecture.\n\n2.1.12 The Intel® Xeon® Processor 5100, 5300 Series and Intel® Core™2 Processor Family \n(2006)\n\nThe Intel Xeon processor 3000, 3200, 5100, 5300, and 7300 series, Intel Pentium Dual-Core, Intel Core 2 Extreme, \nIntel Core 2 Quad processors, and Intel Core 2 Duo processor family support Intel 64 architecture; they are based \non the high-performance, power-efficient Intel® Core microarchitecture built on 65 nm process technology. The \nIntel Core microarchitecture includes the following innovative features:\n• Intel® Wide Dynamic Execution to increase performance and execution throughput\n• Intel® Intelligent Power Capability to reduce power consumption\n• Intel® Advanced Smart Cache which allows for efficient data sharing between two processor cores\n• Intel® Smart Memory Access to increase data bandwidth and hide latency of memory accesses\n• Intel® Advanced Digital Media Boost which improves application performance using multiple generations of \n\nStreaming SIMD extensions \n\nThe Intel Xeon processor 5300 series, Intel Core 2 Extreme processor QX6800 series, and Intel Core 2 Quad \nprocessors support Intel quad-core technology.\n\n2.1.13 The Intel® Xeon® Processor 5200, 5400, 7400 Series and Intel® Core™2 Processor \nFamily (2007)\n\nThe Intel Xeon processor 5200, 5400, and 7400 series, Intel Core 2 Quad processor Q9000 Series, Intel Core 2 Duo \nprocessor E8000 series support Intel 64 architecture; they are based on the Enhanced Intel® Core microarchitec-\n2-4 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nture using 45 nm process technology. The Enhanced Intel Core microarchitecture provides the following improved \nfeatures:\n• A radix-16 divider, faster OS primitives further increases the performance of Intel® Wide Dynamic Execution. \n• Improves Intel® Advanced Smart Cache with Up to 50% larger level-two cache and up to 50% increase in way-\n\nset associativity. \n• A 128-bit shuffler engine significantly improves the performance of Intel® Advanced Digital Media Boost and \n\nSSE4.\n\nIntel Xeon processor 5400 series and Intel Core 2 Quad processor Q9000 Series support Intel quad-core tech-\nnology. Intel Xeon processor 7400 series offers up to six processor cores and an L3 cache up to 16 MBytes.\n\n2.1.14 The Intel® Atom™ Processor Family (2008)\nThe first generation of Intel® AtomTM processors are built on 45 nm process technology. They are based on a new \nmicroarchitecture, Intel® AtomTM microarchitecture, which is optimized for ultra low power devices. The Intel® \nAtomTM microarchitecture features two in-order execution pipelines that minimize power consumption, increase \nbattery life, and enable ultra-small form factors. The initial Intel Atom Processor family and subsequent generations including \nIntel Atom processor D2000, N2000, E2000, Z2000, C1000 series provide the following features:\n• Enhanced Intel® SpeedStep® Technology\n• Intel® Hyper-Threading Technology\n• Deep Power Down Technology with Dynamic Cache Sizing\n• Support for instruction set extensions up to and including Supplemental Streaming SIMD Extensions 3 \n\n(SSSE3).\n• Support for Intel® Virtualization Technology\n• Support for Intel® 64 Architecture (excluding Intel Atom processor Z5xx Series)\n\n2.1.15 The Intel® Atom™ Processor Family Based on Silvermont Microarchitecture (2013)\nIntel Atom Processor C2xxx, E3xxx, S1xxx series are based on the Silvermont microarchitecture. Processors based on the Silvermont \nmicroarchitecture supports instruction set extensions up to and including SSE4.2, AESNI, and PCLMULQDQ.\n\n2.1.16 The Intel® Core™i7 Processor Family (2008)\nThe Intel Core i7 processor 900 series support Intel 64 architecture; they are based on Intel® microarchitecture \ncode name Nehalem using 45 nm process technology. The Intel Core i7 processor and Intel Xeon processor 5500 \nseries include the following innovative features:\n• Intel® Turbo Boost Technology converts thermal headroom into higher performance. \n• Intel® HyperThreading Technology in conjunction with Quadcore to provide four cores and eight threads. \n• Dedicated power control unit to reduce active and idle power consumption.\n• Integrated memory controller on the processor supporting three channel of DDR3 memory.\n• 8 MB inclusive Intel® Smart Cache.\n• Intel® QuickPath interconnect (QPI) providing point-to-point link to chipset.\n• Support for SSE4.2 and SSE4.1 instruction sets.\n• Second generation Intel Virtualization Technology.\n\n2.1.17 The Intel® Xeon® Processor 7500 Series (2010)\nThe Intel Xeon processor 7500 and 6500 series are based on Intel microarchitecture code name Nehalem using 45 \nnm process technology. They support the same features described in Section 2.1.16, plus the following innovative \nfeatures:\nVol. 1 2-5\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n• Up to eight cores per physical processor package.\n• Up to 24 MB inclusive Intel® Smart Cache.\n• Provides Intel® Scalable Memory Interconnect (Intel® SMI) channels with Intel® 7500 Scalable Memory Buffer \n\nto connect to system memory. \n• Advanced RAS supporting software recoverable machine check architecture.\n\n2.1.18 2010 Intel® Core™ Processor Family (2010)\n2010 Intel Core processor family spans Intel Core i7, i5 and i3 processors. They are based on Intel® microarchitec-\nture code name Westmere using 32 nm process technology. The innovative features can include:\n• Deliver smart performance using Intel Hyper-Threading Technology plus Intel Turbo Boost Technology. \n• Enhanced Intel Smart Cache and integrated memory controller.\n• Intelligent power gating.\n• Repartitioned platform with on-die integration of 45 nm integrated graphics.\n• Range of instruction set support up to AESNI, PCLMULQDQ, SSE4.2 and SSE4.1.\n\n2.1.19 The Intel® Xeon® Processor 5600 Series (2010)\nThe Intel Xeon processor 5600 series are based on Intel microarchitecture code name Westmere using 32 nm \nprocess technology. They support the same features described in Section 2.1.16, plus the following innovative \nfeatures:\n• Up to six cores per physical processor package.\n• Up to 12 MB enhanced Intel® Smart Cache.\n• Support for AESNI, PCLMULQDQ, SSE4.2 and SSE4.1 instruction sets.\n• Flexible Intel Virtualization Technologies across processor and I/O.\n\n2.1.20 The Second Generation Intel® Core™ Processor Family (2011)\nThe Second Generation Intel Core processor family spans Intel Core i7, i5 and i3 processors based on the Sandy \nBridge microarchitecture. They are built from 32 nm process technology and have innovative features including:\n• Intel Turbo Boost Technology for Intel Core i5 and i7 processors\n• Intel Hyper-Threading Technology. \n• Enhanced Intel Smart Cache and integrated memory controller.\n• Processor graphics and built-in visual features like Intel® Quick Sync Video, Intel® InsiderTM etc.\n• Range of instruction set support up to AVX, AESNI, PCLMULQDQ, SSE4.2 and SSE4.1.\n\nIntel Xeon processor E3-1200 product family is also based on the Sandy Bridge microarchitecture.\n\nIntel Xeon processor E5-2400/1400 product families are based on the Sandy Bridge-EP microarchitecture.\n\nIntel Xeon processor E5-4600/2600/1600 product families are based on the Sandy Bridge-EP microarchitecture \nand provide support for multiple sockets.\n\n2.1.21 The Third Generation Intel® Core™ Processor Family (2012)\nThe Third Generation Intel Core processor family spans Intel Core i7, i5 and i3 processors based on the Ivy Bridge \nmicroarchitecture. The Intel Xeon processor E7-8800/4800/2800 v2 product families and Intel Xeon processor E3-\n1200 v2 product family are also based on the Ivy Bridge microarchitecture.\n\nThe Intel Xeon processor E5-2400/1400 v2 product families are based on the Ivy Bridge-EP microarchitecture.\n2-6 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nThe Intel Xeon processor E5-4600/2600/1600 v2 product families are based on the Ivy Bridge-EP microarchitec-\nture and provide support for multiple sockets.\n\n2.1.22 The Fourth Generation Intel® Core™ Processor Family (2013)\nThe Fourth Generation Intel Core processor family spans Intel Core i7, i5 and i3 processors based on the Haswell \nmicroarchitecture. Intel Xeon processor E3-1200 v3 product family is also based on the Haswell microarchitecture.\n\n2.2 MORE ON SPECIFIC ADVANCES\nThe following sections provide more information on major innovations.\n\n2.2.1 P6 Family Microarchitecture\nThe Pentium Pro processor introduced a new microarchitecture commonly referred to as P6 processor microarchi-\ntecture. The P6 processor microarchitecture was later enhanced with an on-die, Level 2 cache, called Advanced \nTransfer Cache.\n\nThe microarchitecture is a three-way superscalar, pipelined architecture. Three-way superscalar means that by \nusing parallel processing techniques, the processor is able on average to decode, dispatch, and complete execution \nof (retire) three instructions per clock cycle. To handle this level of instruction throughput, the P6 processor family \nuses a decoupled, 12-stage superpipeline that supports out-of-order instruction execution. \n\nFigure 2-1 shows a conceptual view of the P6 processor microarchitecture pipeline with the Advanced Transfer \nCache enhancement. \n\nTo ensure a steady supply of instructions and data for the instruction execution pipeline, the P6 processor microar-\nchitecture incorporates two cache levels. The Level 1 cache provides an 8-KByte instruction cache and an 8-KByte \n\nFigure 2-1.  The P6 Processor Microarchitecture with Advanced Transfer Cache Enhancement\n\nBus Unit\n\n2nd Level Cache\nOn-die, 8-way\n\n1st  Level  Cache\n4-way, low latency\n\nFetch/\nDecode\n\nExecution\nInstruction\n\nCache\nMicrocode\n\nROM\n\nExecution\nOut-of-Order\n\nCore\nRetirement\n\nBTSs/Branch Prediction\n\nSystem Bus\n\nBranch  History  Update\n\nFrequently  used\n\nLess  frequently  used\n\nFront End\n\nOM16520\nVol. 1 2-7\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\ndata cache, both closely coupled to the pipeline. The Level 2 cache provides 256-KByte, 512-KByte, or 1-MByte \nstatic RAM that is coupled to the core processor through a full clock-speed 64-bit cache bus.\n\nThe centerpiece of the P6 processor microarchitecture is an out-of-order execution mechanism called dynamic \nexecution. Dynamic execution incorporates three data-processing concepts:\n• Deep branch prediction allows the processor to decode instructions beyond branches to keep the instruction \n\npipeline full. The P6 processor family implements highly optimized branch prediction algorithms to predict the \ndirection of the instruction.\n\n• Dynamic data flow analysis requires real-time analysis of the flow of data through the processor to \ndetermine dependencies and to detect opportunities for out-of-order instruction execution. The out-of-order \nexecution core can monitor many instructions and execute these instructions in the order that best optimizes \nthe use of the processor’s multiple execution units, while maintaining the data integrity.\n\n• Speculative execution refers to the processor’s ability to execute instructions that lie beyond a conditional \nbranch that has not yet been resolved, and ultimately to commit the results in the order of the original \ninstruction stream. To make speculative execution possible, the P6 processor microarchitecture decouples the \ndispatch and execution of instructions from the commitment of results. The processor’s out-of-order execution \ncore uses data-flow analysis to execute all available instructions in the instruction pool and store the results in \ntemporary registers. The retirement unit then linearly searches the instruction pool for completed instructions \nthat no longer have data dependencies with other instructions or unresolved branch predictions. When \ncompleted instructions are found, the retirement unit commits the results of these instructions to memory \nand/or the IA-32 registers (the processor’s eight general-purpose registers and eight x87 FPU data registers) \nin the order they were originally issued and retires the instructions from the instruction pool.\n\n2.2.2 Intel NetBurst® Microarchitecture\nThe Intel NetBurst microarchitecture provides:\n• The Rapid Execution Engine\n\n— Arithmetic Logic Units (ALUs) run at twice the processor frequency \n\n— Basic integer operations can dispatch in 1/2 processor clock tick\n• Hyper-Pipelined Technology\n\n— Deep pipeline to enable industry-leading clock rates for desktop PCs and servers\n\n— Frequency headroom and scalability to continue leadership into the future\n• Advanced Dynamic Execution\n\n— Deep, out-of-order, speculative execution engine\n\n• Up to 126 instructions in flight\n\n• Up to 48 loads and 24 stores in pipeline1\n\n— Enhanced branch prediction capability\n\n• Reduces the misprediction penalty associated with deeper pipelines \n\n• Advanced branch prediction algorithm\n\n• 4K-entry branch target array\n• New cache subsystem\n\n— First level caches\n\n• Advanced Execution Trace Cache stores decoded instructions\n\n• Execution Trace Cache removes decoder latency from main execution loops\n\n• Execution Trace Cache integrates path of program execution flow into a single line\n\n1. Intel 64 and IA-32 processors based on the Intel NetBurst microarchitecture at 90 nm process can handle more than 24 stores in \nflight.\n2-8 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n• Low latency data cache\n\n— Second level cache\n\n• Full-speed, unified 8-way Level 2 on-die Advance Transfer Cache\n\n• Bandwidth and performance increases with processor frequency\n• High-performance, quad-pumped bus interface to the Intel NetBurst microarchitecture system bus\n\n— Supports quad-pumped, scalable bus clock to achieve up to 4X effective speed\n\n— Capable of delivering up to 8.5 GBytes of bandwidth per second\n• Superscalar issue to enable parallelism\n• Expanded hardware registers with renaming to avoid register name space limitations\n• 64-byte cache line size (transfers data up to two lines per sector)\n\nFigure 2-2 is an overview of the Intel NetBurst microarchitecture. This microarchitecture pipeline is made up of \nthree sections: (1) the front end pipeline, (2) the out-of-order execution core, and (3) the retirement unit. \n\n2.2.2.1  The Front End Pipeline\nThe front end supplies instructions in program order to the out-of-order execution core. It performs a number of \nfunctions:\n• Prefetches instructions that are likely to be executed\n• Fetches instructions that have not already been prefetched\n• Decodes instructions into micro-operations\n• Generates microcode for complex instructions and special-purpose code\n• Delivers decoded instructions from the execution trace cache\n\nFigure 2-2.  The Intel NetBurst Microarchitecture\n\nFetch/Decode Trace Cache\nMicrocode ROM\n\nExecution\nOut-Of-Order\n\nCore\nRetirement\n\n1st Level Cache\n4-way\n\n2nd Level Cache\n 8-Way\n\nBTBs/Branch Prediction\n\nBus Unit\n\nSystem Bus\nFrequently used paths\n\nLess frequently used\npaths\n\nFront End\n\n3rd Level  Cache\nOptional\n\nBranch History Update\n\nOM16521\nVol. 1 2-9\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n• Predicts branches using highly advanced algorithm\n\nThe pipeline is designed to address common problems in high-speed, pipelined microprocessors. Two of these \nproblems contribute to major sources of delays:\n• time to decode instructions fetched from the target\n• wasted decode bandwidth due to branches or branch target in the middle of cache lines\n\nThe operation of the pipeline’s trace cache addresses these issues. Instructions are constantly being fetched and \ndecoded by the translation engine (part of the fetch/decode logic) and built into sequences of micro-ops called \ntraces. At any time, multiple traces (representing prefetched branches) are being stored in the trace cache. The \ntrace cache is searched for the instruction that follows the active branch. If the instruction also appears as the first \ninstruction in a pre-fetched branch, the fetch and decode of instructions from the memory hierarchy ceases and the \npre-fetched branch becomes the new source of instructions (see Figure 2-2).\n\nThe trace cache and the translation engine have cooperating branch prediction hardware. Branch targets are \npredicted based on their linear addresses using branch target buffers (BTBs) and fetched as soon as possible.\n\n2.2.2.2  Out-Of-Order Execution Core\nThe out-of-order execution core’s ability to execute instructions out of order is a key factor in enabling parallelism. \nThis feature enables the processor to reorder instructions so that if one micro-op is delayed, other micro-ops may \nproceed around it. The processor employs several buffers to smooth the flow of micro-ops.\n\nThe core is designed to facilitate parallel execution. It can dispatch up to six micro-ops per cycle (this exceeds trace \ncache and retirement micro-op bandwidth). Most pipelines can start executing a new micro-op every cycle, so \nseveral instructions can be in flight at a time for each pipeline. A number of arithmetic logical unit (ALU) instruc-\ntions can start at two per cycle; many floating-point instructions can start once every two cycles. \n\n2.2.2.3  Retirement Unit\nThe retirement unit receives the results of the executed micro-ops from the out-of-order execution core and \nprocesses the results so that the architectural state updates according to the original program order. \n\nWhen a micro-op completes and writes its result, it is retired. Up to three micro-ops may be retired per cycle. The \nReorder Buffer (ROB) is the unit in the processor which buffers completed micro-ops, updates the architectural \nstate in order, and manages the ordering of exceptions. The retirement section also keeps track of branches and \nsends updated branch target information to the BTB. The BTB then purges pre-fetched traces that are no longer \nneeded.\n\n2.2.3 Intel® Core™ Microarchitecture\nIntel Core microarchitecture introduces the following features that enable high performance and power-efficient \nperformance for single-threaded as well as multi-threaded workloads:\n• Intel® Wide Dynamic Execution enable each processor core to fetch, dispatch, execute in high bandwidths \n\nto support retirement of up to four instructions per cycle.\n\n— Fourteen-stage efficient pipeline\n\n— Three arithmetic logical units\n\n— Four decoders to decode up to five instruction per cycle \n\n— Macro-fusion and micro-fusion to improve front-end throughput\n\n— Peak issue rate of dispatching up to six micro-ops per cycle\n\n— Peak retirement bandwidth of up to 4 micro-ops per cycle\n\n— Advanced branch prediction\n\n— Stack pointer tracker to improve efficiency of executing function/procedure entries and exits\n• Intel® Advanced Smart Cache delivers higher bandwidth from the second level cache to the core, and \n\noptimal performance and flexibility for single-threaded and multi-threaded applications.\n2-10 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n— Large second level cache up to 4 MB and 16-way associativity\n\n— Optimized for multicore and single-threaded execution environments\n\n— 256 bit internal data path to improve bandwidth from L2 to first-level data cache\n• Intel® Smart Memory Access prefetches data from memory in response to data access patterns and reduces \n\ncache-miss exposure of out-of-order execution.\n\n— Hardware prefetchers to reduce effective latency of second-level cache misses\n\n— Hardware prefetchers to reduce effective latency of first-level data cache misses\n\n— Memory disambiguation to improve efficiency of speculative execution execution engine\n• Intel® Advanced Digital Media Boost improves most 128-bit SIMD instruction with single-cycle throughput \n\nand floating-point operations.\n\n— Single-cycle throughput of most 128-bit SIMD instructions\n\n— Up to eight floating-point operation per cycle\n\n— Three issue ports available to dispatching SIMD instructions for execution\n\nIntel Core 2 Extreme, Intel Core 2 Duo processors and Intel Xeon processor 5100 series implement two processor \ncores based on the Intel Core microarchitecture, the functionality of the subsystems in each core are depicted in \nFigure 2-3. \n\n2.2.3.1  The Front End\nThe front end of Intel Core microarchitecture provides several enhancements to feed the Intel Wide Dynamic \nExecution engine:\n• Instruction fetch unit prefetches instructions into an instruction queue to maintain steady supply of instruction \n\nto the decode units.\n• Four-wide decode unit can decode 4 instructions per cycle or 5 instructions per cycle with Macrofusion.\n\nFigure 2-3.  The Intel Core Microarchitecture Pipeline Functionality\n\nDecode\n\nALU\nBranch\n\nMMX/SSE/FP\nMove\n\nLoad\n\nShared L2 Cache\nUp to 10.7 GB/s \n\nFSB\n\nRetirement Unit \n(Re-Order Buffer)\n\nL1D Cache and DTLB\n\nInstruction Fetch and PreDecode\n\nInstruction Queue\n\nRename/Alloc\n\nALU\nFAdd\n\nMMX/SSE\n\nALU\nFMul\n\nMMX/SSE\n\nScheduler\n\nMicro-\ncode \nROM\n\nStore\nVol. 1 2-11\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n• Macrofusion fuses common sequence of two instructions as one decoded instruction (micro-ops) to increase \ndecoding throughput.\n\n• Microfusion fuses common sequence of two micro-ops as one micro-ops to improve retirement throughput.\n• Instruction queue provides caching of short loops to improve efficiency.\n• Stack pointer tracker improves efficiency of executing procedure/function entries and exits.\n• Branch prediction unit employs dedicated hardware to handle different types of branches for improved branch \n\nprediction.\n• Advanced branch prediction algorithm directs instruction fetch unit to fetch instructions likely in the architec-\n\ntural code path for decoding.\n\n2.2.3.2  Execution Core \nThe execution core of the Intel Core microarchitecture is superscalar and can process instructions out of order to \nincrease the overall rate of instructions executed per cycle (IPC). The execution core employs the following feature \nto improve execution throughput and efficiency:\n• Up to six micro-ops can be dispatched to execute per cycle\n• Up to four instructions can be retired per cycle\n• Three full arithmetic logical units\n• SIMD instructions can be dispatched through three issue ports\n• Most SIMD instructions have 1-cycle throughput (including 128-bit SIMD instructions)\n• Up to eight floating-point operation per cycle\n• Many long-latency computation operation are pipelined in hardware to increase overall throughput\n• Reduced exposure to data access delays using Intel Smart Memory Access\n\n2.2.4 Intel® Atom™ Microarchitecture\nIntel Atom microarchitecture maximizes power-efficient performance for single-threaded and multi-threaded \nworkloads by providing:\n• Advanced Micro-Ops Execution \n\n— Single-micro-op instruction execution from decode to retirement, including instructions with register-only, \nload, and store semantics.\n\n— Sixteen-stage, in-order pipeline optimized for throughput and reduced power consumption.\n\n— Dual pipelines to enable decode, issue, execution and retirement of two instructions per cycle.\n\n— Advanced stack pointer to improve efficiency of executing function entry/returns.\n• Intel® Smart Cache\n\n— Second level cache is 512 KB and 8-way associativity.\n\n— Optimized for multi-threaded and single-threaded execution environments\n\n— 256 bit internal data path between L2 and L1 data cache improves high bandwidth.\n• Efficient Memory Access\n\n— Efficient hardware prefetchers to L1 and L2, speculatively loading data likely to be requested by processor \nto reduce cache miss impact.\n\n• Intel® Digital Media Boost\n\n— Two issue ports for dispatching SIMD instructions to execution units.\n\n— Single-cycle throughput for most 128-bit integer SIMD instructions\n\n— Up to six floating-point operations per cycle\n\n— Up to two 128-bit SIMD integer operations per cycle\n2-12 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n— Safe Instruction Recognition (SIR) to allow long-latency floating-point operations to retire out of order with \nrespect to integer instructions.\n\n2.2.5 Intel® Microarchitecture Code Name Nehalem\nIntel microarchitecture code name Nehalem provides the foundation for many innovative features of Intel Core i7 \nprocessors. It builds on the success of 45 nm Intel Core microarchitecture and provides the following feature \nenhancements:\n• Enhanced processor core\n\n— Improved branch prediction and recovery from misprediction.\n\n— Enhanced loop streaming to improve front end performance and reduce power consumption.\n\n— Deeper buffering in out-of-order engine to extract parallelism.\n\n— Enhanced execution units to provide acceleration in CRC, string/text processing and data shuffling.\n• Smart Memory Access\n\n— Integrated memory controller provides low-latency access to system memory and scalable memory \nbandwidth\n\n— New cache hierarchy organization with shared, inclusive L3 to reduce snoop traffic\n\n— Two level TLBs and increased TLB size.\n\n— Fast unaligned memory access.\n• HyperThreading Technology\n\n— Provides two hardware threads (logical processors) per core.\n\n— Takes advantage of 4-wide execution engine, large L3, and massive memory bandwidth.\n• Dedicated Power management Innovations\n\n— Integrated microcontroller with optimized embedded firmware to manage power consumption.\n\n— Embedded real-time sensors for temperature, current, and power.\n\n— Integrated power gate to turn off/on per-core power consumption\n\n— Versatility to reduce power consumption of memory, link subsystems.\n\n2.2.6 Intel® Microarchitecture Code Name Sandy Bridge\nIntel® microarchitecture code name Sandy Bridge builds on the successes of Intel® Core™ microarchitecture and \nIntel microarchitecture code name Nehalem. It offers the following innovative features:\n• Intel Advanced Vector Extensions (Intel AVX)\n\n— 256-bit floating-point instruction set extensions to the 128-bit Intel Streaming SIMD Extensions, providing \nup to 2X performance benefits relative to 128-bit code.\n\n— Non-destructive destination encoding offers more flexible coding techniques.\n\n— Supports flexible migration and co-existence between 256-bit AVX code, 128-bit AVX code and legacy 128-\nbit SSE code.\n\n• Enhanced front-end and execution engine\n\n— New decoded Icache component that improves front-end bandwidth and reduces branch misprediction \npenalty.\n\n— Advanced branch prediction.\n\n— Additional macro-fusion support.\n\n— Larger dynamic execution window.\n\n— Multi-precision integer arithmetic enhancements (ADC/SBB, MUL/IMUL).\nVol. 1 2-13\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n— LEA bandwidth improvement.\n\n— Reduction of general execution stalls (read ports, writeback conflicts, bypass latency, partial stalls).\n\n— Fast floating-point exception handling.\n\n— XSAVE/XRSTORE performance improvements and XSAVEOPT new instruction.\n• Cache hierarchy improvements for wider data path\n\n— Doubling of bandwidth enabled by two symmetric ports for memory operation.\n\n— Simultaneous handling of more in-flight loads and stores enabled by increased buffers.\n\n— Internal bandwidth of two loads and one store each cycle.\n\n— Improved prefetching.\n\n— High bandwidth low latency LLC architecture.\n\n— High bandwidth ring architecture of on-die interconnect.\n\nFor additional information on Intel® Advanced Vector Extensions (AVX), see Section 5.13, “Intel® Advanced Vector \nExtensions (Intel® AVX)” and Chapter 14, “Programming with AVX, FMA and AVX2” in Intel® 64 and IA-32 Archi-\ntectures Software Developer’s Manual, Volume 1.\n\n2.2.7 SIMD Instructions\nBeginning with the Pentium II and Pentium with Intel MMX technology processor families, six extensions have been \nintroduced into the Intel 64 and IA-32 architectures to perform single-instruction multiple-data (SIMD) operations. \nThese extensions include the MMX technology, SSE extensions, SSE2 extensions, SSE3 extensions, Supplemental \nStreaming SIMD Extensions 3, and SSE4. Each of these extensions provides a group of instructions that perform \nSIMD operations on packed integer and/or packed floating-point data elements. \n\nSIMD integer operations can use the 64-bit MMX or the 128-bit XMM registers. SIMD floating-point operations use \n128-bit XMM registers. Figure 2-4 shows a summary of the various SIMD extensions (MMX technology, SSE, SSE2, \nSSE3, SSSE3, and SSE4), the data types they operate on, and how the data types are packed into MMX and XMM \nregisters.\n\nThe Intel MMX technology was introduced in the Pentium II and Pentium with MMX technology processor families. \nMMX instructions perform SIMD operations on packed byte, word, or doubleword integers located in MMX registers. \nThese instructions are useful in applications that operate on integer arrays and streams of integer data that lend \nthemselves to SIMD processing.\n\nSSE extensions were introduced in the Pentium III processor family. SSE instructions operate on packed single-\nprecision floating-point values contained in XMM registers and on packed integers contained in MMX registers. \nSeveral SSE instructions provide state management, cache control, and memory ordering operations. Other SSE \ninstructions are targeted at applications that operate on arrays of single-precision floating-point data elements (3-\nD geometry, 3-D rendering, and video encoding and decoding applications).\n\nSSE2 extensions were introduced in Pentium 4 and Intel Xeon processors. SSE2 instructions operate on packed \ndouble-precision floating-point values contained in XMM registers and on packed integers contained in MMX and \nXMM registers. SSE2 integer instructions extend IA-32 SIMD operations by adding new 128-bit SIMD integer oper-\nations and by expanding existing 64-bit SIMD integer operations to 128-bit XMM capability. SSE2 instructions also \nprovide new cache control and memory ordering operations.\n\nSSE3 extensions were introduced with the Pentium 4 processor supporting Hyper-Threading Technology (built on \n90 nm process technology). SSE3 offers 13 instructions that accelerate performance of Streaming SIMD Extensions \ntechnology, Streaming SIMD Extensions 2 technology, and x87-FP math capabilities.\n\nSSSE3 extensions were introduced with the Intel Xeon processor 5100 series and Intel Core 2 processor family. \nSSSE3 offer 32 instructions to accelerate processing of SIMD integer data.\n\nSSE4 extensions offer 54 instructions. 47 of them are referred to as SSE4.1 instructions. SSE4.1 are introduced \nwith Intel Xeon processor 5400 series and Intel Core 2 Extreme processor QX9650. The other 7 SSE4 instructions \nare referred to as SSE4.2 instructions.\n2-14 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nAESNI and PCLMULQDQ introduce 7 new instructions. Six of them are primitives for accelerating algorithms based \non AES encryption/decryption standard, referred to as AESNI.\n\nThe PCLMULQDQ instruction accelerates general-purpose block encryption, which can perform carry-less multipli-\ncation for two binary numbers up to 64-bit wide.\n\nIntel 64 architecture allows four generations of 128-bit SIMD extensions to access up to 16 XMM registers. IA-32 \narchitecture provides 8 XMM registers.\n\nIntel® Advanced Vector Extensions offers comprehensive architectural enhancements over previous generations of \nStreaming SIMD Extensions. Intel AVX introduces the following architectural enhancements:\n• Support for 256-bit wide vectors and SIMD register set.\n• 256-bit floating-point instruction set enhancement with up to 2X performance gain relative to 128-bit \n\nStreaming SIMD extensions.\n• Instruction syntax support for generalized three-operand syntax to improve instruction programming flexibility \n\nand efficient encoding of new instruction extensions.\n• Enhancement of legacy 128-bit SIMD instruction extensions to support three operand syntax and to simplify \n\ncompiler vectorization of high-level language expressions.\n• Support flexible deployment of 256-bit AVX code, 128-bit AVX code, legacy 128-bit code and scalar code.\nIn addition to performance considerations, programmers should also be cognizant of the implications of VEX-\nencoded AVX instructions with the expectations of system software components that manage the processor state \ncomponents enabled by XCR0. For additional information see Section 2.3.10.1, “Vector Length Transition and \nProgramming Considerations” in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A.\n\nSee also: \n• Section 5.4, “MMX™ Instructions,” and Chapter 9, “Programming with Intel® MMX™ Technology”\n• Section 5.5, “SSE Instructions,” and Chapter 10, “Programming with Intel® Streaming SIMD Extensions \n\n(Intel® SSE)”\n• Section 5.6, “SSE2 Instructions,” and Chapter 11, “Programming with Intel® Streaming SIMD Extensions 2 \n\n(Intel® SSE2)”\n• Section 5.7, “SSE3 Instructions”, Section 5.8, “Supplemental Streaming SIMD Extensions 3 (SSSE3) Instruc-\n\ntions”, Section 5.9, “SSE4 Instructions”, and Chapter 12, “Programming with Intel® SSE3, SSSE3, Intel® \nSSE4 and Intel® AESNI”\nVol. 1 2-15\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.2.8 Intel® Hyper-Threading Technology\nIntel Hyper-Threading Technology (Intel HT Technology) was developed to improve the performance of IA-32 \nprocessors when executing multi-threaded operating system and application code or single-threaded applications \nunder multi-tasking environments. The technology enables a single physical processor to execute two or more \nseparate code streams (threads) concurrently using shared execution resources. \n\nIntel HT Technology is one form of hardware multi-threading capability in IA-32 processor families. It differs from \nmulti-processor capability using separate physically distinct packages with each physical processor package mated \nwith a physical socket. Intel HT Technology provides hardware multi-threading capability with a single physical \npackage by using shared execution resources in a processor core.\n\nArchitecturally, an IA-32 processor that supports Intel HT Technology consists of two or more logical processors, \neach of which has its own IA-32 architectural state. Each logical processor consists of a full set of IA-32 data regis-\nters, segment registers, control registers, debug registers, and most of the MSRs. Each also has its own advanced \nprogrammable interrupt controller (APIC). \n\nFigure 2-5 shows a comparison of a processor that supports Intel HT Technology (implemented with two logical \nprocessors) and a traditional dual processor system. \n\nFigure 2-4.  SIMD Extensions, Register Layouts, and Data Types\n\n4 Packed Word Integers\n\n8 Packed Byte Integers\n\n2 Packed Doubleword Integers\n\nMMX Registers\n\nQuadword\n\nMMX Technology - SSSE3\n\nData TypeRegister LayoutSIMD Extension\n\nSSE - AVX\n\n4 Packed Single-Precision\nFloating-Point Values\n\n2 Packed Double-Precision\nFloating-Point Values\n\n8 Packed Word Integers\n\n16 Packed Byte Integers\n\n4 Packed Doubleword\n\n2 Quadword Integers\n\nDouble Quadword\n\nIntegers\n\nXMM Registers\n\n8 Packed SP FP Values\n\n4 Packed DP FP Values\n\nYMM Registers\nAVX\n\n2 128-bit Data\n2-16 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nUnlike a traditional MP system configuration that uses two or more separate physical IA-32 processors, the logical \nprocessors in an IA-32 processor supporting Intel HT Technology share the core resources of the physical \nprocessor. This includes the execution engine and the system bus interface. After power up and initialization, each \nlogical processor can be independently directed to execute a specified thread, interrupted, or halted.\n\nIntel HT Technology leverages the process and thread-level parallelism found in contemporary operating systems \nand high-performance applications by providing two or more logical processors on a single chip. This configuration \nallows two or more threads1 to be executed simultaneously on each a physical processor. Each logical processor \nexecutes instructions from an application thread using the resources in the processor core. The core executes \nthese threads concurrently, using out-of-order instruction scheduling to maximize the use of execution units during \neach clock cycle.\n\n2.2.8.1  Some Implementation Notes\nAll Intel HT Technology configurations require:\n• A processor that supports Intel HT Technology\n• A chipset and BIOS that utilize the technology\n• Operating system optimizations\n\nSee http://www.intel.com/products/ht/hyperthreading_more.htm for information.\n\nAt the firmware (BIOS) level, the basic procedures to initialize the logical processors in a processor supporting Intel \nHT Technology are the same as those for a traditional DP or MP platform. The mechanisms that are described in the \nMultiprocessor Specification, Version 1.4 to power-up and initialize physical processors in an MP system also apply \nto logical processors in a processor that supports Intel HT Technology. \n\nAn operating system designed to run on a traditional DP or MP platform may use CPUID to determine the presence \nof hardware multi-threading support feature and the number of logical processors they provide.\n\nAlthough existing operating system and application code should run correctly on a processor that supports Intel HT \nTechnology, some code modifications are recommended to get the optimum benefit. These modifications are \ndiscussed in Chapter 7, “Multiple-Processor Management,” Intel® 64 and IA-32 Architectures Software Devel-\noper’s Manual, Volume 3A.\n\nFigure 2-5.  Comparison of an IA-32 Processor Supporting Hyper-Threading Technology and a Traditional Dual \nProcessor System\n\n1. In the remainder of this document, the term “thread” will be used as a general term for the terms “process” and “thread.”\n\nProcessor Core Processor CoreProcessor Core\n\nAS ASASAS\n\nTraditional Multiple Processor (MP) SystemIA-32 Processor Supporting\nHyper-Threading Technology\n\nAS = IA-32 Architectural State\n\nIA-32 processor IA-32 processor\n\nTwo logical \nprocessors that share \na single core\n\nEach processor is a \nseparate physical \npackage\n\nIA-32 processor\n\nOM16522\nVol. 1 2-17\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.2.9 Multi-Core Technology\nMulti-core technology is another form of hardware multi-threading capability in IA-32 processor families. Multi-core \ntechnology enhances hardware multi-threading capability by providing two or more execution cores in a physical \npackage.\n\nThe Intel Pentium processor Extreme Edition is the first member in the IA-32 processor family to introduce multi-\ncore technology. The processor provides hardware multi-threading support with both two processor cores and Intel \nHyper-Threading Technology. This means that the Intel Pentium processor Extreme Edition provides four logical \nprocessors in a physical package (two logical processors for each processor core). The Dual-Core Intel Xeon \nprocessor features multi-core, Intel Hyper-Threading Technology and supports multi-processor platforms. \n\nThe Intel Pentium D processor also features multi-core technology. This processor provides hardware multi-\nthreading support with two processor cores but does not offer Intel Hyper-Threading Technology. This means that \nthe Intel Pentium D processor provides two logical processors in a physical package, with each logical processor \nowning the complete execution resources of a processor core.\n\nThe Intel Core 2 processor family, Intel Xeon processor 3000 series, Intel Xeon processor 5100 series, and Intel \nCore Duo processor offer power-efficient multi-core technology. The processor contains two cores that share a \nsmart second level cache. The Level 2 cache enables efficient data sharing between two cores to reduce memory \ntraffic to the system bus.\n\nThe Pentium® dual-core processor is based on the same technology as the Intel Core 2 Duo processor family.\n\nThe Intel Xeon processor 7300, 5300 and 3200 series, Intel Core 2 Extreme Quad-Core processor, and Intel Core 2 \nQuad processors support Intel quad-core technology. The Quad-core Intel Xeon processors and the Quad-Core \nIntel Core 2 processor family are also in Figure 2-7. \n\nFigure 2-6.  Intel 64 and IA-32 Processors that Support Dual-Core \n\nArchitectual \nState\n\nSystem Bus\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual \nState\n\nBus Interface Bus Interface\n\nLocal APIC Local APIC\n\nArchitectual \nState\n\nArchitectual \nState\n\nPentium Processor Extreme Edition\nSystem Bus\n\nArchitectual State\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual State\n\nBus Interface\n\nIntel Core Duo Processor\nIntel Core 2 Duo Processor\n\nIntel Pentium dual-core Processor\n\nSecond Level Cache\n\nArchitectual State\n\nSystem Bus\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual State\n\nBus Interface Bus Interface\n\nPentium D Processor\n\nOM19809\n2-18 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Core i7 processors support Intel quad-core technology, Intel HyperThreading Technology, provides Intel \nQuickPath interconnect link to the chipset and have integrated memory controller supporting three channel to \nDDR3 memory.\n\nFigure 2-7.  Intel 64 Processors that Support Quad-Core \n\nFigure 2-8.  Intel Core i7 Processor \n\nSystem Bus\n\nIntel Core 2 Extreme Quad-core Processor\nIntel Core 2 Quad Processor\n\nIntel Xeon Processor 3200 Series\nIntel Xeon Processor 5300 Series\n\nArchitectual State\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual State\n\nBus Interface\n\nSecond Level Cache\n\nArchitectual State\n\nExecution Engine\n\nLocal APIC Local APIC\n\nExecution Engine\n\nArchitectual State\n\nBus Interface\n\nSecond Level Cache\n\nOM19810\n\nChipset\n\nIntel Core i7  Processor\n\nQPI\n\nLogical \nProces\n\nsor\n\nL1 and L2\n\nExecution Engine Execution Engine\n\nL1 and L2 L1 and L2\n\nExecution Engine Execution Engine\n\nL1 and L2\n\nQuickPath Interconnect (QPI) Interface, Integrated Memory Controller\n\nThird Level Cache\n\nOM19810b\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nLogical \nProces\n\nsor\n\nDDR3\n\nIMC\nVol. 1 2-19\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\n2.2.10 Intel® 64 Architecture\nIntel 64 architecture increases the linear address space for software to 64 bits and supports physical address space \nup to 52 bits. The technology also introduces a new operating mode referred to as IA-32e mode.\n\nIA-32e mode operates in one of two sub-modes: (1) compatibility mode enables a 64-bit operating system to run \nmost legacy 32-bit software unmodified, (2) 64-bit mode enables a 64-bit operating system to run applications \nwritten to access 64-bit address space. \n\nIn the 64-bit mode, applications may access:\n• 64-bit flat linear addressing\n• 8 additional general-purpose registers (GPRs)\n• 8 additional registers for streaming SIMD extensions (SSE, SSE2, SSE3 and SSSE3)\n• 64-bit-wide GPRs and instruction pointers\n• uniform byte-register addressing\n• fast interrupt-prioritization mechanism\n• a new instruction-pointer relative-addressing mode\n\nAn Intel 64 architecture processor supports existing IA-32 software because it is able to run all non-64-bit legacy \nmodes supported by IA-32 architecture. Most existing IA-32 applications also run in compatibility mode.\n\n2.2.11 Intel® Virtualization Technology (Intel® VT)\nIntel® Virtualization Technology for Intel 64 and IA-32 architectures provide extensions that support virtualization. \nThe extensions are referred to as Virtual Machine Extensions (VMX). An Intel 64 or IA-32 platform with VMX can \nfunction as multiple virtual systems (or virtual machines). Each virtual machine can run operating systems and \napplications in separate partitions. \n\nVMX also provides programming interface for a new layer of system software (called the Virtual Machine Monitor \n(VMM)) used to manage the operation of virtual machines. Information on VMX and on the programming of VMMs \nis in Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3C.\n\nIntel Core i7 processor provides the following enhancements to Intel Virtualization Technology:\n• Virtual processor ID (VPID) to reduce the cost of VMM managing transitions.\n• Extended page table (EPT) to reduce the number of transitions for VMM to manage memory virtualization.\n• Reduced latency of VM transitions.\n\n2.3 INTEL® 64 AND IA-32 PROCESSOR GENERATIONS\nIn the mid-1960s, Intel cofounder and Chairman Emeritus Gordon Moore had this observation: “... the number of \ntransistors that would be incorporated on a silicon die would double every 18 months for the next several years.” \nOver the past three and half decades, this prediction known as “Moore's Law” has continued to hold true.\n\nThe computing power and the complexity (or roughly, the number of transistors per processor) of Intel architecture \nprocessors has grown in close relation to Moore's law. By taking advantage of new process technology and new \nmicroarchitecture designs, each new generation of IA-32 processors has demonstrated frequency-scaling head-\nroom and new performance levels over the previous generation processors.\n2-20 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nThe key features of the Intel Pentium 4 processor, Intel Xeon processor, Intel Xeon processor MP, Pentium III \nprocessor, and Pentium III Xeon processor with advanced transfer cache are shown in Table 2-1. Older generation \nIA-32 processors, which do not employ on-die Level 2 cache, are shown in Table 2-2. \n\nTable 2-1.  Key Features of Most Recent IA-32 Processors \n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architecture Top-Bin Clock \nFre-quency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes1\n\nNOTES:\n1. The register size and external data bus size are given in bits.\n\nSystem \nBus Band-\nwidth\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches2\n\n2. First level cache is denoted using the abbreviation L1, 2nd level cache is denoted as L2. The size\nof L1 includes the first-level data cache and the instruction cache where applicable, but \ndoes not include the trace cache.\n\nIntel Pentium \nM\nProcessor \n7553\n\n3. Intel processor numbers are not a measure of performance. Processor numbers differentiate \nfeatures within each processor family, not across different processor families. \nSee http://www.intel.com/products/processor_number for details.\n\n2004 Intel Pentium M \nProcessor\n\n2.00 GHz 140 M GP: 32 \nFPU: 80 \nMMX: 64\nXMM: 128\n\n3.2 GB/s 4 GB L1: 64 KB\nL2: 2 MB\n\nIntel Core Duo\nProcessor \nT26003\n\n2006 Improved Intel \nPentium M \nProcessor \nMicroarchitecture; \nDual Core;\n\nIntel Smart Cache, \nAdvanced Thermal \nManager\n\n2.16 GHz  152M GP: 32 \nFPU: 80 \nMMX: 64\nXMM: 128\n\n5.3 GB/s 4 GB L1: 64 KB\nL2: 2 MB \n(2MB Total)\n\nIntel Atom\nProcessor \nZ5xx series\n\n2008 Intel Atom \nMicroarchitecture; \n\nIntel Virtualization \nTechnology.\n\n1.86 GHz - \n800 MHz\n\n 47M GP: 32 \nFPU: 80 \nMMX: 64\nXMM: 128\n\nUp to 4.2 \nGB/s\n\n4 GB L1: 56 KB4\n\nL2: 512KB \n\n4. In Intel Atom Processor, the size of L1 instruction cache is 32 KBytes, L1 data cache is 24 KBytes.\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\n\n64-bit Intel \nXeon\nProcessor \nwith 800 MHz \nSystem Bus\n\n2004 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture\n\n3.60 GHz 125 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n6.4 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n1 MB L2\n\n64-bit Intel \nXeon\nProcessor MP \nwith 8MB L3\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture \n\n3.33 GHz 675M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n5.3 GB/s 1 1024 GB \n(1 TB)\n\n12K µop \nExecution \nTrace Cache;\n16 KB L1;\n1 MB L2,\n8 MB L3\nVol. 1 2-21\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Pentium \n4\nProcessor \nExtreme \nEdition \nSupporting \nHyper-\nThreading \nTechnology\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture \n\n3.73 GHz 164 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n2 MB L2\n\nIntel Pentium \nProcessor \nExtreme \nEdition 840\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture;\n\nDual-core 2\n\n3.20 GHz 230 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n6.4 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n1MB L2 \n(2MB Total)\n\nDual-Core Intel \nXeon \nProcessor \n7041\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture;\n\nDual-core 3\n\n3.00 GHz  321M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n6.4 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n2MB L2 \n(4MB Total)\n\nIntel Pentium \n4\nProcessor 672\n\n2005 Intel NetBurst \nMicroarchitecture; \nIntel Hyper-\nThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n3.80 GHz 164 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n6.4 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n2MB L2 \n\nIntel Pentium \nProcessor \nExtreme \nEdition 955\n\n2006 Intel NetBurst \nMicroarchitecture; \nIntel 64 \nArchitecture; Dual \nCore;\n\nIntel Virtualization \nTechnology.\n\n3.46 GHz  376M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 64 GB 12K µop \nExecution \nTrace Cache;\n16 KB L1;\n2MB L2 \n\n(4MB Total)\n\nIntel Core 2 \nExtreme \nProcessor \nX6800\n\n2006 Intel Core \nMicroarchitecture; \nDual Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.93 GHz  291M GP: 32,64 \nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 64 GB L1: 64 KB\nL2: 4MB \n(4MB Total)\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\n2-22 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Xeon\nProcessor \n5160\n\n2006 Intel Core \nMicroarchitecture; \nDual Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n3.00 GHz  291M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n10.6 GB/s 64 GB L1: 64 KB\nL2: 4MB \n(4MB Total)\n\nIntel Xeon\nProcessor \n7140\n\n2006 Intel NetBurst \nMicroarchitecture; \nDual Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n3.40 GHz  1.3 B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n12.8 GB/s 64 GB L1: 64 KB\nL2: 1MB \n(2MB Total)\n\nL3: 16 MB \n(16MB Total)\n\nIntel Core 2 \nExtreme \nProcessor \nQX6700\n\n2006 Intel Core \nMicroarchitecture; \nQuad Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.66 GHz 582M GP: 32,64 \nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 64 GB L1: 64 KB\nL2: 4MB \n(4MB Total)\n\nQuad-core \nIntel Xeon\nProcessor \n5355\n\n2006 Intel Core \nMicroarchitecture; \nQuad Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.66 GHz 582 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n10.6 GB/s 256 GB L1: 64 KB\nL2: 4MB (8 \nMB Total)\n\nIntel Core 2 \nDuo Processor \nE6850\n\n2007 Intel Core \nMicroarchitecture; \nDual Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology;\n\nIntel Trusted \nExecution \nTechnology\n\n3.00 GHz 291 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n10.6 GB/s 64 GB L1: 64 KB\nL2: 4MB \n(4MB Total)\n\nIntel Xeon\nProcessor \n7350\n\n2007 Intel Core \nMicroarchitecture; \nQuad Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.93 GHz  582 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 1024 GB L1: 64 KB\nL2: 4MB \n(8MB Total)\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\nVol. 1 2-23\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Xeon\nProcessor \n5472\n\n2007 Enhanced Intel \nCore \nMicroarchitecture; \nQuad Core; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n3.00 GHz  820 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n12.8 GB/s 256 GB L1: 64 KB\nL2: 6MB \n(12MB Total)\n\nIntel Atom\nProcessor\n\n2008 Intel Atom \nMicroarchitecture; \nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.0 - 1.60 \nGHz\n\n47 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nUp to 4.2 \nGB/s\n\nUp to \n64GB\n\nL1: 56 KB4\n\nL2: 512KB \n\nIntel Xeon\nProcessor \n7460\n\n2008 Enhanced Intel \nCore \nMicroarchitecture; \nSix Cores; \n\nIntel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n2.67 GHz  1.9 B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n8.5 GB/s 1024 GB L1: 64 KB\nL2: 3MB \n(9MB Total)\n\nL3: 16MB\n\nIntel Atom\nProcessor 330\n\n2008 Intel Atom \nMicroarchitecture; \nIntel 64 \nArchitecture;\n\nDual core;\n\nIntel Virtualization \nTechnology.\n\n1.60 GHz 94 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nUp to 4.2 \nGB/s\n\nUp to \n64GB\n\nL1: 56 KB5\n\nL2: 512KB \n(1MB Total)\n\nIntel Core i7-\n965\nProcessor \nExtreme \nEdition\n\n2008 Intel \nmicroarchitecture \ncode name \nNehalem; \nQuadcore; \nHyperThreading \nTechnology; Intel \nQPI; Intel 64 \nArchitecture;\n\nIntel Virtualization \nTechnology.\n\n3.20 GHz  731 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nQPI: 6.4 \nGT/s; \nMemory: \n25 GB/s \n\n64 GB L1: 64 KB\nL2: 256KB \n\nL3: 8MB\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\n2-24 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Core i7-\n620M\nProcessor \n\n2010 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name \nWestmere; \nDualcore; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology., \nIntegrated graphics\n\n2.66 GHz  383 M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\n64 GB L1: 64 KB\nL2: 256KB \n\nL3: 4MB\n\nIntel Xeon-\nProcessor \n5680\n\n2010 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name \nWestmere; Six core; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n3.33 GHz 1.1B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nQPI: 6.4 \nGT/s; 32 \nGB/s\n\n1 TB L1: 64 KB\nL2: 256KB \n\nL3: 12MB\n\nIntel Xeon-\nProcessor \n7560\n\n2010 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name \nNehalem; Eight \ncore; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n2.26 GHz 2.3B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nQPI: 6.4 \nGT/s; \nMemory: \n76 GB/s \n\n16 TB L1: 64 KB\nL2: 256KB \n\nL3: 24MB\n\nIntel Core i7-\n2600K\nProcessor \n\n2011 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name Sandy \nBridge; Four core; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology., \nProcessor graphics, \nQuicksync Video\n\n3.40 GHz  995M GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nYMM: 256\n\nDMI: 5 \nGT/s; \nMemory: \n21 GB/s\n\n64 GB L1: 64 KB\nL2: 256KB \n\nL3: 8MB\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\nVol. 1 2-25\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nIntel Xeon-\nProcessor E3-\n1280\n\n2011 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name Sandy \nBridge; Four core; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n3.50 GHz GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nYMM: 256\n\nDMI: 5 \nGT/s; \nMemory: \n21 GB/s\n\n1 TB L1: 64 KB\nL2: 256KB \n\nL3: 8MB\n\nIntel Xeon-\nProcessor E7-\n8870\n\n2011 Intel Turbo Boost \nTechnology, Intel \nmicroarchitecture \ncode name \nWestmere; Ten \ncore; \nHyperThreading \nTechnology; Intel \n64 Architecture;\n\nIntel Virtualization \nTechnology.\n\n2.40 GHz 2.2B GP: 32, 64\nFPU: 80 \nMMX: 64\nXMM: 128\n\nQPI: 6.4 \nGT/s; \nMemory: \n102 GB/s \n\n16 TB L1: 64 KB\nL2: 256KB \n\nL3: 30MB\n\nNOTES:\n1. The 64-bit Intel Xeon Processor MP with an 8-MByte L3 supports a multi-processor platform with a dual system bus; this creates a \n\nplatform bandwidth with 10.6 GBytes.\n2. In Intel Pentium Processor Extreme Edition 840, the size of on-die cache is listed for each core. The total size of L2 in the physical\n\npackage in 2 MBytes.\n3. In Dual-Core Intel Xeon Processor 7041, the size of on-die cache is listed for each core. The total size of L2 in the physical package in\n\n4 MBytes.\n4. In Intel Atom Processor, the size of L1 instruction cache is 32 KBytes, L1 data cache is 24 KBytes.\n5. In Intel Atom Processor, the size of L1 instruction cache is 32 KBytes, L1 data cache is 24 KBytes.\n\nTable 2-2.  Key Features of Most Recent Intel 64 Processors (Contd.)\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMicro-architec-\nture\n\nHighest \nProcessor \nBase Fre-\nquency at \nIntro-\nduction\n\nTran-\nsistors\n\nRegister \nSizes\n\nSystem \nBus/QPI \nLink \nSpeed\n\nMax. \nExtern. \nAddr. \nSpace\n\nOn-Die \nCaches\n2-26 Vol. 1\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nTable 2-3.  Key Features of Previous Generations of IA-32 Processors\n\nIntel \nProcessor\n\nDate \nIntro-\nduced\n\nMax. Clock \nFrequency/\nTechnology at \nIntroduction\n\nTran-\nsistors\n\nRegister \nSizes1\n\nExt. Data \nBus Size2\n\nMax. \nExtern. \nAddr. \nSpace\n\nCaches \n\n8086 1978 8 MHz 29 K 16 GP 16 1 MB None\n\nIntel 286 1982 12.5 MHz 134 K 16 GP 16 16 MB Note 3\n\nIntel386 DX \nProcessor\n\n1985 20 MHz 275 K 32 GP 32 4 GB Note 3\n\nIntel486 DX \nProcessor\n\n1989 25 MHz 1.2 M 32 GP\n80 FPU\n\n32 4 GB L1: 8 KB\n\nPentium Processor 1993 60 MHz 3.1 M 32 GP\n80 FPU\n\n64 4 GB L1:16 KB\n\nPentium Pro \nProcessor\n\n1995 200 MHz 5.5 M 32 GP\n80 FPU\n\n64 64 GB L1: 16 KB\nL2: 256 KB or \n512 KB \n\nPentium II Processor 1997 266 MHz 7 M 32 GP\n80 FPU\n64 MMX\n\n64 64 GB L1: 32 KB\nL2: 256 KB or \n512 KB\n\nPentium III Processor 1999 500 MHz 8.2 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB L1: 32 KB\nL2: 512 KB\n\nPentium III and \nPentium III Xeon \nProcessors\n\n1999 700 MHz 28 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB L1: 32 KB\nL2: 256 KB\n\nPentium 4 Processor 2000 1.50 GHz, Intel \nNetBurst \nMicroarchitecture\n\n42 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB 12K µop \nExecution \nTrace Cache; \nL1: 8KB\nL2: 256 KB\n\nIntel Xeon Processor 2001 1.70 GHz, Intel \nNetBurst \nMicroarchitecture\n\n42 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB 12K µop \nExecution \nTrace Cache; \nL1: 8KB\nL2: 512KB\n\nIntel Xeon Processor 2002 2.20 GHz, Intel \nNetBurst \nMicroarchitecture, \nHyperThreading \nTechnology\n\n55 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB 12K µop \nExecution \nTrace Cache; \nL1: 8KB\nL2: 512KB\n\nPentium M Processor 2003 1.60 GHz, Intel \nNetBurst \nMicroarchitecture\n\n77 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 4 GB L1: 64KB\nL2: 1 MB\nVol. 1 2-27\n\n\n\nINTEL® 64 AND IA-32 ARCHITECTURES\nNOTE:\n1. The register size and external data bus size are given in bits. Note also that each 32-bit general-purpose (GP) registers can be \n\naddressed as an 8- or a 16-bit data registers in all of the processors.\n2. Internal data paths are 2 to 4 times wider than the external data bus for each processor.\n\n2.4 PROPOSED REMOVAL OF INTEL INSTRUCTION SET ARCHITECTURE AND \nFEATURES FROM UPCOMING PRODUCTS\n\nThis section lists Intel Instruction Set Architecture (ISA) and features that Intel plans to remove from select prod-\nucts starting from a specific year.\n\n2.5 INTEL INSTRUCTION SET ARCHITECTURE AND FEATURES REMOVED\nThis section lists Intel ISA and features that Intel has already removed for select upcoming products. All sections \nrelevant to the removed features will be identified as such and may be moved to an archived section in future \nIntel® 64 and IA-32 Architectures Software Developer's Manual releases.\n\nIntel Pentium 4\nProcessor \nSupporting Hyper-\nThreading \nTechnology at 90 nm \nprocess\n\n2004 3.40 GHz, Intel \nNetBurst \nMicroarchitecture, \nHyperThreading \nTechnology\n\n125 M 32 GP\n80 FPU\n64 MMX\n128 XMM\n\n64 64 GB 12K µop \nExecution \nTrace Cache; \nL1: 16KB\nL2: 1 MB\n\nTable 2-4.  Proposed Intel ISA and Features Removal List \n\nIntel ISA/Feature Year of Removal\n\nNA NA\n\nTable 2-5.  Intel ISA and Features Removal List \n\nIntel ISA/Feature Year of Removal\n\nIntel® Memory Protection Extensions (Intel® MPX) 2019 onwards\n\n MSR_TEST_CTRL, bit 31 (MSR address 33H) 2019 onwards\n\nHardware Lock Elision (HLE) 2019 onwards\n\nTable 2-3.  Key Features of Previous Generations of IA-32 Processors (Contd.)\n2-28 Vol. 1\n\n\n\nCHAPTER 3\nBASIC EXECUTION ENVIRONMENT\n\nThis chapter describes the basic execution environment of an Intel 64 or IA-32 processor as seen by assembly-\nlanguage programmers. It describes how the processor executes instructions and how it stores and manipulates \ndata. The execution environment described here includes memory (the address space), general-purpose data \nregisters, segment registers, the flag register, and the instruction pointer register.\n\n3.1 MODES OF OPERATION\nThe IA-32 architecture supports three basic operating modes: protected mode, real-address mode, and system \nmanagement mode. The operating mode determines which instructions and architectural features are accessible:\n• Protected mode — This mode is the native state of the processor. Among the capabilities of protected mode \n\nis the ability to directly execute “real-address mode” 8086 software in a protected, multi-tasking environment. \nThis feature is called virtual-8086 mode, although it is not actually a processor mode. Virtual-8086 mode is \nactually a protected mode attribute that can be enabled for any task. \n\n• Real-address mode — This mode implements the programming environment of the Intel 8086 processor with \nextensions (such as the ability to switch to protected or system management mode). The processor is placed in \nreal-address mode following power-up or a reset.\n\n• System management mode (SMM) — This mode provides an operating system or executive with a \ntransparent mechanism for implementing platform-specific functions such as power management and system \nsecurity. The processor enters SMM when the external SMM interrupt pin (SMI#) is activated or an SMI is \nreceived from the advanced programmable interrupt controller (APIC). \nIn SMM, the processor switches to a separate address space while saving the basic context of the currently \nrunning program or task. SMM-specific code may then be executed transparently. Upon returning from SMM, \nthe processor is placed back into its state prior to the system management interrupt. SMM was introduced with \nthe Intel386™ SL and Intel486™ SL processors and became a standard IA-32 feature with the Pentium \nprocessor family. \n\n3.1.1 Intel® 64 Architecture\nIntel 64 architecture adds IA-32e mode. IA-32e mode has two sub-modes.\nThese are:\n• Compatibility mode (sub-mode of IA-32e mode) — Compatibility mode permits most legacy 16-bit and \n\n32-bit applications to run without re-compilation under a 64-bit operating system. For brevity, the compatibility \nsub-mode is referred to as compatibility mode in IA-32 architecture. The execution environment of compati-\nbility mode is the same as described in Section 3.2. Compatibility mode also supports all of the privilege levels \nthat are supported in 64-bit and protected modes. Legacy applications that run in Virtual 8086 mode or use \nhardware task management will not work in this mode. \nCompatibility mode is enabled by the operating system (OS) on a code segment basis. This means that a single \n64-bit OS can support 64-bit applications running in 64-bit mode and support legacy 32-bit applications (not \nrecompiled for 64-bits) running in compatibility mode.\nCompatibility mode is similar to 32-bit protected mode. Applications access only the first 4 GByte of linear-\naddress space. Compatibility mode uses 16-bit and 32-bit address and operand sizes. Like protected mode, this \nmode allows applications to access physical memory greater than 4 GByte using PAE (Physical Address Exten-\nsions). \n\n• 64-bit mode (sub-mode of IA-32e mode) — This mode enables a 64-bit operating system to run applica-\ntions written to access 64-bit linear address space. For brevity, the 64-bit sub-mode is referred to as 64-bit \nmode in IA-32 architecture.\nVol. 1 3-1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n64-bit mode extends the number of general purpose registers and SIMD extension registers from 8 to 16. \nGeneral purpose registers are widened to 64 bits. The mode also introduces a new opcode prefix (REX) to \naccess the register extensions. See Section 3.2.1 for a detailed description.\n64-bit mode is enabled by the operating system on a code-segment basis. Its default address size is 64 bits and \nits default operand size is 32 bits. The default operand size can be overridden on an instruction-by-instruction \nbasis using a REX opcode prefix in conjunction with an operand size override prefix. \nREX prefixes allow a 64-bit operand to be specified when operating in 64-bit mode. By using this mechanism, \nmany existing instructions have been promoted to allow the use of 64-bit registers and 64-bit addresses.\n\n3.2 OVERVIEW OF THE BASIC EXECUTION ENVIRONMENT\nAny program or task running on an IA-32 processor is given a set of resources for executing instructions and for \nstoring code, data, and state information. These resources (described briefly in the following paragraphs and \nshown in Figure 3-1) make up the basic execution environment for an IA-32 processor. \n\nAn Intel 64 processor supports the basic execution environment of an IA-32 processor, and a similar environment \nunder IA-32e mode that can execute 64-bit programs (64-bit sub-mode) and 32-bit programs (compatibility sub-\nmode). \n\nThe basic execution environment is used jointly by the application programs and the operating system or executive \nrunning on the processor.\n• Address space — Any task or program running on an IA-32 processor can address a linear address space of \n\nup to 4 GBytes (232 bytes) and a physical address space of up to 64 GBytes (236 bytes). See Section 3.3.6, \n“Extended Physical Addressing in Protected Mode,” for more information about addressing an address space \ngreater than 4 GBytes.\n\n• Basic program execution registers — The eight general-purpose registers, the six segment registers, the \nEFLAGS register, and the EIP (instruction pointer) register comprise a basic execution environment in which to \nexecute a set of general-purpose instructions. These instructions perform basic integer arithmetic on byte, \nword, and doubleword integers, handle program flow control, operate on bit and byte strings, and address \nmemory. See Section 3.4, “Basic Program Execution Registers,” for more information about these registers.\n\n• x87 FPU registers — The eight x87 FPU data registers, the x87 FPU control register, the status register, the \nx87 FPU instruction pointer register, the x87 FPU operand (data) pointer register, the x87 FPU tag register, and \nthe x87 FPU opcode register provide an execution environment for operating on single-precision, double-\nprecision, and double extended-precision floating-point values, word integers, doubleword integers, quadword \nintegers, and binary coded decimal (BCD) values. See Section 8.1, “x87 FPU Execution Environment,” for more \ninformation about these registers.\n\n• MMX registers — The eight MMX registers support execution of single-instruction, multiple-data (SIMD) \noperations on 64-bit packed byte, word, and doubleword integers. See Section 9.2, “The MMX Technology \nProgramming Environment,” for more information about these registers.\n\n• XMM registers — The eight XMM data registers and the MXCSR register support execution of SIMD operations \non 128-bit packed single-precision and double-precision floating-point values and on 128-bit packed byte, \nword, doubleword, and quadword integers. See Section 10.2, “SSE Programming Environment,” for more \ninformation about these registers.\n\n• YMM registers — The YMM data registers support execution of 256-bit SIMD operations on 256-bit packed \nsingle-precision and double-precision floating-point values and on 256-bit packed byte, word, doubleword, and \nquadword integers. \n\n• Bounds registers — Each of the BND0-BND3 register stores the lower and upper bounds (64 bits each) \nassociated with the pointer to a memory buffer. They support execution of the Intel MPX instructions. \n\n• BNDCFGU and BNDSTATUS— BNDCFGU configures user mode MPX operations on bounds checking. \nBNDSTATUS provides additional information on the #BR caused by an MPX operation.\n3-2 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nFigure 3-1.  IA-32 Basic Execution Environment for Non-64-bit Modes\n\n0\n\n2^32 -1\nEight 32-bit\n\n32-bits\n\n32-bits\n\nGeneral-Purpose Registers\n\nSegment Registers\n\nEFLAGS Register\n\nEIP (Instruction Pointer Register)\n\nAddress Space*\n\n*The address space can be\n\nSix 16-bit\nRegisters\n\nRegisters\n\nEight 80-bit\nRegisters\n\nFloating-Point\nData Registers\n\nEight 64-bit\nRegisters MMX Registers\n\nflat or segmented. Using\n\nXMM Registers\nEight 128-bit\n\nRegisters\n\n16 bits Control Register\n\n16 bits Status Register\n\n48 bits FPU Instruction Pointer Register\n\n48 bits FPU Data (Operand) Pointer Register\n\nFPU Registers\n\nMMX Registers\n\nXMM Registers\n\n32-bits MXCSR Register\n\nOpcode Register (11-bits)\n\nBasic Program Execution Registers\n\n16 bits Tag Register\n\nthe physical address\nextension mechanism, a\nphysical address space of\n2^36 - 1 can be addressed.\n\nYMM Registers\nEight 256-bit\n\nRegisters\n\nYMM Registers\n\nFour 128-bit Registers\n\nBounds Registers\n\nBNDCFGU BNDSTATUS\nVol. 1 3-3\n\n\n\nBASIC EXECUTION ENVIRONMENT\n• Stack — To support procedure or subroutine calls and the passing of parameters between procedures or \nsubroutines, a stack and stack management resources are included in the execution environment. The stack \n(not shown in Figure 3-1) is located in memory. See Section 6.2, “Stacks,” for more information about stack \nstructure.\n\nIn addition to the resources provided in the basic execution environment, the IA-32 architecture provides the \nfollowing resources as part of its system-level architecture. They provide extensive support for operating-system \nand system-development software. Except for the I/O ports, the system resources are described in detail in the \nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 3A & 3B.\n• I/O ports — The IA-32 architecture supports a transfers of data to and from input/output (I/O) ports. See \n\nChapter 19, “Input/Output,” in this volume.\n• Control registers — The five control registers (CR0 through CR4) determine the operating mode of the \n\nprocessor and the characteristics of the currently executing task. See Chapter 2, “System Architecture \nOverview,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\n\n• Memory management registers — The GDTR, IDTR, task register, and LDTR specify the locations of data \nstructures used in protected mode memory management. See Chapter 2, “System Architecture Overview,” in \nthe Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\n\n• Debug registers — The debug registers (DR0 through DR7) control and allow monitoring of the processor’s \ndebugging operations. See in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3B.\n\n• Memory type range registers (MTRRs) — The MTRRs are used to assign memory types to regions of \nmemory. See the sections on MTRRs in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolumes 3A & 3B.\n\n• Model-specific registers (MSRs) — The processor provides a variety of model-specific registers that are \nused to control and report on processor performance. Virtually all MSRs handle system related functions and \nare not accessible to an application program. One exception to this rule is the time-stamp counter. The MSRs \nare described in Chapter 2, “Model-Specific Registers (MSRs)” of the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volume 4.\n\n• Machine check registers — The machine check registers consist of a set of control, status, and error-\nreporting MSRs that are used to detect and report on hardware (machine) errors. See Chapter 15, “Machine-\nCheck Architecture,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 3A.\n\n• Performance monitoring counters — The performance monitoring counters allow processor performance \nevents to be monitored. See Chapter 18, “Performance Monitoring,” in the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volume 3B.\n\nThe remainder of this chapter describes the organization of memory and the address space, the basic program \nexecution registers, and addressing modes. Refer to the following chapters in this volume for descriptions of the \nother program execution resources shown in Figure 3-1:\n• x87 FPU registers — See Chapter 8, “Programming with the x87 FPU.”\n• MMX Registers — See Chapter 9, “Programming with Intel® MMX™ Technology.”\n• XMM registers — See Chapter 10, “Programming with Intel® Streaming SIMD Extensions (Intel® SSE),” \n\nChapter 11, “Programming with Intel® Streaming SIMD Extensions 2 (Intel® SSE2),” and Chapter 12, \n“Programming with Intel® SSE3, SSSE3, Intel® SSE4 and Intel® AESNI.”\n\n• YMM registers — See Chapter 14, “Programming with AVX, FMA and AVX2”. \n• BND registers, BNDCFGU, BNDSTATUS — See Chapter 13, “Managing State Using the XSAVE Feature Set,” \n\nand Chapter 17, “Intel® MPX”. \n• Stack implementation and procedure calls — See Chapter 6, “Procedure Calls, Interrupts, and Exceptions.”\n3-4 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.2.1 64-Bit Mode Execution Environment\nThe execution environment for 64-bit mode is similar to that described in Section 3.2. The following paragraphs \ndescribe the differences that apply. \n• Address space — A task or program running in 64-bit mode on an IA-32 processor can address linear address \n\nspace of up to 264 bytes (subject to the canonical addressing requirement described in Section 3.3.7.1) and \nphysical address space of up to 252 bytes. Software can query CPUID for the physical address size supported \nby a processor.\n\n• Basic program execution registers — The number of general-purpose registers (GPRs) available is 16. \nGPRs are 64-bits wide and they support operations on byte, word, doubleword and quadword integers. \nAccessing byte registers is done uniformly to the lowest 8 bits. The instruction pointer register becomes 64 bits. \nThe EFLAGS register is extended to 64 bits wide, and is referred to as the RFLAGS register. The upper 32 bits \nof RFLAGS is reserved. The lower 32 bits of RFLAGS is the same as EFLAGS. See Figure 3-2.\n\n• XMM registers — There are 16 XMM data registers for SIMD operations. See Section 10.2, “SSE Programming \nEnvironment,” for more information about these registers.\n\n• YMM registers — There are 16 YMM data registers for SIMD operations. See Chapter 14, “Programming with \nAVX, FMA and AVX2” for more information about these registers.\n\n• BND registers, BNDCFGU, BNDSTATUS — See Chapter 13, “Managing State Using the XSAVE Feature Set,” \nand Chapter 17, “Intel® MPX”. \n\n• Stack — The stack pointer size is 64 bits. Stack size is not controlled by a bit in the SS descriptor (as it is in \nnon-64-bit modes) nor can the pointer size be overridden by an instruction prefix.\n\n• Control registers — Control registers expand to 64 bits. A new control register (the task priority register: CR8 \nor TPR) has been added. See Chapter 2, “Intel® 64 and IA-32 Architectures,” in this volume.\n\n• Debug registers — Debug registers expand to 64 bits. See Chapter 17, “Debug, Branch Profile, TSC, and \nIntel® Resource Director Technology (Intel® RDT) Features,” in the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volume 3A.\nVol. 1 3-5\n\n\n\nBASIC EXECUTION ENVIRONMENT\n• Descriptor table registers — The global descriptor table register (GDTR) and interrupt descriptor table \nregister (IDTR) expand to 10 bytes so that they can hold a full 64-bit base address. The local descriptor table \nregister (LDTR) and the task register (TR) also expand to hold a full 64-bit base address.\n\n3.3 MEMORY ORGANIZATION\nThe memory that the processor addresses on its bus is called physical memory. Physical memory is organized as \na sequence of 8-bit bytes. Each byte is assigned a unique address, called a physical address. The physical \naddress space ranges from zero to a maximum of 236 − 1 (64 GBytes) if the processor does not support Intel \n64 architecture. Intel 64 architecture introduces a set of changes in physical and linear address space; these \nare described in Section 3.3.3, Section 3.3.4, and Section 3.3.7.\n\nFigure 3-2.  64-Bit Mode Execution Environment\n\n0\n\n2^64 -1Sixteen 64-bit\n\n64-bits\n\n64-bits\n\nGeneral-Purpose Registers\n\nSegment Registers\n\nRFLAGS Register\n\nRIP (Instruction Pointer Register)\n\nAddress Space\n\nSix 16-bit\nRegisters\n\nRegisters\n\nEight 80-bit\nRegisters Floating-Point\n\nData Registers\n\nEight 64-bit\nRegisters MMX Registers\n\nXMM Registers\nSixteen 128-bit\n\nRegisters\n\n16 bits Control Register\n\n16 bits Status Register\n\n64 bits FPU Instruction Pointer Register\n\n64 bits FPU Data (Operand) Pointer Register\n\nFPU Registers\n\nMMX Registers\n\nXMM Registers\n\n32-bits MXCSR Register\n\nOpcode Register (11-bits)\n\nBasic Program Execution Registers\n\n16 bits Tag Register\n\nFour 128-bit Registers\n\nBounds Registers\n\nBNDCFGU BNDSTATUS\n\nYMM Registers\nSixteen 256-bit\n\nRegisters\n\nYMM Registers\n3-6 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nVirtually any operating system or executive designed to work with an IA-32 or Intel 64 processor will use the \nprocessor’s memory management facilities to access memory. These facilities provide features such as segmenta-\ntion and paging, which allow memory to be managed efficiently and reliably. Memory management is described in \ndetail in Chapter 3, “Protected-Mode Memory Management,” in the Intel® 64 and IA-32 Architectures Software \nDeveloper’s Manual, Volume 3A. The following paragraphs describe the basic methods of addressing memory when \nmemory management is used.\n\n3.3.1 IA-32 Memory Models\nWhen employing the processor’s memory management facilities, programs do not directly address physical \nmemory. Instead, they access memory using one of three memory models: flat, segmented, or real address mode:\n• Flat memory model — Memory appears to a program as a single, continuous address space (Figure 3-3). This \n\nspace is called a linear address space. Code, data, and stacks are all contained in this address space. Linear \naddress space is byte addressable, with addresses running contiguously from 0 to 232 - 1 (if not in 64-bit \nmode). An address for any byte in linear address space is called a linear address.\n\n• Segmented memory model — Memory appears to a program as a group of independent address spaces \ncalled segments. Code, data, and stacks are typically contained in separate segments. To address a byte in a \nsegment, a program issues a logical address. This consists of a segment selector and an offset (logical \naddresses are often referred to as far pointers). The segment selector identifies the segment to be accessed \nand the offset identifies a byte in the address space of the segment. Programs running on an IA-32 processor \ncan address up to 16,383 segments of different sizes and types, and each segment can be as large as 232 \nbytes.\nInternally, all the segments that are defined for a system are mapped into the processor’s linear address space. \nTo access a memory location, the processor thus translates each logical address into a linear address. This \ntranslation is transparent to the application program.\nThe primary reason for using segmented memory is to increase the reliability of programs and systems. For \nexample, placing a program’s stack in a separate segment prevents the stack from growing into the code or \ndata space and overwriting instructions or data, respectively.\n\n• Real-address mode memory model — This is the memory model for the Intel 8086 processor. It is \nsupported to provide compatibility with existing programs written to run on the Intel 8086 processor. The real-\naddress mode uses a specific implementation of segmented memory in which the linear address space for the \nprogram and the operating system/executive consists of an array of segments of up to 64 KBytes in size each. \nThe maximum size of the linear address space in real-address mode is 220 bytes. \nSee also: Chapter 19, “8086 Emulation,” Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 3B.\nVol. 1 3-7\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.3.2 Paging and Virtual Memory\nWith the flat or the segmented memory model, linear address space is mapped into the processor’s physical \naddress space either directly or through paging. When using direct mapping (paging disabled), each linear address \nhas a one-to-one correspondence with a physical address. Linear addresses are sent out on the processor’s address \nlines without translation. \n\nWhen using the IA-32 architecture’s paging mechanism (paging enabled), linear address space is divided into \npages which are mapped to virtual memory. The pages of virtual memory are then mapped as needed into physical \nmemory. When an operating system or executive uses paging, the paging mechanism is transparent to an applica-\ntion program. All that the application sees is linear address space.\n\nIn addition, IA-32 architecture’s paging mechanism includes extensions that support:\n• Physical Address Extensions (PAE) to address physical address space greater than 4 GBytes.\n• Page Size Extensions (PSE) to map linear address to physical address in 4-MBytes pages.\n\nSee also: Chapter 3, “Protected-Mode Memory Management,” in the Intel® 64 and IA-32 Architectures Software \nDeveloper’s Manual, Volume 3A.\n\n3.3.3 Memory Organization in 64-Bit Mode\nIntel 64 architecture supports physical address space greater than 64 GBytes; the actual physical address size of \nIA-32 processors is implementation specific. In 64-bit mode, there is architectural support for 64-bit linear address \nspace. However, processors supporting Intel 64 architecture may implement less than 64-bits (see Section \n3.3.7.1). The linear address space is mapped into the processor physical address space through the PAE paging \nmechanism.\n\nFigure 3-3.  Three Memory Management Models\n\nLinear Address\n\nFlat Model\n\nLinear\nAddress\nSpace*\n\nSegment Selector\n\nOffset\n\nSegment Selector\n\nSegmented Model\n\nReal-Address Mode Model\n\nLinear Address\n\nLogical\n\nOffset (effective address)\n\nSpace Divided\nInto Equal\n\nSized Segments\n\nAddress\n\nLogical\nAddress\n\nLinear\nAddress\n\nSpace*\n\nSegments\n\n* The linear address space\ncan be paged when using the \nflat or segmented model.\n3-8 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.3.4 Modes of Operation vs. Memory Model\nWhen writing code for an IA-32 or Intel 64 processor, a programmer needs to know the operating mode the \nprocessor is going to be in when executing the code and the memory model being used. The relationship between \noperating modes and memory models is as follows:\n• Protected mode — When in protected mode, the processor can use any of the memory models described in \n\nthis section. (The real-addressing mode memory model is ordinarily used only when the processor is in the \nvirtual-8086 mode.) The memory model used depends on the design of the operating system or executive. \nWhen multitasking is implemented, individual tasks can use different memory models.\n\n• Real-address mode — When in real-address mode, the processor only supports the real-address mode \nmemory model.\n\n• System management mode — When in SMM, the processor switches to a separate address space, called the \nsystem management RAM (SMRAM). The memory model used to address bytes in this address space is similar \nto the real-address mode model. See Chapter 30, “System Management Mode,” in the Intel® 64 and IA-32 \nArchitectures Software Developer’s Manual, Volume 3C, for more information on the memory model used in \nSMM.\n\n• Compatibility mode — Software that needs to run in compatibility mode should observe the same memory \nmodel as those targeted to run in 32-bit protected mode. The effect of segmentation is the same as it is in 32-\nbit protected mode semantics.\n\n• 64-bit mode — Segmentation is generally (but not completely) disabled, creating a flat 64-bit linear-address \nspace. Specifically, the processor treats the segment base of CS, DS, ES, and SS as zero in 64-bit mode (this \nmakes a linear address equal an effective address). Segmented and real address modes are not available in 64-\nbit mode.\n\n3.3.5 32-Bit and 16-Bit Address and Operand Sizes\nIA-32 processors in protected mode can be configured for 32-bit or 16-bit address and operand sizes. With 32-bit \naddress and operand sizes, the maximum linear address or segment offset is FFFFFFFFH (232-1); operand sizes are \ntypically 8 bits or 32 bits. With 16-bit address and operand sizes, the maximum linear address or segment offset is \nFFFFH (216-1); operand sizes are typically 8 bits or 16 bits. \n\nWhen using 32-bit addressing, a logical address (or far pointer) consists of a 16-bit segment selector and a 32-bit \noffset; when using 16-bit addressing, an address consists of a 16-bit segment selector and a 16-bit offset. \n\nInstruction prefixes allow temporary overrides of the default address and/or operand sizes from within a program.\n\nWhen operating in protected mode, the segment descriptor for the currently executing code segment defines the \ndefault address and operand size. A segment descriptor is a system data structure not normally visible to applica-\ntion code. Assembler directives allow the default addressing and operand size to be chosen for a program. The \nassembler and other tools then set up the segment descriptor for the code segment appropriately.\n\nWhen operating in real-address mode, the default addressing and operand size is 16 bits. An address-size override \ncan be used in real-address mode to enable 32-bit addressing. However, the maximum allowable 32-bit linear \naddress is still 000FFFFFH (220-1).\n\n3.3.6 Extended Physical Addressing in Protected Mode\nBeginning with P6 family processors, the IA-32 architecture supports addressing of up to 64 GBytes (236 bytes) of \nphysical memory. A program or task could not address locations in this address space directly. Instead, it \naddresses individual linear address spaces of up to 4 GBytes that mapped to 64-GByte physical address space \nthrough a virtual memory management mechanism. Using this mechanism, an operating system can enable a \nprogram to switch 4-GByte linear address spaces within 64-GByte physical address space.\n\nThe use of extended physical addressing requires the processor to operate in protected mode and the operating \nsystem to provide a virtual memory management system. See “36-Bit Physical Addressing Using the PAE Paging \nMechanism” in Chapter 3, “Protected-Mode Memory Management,” of the Intel® 64 and IA-32 Architectures Soft-\nware Developer’s Manual, Volume 3A.\nVol. 1 3-9\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.3.7 Address Calculations in 64-Bit Mode\nIn most cases, 64-bit mode uses flat address space for code, data, and stacks. In 64-bit mode (if there is no \naddress-size override), the size of effective address calculations is 64 bits. An effective-address calculation uses a \n64-bit base and index registers and sign-extend displacements to 64 bits.\n\nIn the flat address space of 64-bit mode, linear addresses are equal to effective addresses because the base \naddress is zero. In the event that FS or GS segments are used with a non-zero base, this rule does not hold. In 64-\nbit mode, the effective address components are added and the effective address is truncated (See for example the \ninstruction LEA) before adding the full 64-bit segment base. The base is never truncated, regardless of addressing \nmode in 64-bit mode.\n\nThe instruction pointer is extended to 64 bits to support 64-bit code offsets. The 64-bit instruction pointer is called \nthe RIP. Table 3-1 shows the relationship between RIP, EIP, and IP.\n\nTable 3-1.  Instruction Pointer Sizes\n\nGenerally, displacements and immediates in 64-bit mode are not extended to 64 bits. They are still limited to 32 \nbits and sign-extended during effective-address calculations. In 64-bit mode, however, support is provided for 64-\nbit displacement and immediate forms of the MOV instruction. \n\nAll 16-bit and 32-bit address calculations are zero-extended in IA-32e mode to form 64-bit addresses. Address \ncalculations are first truncated to the effective address size of the current mode (64-bit mode or compatibility \nmode), as overridden by any address-size prefix. The result is then zero-extended to the full 64-bit address width. \nBecause of this, 16-bit and 32-bit applications running in compatibility mode can access only the low 4 GBytes of \nthe 64-bit mode effective addresses. Likewise, a 32-bit address generated in 64-bit mode can access only the low \n4 GBytes of the 64-bit mode effective addresses.\n\n3.3.7.1  Canonical Addressing\nIn 64-bit mode, an address is considered to be in canonical form if address bits 63 through to the most-significant \nimplemented bit by the microarchitecture are set to either all ones or all zeros.\n\nIntel 64 architecture defines a 64-bit linear address. Implementations can support less. The first implementation of \nIA-32 processors with Intel 64 architecture supports a 48-bit linear address. This means a canonical address must \nhave bits 63 through 48 set to zeros or ones (depending on whether bit 47 is a zero or one).\n\nAlthough implementations may not use all 64 bits of the linear address, they should check bits 63 through the \nmost-significant implemented bit to see if the address is in canonical form. If a linear-memory reference is not in \ncanonical form, the implementation should generate an exception. In most cases, a general-protection exception \n(#GP) is generated. However, in the case of explicit or implied stack references, a stack fault (#SS) is generated. \n\nInstructions that have implied stack references, by default, use the SS segment register. These include PUSH/POP-\nrelated instructions and instructions using RSP/RBP as base registers. In these cases, the canonical fault is #SS. \n\nIf an instruction uses base registers RSP/RBP and uses a segment override prefix to specify a non-SS segment, a \ncanonical fault generates a #GP (instead of an #SS). In 64-bit mode, only FS and GS segment-overrides are appli-\ncable in this situation. Other segment override prefixes (CS, DS, ES and SS) are ignored. Note that this also means \nthat an SS segment-override applied to a “non-stack” register reference is ignored. Such a sequence still produces \na #GP for a canonical fault (and not an #SS).\n\n3.4 BASIC PROGRAM EXECUTION REGISTERS\nIA-32 architecture provides 16 basic program execution registers for use in general system and application \nprograming (see Figure 3-4). These registers can be grouped as follows:\n\nBits 63:32 Bits 31:16 Bits 15:0\n\n16-bit instruction pointer Not Modified IP\n\n32-bit instruction pointer Zero Extension EIP\n\n64-bit instruction pointer RIP\n3-10 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n• General-purpose registers. These eight registers are available for storing operands and pointers.\n• Segment registers. These registers hold up to six segment selectors.\n• EFLAGS (program status and control) register. The EFLAGS register report on the status of the program \n\nbeing executed and allows limited (application-program level) control of the processor. \n• EIP (instruction pointer) register. The EIP register contains a 32-bit pointer to the next instruction to be \n\nexecuted. \n\n3.4.1 General-Purpose Registers\nThe 32-bit general-purpose registers EAX, EBX, ECX, EDX, ESI, EDI, EBP, and ESP are provided for holding the \nfollowing items:\n• Operands for logical and arithmetic operations\n• Operands for address calculations\n• Memory pointers\n\nAlthough all of these registers are available for general storage of operands, results, and pointers, caution should \nbe used when referencing the ESP register. The ESP register holds the stack pointer and as a general rule should \nnot be used for another purpose. \n\nMany instructions assign specific registers to hold operands. For example, string instructions use the contents of \nthe ECX, ESI, and EDI registers as operands. When using a segmented memory model, some instructions assume \nthat pointers in certain registers are relative to specific segments. For instance, some instructions assume that a \npointer in the EBX register points to a memory location in the DS segment. \n\nFigure 3-4.  General System and Application Programming Registers\n\n031\nEAX\nEBX\nECX\n\nEDX\nESI\n\nEDI\nEBP\n\nESP\n\nSegment Registers\n\nCS\n\nDS\nSS\n\nES\nFS\n\nGS\n\n015\n\n031\nEFLAGS\n\nEIP\n31 0\n\nGeneral-Purpose Registers\n\nProgram Status and Control Register\n\nInstruction Pointer\nVol. 1 3-11\n\n\n\nBASIC EXECUTION ENVIRONMENT\nThe special uses of general-purpose registers by instructions are described in Chapter 5, “Instruction Set \nSummary,” in this volume. See also: Chapter 3, Chapter 4 and Chapter 5 of Intel® 64 and IA-32 Architectures Soft-\nware Developer’s Manual, Volumes 2A, 2B & 2C. The following is a summary of special uses:\n• EAX — Accumulator for operands and results data\n• EBX — Pointer to data in the DS segment\n• ECX — Counter for string and loop operations\n• EDX — I/O pointer\n• ESI — Pointer to data in the segment pointed to by the DS register; source pointer for string operations\n• EDI — Pointer to data (or destination) in the segment pointed to by the ES register; destination pointer for \n\nstring operations\n• ESP — Stack pointer (in the SS segment)\n• EBP — Pointer to data on the stack (in the SS segment)\n\nAs shown in Figure 3-5, the lower 16 bits of the general-purpose registers map directly to the register set found in \nthe 8086 and Intel 286 processors and can be referenced with the names AX, BX, CX, DX, BP, SI, DI, and SP. Each \nof the lower two bytes of the EAX, EBX, ECX, and EDX registers can be referenced by the names AH, BH, CH, and \nDH (high bytes) and AL, BL, CL, and DL (low bytes).\n\n3.4.1.1  General-Purpose Registers in 64-Bit Mode\nIn 64-bit mode, there are 16 general purpose registers and the default operand size is 32 bits. However, general-\npurpose registers are able to work with either 32-bit or 64-bit operands. If a 32-bit operand size is specified: EAX, \nEBX, ECX, EDX, EDI, ESI, EBP, ESP, R8D - R15D are available. If a 64-bit operand size is specified: RAX, RBX, RCX, \nRDX, RDI, RSI, RBP, RSP, R8-R15 are available. R8D-R15D/R8-R15 represent eight new general-purpose registers. \nAll of these registers can be accessed at the byte, word, dword, and qword level. REX prefixes are used to generate \n64-bit operand sizes or to reference registers R8-R15.\n\nRegisters only available in 64-bit mode (R8-R15 and XMM8-XMM15) are preserved across transitions from 64-bit \nmode into compatibility mode then back into 64-bit mode. However, values of R8-R15 and XMM8-XMM15 are unde-\nfined after transitions from 64-bit mode through compatibility mode to legacy or real mode and then back through \ncompatibility mode to 64-bit mode.\n\nFigure 3-5.  Alternate General-Purpose Register Names\n\n071531 16 8\n\nAH AL\n\nBH BL\n\nCH CL\n\nDH DL\n\nBP\n\nSI\n\nDI\n\nSP\n\n16-bit\n\nAX\n\nDX\n\nCX\n\nBX\n\n32-bit\n\nEAX\n\nEBX\n\nECX\n\nEDX\n\nEBP\n\nESI\n\nESP\n\nGeneral-Purpose Registers\n\nEDI\n3-12 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nIn 64-bit mode, there are limitations on accessing byte registers. An instruction cannot reference legacy high-\nbytes (for example: AH, BH, CH, DH) and one of the new byte registers at the same time (for example: the low \nbyte of the RAX register). However, instructions may reference legacy low-bytes (for example: AL, BL, CL or DL) \nand new byte registers at the same time (for example: the low byte of the R8 register, or RBP). The architecture \nenforces this limitation by changing high-byte references (AH, BH, CH, DH) to low byte references (BPL, SPL, DIL, \nSIL: the low 8 bits for RBP, RSP, RDI and RSI) for instructions using a REX prefix.\n\nWhen in 64-bit mode, operand size determines the number of valid bits in the destination general-purpose \nregister: \n• 64-bit operands generate a 64-bit result in the destination general-purpose register.\n• 32-bit operands generate a 32-bit result, zero-extended to a 64-bit result in the destination general-purpose \n\nregister.\n• 8-bit and 16-bit operands generate an 8-bit or 16-bit result. The upper 56 bits or 48 bits (respectively) of the \n\ndestination general-purpose register are not modified by the operation. If the result of an 8-bit or 16-bit \noperation is intended for 64-bit address calculation, explicitly sign-extend the register to the full 64-bits. \n\nBecause the upper 32 bits of 64-bit general-purpose registers are undefined in 32-bit modes, the upper 32 bits of \nany general-purpose register are not preserved when switching from 64-bit mode to a 32-bit mode (to protected \nmode or compatibility mode). Software must not depend on these bits to maintain a value after a 64-bit to 32-bit \nmode switch.\n\n3.4.2 Segment Registers\nThe segment registers (CS, DS, SS, ES, FS, and GS) hold 16-bit segment selectors. A segment selector is a special \npointer that identifies a segment in memory. To access a particular segment in memory, the segment selector for \nthat segment must be present in the appropriate segment register.\n\nWhen writing application code, programmers generally create segment selectors with assembler directives and \nsymbols. The assembler and other tools then create the actual segment selector values associated with these \ndirectives and symbols. If writing system code, programmers may need to create segment selectors directly. See \nChapter 3, “Protected-Mode Memory Management,” in the Intel® 64 and IA-32 Architectures Software Developer’s \nManual, Volume 3A.\n\nHow segment registers are used depends on the type of memory management model that the operating system or \nexecutive is using. When using the flat (unsegmented) memory model, segment registers are loaded with segment \nselectors that point to overlapping segments, each of which begins at address 0 of the linear address space (see \nFigure 3-6). These overlapping segments then comprise the linear address space for the program. Typically, two \noverlapping segments are defined: one for code and another for data and stacks. The CS segment register points \nto the code segment and all the other segment registers point to the data and stack segment.\n\nWhen using the segmented memory model, each segment register is ordinarily loaded with a different segment \nselector so that each segment register points to a different segment within the linear address space (see \nFigure 3-7). At any time, a program can thus access up to six segments in the linear address space. To access a \nsegment not pointed to by one of the segment registers, a program must first load the segment selector for the \nsegment to be accessed into a segment register.\n\nTable 3-2.  Addressable General Purpose Registers\nRegister Type Without REX With REX\n\nByte Registers AL, BL, CL, DL, AH, BH, CH, DH AL, BL, CL, DL, DIL, SIL, BPL, SPL, R8B - R15B\n\nWord Registers AX, BX, CX, DX, DI, SI, BP, SP AX, BX, CX, DX, DI, SI, BP, SP, R8W - R15W\n\nDoubleword Registers EAX, EBX, ECX, EDX, EDI, ESI, EBP, ESP EAX, EBX, ECX, EDX, EDI, ESI, EBP, ESP, R8D - R15D\n\nQuadword Registers N.A. RAX, RBX, RCX, RDX, RDI, RSI, RBP, RSP, R8 - R15\nVol. 1 3-13\n\n\n\nBASIC EXECUTION ENVIRONMENT\nEach of the segment registers is associated with one of three types of storage: code, data, or stack. For example, \nthe CS register contains the segment selector for the code segment, where the instructions being executed are \nstored. The processor fetches instructions from the code segment, using a logical address that consists of the \nsegment selector in the CS register and the contents of the EIP register. The EIP register contains the offset within \nthe code segment of the next instruction to be executed. The CS register cannot be loaded explicitly by an applica-\ntion program. Instead, it is loaded implicitly by instructions or internal processor operations that change program \ncontrol (such as procedure calls, interrupt handling, or task switching).\n\nThe DS, ES, FS, and GS registers point to four data segments. The availability of four data segments permits effi-\ncient and secure access to different types of data structures. For example, four separate data segments might be \ncreated: one for the data structures of the current module, another for the data exported from a higher-level \nmodule, a third for a dynamically created data structure, and a fourth for data shared with another program. To \naccess additional data segments, the application program must load segment selectors for these segments into the \nDS, ES, FS, and GS registers, as needed.\n\nThe SS register contains the segment selector for the stack segment, where the procedure stack is stored for the \nprogram, task, or handler currently being executed. All stack operations use the SS register to find the stack \n\nFigure 3-6.  Use of Segment Registers for Flat Memory Model\n\nFigure 3-7.  Use of Segment Registers in Segmented Memory Model\n\nSegment Registers\n\nCS\n\nSS\nDS\n\nES\nFS\nGS\n\nLinear Address\nSpace for Program\n\nThe segment selector in\neach segment register\npoints to an overlapping \n\nOverlapping\nSegments\n\nof up to\n4 GBytes\n\nsegment in the linear\naddress space.\n\nBeginning at\nAddress 0\n\nSegment Registers\n\nCS\nDS\nSS\nES\nFS\nGS\n\nCode\nSegment\n\nData\nSegment\n\nStack\nSegment\n\nData\nSegment\n\nData\nSegment\n\nData\nSegment\n\nAll segments\nare mapped\nto the same\nlinear-address\nspace\n3-14 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nsegment. Unlike the CS register, the SS register can be loaded explicitly, which permits application programs to set \nup multiple stacks and switch among them.\n\nSee Section 3.3, “Memory Organization,” for an overview of how the segment registers are used in real-address \nmode.\n\nThe four segment registers CS, DS, SS, and ES are the same as the segment registers found in the Intel 8086 and \nIntel 286 processors and the FS and GS registers were introduced into the IA-32 Architecture with the Intel386™ \nfamily of processors.\n\n3.4.2.1  Segment Registers in 64-Bit Mode\nIn 64-bit mode: CS, DS, ES, SS are treated as if each segment base is 0, regardless of the value of the associated \nsegment descriptor base. This creates a flat address space for code, data, and stack. FS and GS are exceptions. \nBoth segment registers may be used as additional base registers in linear address calculations (in the addressing \nof local data and certain operating system data structures). \n\nEven though segmentation is generally disabled, segment register loads may cause the processor to perform \nsegment access assists. During these activities, enabled processors will still perform most of the legacy checks on \nloaded values (even if the checks are not applicable in 64-bit mode). Such checks are needed because a segment \nregister loaded in 64-bit mode may be used by an application running in compatibility mode. \n\nLimit checks for CS, DS, ES, SS, FS, and GS are disabled in 64-bit mode.\n\n3.4.3 EFLAGS Register\nThe 32-bit EFLAGS register contains a group of status flags, a control flag, and a group of system flags. Figure 3-8 \ndefines the flags within this register. Following initialization of the processor (either by asserting the RESET pin or \nthe INIT pin), the state of the EFLAGS register is 00000002H. Bits 1, 3, 5, 15, and 22 through 31 of this register \nare reserved. Software should not use or depend on the states of any of these bits.\n\nSome of the flags in the EFLAGS register can be modified directly, using special-purpose instructions (described in \nthe following sections). There are no instructions that allow the whole register to be examined or modified directly. \n\nThe following instructions can be used to move groups of flags to and from the procedure stack or the EAX register: \nLAHF, SAHF, PUSHF, PUSHFD, POPF, and POPFD. After the contents of the EFLAGS register have been transferred to \nthe procedure stack or EAX register, the flags can be examined and modified using the processor’s bit manipulation \ninstructions (BT, BTS, BTR, and BTC).\n\nWhen suspending a task (using the processor’s multitasking facilities), the processor automatically saves the state \nof the EFLAGS register in the task state segment (TSS) for the task being suspended. When binding itself to a new \ntask, the processor loads the EFLAGS register with data from the new task’s TSS.\n\nWhen a call is made to an interrupt or exception handler procedure, the processor automatically saves the state of \nthe EFLAGS registers on the procedure stack. When an interrupt or exception is handled with a task switch, the \nstate of the EFLAGS register is saved in the TSS for the task being suspended.\nVol. 1 3-15\n\n\n\nBASIC EXECUTION ENVIRONMENT\nAs the IA-32 Architecture has evolved, flags have been added to the EFLAGS register, but the function and place-\nment of existing flags have remained the same from one family of the IA-32 processors to the next. As a result, \ncode that accesses or modifies these flags for one family of IA-32 processors works as expected when run on later \nfamilies of processors.\n\n3.4.3.1  Status Flags\nThe status flags (bits 0, 2, 4, 6, 7, and 11) of the EFLAGS register indicate the results of arithmetic instructions, \nsuch as the ADD, SUB, MUL, and DIV instructions. The status flag functions are:\nCF (bit 0) Carry flag — Set if an arithmetic operation generates a carry or a borrow out of the most-\n\nsignificant bit of the result; cleared otherwise. This flag indicates an overflow condition for \nunsigned-integer arithmetic. It is also used in multiple-precision arithmetic.\n\nPF (bit 2) Parity flag — Set if the least-significant byte of the result contains an even number of 1 bits; \ncleared otherwise.\n\nAF (bit 4) Auxiliary Carry flag — Set if an arithmetic operation generates a carry or a borrow out of bit \n3 of the result; cleared otherwise. This flag is used in binary-coded decimal (BCD) arithmetic.\n\nZF (bit 6) Zero flag — Set if the result is zero; cleared otherwise.\nSF (bit 7) Sign flag — Set equal to the most-significant bit of the result, which is the sign bit of a signed \n\ninteger. (0 indicates a positive value and 1 indicates a negative value.)\nOF (bit 11) Overflow flag — Set if the integer result is too large a positive number or too small a negative \n\nnumber (excluding the sign-bit) to fit in the destination operand; cleared otherwise. This flag \nindicates an overflow condition for signed-integer (two’s complement) arithmetic.\n\nOf these status flags, only the CF flag can be modified directly, using the STC, CLC, and CMC instructions. Also the \nbit instructions (BT, BTS, BTR, and BTC) copy a specified bit into the CF flag.\n\nFigure 3-8.  EFLAGS Register\n\n31 2930 28 27 26 25 24 23 22 21 20 19 18 17 16\n\n0 R\nF\n\nI\nD\n\nA\nC\n\nV\nM\n\nX  Virtual-8086 Mode (VM)\nX Resume Flag (RF)\nX Nested Task (NT)\nX  I/O Privilege Level (IOPL)\nS Overflow Flag (OF)\nC Direction Flag (DF)\nX  Interrupt Enable Flag (IF)\n\nX  Alignment Check / Access Control (AC)\n\nX ID Flag (ID)\nX Virtual Interrupt Pending (VIP)\n\n15 1314 12 11 10 9 8 7 6 5 4 3 2 1 0\n\n0 C\nF\n\nA\nF\n\nP\nF 1D\n\nF\nI\nF\n\nT\nF\n\nS\nF\n\nZ\nF\n\nN\nT 000 0 0 0 0 0 0 0 0\n\nV\nI\nP\n\nV\nI\nF\n\nO\nF\n\nI\nO\nP\nL\n\nX  Virtual Interrupt Flag (VIF)\n\nX  Trap Flag (TF)\nS  Sign Flag (SF)\nS  Zero Flag (ZF)\nS  Auxiliary Carry Flag (AF)\nS  Parity Flag (PF)\nS  Carry Flag (CF)\n\nS  Indicates a Status Flag\nC  Indicates a Control Flag\nX  Indicates a System Flag\n\nReserved bit positions. DO NOT USE.\nAlways set to values previously read.\n3-16 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nThe status flags allow a single arithmetic operation to produce results for three different data types: unsigned inte-\ngers, signed integers, and BCD integers. If the result of an arithmetic operation is treated as an unsigned integer, \nthe CF flag indicates an out-of-range condition (carry or a borrow); if treated as a signed integer (two’s comple-\nment number), the OF flag indicates a carry or borrow; and if treated as a BCD digit, the AF flag indicates a carry \nor borrow. The SF flag indicates the sign of a signed integer. The ZF flag indicates either a signed- or an unsigned-\ninteger zero.\n\nWhen performing multiple-precision arithmetic on integers, the CF flag is used in conjunction with the add with \ncarry (ADC) and subtract with borrow (SBB) instructions to propagate a carry or borrow from one computation to \nthe next. \n\nThe condition instructions Jcc (jump on condition code cc), SETcc (byte set on condition code cc), LOOPcc, and \nCMOVcc (conditional move) use one or more of the status flags as condition codes and test them for branch, set-\nbyte, or end-loop conditions.\n\n3.4.3.2  DF Flag\nThe direction flag (DF, located in bit 10 of the EFLAGS register) controls string instructions (MOVS, CMPS, SCAS, \nLODS, and STOS). Setting the DF flag causes the string instructions to auto-decrement (to process strings from \nhigh addresses to low addresses). Clearing the DF flag causes the string instructions to auto-increment \n(process strings from low addresses to high addresses).\n\nThe STD and CLD instructions set and clear the DF flag, respectively.\n\n3.4.3.3  System Flags and IOPL Field\nThe system flags and IOPL field in the EFLAGS register control operating-system or executive operations. They \nshould not be modified by application programs. The functions of the system flags are as follows:\nTF (bit 8) Trap flag — Set to enable single-step mode for debugging; clear to disable single-step mode.\nIF (bit 9) Interrupt enable flag — Controls the response of the processor to maskable interrupt \n\nrequests. Set to respond to maskable interrupts; cleared to inhibit maskable interrupts.\nIOPL (bits 12 and 13)\n\nI/O privilege level field — Indicates the I/O privilege level of the currently running program \nor task. The current privilege level (CPL) of the currently running program or task must be less \nthan or equal to the I/O privilege level to access the I/O address space. The POPF and IRET \ninstructions can modify this field only when operating at a CPL of 0.\n\nNT (bit 14) Nested task flag — Controls the chaining of interrupted and called tasks. Set when the \ncurrent task is linked to the previously executed task; cleared when the current task is not \nlinked to another task.\n\nRF (bit 16) Resume flag — Controls the processor’s response to debug exceptions.\nVM (bit 17) Virtual-8086 mode flag — Set to enable virtual-8086 mode; clear to return to protected \n\nmode without virtual-8086 mode semantics.\nAC (bit 18) Alignment check (or access control) flag — If the AM bit is set in the CR0 register, align-\n\nment checking of user-mode data accesses is enabled if and only if this flag is 1.\nIf the SMAP bit is set in the CR4 register, explicit supervisor-mode data accesses to user-mode \npages are allowed if and only if this bit is 1. See Section 4.6, “Access Rights,” in the Intel® 64 \nand IA-32 Architectures Software Developer’s Manual, Volume 3A.\n\nVIF (bit 19) Virtual interrupt flag — Virtual image of the IF flag. Used in conjunction with the VIP flag. \n(To use this flag and the VIP flag the virtual mode extensions are enabled by setting the VME \nflag in control register CR4.)\n\nVIP (bit 20) Virtual interrupt pending flag — Set to indicate that an interrupt is pending; clear when no \ninterrupt is pending. (Software sets and clears this flag; the processor only reads it.) Used in \nconjunction with the VIF flag.\n\nID (bit 21) Identification flag — The ability of a program to set or clear this flag indicates support for \nthe CPUID instruction.\nVol. 1 3-17\n\n\n\nBASIC EXECUTION ENVIRONMENT\nFor a detailed description of these flags: see Chapter 3, “Protected-Mode Memory Management,” in the Intel® 64 \nand IA-32 Architectures Software Developer’s Manual, Volume 3A. \n\n3.4.3.4  RFLAGS Register in 64-Bit Mode\nIn 64-bit mode, EFLAGS is extended to 64 bits and called RFLAGS. The upper 32 bits of RFLAGS register is \nreserved. The lower 32 bits of RFLAGS is the same as EFLAGS.\n\n3.5 INSTRUCTION POINTER\nThe instruction pointer (EIP) register contains the offset in the current code segment for the next instruction to be \nexecuted. It is advanced from one instruction boundary to the next in straight-line code or it is moved ahead or \nbackwards by a number of instructions when executing JMP, Jcc, CALL, RET, and IRET instructions. \n\nThe EIP register cannot be accessed directly by software; it is controlled implicitly by control-transfer instructions \n(such as JMP, Jcc, CALL, and RET), interrupts, and exceptions. The only way to read the EIP register is to execute a \nCALL instruction and then read the value of the return instruction pointer from the procedure stack. The EIP \nregister can be loaded indirectly by modifying the value of a return instruction pointer on the procedure stack and \nexecuting a return instruction (RET or IRET). See Section 6.2.4.2, “Return Instruction Pointer.”\n\nAll IA-32 processors prefetch instructions. Because of instruction prefetching, an instruction address read from the \nbus during an instruction load does not match the value in the EIP register. Even though different processor gener-\nations use different prefetching mechanisms, the function of the EIP register to direct program flow remains fully \ncompatible with all software written to run on IA-32 processors.\n\n3.5.1 Instruction Pointer in 64-Bit Mode\nIn 64-bit mode, the RIP register becomes the instruction pointer. This register holds the 64-bit offset of the next \ninstruction to be executed. 64-bit mode also supports a technique called RIP-relative addressing. Using this tech-\nnique, the effective address is determined by adding a displacement to the RIP of the next instruction.\n\n3.6 OPERAND-SIZE AND ADDRESS-SIZE ATTRIBUTES\nWhen the processor is executing in protected mode, every code segment has a default operand-size attribute and \naddress-size attribute. These attributes are selected with the D (default size) flag in the segment descriptor for the \ncode segment (see Chapter 3, “Protected-Mode Memory Management,” in the Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volume 3A). When the D flag is set, the 32-bit operand-size and address-size attri-\nbutes are selected; when the flag is clear, the 16-bit size attributes are selected. When the processor is executing \nin real-address mode, virtual-8086 mode, or SMM, the default operand-size and address-size attributes are always \n16 bits.\n\nThe operand-size attribute selects the size of operands. When the 16-bit operand-size attribute is in force, oper-\nands can generally be either 8 bits or 16 bits, and when the 32-bit operand-size attribute is in force, operands can \ngenerally be 8 bits or 32 bits.\n\nThe address-size attribute selects the sizes of addresses used to address memory: 16 bits or 32 bits. When the 16-\nbit address-size attribute is in force, segment offsets and displacements are 16 bits. This restriction limits the size \nof a segment to 64 KBytes. When the 32-bit address-size attribute is in force, segment offsets and displacements \nare 32 bits, allowing up to 4 GBytes to be addressed.\n\nThe default operand-size attribute and/or address-size attribute can be overridden for a particular instruction by \nadding an operand-size and/or address-size prefix to an instruction. See Chapter 2, “Instruction Format,” in the \nIntel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A. The effect of this prefix applies only \nto the targeted instruction.\n\nTable 3-4 shows effective operand size and address size (when executing in protected mode or compatibility mode) \ndepending on the settings of the D flag and the operand-size and address-size prefixes.\n3-18 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.6.1 Operand Size and Address Size in 64-Bit Mode\nIn 64-bit mode, the default address size is 64 bits and the default operand size is 32 bits. Defaults can be over-\nridden using prefixes. Address-size and operand-size prefixes allow mixing of 32/64-bit data and 32/64-bit \naddresses on an instruction-by-instruction basis. Table 3-4 shows valid combinations of the 66H instruction prefix \nand the REX.W prefix that may be used to specify operand-size overrides in 64-bit mode. Note that 16-bit \naddresses are not supported in 64-bit mode.\n\nREX prefixes consist of 4-bit fields that form 16 different values. The W-bit field in the REX prefixes is referred to as \nREX.W. If the REX.W field is properly set, the prefix specifies an operand size override to 64 bits. Note that software \ncan still use the operand-size 66H prefix to toggle to a 16-bit operand size. However, setting REX.W takes prece-\ndence over the operand-size prefix (66H) when both are used.\n\nIn the case of SSE/SSE2/SSE3/SSSE3 SIMD instructions: the 66H, F2H, and F3H prefixes are mandatory for \nopcode extensions. In such a case, there is no interaction between a valid REX.W prefix and a 66H opcode exten-\nsion prefix.\n\nSee Chapter 2, “Instruction Format,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 2A.\n\n3.7 OPERAND ADDRESSING\nIA-32 machine-instructions act on zero or more operands. Some operands are specified explicitly and others are \nimplicit. The data for a source operand can be located in:\n• the instruction itself (an immediate operand)\n• a register\n• a memory location\n• an I/O port\n\nTable 3-3.  Effective Operand- and Address-Size Attributes\nD Flag in Code Segment Descriptor 0 0 0 0 1 1 1 1 \n\nOperand-Size Prefix 66H N N Y Y N N Y Y \n\nAddress-Size Prefix 67H N Y N Y N Y N Y \n\nEffective Operand Size 16 16 32 32 32 32 16 16 \n\nEffective Address Size 16 32 16 32 32 16 32 16\n\nNOTES:\nY: Yes - this instruction prefix is present.\nN: No - this instruction prefix is not present.\n\nTable 3-4.  Effective Operand- and Address-Size Attributes in 64-Bit Mode\n\nL Flag in Code Segment Descriptor\n1 1 1 1 1 1 1 1 \n\nREX.W Prefix 0 0 0 0 1 1 1 1 \n\nOperand-Size Prefix 66H N N Y Y N N Y Y \n\nAddress-Size Prefix 67H N Y N Y N Y N Y \n\nEffective Operand Size 32 32 16 16 64 64 64 64\n\nEffective Address Size 64 32 64 32 64 32 64 32\n\nNOTES:\nY: Yes - this instruction prefix is present.\nN: No - this instruction prefix is not present.\nVol. 1 3-19\n\n\n\nBASIC EXECUTION ENVIRONMENT\nWhen an instruction returns data to a destination operand, it can be returned to:\n• a register\n• a memory location\n• an I/O port\n\n3.7.1 Immediate Operands\nSome instructions use data encoded in the instruction itself as a source operand. These operands are called imme-\ndiate operands (or simply immediates). For example, the following ADD instruction adds an immediate value of 14 \nto the contents of the EAX register:\n\nADD EAX, 14\n\nAll arithmetic instructions (except the DIV and IDIV instructions) allow the source operand to be an immediate \nvalue. The maximum value allowed for an immediate operand varies among instructions, but can never be greater \nthan the maximum value of an unsigned doubleword integer (232).\n\n3.7.2 Register Operands\nSource and destination operands can be any of the following registers, depending on the instruction being \nexecuted:\n• 32-bit general-purpose registers (EAX, EBX, ECX, EDX, ESI, EDI, ESP, or EBP)\n• 16-bit general-purpose registers (AX, BX, CX, DX, SI, DI, SP, or BP)\n• 8-bit general-purpose registers (AH, BH, CH, DH, AL, BL, CL, or DL)\n• segment registers (CS, DS, SS, ES, FS, and GS)\n• EFLAGS register\n• x87 FPU registers (ST0 through ST7, status word, control word, tag word, data operand pointer, and instruction \n\npointer)\n• MMX registers (MM0 through MM7)\n• XMM registers (XMM0 through XMM7) and the MXCSR register\n• control registers (CR0, CR2, CR3, and CR4) and system table pointer registers (GDTR, LDTR, IDTR, and task \n\nregister)\n• debug registers (DR0, DR1, DR2, DR3, DR6, and DR7)\n• MSR registers\n\nSome instructions (such as the DIV and MUL instructions) use quadword operands contained in a pair of 32-bit \nregisters. Register pairs are represented with a colon separating them. For example, in the register pair EDX:EAX, \nEDX contains the high order bits and EAX contains the low order bits of a quadword operand. \n\nSeveral instructions (such as the PUSHFD and POPFD instructions) are provided to load and store the contents of \nthe EFLAGS register or to set or clear individual flags in this register. Other instructions (such as the Jcc instruc-\ntions) use the state of the status flags in the EFLAGS register as condition codes for branching or other decision \nmaking operations.\n\nThe processor contains a selection of system registers that are used to control memory management, interrupt and \nexception handling, task management, processor management, and debugging activities. Some of these system \nregisters are accessible by an application program, the operating system, or the executive through a set of system \ninstructions. When accessing a system register with a system instruction, the register is generally an implied \noperand of the instruction.\n3-20 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.7.2.1  Register Operands in 64-Bit Mode\nRegister operands in 64-bit mode can be any of the following:\n• 64-bit general-purpose registers (RAX, RBX, RCX, RDX, RSI, RDI, RSP, RBP, or R8-R15)\n• 32-bit general-purpose registers (EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP, or R8D-R15D)\n• 16-bit general-purpose registers (AX, BX, CX, DX, SI, DI, SP, BP, or R8W-R15W)\n• 8-bit general-purpose registers: AL, BL, CL, DL, SIL, DIL, SPL, BPL, and R8B-R15B are available using REX \n\nprefixes; AL, BL, CL, DL, AH, BH, CH, DH are available without using REX prefixes.\n• Segment registers (CS, DS, SS, ES, FS, and GS)\n• RFLAGS register\n• x87 FPU registers (ST0 through ST7, status word, control word, tag word, data operand pointer, and instruction \n\npointer)\n• MMX registers (MM0 through MM7)\n• XMM registers (XMM0 through XMM15) and the MXCSR register\n• Control registers (CR0, CR2, CR3, CR4, and CR8) and system table pointer registers (GDTR, LDTR, IDTR, and \n\ntask register)\n• Debug registers (DR0, DR1, DR2, DR3, DR6, and DR7)\n• MSR registers\n• RDX:RAX register pair representing a 128-bit operand\n\n3.7.3 Memory Operands\nSource and destination operands in memory are referenced by means of a segment selector and an offset (see \nFigure 3-9). Segment selectors specify the segment containing the operand. Offsets specify the linear or effective \naddress of the operand. Offsets can be 32 bits (represented by the notation m16:32) or 16 bits (represented by the \nnotation m16:16).\n\n3.7.3.1  Memory Operands in 64-Bit Mode\nIn 64-bit mode, a memory operand can be referenced by a segment selector and an offset. The offset can be 16 \nbits, 32 bits or 64 bits (see Figure 3-10).\n\n3.7.4 Specifying a Segment Selector\nThe segment selector can be specified either implicitly or explicitly. The most common method of specifying a \nsegment selector is to load it in a segment register and then allow the processor to select the register implicitly, \ndepending on the type of operation being performed. The processor automatically chooses a segment according to \nthe rules given in Table 3-5. \n\nFigure 3-9.  Memory Operand Address\n\nFigure 3-10.  Memory Operand Address in 64-Bit Mode\n\nOffset (or Linear Address)\n015\n\nSegment\n310\n\nSelector\n\nOffset (or Linear Address)\n015\n\nSegment\n630\n\nSelector\nVol. 1 3-21\n\n\n\nBASIC EXECUTION ENVIRONMENT\nWhen storing data in memory or loading data from memory, the DS segment default can be overridden to allow \nother segments to be accessed. Within an assembler, the segment override is generally handled with a colon “:” \noperator. For example, the following MOV instruction moves a value from register EAX into the segment pointed to \nby the ES register. The offset into the segment is contained in the EBX register:\n\nMOV ES:[EBX], EAX\n\nAt the machine level, a segment override is specified with a segment-override prefix, which is a byte placed at the \nbeginning of an instruction. The following default segment selections cannot be overridden:\n• Instruction fetches must be made from the code segment.\n• Destination strings in string instructions must be stored in the data segment pointed to by the ES register.\n• Push and pop operations must always reference the SS segment.\n\nSome instructions require a segment selector to be specified explicitly. In these cases, the 16-bit segment selector \ncan be located in a memory location or in a 16-bit register. For example, the following MOV instruction moves a \nsegment selector located in register BX into segment register DS:\n\nMOV DS, BX\n\nSegment selectors can also be specified explicitly as part of a 48-bit far pointer in memory. Here, the first double-\nword in memory contains the offset and the next word contains the segment selector.\n\n3.7.4.1  Segmentation in 64-Bit Mode\nIn IA-32e mode, the effects of segmentation depend on whether the processor is running in compatibility mode or \n64-bit mode. In compatibility mode, segmentation functions just as it does in legacy IA-32 mode, using the 16-bit \nor 32-bit protected mode semantics described above.\n\nIn 64-bit mode, segmentation is generally (but not completely) disabled, creating a flat 64-bit linear-address \nspace. The processor treats the segment base of CS, DS, ES, SS as zero, creating a linear address that is equal to \nthe effective address. The exceptions are the FS and GS segments, whose segment registers (which hold the \nsegment base) can be used as additional base registers in some linear address calculations.\n\n3.7.5 Specifying an Offset\nThe offset part of a memory address can be specified directly as a static value (called a displacement) or through \nan address computation made up of one or more of the following components:\n• Displacement — An 8-, 16-, or 32-bit value.\n• Base — The value in a general-purpose register.\n• Index — The value in a general-purpose register.\n• Scale factor — A value of 2, 4, or 8 that is multiplied by the index value.\n\nTable 3-5.  Default Segment Selection Rules\n\nReference Type Register Used Segment Used Default Selection Rule\n\nInstructions CS Code Segment All instruction fetches.\n\nStack SS Stack Segment All stack pushes and pops.\nAny memory reference which uses the ESP or EBP register as a base \nregister.\n\nLocal Data DS Data Segment All data references, except when relative to stack or string destination.\n\nDestination Strings ES Data Segment \npointed to with the \nES register\n\nDestination of string instructions.\n3-22 Vol. 1\n\n\n\nBASIC EXECUTION ENVIRONMENT\nThe offset which results from adding these components is called an effective address. Each of these components \ncan have either a positive or negative (2s complement) value, with the exception of the scaling factor. Figure 3-11 \nshows all the possible ways that these components can be combined to create an effective address in the selected \nsegment.\n\nThe uses of general-purpose registers as base or index components are restricted in the following manner:\n• The ESP register cannot be used as an index register.\n• When the ESP or EBP register is used as the base, the SS segment is the default segment. In all other cases, \n\nthe DS segment is the default segment.\n\nThe base, index, and displacement components can be used in any combination, and any of these components can \nbe NULL. A scale factor may be used only when an index also is used. Each possible combination is useful for data \nstructures commonly used by programmers in high-level languages and assembly language. \n\nThe following addressing modes suggest uses for common combinations of address components.\n• Displacement ⎯ A displacement alone represents a direct (uncomputed) offset to the operand. Because the \n\ndisplacement is encoded in the instruction, this form of an address is sometimes called an absolute or static \naddress. It is commonly used to access a statically allocated scalar operand.\n\n• Base ⎯ A base alone represents an indirect offset to the operand. Since the value in the base register can \nchange, it can be used for dynamic storage of variables and data structures.\n\n• Base + Displacement ⎯ A base register and a displacement can be used together for two distinct purposes:\n\n— As an index into an array when the element size is not 2, 4, or 8 bytes—The displacement component \nencodes the static offset to the beginning of the array. The base register holds the results of a calculation \nto determine the offset to a specific element within the array.\n\n— To access a field of a record: the base register holds the address of the beginning of the record, while the \ndisplacement is a static offset to the field.\n\nAn important special case of this combination is access to parameters in a procedure activation record. A \nprocedure activation record is the stack frame created when a procedure is entered. Here, the EBP register is \nthe best choice for the base register, because it automatically selects the stack segment. This is a compact \nencoding for this common function.\n\n• (Index ∗ Scale) + Displacement ⎯ This address mode offers an efficient way to index into a static array \nwhen the element size is 2, 4, or 8 bytes. The displacement locates the beginning of the array, the index \nregister holds the subscript of the desired array element, and the processor automatically converts the \nsubscript into an index by applying the scaling factor.\n\n• Base + Index + Displacement ⎯ Using two registers together supports either a two-dimensional array (the \ndisplacement holds the address of the beginning of the array) or one of several instances of an array of records \n(the displacement is an offset to a field within the record).\n\n• Base + (Index ∗ Scale) + Displacement ⎯ Using all the addressing components together allows efficient \nindexing of a two-dimensional array when the elements of the array are 2, 4, or 8 bytes in size.\n\nFigure 3-11.  Offset (or Effective Address) Computation\n\nOffset = Base + (Index * Scale) + Displacement\n\nBase\n\nEAX\nEBX\nECX\nEDX\nESP\nEBP\nESI\nEDI\n\nEAX\nEBX\nECX\nEDX\nEBP\nESI\nEDI\n\n1 None\n\n2\n\n4\n\n8\n\n8-bit\n\n16-bit\n\n32-bit\n\nIndex Scale Displacement\n\n*\n+ +\nVol. 1 3-23\n\n\n\nBASIC EXECUTION ENVIRONMENT\n3.7.5.1  Specifying an Offset in 64-Bit Mode\nThe offset part of a memory address in 64-bit mode can be specified directly as a static value or through an address \ncomputation made up of one or more of the following components:\n• Displacement — An 8-bit, 16-bit, or 32-bit value.\n• Base — The value in a 64-bit general-purpose register.\n• Index — The value in a 64-bit general-purpose register.\n• Scale factor — A value of 2, 4, or 8 that is multiplied by the index value.\n\nThe base and index value can be specified in one of sixteen available general-purpose registers in most cases. See \nChapter 2, “Instruction Format,” in the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volume 2A.\n\nThe following unique combination of address components is also available.\n• RIP + Displacement ⎯ In 64-bit mode, RIP-relative addressing uses a signed 32-bit displacement to \n\ncalculate the effective address of the next instruction by sign-extend the 32-bit value and add to the 64-bit \nvalue in RIP.\n\n3.7.6 Assembler and Compiler Addressing Modes\nAt the machine-code level, the selected combination of displacement, base register, index register, and scale factor \nis encoded in an instruction. All assemblers permit a programmer to use any of the allowable combinations of these \naddressing components to address operands. High-level language compilers will select an appropriate combination \nof these components based on the language construct a programmer defines.\n\n3.7.7 I/O Port Addressing\nThe processor supports an I/O address space that contains up to 65,536 8-bit I/O ports. Ports that are 16-bit and \n32-bit may also be defined in the I/O address space. An I/O port can be addressed with either an immediate \noperand or a value in the DX register. See Chapter 19, “Input/Output,” for more information about I/O port \naddressing.\n3-24 Vol. 1\n\n\n\nCHAPTER 4\nDATA TYPES\n\nThis chapter introduces data types defined for the Intel 64 and IA-32 architectures. A section at the end of this \nchapter describes the real-number and floating-point concepts used in x87 FPU, SSE, SSE2, SSE3, SSSE3, SSE4 \nand Intel AVX extensions.\n\n4.1 FUNDAMENTAL DATA TYPES\nThe fundamental data types are bytes, words, doublewords, quadwords, and double quadwords (see Figure 4-1). \nA byte is eight bits, a word is 2 bytes (16 bits), a doubleword is 4 bytes (32 bits), a quadword is 8 bytes (64 bits), \nand a double quadword is 16 bytes (128 bits). A subset of the IA-32 architecture instructions operates on these \nfundamental data types without any additional operand typing.\n\nThe quadword data type was introduced into the IA-32 architecture in the Intel486 processor; the double quadword \ndata type was introduced in the Pentium III processor with the SSE extensions.\n\nFigure 4-2 shows the byte order of each of the fundamental data types when referenced as operands in memory. \nThe low byte (bits 0 through 7) of each data type occupies the lowest address in memory and that address is also \nthe address of the operand.\n\nFigure 4-1.  Fundamental Data Types\n\n0\n\n63\n\nDouble \n\n0\n\nWord\n\n31\n\n0\n\nDoubleword\n\n15\n\n0\n\nByte\n\n7\n\n78\n\nLow WordHigh Word\n\nLow DoublewordHigh Doubleword\n\n1516\n\n3132\n\nN+1\n\nN+2\n\nN+4\n\nLow\nByte\n\nHigh\nByte\n\nN\n\nLow QuadwordHigh Quadword\nQuadword\n\nN\n\nN\n\nN\n\nN\n\nN+8\n\n0\n\nQuadword\n\n127 6364\nVol. 1 4-1\n\n\n\nDATA TYPES\n4.1.1 Alignment of Words, Doublewords, Quadwords, and Double Quadwords\nWords, doublewords, and quadwords do not need to be aligned in memory on natural boundaries. The natural \nboundaries for words, double words, and quadwords are even-numbered addresses, addresses evenly divisible by \nfour, and addresses evenly divisible by eight, respectively. However, to improve the performance of programs, data \nstructures (especially stacks) should be aligned on natural boundaries whenever possible. The reason for this is \nthat the processor requires two memory accesses to make an unaligned memory access; aligned accesses require \nonly one memory access. A word or doubleword operand that crosses a 4-byte boundary or a quadword operand \nthat crosses an 8-byte boundary is considered unaligned and requires two separate memory bus cycles for access.\n\nSome instructions that operate on double quadwords require memory operands to be aligned on a natural \nboundary. These instructions generate a general-protection exception (#GP) if an unaligned operand is specified. A \nnatural boundary for a double quadword is any address evenly divisible by 16. Other instructions that operate on \ndouble quadwords permit unaligned access (without generating a general-protection exception). However, addi-\ntional memory bus cycles are required to access unaligned data from memory.\n\n4.2 NUMERIC DATA TYPES\nAlthough bytes, words, and doublewords are fundamental data types, some instructions support additional inter-\npretations of these data types to allow operations to be performed on numeric data types (signed and unsigned \nintegers, and floating-point numbers). Single-precision (32-bit) floating-point and double-precision (64-bit) \nfloating-point data types are supported across all generations of SSE extensions and Intel AVX extensions. Half-\nprecision (16-bit) floating-point data type is supported only with F16C extensions (VCVTPH2PS, VCVTPS2PH). See \nFigure 4-3. \n\nFigure 4-2.  Bytes, Words, Doublewords, Quadwords, and Double Quadwords in Memory\n\nEH\n\nDH7AH\n\nCHFEH\n\nBH06H\n\nAH36H\n\n9H1FH\n\n8HA4H\n\n7H23H\n\n6H0BH\n\n5H\n\n4H\n\n3H74H\n\n2HCBH\n\n1H31H\n\n0H\n\nQuadword at Address 6H\nContains \n\nDoubleword at Address AH\nContains 7AFE0636H\n\nWord at Address BH\nContains FE06H\n\nByte at Address 9H\nContains 1FH\n\nWord at Address 6H\nContains 230BH\n\nWord at Address 1H\nContains CB31H\n\nWord at Address 2H\nContains 74CBH\n\nDouble quadword at Address 0H\n\n45H\n\n67H\n\n12H\n\nContains\n\n12H\n\n7AFE06361FA4230BH\n\n4E127AFE06361FA4230B456774CB3112\n\n4EH FH\n4-2 Vol. 1\n\n\n\nDATA TYPES\n4.2.1 Integers\nThe Intel 64 and IA-32 architectures define two types of integers: unsigned and signed. Unsigned integers are ordi-\nnary binary values ranging from 0 to the maximum positive number that can be encoded in the selected operand \nsize. Signed integers are two’s complement binary values that can be used to represent both positive and negative \ninteger values.\n\nSome integer instructions (such as the ADD, SUB, PADDB, and PSUBB instructions) operate on either unsigned or \nsigned integer operands. Other integer instructions (such as IMUL, MUL, IDIV, DIV, FIADD, and FISUB) operate on \nonly one integer type.\n\nThe following sections describe the encodings and ranges of the two types of integers.\n\n4.2.1.1  Unsigned Integers\nUnsigned integers are unsigned binary numbers contained in a byte, word, doubleword, and quadword. Their \nvalues range from 0 to 255 for an unsigned byte integer, from 0 to 65,535 for an unsigned word integer, from 0 \n\nFigure 4-3.  Numeric Data Types\n\n0\n\n0\n\n022\n\n0\n\nDouble Extended Precision\n\n63 62\n\n0\n\nWord Signed Integer\n\n0\n\nByte Signed Integer\n\n7 6\n\nSign\n\nSign\n\nDoubleword Signed Integer\n\n15 14\n\nSign\n\n31 30\n\nSign\n\nQuadword Signed Integer\n\n0\n\n0\n\nWord Unsigned Integer\n\n0\nByte Unsigned Integer\n\n7\n\nDoubleword Unsigned Integer\n\n15\n\n31\n\nQuadword Unsigned Integer\n\n63\n\n0\n\n0\n\n233031\n\n51526263\n\n64 63 62 79 78\nFloating Point\n\nSingle Precision\nFloating Point\n\nDouble Precision\nFloating Point\n\nSign\n\nInteger Bit\n\nSign\n\nSign\n\n091415\n\nHalf Precision\nFloating Point\n\nSign\nVol. 1 4-3\n\n\n\nDATA TYPES\nto 232 – 1 for an unsigned doubleword integer, and from 0 to 264 – 1 for an unsigned quadword integer. Unsigned \nintegers are sometimes referred to as ordinals.\n\n4.2.1.2  Signed Integers\nSigned integers are signed binary numbers held in a byte, word, doubleword, or quadword. All operations on signed \nintegers assume a two's complement representation. The sign bit is located in bit 7 in a byte integer, bit 15 in a \nword integer, bit 31 in a doubleword integer, and bit 63 in a quadword integer (see the signed integer encodings in \nTable 4-1).\n\nThe sign bit is set for negative integers and cleared for positive integers and zero. Integer values range from –128 \nto +127 for a byte integer, from –32,768 to +32,767 for a word integer, from –231 to +231 – 1 for a doubleword \ninteger, and from –263 to +263 – 1 for a quadword integer.\n\nWhen storing integer values in memory, word integers are stored in 2 consecutive bytes; doubleword integers are \nstored in 4 consecutive bytes; and quadword integers are stored in 8 consecutive bytes.\n\nThe integer indefinite is a special value that is sometimes returned by the x87 FPU when operating on integer \nvalues. For more information, see Section 8.2.1, “Indefinites.”\n\n4.2.2 Floating-Point Data Types\nThe IA-32 architecture defines and operates on three floating-point data types: single-precision floating-point, \ndouble-precision floating-point, and double-extended precision floating-point (see Figure 4-3). The data formats \nfor these data types correspond directly to formats specified in the IEEE Standard 754 for Binary Floating-Point \nArithmetic. \n\nHalf-precision (16-bit) floating-point data type is supported only for conversion operation with single-precision \nfloating data using F16C extensions (VCVTPH2PS, VCVTPS2PH).\n\nTable 4-2 gives the length, precision, and approximate normalized range that can be represented by each of these \ndata types. Denormal values are also supported in each of these types.\n\nTable 4-1.  Signed Integer Encodings\nClass Two’s Complement Encoding\n\nSign\n\nPositive Largest 0 11..11\n\n. .\n\n. .\n\nSmallest 0 00..01\n\nZero 0 00..00\n\nNegative Smallest 1 11..11\n\n. .\n\n. .\n\nLargest 1 00..00\n\nInteger indefinite 1 00..00\n\nSigned Byte Integer:\nSigned Word Integer:\nSigned Doubleword Integer:\nSigned Quadword Integer:\n\n← 7 bits →\n← 15 bits →\n← 31 bits →\n← 63 bits →\n4-4 Vol. 1\n\n\n\nDATA TYPES\nNOTE\nSection 4.8, “Real Numbers and Floating-Point Formats,” gives an overview of the IEEE Standard \n754 floating-point formats and defines the terms integer bit, QNaN, SNaN, and denormal value.\n\nTable 4-3 shows the floating-point encodings for zeros, denormalized finite numbers, normalized finite numbers, \ninfinites, and NaNs for each of the three floating-point data types. It also gives the format for the QNaN floating-\npoint indefinite value. (See Section 4.8.3.7, “QNaN Floating-Point Indefinite,” for a discussion of the use of the \nQNaN floating-point indefinite value.)\n\nFor the single-precision and double-precision formats, only the fraction part of the significand is encoded. The \ninteger is assumed to be 1 for all numbers except 0 and denormalized finite numbers. For the double extended-\nprecision format, the integer is contained in bit 63, and the most-significant fraction bit is bit 62. Here, the integer \nis explicitly set to 1 for normalized numbers, infinities, and NaNs, and to 0 for zero and denormalized numbers.\n\nTable 4-2.  Length, Precision, and Range of Floating-Point Data Types\nData Type Length Precision\n\n(Bits)\nApproximate Normalized Range\n\nBinary Decimal\n\nHalf Precision 16 11 2–14 to 215 3.1 × 10–5 to 6.50 × 104\n\nSingle Precision 32 24 2–126 to 2127 1.18 × 10–38 to 3.40 × 1038\n\nDouble Precision 64 53 2–1022 to 21023 2.23 × 10–308 to 1.79 × 10308\n\nDouble Extended \nPrecision\n\n80 64 2–16382 to 216383 3.37 × 10–4932 to 1.18 × 104932\n\nTable 4-3.  Floating-Point Number and NaN Encodings\n\nClass Sign Biased Exponent\nSignificand\n\nInteger1 Fraction\n\nPositive +∞ 0 11..11 1 00..00\n\n+Normals 0\n.\n.\n0\n\n11..10\n    .\n    .\n\n00..01\n\n1\n.\n.\n1\n\n11..11\n    .\n    .\n\n00..00\n\n+Denormals 0\n.\n.\n0\n\n00..00\n    .\n    .\n\n00..00\n\n0\n.\n.\n0\n\n11.11\n    .\n    .\n\n00..01\n\n+Zero 0 00..00 0 00..00\n\nNegative −Zero 1 00..00 0 00..00\n\n−Denormals 1\n.\n.\n1\n\n00..00\n    .\n    .\n\n00..00\n\n0\n.\n.\n0\n\n00..01\n    .\n    .\n\n11..11\n\n−Normals 1\n.\n.\n1\n\n00..01\n    .\n    .\n\n11..10\n\n1\n.\n.\n1\n\n00..00\n    .\n    .\n\n11..11\n\n-∞ 1 11..11 1 00..00\nVol. 1 4-5\n\n\n\nDATA TYPES\nThe exponent of each floating-point data type is encoded in biased format; see Section 4.8.2.2, “Biased Exponent.” \nThe biasing constant is 15 for the half-precision format, 127 for the single-precision format, 1023 for the double-\nprecision format, and 16,383 for the double extended-precision format.\n\nWhen storing floating-point values in memory, half-precision values are stored in 2 consecutive bytes in memory; \nsingle-precision values are stored in 4 consecutive bytes in memory; double-precision values are stored in 8 \nconsecutive bytes; and double extended-precision values are stored in 10 consecutive bytes.\n\nThe single-precision and double-precision floating-point data types are operated on by x87 FPU, and \nSSE/SSE2/SSE3/SSE4.1 and Intel AVX instructions. The double-extended-precision floating-point format is only \noperated on by the x87 FPU. See Section 11.6.8, “Compatibility of SIMD and x87 FPU Floating-Point Data Types,” \nfor a discussion of the compatibility of single-precision and double-precision floating-point data types between the \nx87 FPU and SSE/SSE2/SSE3 extensions.\n\n4.3 POINTER DATA TYPES\nPointers are addresses of locations in memory. \n\nIn non-64-bit modes, the architecture defines two types of pointers: a near pointer and a far pointer. A near \npointer is a 32-bit (or 16-bit) offset (also called an effective address) within a segment. Near pointers are used \nfor all memory references in a flat memory model or for references in a segmented model where the identity of the \nsegment being accessed is implied. \n\nA far pointer is a logical address, consisting of a 16-bit segment selector and a 32-bit (or 16-bit) offset. Far pointers \nare used for memory references in a segmented memory model where the identity of a segment being accessed \nmust be specified explicitly. Near and far pointers with 32-bit offsets are shown in Figure 4-4.\n\nNaNs SNaN X 11..11 1 0X..XX2\n\nQNaN X 11..11 1 1X..XX\n\nQNaN Floating-\nPoint Indefinite\n\n1 11..11 1 10..00\n\nHalf-Precision\n\nSingle-Precision:\nDouble-Precision:\nDouble Extended-Precision:\n\n← 5Bits →\n← 8 Bits →\n← 11 Bits →\n← 15 Bits →\n\n← 10 Bits →\n← 23 Bits →\n← 52 Bits →\n← 63 Bits →\n\nNOTES:\n1. Integer bit is implied and not stored for single-precision and double-precision formats.\n2. The fraction for SNaN encodings must be non-zero with the most-significant bit 0.\n\nFigure 4-4.  Pointer Data Types\n\nTable 4-3.  Floating-Point Number and NaN Encodings (Contd.)\n\nClass Sign Biased Exponent\nSignificand\n\nInteger1 Fraction\n\n047\n\nFar Pointer or Logical Address\nSegment Selector\n\n32 31\nOffset\n\nNear Pointer\n\n031\nOffset\n4-6 Vol. 1\n\n\n\nDATA TYPES\n4.3.1 Pointer Data Types in 64-Bit Mode\nIn 64-bit mode (a sub-mode of IA-32e mode), a near pointer is 64 bits. This equates to an effective address. Far \npointers in 64-bit mode can be one of three forms: \n• 16-bit segment selector, 16-bit offset if the operand size is 32 bits \n• 16-bit segment selector, 32-bit offset if the operand size is 32 bits \n• 16-bit segment selector, 64-bit offset if the operand size is 64 bits\n\nSee Figure 4-5.\n\n4.4 BIT FIELD DATA TYPE\nA bit field (see Figure 4-6) is a contiguous sequence of bits. It can begin at any bit position of any byte in memory \nand can contain up to 32 bits.\n\nFigure 4-5.  Pointers in 64-Bit Mode\n\nFigure 4-6.  Bit Field Data Type\n\n16-bit Segment Selector 16-bit Offset\n\n016 1531\n\n16-bit Segment Selector 32-bit Offset\n\n032 3147\n\n16-bit Segment Selector 64-bit Offset\n\n064 6379\n\n64-bit Offset\n\n063\n\nNear Pointer\n\nFar Pointer with 64-bit Operand Size\n\nFar Pointer with 32-bit Operand Size\n\nFar Pointer with 32-bit Operand Size\n\nBit Field\n\nField Length\n\nLeast\n\nBit\nSignificant\nVol. 1 4-7\n\n\n\nDATA TYPES\n4.5 STRING DATA TYPES\nStrings are continuous sequences of bits, bytes, words, or doublewords. A bit string can begin at any bit position \nof any byte and can contain up to 232 – 1 bits. A byte string can contain bytes, words, or doublewords and can \nrange from zero to 232 – 1 bytes (4 GBytes).\n\n4.6 PACKED SIMD DATA TYPES\nIntel 64 and IA-32 architectures define and operate on a set of 64-bit and 128-bit packed data type for use in SIMD \noperations. These data types consist of fundamental data types (packed bytes, words, doublewords, and quad-\nwords) and numeric interpretations of fundamental types for use in packed integer and packed floating-point oper-\nations.\n\n4.6.1 64-Bit SIMD Packed Data Types\nThe 64-bit packed SIMD data types were introduced into the IA-32 architecture in the Intel MMX technology. They \nare operated on in MMX registers. The fundamental 64-bit packed data types are packed bytes, packed words, and \npacked doublewords (see Figure 4-7). When performing numeric SIMD operations on these data types, these data \ntypes are interpreted as containing byte, word, or doubleword integer values.\n\n4.6.2 128-Bit Packed SIMD Data Types\nThe 128-bit packed SIMD data types were introduced into the IA-32 architecture in the SSE extensions and used \nwith SSE2, SSE3 and SSSE3 extensions. They are operated on primarily in the 128-bit XMM registers and memory. \nThe fundamental 128-bit packed data types are packed bytes, packed words, packed doublewords, and packed \nquadwords (see Figure 4-8). When performing SIMD operations on these fundamental data types in XMM registers, \nthese data types are interpreted as containing packed or scalar single-precision floating-point or double-precision \nfloating-point values, or as containing packed byte, word, doubleword, or quadword integer values.\n\nFigure 4-7.  64-Bit Packed SIMD Data Types\n\nPacked Words\n\nPacked Bytes\n\nPacked Doublewords\n\n063\n\n063\n\n063\n\nPacked Word Integers\n\nPacked Byte Integers\n\nPacked Doubleword Integers\n\n063\n\n063\n\n063\n\nFundamental 64-Bit Packed SIMD Data Types\n\n64-Bit Packed Integer Data Types\n4-8 Vol. 1\n\n\n\nDATA TYPES\n4.7 BCD AND PACKED BCD INTEGERS\nBinary-coded decimal integers (BCD integers) are unsigned 4-bit integers with valid values ranging from 0 to 9. IA-\n32 architecture defines operations on BCD integers located in one or more general-purpose registers or in one or \nmore x87 FPU registers (see Figure 4-9).\n\nFigure 4-8.  128-Bit Packed SIMD Data Types\n\n0127\n\nPacked Words\n\nPacked Bytes\n\nPacked Doublewords\n\nPacked Word Integers\n\nPacked Byte Integers\n\nPacked Doubleword Integers\n\nFundamental 128-Bit Packed SIMD Data Types\n\n128-Bit Packed Floating-Point and Integer Data Types\n\nPacked Quadwords\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\n0127\n\nPacked Quadword Integers\n\nPacked Single Precision \nFloating Point\n\nPacked Double Precision \nFloating Point\nVol. 1 4-9\n\n\n\nDATA TYPES\nWhen operating on BCD integers in general-purpose registers, the BCD values can be unpacked (one BCD digit per \nbyte) or packed (two BCD digits per byte). The value of an unpacked BCD integer is the binary value of the low half-\nbyte (bits 0 through 3). The high half-byte (bits 4 through 7) can be any value during addition and subtraction, but \nmust be zero during multiplication and division. Packed BCD integers allow two BCD digits to be contained in one \nbyte. Here, the digit in the high half-byte is more significant than the digit in the low half-byte.\n\nWhen operating on BCD integers in x87 FPU data registers, BCD values are packed in an 80-bit format and referred \nto as decimal integers. In this format, the first 9 bytes hold 18 BCD digits, 2 digits per byte. The least-significant \ndigit is contained in the lower half-byte of byte 0 and the most-significant digit is contained in the upper half-byte \nof byte 9. The most significant bit of byte 10 contains the sign bit (0 = positive and 1 = negative; bits 0 through 6 \nof byte 10 are don’t care bits). Negative decimal integers are not stored in two's complement form; they are distin-\nguished from positive decimal integers only by the sign bit. The range of decimal integers that can be encoded in \nthis format is –1018 + 1 to 1018 – 1. \nThe decimal integer format exists in memory only. When a decimal integer is loaded in an x87 FPU data register, it \nis automatically converted to the double-extended-precision floating-point format. All decimal integers are exactly \nrepresentable in double extended-precision format.\n\nTable 4-4 gives the possible encodings of value in the decimal integer data type.\n\nFigure 4-9.  BCD Data Types\n\nTable 4-4.  Packed Decimal Integer Encodings\n\nClass Sign\nMagnitude\n\ndigit digit digit digit ... digit\n\nPositive\n\n Largest 0 0000000 1001 1001 1001 1001 ... 1001\n\n. . .\n\n. . .\n\n Smallest 0 0000000 0000 0000 0000 0000 ... 0001\n\n Zero 0 0000000 0000 0000 0000 0000 ... 0000\n\nNegative\n\n Zero 1 0000000 0000 0000 0000 0000 ... 0000\n\n Smallest 1 0000000 0000 0000 0000 0000 ... 0001\n\n. . .\n\n. . .\n\n Largest 1 0000000 1001 1001 1001 1001 ... 1001\n\nPacked BCD Integers\n\nBCDBCD\n\n0\n\nBCD Integers\n\n7\nBCDX\n\n34\n\n0\n\n80-Bit Packed BCD Decimal Integers\n\n79\nD0\n\n4 Bits = 1 BCD Digit\n\nSign\nD1D2D3D4D5D6D7D8D9D10D11D12D13D14D15D16D17\n\n78 72 71\nX\n\n07 34\n4-10 Vol. 1\n\n\n\nDATA TYPES\nThe packed BCD integer indefinite encoding (FFFFC000000000000000H) is stored by the FBSTP instruction in \nresponse to a masked floating-point invalid-operation exception. Attempting to load this value with the FBLD \ninstruction produces an undefined result.\n\n4.8 REAL NUMBERS AND FLOATING-POINT FORMATS\nThis section describes how real numbers are represented in floating-point format in x87 FPU and \nSSE/SSE2/SSE3/SSE4.1 and Intel AVX floating-point instructions. It also introduces terms such as normalized \nnumbers, denormalized numbers, biased exponents, signed zeros, and NaNs. Readers who are already familiar \nwith floating-point processing techniques and the IEEE Standard 754 for Binary Floating-Point Arithmetic may wish \nto skip this section.\n\n4.8.1 Real Number System\nAs shown in Figure 4-10, the real-number system comprises the continuum of real numbers from minus infinity (−\n∞) to plus infinity (+ ∞).\n\nBecause the size and number of registers that any computer can have is limited, only a subset of the real-number \ncontinuum can be used in real-number (floating-point) calculations. As shown at the bottom of Figure 4-10, the \nsubset of real numbers that the IA-32 architecture supports represents an approximation of the real number \nsystem. The range and precision of this real-number subset is determined by the IEEE Standard 754 floating-point \nformats. \n\n4.8.2 Floating-Point Format\nTo increase the speed and efficiency of real-number computations, computers and microprocessors typically repre-\nsent real numbers in a binary floating-point format. In this format, a real number has three parts: a sign, a signif-\nicand, and an exponent (see Figure 4-11).\n\nThe sign is a binary value that indicates whether the number is positive (0) or negative (1). The significand has \ntwo parts: a 1-bit binary integer (also referred to as the J-bit) and a binary fraction. The integer-bit is often not \nrepresented, but instead is an implied value. The exponent is a binary integer that represents the base-2 power by \nwhich the significand is multiplied.\n\nTable 4-5 shows how the real number 178.125 (in ordinary decimal format) is stored in IEEE Standard 754 floating-\npoint format. The table lists a progression of real number notations that leads to the single-precision, 32-bit \nfloating-point format. In this format, the significand is normalized (see Section 4.8.2.1, “Normalized Numbers”) \nand the exponent is biased (see Section 4.8.2.2, “Biased Exponent”). For the single-precision floating-point \nformat, the biasing constant is +127.\n\nPacked BCD \nInteger \nIndefinite\n\n1 1111111 1111 1111 1100 0000 ... 0000\n\n← 1 byte → ← 9 bytes →\n\nTable 4-4.  Packed Decimal Integer Encodings (Contd.)\n\nClass Sign\nMagnitude\n\ndigit digit digit digit ... digit\nVol. 1 4-11\n\n\n\nDATA TYPES\nFigure 4-10.  Binary Real Number System\n\nFigure 4-11.  Binary Floating-Point Format\n\nTable 4-5.  Real and Floating-Point Number Notation\n\nNotation Value\n\nOrdinary Decimal 178.125\n\nScientific Decimal 1.78125E10 2\n\nScientific Binary 1.0110010001E2111\n\nScientific Binary\n(Biased Exponent)\n\n 1.0110010001E210000110\n\nIEEE Single-Precision Format Sign Biased Exponent Normalized Significand\n\n0 10000110 01100100010000000000000\n\n          1. (Implied)\n\nBinary Real Number System\n\nSubset of binary real numbers that can be represented with\nIEEE single-precision (32-bit) floating-point format\n\n+10\n\n10.0000000000000000000000\n\n1.11111111111111111111111\nPrecision 24 Binary Digits\n\nNumbers within this range\ncannot be represented.\n\nςς ςς\n-100 -10 -1 0 1 10 100\n\nςς ςς\n-100 -10 -1 0 1 10 100\n\nSign\n\nInteger or J-Bit\n\nExponent Significand\n\nFraction\n4-12 Vol. 1\n\n\n\nDATA TYPES\n4.8.2.1  Normalized Numbers\nIn most cases, floating-point numbers are encoded in normalized form. This means that except for zero, the signif-\nicand is always made up of an integer of 1 and the following fraction:\n\n1.fff...ff\n\nFor values less than 1, leading zeros are eliminated. (For each leading zero eliminated, the exponent is decre-\nmented by one.)\n\nRepresenting numbers in normalized form maximizes the number of significant digits that can be accommodated \nin a significand of a given width. To summarize, a normalized real number consists of a normalized significand that \nrepresents a real number between 1 and 2 and an exponent that specifies the number’s binary point.\n\n4.8.2.2  Biased Exponent\nIn the IA-32 architecture, the exponents of floating-point numbers are encoded in a biased form. This means that \na constant is added to the actual exponent so that the biased exponent is always a positive number. The value of \nthe biasing constant depends on the number of bits available for representing exponents in the floating-point \nformat being used. The biasing constant is chosen so that the smallest normalized number can be reciprocated \nwithout overflow.\n\nSee Section 4.2.2, “Floating-Point Data Types,” for a list of the biasing constants that the IA-32 architecture uses \nfor the various sizes of floating-point data-types.\n\n4.8.3 Real Number and Non-number Encodings\nA variety of real numbers and special values can be encoded in the IEEE Standard 754 floating-point format. These \nnumbers and values are generally divided into the following classes:\n• Signed zeros\n• Denormalized finite numbers\n• Normalized finite numbers\n• Signed infinities\n• NaNs\n• Indefinite numbers\n\n(The term NaN stands for “Not a Number.”)\n\nFigure 4-12 shows how the encodings for these numbers and non-numbers fit into the real number continuum. The \nencodings shown here are for the IEEE single-precision floating-point format. The term “S” indicates the sign bit, \n“E” the biased exponent, and “Sig” the significand. The exponent values are given in decimal. The integer bit is \nshown for the significands, even though the integer bit is implied in single-precision floating-point format.\nVol. 1 4-13\n\n\n\nDATA TYPES\nAn IA-32 processor can operate on and/or return any of these values, depending on the type of computation being \nperformed. The following sections describe these number and non-number classes.\n\n4.8.3.1  Signed Zeros\nZero can be represented as a +0 or a −0 depending on the sign bit. Both encodings are equal in value. The sign of \na zero result depends on the operation being performed and the rounding mode being used. Signed zeros have \nbeen provided to aid in implementing interval arithmetic. The sign of a zero may indicate the direction from which \nunderflow occurred, or it may indicate the sign of an ∞ that has been reciprocated.\n\n4.8.3.2  Normalized and Denormalized Finite Numbers\nNon-zero, finite numbers are divided into two classes: normalized and denormalized. The normalized finite \nnumbers comprise all the non-zero finite values that can be encoded in a normalized real number format between \nzero and ∞. In the single-precision floating-point format shown in Figure 4-12, this group of numbers includes all \nthe numbers with biased exponents ranging from 1 to 25410 (unbiased, the exponent range is from −12610 to \n+12710).\n\nWhen floating-point numbers become very close to zero, the normalized-number format can no longer be used to \nrepresent the numbers. This is because the range of the exponent is not large enough to compensate for shifting \nthe binary point to the right to eliminate leading zeros.\n\nWhen the biased exponent is zero, smaller numbers can only be represented by making the integer bit (and \nperhaps other leading bits) of the significand zero. The numbers in this range are called denormalized numbers. \nThe use of leading zeros with denormalized numbers allows smaller numbers to be represented. However, this \ndenormalization may cause a loss of precision (the number of significant bits is reduced by the leading zeros).\n\nWhen performing normalized floating-point computations, an IA-32 processor normally operates on normalized \nnumbers and produces normalized numbers as results. Denormalized numbers represent an underflow condition. \nThe exact conditions are specified in Section 4.9.1.5, “Numeric Underflow Exception (#U).”\n\nA denormalized number is computed through a technique called gradual underflow. Table 4-6 gives an example of \ngradual underflow in the denormalization process. Here the single-precision format is being used, so the minimum \nexponent (unbiased) is −12610. The true result in this example requires an exponent of −12910 in order to have a \n\nFigure 4-12.  Real Numbers and NaNs\n\n1 0\nS E Sig1\n\n− 0\n\n1 0 − Denormalized\nFinite\n\nNaN\n\n1 1...254 − Normalized\nFinite\n\n1 255 − ∞\n\n255 SNaN\n\n255 QNaN\n\nNOTES:\n\n3. Sign bit ignored.\n2. Fraction must be non-zero.\n\n0 0\nS E Sig1\n\n0 0\n\nNaN\n\n0 1...254\n\n0 255\n\nX3 255 1.0XX...2\n\n255 1.1XX...\n\n+ 0\n\n+Denormalized\nFinite\n\n+Normalized\nFinite\n\n+ ∞\n\nSNaN\n\nQNaN X3\n\nX3\n\nX3\n\nReal Number and NaN Encodings For 32-Bit Floating-Point Format\n\n− Denormalized Finite\n− Normalized Finite − 0− ∞ + ∞\n\n+ Denormalized Finite\n+ Normalized Finite+ 0\n\n0.XXX...2\n\n0.000...\n\n1.000...\n\n1.XXX...\n\n1.000...\n\n0.000...\n\n0.XXX...2\n\n1.XXX...\n\n1.0XX...2\n\n1.1XX...\n\n1. Integer bit of fraction implied for\nsingle-precision floating-point format.\n4-14 Vol. 1\n\n\n\nDATA TYPES\nnormalized number.   Since  −12910 is beyond the allowable exponent range, the result is denormalized by inserting \nleading zeros until the minimum exponent of −12610 is reached.\n\nIn the extreme case, all the significant bits are shifted out to the right by leading zeros, creating a zero result. \n\nThe Intel 64 and IA-32 architectures deal with denormal values in the following ways:\n• It avoids creating denormals by normalizing numbers whenever possible.\n• It provides the floating-point underflow exception to permit programmers to detect cases when denormals are \n\ncreated.\n• It provides the floating-point denormal-operand exception to permit procedures or programs to detect when \n\ndenormals are being used as source operands for computations.\n\n4.8.3.3  Signed Infinities\nThe two infinities, + ∞ and − ∞, represent the maximum positive and negative real numbers, respectively, that can \nbe represented in the floating-point format. Infinity is always represented by a significand of 1.00...00 (the integer \nbit may be implied) and the maximum biased exponent allowed in the specified format (for example, 25510 for the \nsingle-precision format).\n\nThe signs of infinities are observed, and comparisons are possible. Infinities are always interpreted in the affine \nsense; that is, –∞ is less than any finite number and +∞ is greater than any finite number. Arithmetic on infinities \nis always exact. Exceptions are generated only when the use of an infinity as a source operand constitutes an \ninvalid operation.\n\nWhereas denormalized numbers may represent an underflow condition, the two ∞ numbers may represent the \nresult of an overflow condition. Here, the normalized result of a computation has a biased exponent greater than \nthe largest allowable exponent for the selected result format.\n\n4.8.3.4  NaNs\nSince NaNs are non-numbers, they are not part of the real number line. In Figure 4-12, the encoding space for \nNaNs in the floating-point formats is shown above the ends of the real number line. This space includes any value \nwith the maximum allowable biased exponent and a non-zero fraction (the sign bit is ignored for NaNs).\n\nThe IA-32 architecture defines two classes of NaNs: quiet NaNs (QNaNs) and signaling NaNs (SNaNs). A QNaN is a \nNaN with the most significant fraction bit set; an SNaN is a NaN with the most significant fraction bit clear. QNaNs \nare allowed to propagate through most arithmetic operations without signaling an exception. SNaNs generally \nsignal a floating-point invalid-operation exception whenever they appear as operands in arithmetic operations.\n\nSNaNs are typically used to trap or invoke an exception handler. They must be inserted by software; that is, the \nprocessor never generates an SNaN as a result of a floating-point operation.\n\nTable 4-6.  Denormalization Process\n\nOperation Sign Exponent* Significand\n\nTrue Result 0 −129 1.01011100000...00\n\nDenormalize 0 −128 0.10101110000...00\n\nDenormalize 0 −127 0.01010111000...00\n\nDenormalize 0 −126 0.00101011100...00\n\nDenormal Result 0 −126 0.00101011100...00\n\n* Expressed as an unbiased, decimal number.\nVol. 1 4-15\n\n\n\nDATA TYPES\n4.8.3.5  Operating on SNaNs and QNaNs\nWhen a floating-point operation is performed on an SNaN and/or a QNaN, the result of the operation is either a \nQNaN delivered to the destination operand or the generation of a floating-point invalid operation exception, \ndepending on the following rules:\n• If one of the source operands is an SNaN and the floating-point invalid-operation exception is not masked (see \n\nSection 4.9.1.1, “Invalid Operation Exception (#I)”), then a floating-point invalid-operation exception is \nsignaled and no result is stored in the destination operand. If one of the source operands is a QNaN and the \nfloating-point invalid-operation exception is not masked and the operation is one that generates an invalid-\noperation exception for QNaN operands as described in Section 8.5.1.2, “Invalid Arithmetic Operand Exception \n(#IA),” or Section 11.5.2.1, “Invalid Operation Exception (#I)”, then a floating-point invalid-operation \nexception is signaled and no result is stored in the destination operand.\n\n• If either or both of the source operands are NaNs and floating-point invalid-operation exception is masked, the \nresult is as shown in Table 4-7. When an SNaN is converted to a QNaN, the conversion is handled by setting the \nmost-significant fraction bit of the SNaN to 1. Also, when one of the source operands is an SNaN, or when it is \na QNaN and the operation is one that generates an invalid-operation exception for QNaN operands as described \nin Section 8.5.1.2, “Invalid Arithmetic Operand Exception (#IA),” or Section 11.5.2.1, “Invalid Operation \nException (#I)”, then the floating-point invalid-operation exception flag is set. Note that for some combinations \nof source operands, the result is different for x87 FPU operations and for SSE/SSE2/SSE3/SSE4.1 operations. \nIntel AVX follows the same behavior as SSE/SSE2/SSE3/SSE4.1 in this respect.\n\n• When neither of the source operands is a NaN, but the operation generates a floating-point invalid-operation \nexception (see Tables 8-10 and 11-1), the result is commonly a QNaN FP Indefinite (Section 4.8.3.7).\n\nAny exceptions to the behavior described in Table 4-7 are described in Section 8.5.1.2, “Invalid Arithmetic Operand \nException (#IA),” and Section 11.5.2.1, “Invalid Operation Exception (#I).”\n\n4.8.3.6  Using SNaNs and QNaNs in Applications\nExcept for the rules given at the beginning of Section 4.8.3.4, “NaNs,” for encoding SNaNs and QNaNs, software is \nfree to use the bits in the significand of a NaN for any purpose. Both SNaNs and QNaNs can be encoded to carry and \nstore data, such as diagnostic information.\n\nTable 4-7.  Rules for Handling NaNs \n\nSource Operands Result1\n\nSNaN and QNaN x87 FPU — QNaN source operand.\n\nSSE/SSE2/SSE3/SSE4.1/AVX — First source operand (if this operand is an \nSNaN, it is converted to a QNaN)\n\nTwo SNaNs x87 FPU—SNaN source operand with the larger significand, converted into a \nQNaN\n\nSSE/SSE2/SSE3/SSE4.1/AVX — First source operand converted to a QNaN\n\nTwo QNaNs x87 FPU — QNaN source operand with the larger\nsignificand\n\nSSE/SSE2/SSE3/SSE4.1/AVX — First source operand\n\nSNaN and a floating-point value SNaN source operand, converted into a QNaN\n\nQNaN and a floating-point value QNaN source operand\n\nSNaN (for instructions that take only one operand) SNaN source operand, converted into a QNaN\n\nQNaN (for instructions that take only one operand) QNaN source operand\n\nNOTE:\n1. For SSE/SSE2/SSE3/SSE4.1 instructions, the first operand is generally a source operand that becomes the destination operand. For \n\nAVX instructions, the first source operand is usually the 2nd operand in a non-destructive source syntax. Within the Result column, \nthe x87 FPU notation also applies to the FISTTP instruction in SSE3; the SSE3 notation applies to the SIMD floating-point instruc-\ntions.\n4-16 Vol. 1\n\n\n\nDATA TYPES\nBy unmasking the invalid operation exception, the programmer can use signaling NaNs to trap to the exception \nhandler. The generality of this approach and the large number of NaN values that are available provide the sophis-\nticated programmer with a tool that can be applied to a variety of special situations.\n\nFor example, a compiler can use signaling NaNs as references to uninitialized (real) array elements. The compiler \ncan preinitialize each array element with a signaling NaN whose significand contains the index (relative position) of \nthe element. Then, if an application program attempts to access an element that it has not initialized, it can use the \nNaN placed there by the compiler. If the invalid operation exception is unmasked, an interrupt will occur, and the \nexception handler will be invoked. The exception handler can determine which element has been accessed, since \nthe operand address field of the exception pointer will point to the NaN, and the NaN will contain the index number \nof the array element.\n\nQuiet NaNs are often used to speed up debugging. In its early testing phase, a program often contains multiple \nerrors. An exception handler can be written to save diagnostic information in memory whenever it is invoked. After \nstoring the diagnostic data, it can supply a quiet NaN as the result of the erroneous instruction, and that NaN can \npoint to its associated diagnostic area in memory. The program will then continue, creating a different NaN for each \nerror. When the program ends, the NaN results can be used to access the diagnostic data saved at the time the \nerrors occurred. Many errors can thus be diagnosed and corrected in one test run.\n\nIn embedded applications that use computed results in further computations, an undetected QNaN can invalidate \nall subsequent results. Such applications should therefore periodically check for QNaNs and provide a recovery \nmechanism to be used if a QNaN result is detected. \n\n4.8.3.7  QNaN Floating-Point Indefinite\nFor the floating-point data type encodings (single-precision, double-precision, and double-extended-precision), \none unique encoding (a QNaN) is reserved for representing the special value QNaN floating-point indefinite. The \nx87 FPU and the SSE/SSE2/SSE3/SSE4.1/AVX extensions return these indefinite values as responses to some \nmasked floating-point exceptions. Table 4-3 shows the encoding used for the QNaN floating-point indefinite.\n\n4.8.3.8  Half-Precision Floating-Point Operation\nHalf-precision floating-point values are not used by the processor directly for arithmetic operations. Two instruc-\ntions, VCVTPH2PS, VCVTPS2PH, provide conversion only between half-precision and single-precision floating-point \nvalues.\n\nThe SIMD floating-point exception behavior of VCVTPH2PS and VCVTPS2PH are described in Section 14.4.1.\n\n4.8.4 Rounding\nWhen performing floating-point operations, the processor produces an infinitely precise floating-point result in the \ndestination format (single-precision, double-precision, or double extended-precision floating-point) whenever \npossible. However, because only a subset of the numbers in the real number continuum can be represented in IEEE \nStandard 754 floating-point formats, it is often the case that an infinitely precise result cannot be encoded exactly \nin the format of the destination operand.\n\nFor example, the following value (a) has a 24-bit fraction. The least-significant bit of this fraction (the underlined \nbit) cannot be encoded exactly in the single-precision format (which has only a 23-bit fraction):\n\n(a) 1.0001 0000 1000 0011 1001 0111E2 101\n\nTo round this result (a), the processor first selects two representable fractions b and c that most closely bracket a \nin value (b < a < c).\n\n(b) 1.0001 0000 1000 0011 1001 011E2 101\n\n(c) 1.0001 0000 1000 0011 1001 100E2 101\n\nThe processor then sets the result to b or to c according to the selected rounding mode. Rounding introduces an \nerror in a result that is less than one unit in the last place (the least significant bit position of the floating-point \nvalue) to which the result is rounded.\nVol. 1 4-17\n\n\n\nDATA TYPES\nThe IEEE Standard 754 defines four rounding modes (see Table 4-8): round to nearest, round up, round down, and \nround toward zero. The default rounding mode (for the Intel 64 and IA-32 architectures) is round to nearest. This \nmode provides the most accurate and statistically unbiased estimate of the true result and is suitable for most \napplications. \n\nThe round up and round down modes are termed directed rounding and can be used to implement interval arith-\nmetic. Interval arithmetic is used to determine upper and lower bounds for the true result of a multistep computa-\ntion, when the intermediate results of the computation are subject to rounding. \n\nThe round toward zero mode (sometimes called the “chop” mode) is commonly used when performing integer \narithmetic with the x87 FPU.\n\nThe rounded result is called the inexact result. When the processor produces an inexact result, the floating-point \nprecision (inexact) flag (PE) is set (see Section 4.9.1.6, “Inexact-Result (Precision) Exception (#P)”).\n\nThe rounding modes have no effect on comparison operations, operations that produce exact results, or operations \nthat produce NaN results.\n\n4.8.4.1  Rounding Control (RC) Fields\nIn the Intel 64 and IA-32 architectures, the rounding mode is controlled by a 2-bit rounding-control (RC) field \n(Table 4-8 shows the encoding of this field). The RC field is implemented in two different locations: \n• x87 FPU control register (bits 10 and 11)\n• The MXCSR register (bits 13 and 14)\n\nAlthough these two RC fields perform the same function, they control rounding for different execution environ-\nments within the processor. The RC field in the x87 FPU control register controls rounding for computations \nperformed with the x87 FPU instructions; the RC field in the MXCSR register controls rounding for SIMD floating-\npoint computations performed with the SSE/SSE2 instructions.\n\n4.8.4.2  Truncation with SSE and SSE2 Conversion Instructions\nThe following SSE/SSE2 instructions automatically truncate the results of conversions from floating-point values to \nintegers when the result it inexact: CVTTPD2DQ, CVTTPS2DQ, CVTTPD2PI, CVTTPS2PI, CVTTSD2SI, CVTTSS2SI. \nHere, truncation means the round toward zero mode described in Table 4-8.\n\n4.9 OVERVIEW OF FLOATING-POINT EXCEPTIONS\nThe following section provides an overview of floating-point exceptions and their handling in the IA-32 architecture. \nFor information specific to the x87 FPU and to the SSE/SSE2/SSE3/SSE4.1 extensions, refer to the following \nsections:\n• Section 8.4, “x87 FPU Floating-Point Exception Handling”\n\nTable 4-8.  Rounding Modes and Encoding of Rounding Control (RC) Field\n\nRounding Mode RC Field \nSetting\n\nDescription\n\nRound to \nnearest (even)\n\n00B Rounded result is the closest to the infinitely precise result. If two values are equally close, the \nresult is the even value (that is, the one with the least-significant bit of zero). Default\n\nRound down \n(toward −∞)\n\n01B Rounded result is closest to but no greater than the infinitely precise result.\n\nRound up \n(toward +∞)\n\n10B Rounded result is closest to but no less than the infinitely precise result.\n\nRound toward \nzero (Truncate)\n\n11B Rounded result is closest to but no greater in absolute value than the infinitely precise result.\n4-18 Vol. 1\n\n\n\nDATA TYPES\n• Section 11.5, “SSE, SSE2, and SSE3 Exceptions”\n\nWhen operating on floating-point operands, the IA-32 architecture recognizes and detects six classes of exception \nconditions:\n• Invalid operation (#I)\n• Divide-by-zero (#Z)\n• Denormalized operand (#D)\n• Numeric overflow (#O)\n• Numeric underflow (#U)\n• Inexact result (precision) (#P)\n\nThe nomenclature of “#” symbol followed by one or two letters (for example, #P) is used in this manual to indicate \nexception conditions. It is merely a short-hand form and is not related to assembler mnemonics.\n\nNOTE\nAll of the exceptions listed above except the denormal-operand exception (#D) are defined in IEEE \nStandard 754.\n\nThe invalid-operation, divide-by-zero and denormal-operand exceptions are pre-computation exceptions (that is, \nthey are detected before any arithmetic operation occurs). The numeric-underflow, numeric-overflow and precision \nexceptions are post-computation exceptions.\n\nEach of the six exception classes has a corresponding flag bit (IE, ZE, OE, UE, DE, or PE) and mask bit (IM, ZM, OM, \nUM, DM, or PM). When one or more floating-point exception conditions are detected, the processor sets the appro-\npriate flag bits, then takes one of two possible courses of action, depending on the settings of the corresponding \nmask bits:\n• Mask bit set. Handles the exception automatically, producing a predefined (and often times usable) result, \n\nwhile allowing program execution to continue undisturbed.\n• Mask bit clear. Invokes a software exception handler to handle the exception.\n\nThe masked (default) responses to exceptions have been chosen to deliver a reasonable result for each exception \ncondition and are generally satisfactory for most floating-point applications. By masking or unmasking specific \nfloating-point exceptions, programmers can delegate responsibility for most exceptions to the processor and \nreserve the most severe exception conditions for software exception handlers. \n\nBecause the exception flags are “sticky,” they provide a cumulative record of the exceptions that have occurred \nsince they were last cleared. A programmer can thus mask all exceptions, run a calculation, and then inspect the \nexception flags to see if any exceptions were detected during the calculation.\n\nIn the IA-32 architecture, floating-point exception flag and mask bits are implemented in two different locations: \n• x87 FPU status word and control word. The flag bits are located at bits 0 through 5 of the x87 FPU status word \n\nand the mask bits are located at bits 0 through 5 of the x87 FPU control word (see Figures 8-4 and 8-6).\n• MXCSR register. The flag bits are located at bits 0 through 5 of the MXCSR register and the mask bits are \n\nlocated at bits 7 through 12 of the register (see Figure 10-3).\n\nAlthough these two sets of flag and mask bits perform the same function, they report on and control exceptions for \ndifferent execution environments within the processor. The flag and mask bits in the x87 FPU status and control \nwords control exception reporting and masking for computations performed with the x87 FPU instructions; the \ncompanion bits in the MXCSR register control exception reporting and masking for SIMD floating-point computa-\ntions performed with the SSE/SSE2/SSE3 instructions.\n\nNote that when exceptions are masked, the processor may detect multiple exceptions in a single instruction, \nbecause it continues executing the instruction after performing its masked response. For example, the processor \ncan detect a denormalized operand, perform its masked response to this exception, and then detect numeric \nunderflow.\n\nSee Section 4.9.2, “Floating-Point Exception Priority,” for a description of the rules for exception precedence when \nmore than one floating-point exception condition is detected for an instruction.\nVol. 1 4-19\n\n\n\nDATA TYPES\n4.9.1 Floating-Point Exception Conditions\nThe following sections describe the various conditions that cause a floating-point exception to be generated and the \nmasked response of the processor when these conditions are detected. The Intel® 64 and IA-32 Architectures \nSoftware Developer’s Manual, Volumes 3A & 3B, list the floating-point exceptions that can be signaled for each \nfloating-point instruction.\n\n4.9.1.1  Invalid Operation Exception (#I)\nThe processor reports an invalid operation exception in response to one or more invalid arithmetic operands. If the \ninvalid operation exception is masked, the processor sets the IE flag and returns an indefinite value or a QNaN. This \nvalue overwrites the destination register specified by the instruction. If the invalid operation exception is not \nmasked, the IE flag is set, a software exception handler is invoked, and the operands remain unaltered.\n\nSee Section 4.8.3.6, “Using SNaNs and QNaNs in Applications,” for information about the result returned when an \nexception is caused by an SNaN.\n\nThe processor can detect a variety of invalid arithmetic operations that can be coded in a program. These opera-\ntions generally indicate a programming error, such as dividing ∞ by ∞ . See the following sections for information \nregarding the invalid-operation exception when detected while executing x87 FPU or SSE/SSE2/SSE3/SSE4.1 or \nAVX instructions:\n• x87 FPU; Section 8.5.1, “Invalid Operation Exception”.\n• SIMD floating-point exceptions; Section 11.5.2.1, “Invalid Operation Exception (#I)”.\n\n4.9.1.2  Denormal Operand Exception (#D)\nThe processor reports the denormal-operand exception if an arithmetic instruction attempts to operate on a \ndenormal operand (see Section 4.8.3.2, “Normalized and Denormalized Finite Numbers”). When the exception is \nmasked, the processor sets the DE flag and proceeds with the instruction. Operating on denormal numbers will \nproduce results at least as good as, and often better than, what can be obtained when denormal numbers are \nflushed to zero. Programmers can mask this exception so that a computation may proceed, then analyze any loss \nof accuracy when the final result is delivered.\n\nWhen a denormal-operand exception is not masked, the DE flag is set, a software exception handler is invoked, and \nthe operands remain unaltered. When denormal operands have reduced significance due to loss of low-order bits, \nit may be advisable to not operate on them. Precluding denormal operands from computations can be accom-\nplished by an exception handler that responds to unmasked denormal-operand exceptions.\n\nSee the following sections for information regarding the denormal-operand exception when detected while \nexecuting x87 FPU or SSE/SSE2/SSE3 instructions:\n• x87 FPU; Section 8.5.2, “Denormal Operand Exception (#D)”.\n• SIMD floating-point exceptions; Section 11.5.2.2, “Denormal-Operand Exception (#D)”.\n\n4.9.1.3  Divide-By-Zero Exception (#Z)\nThe processor reports the floating-point divide-by-zero exception whenever an instruction attempts to divide a \nfinite non-zero operand by 0. The masked response for the divide-by-zero exception is to set the ZE flag and return \nan infinity signed with the exclusive OR of the sign of the operands. If the divide-by-zero exception is not masked, \nthe ZE flag is set, a software exception handler is invoked, and the operands remain unaltered.\n\nSee the following sections for information regarding the divide-by-zero exception when detected while executing \nx87 FPU or SSE/SSE2 instructions:\n• x87 FPU; Section 8.5.3, “Divide-By-Zero Exception (#Z)”.\n• SIMD floating-point exceptions; Section 11.5.2.3, “Divide-By-Zero Exception (#Z)”.\n4-20 Vol. 1\n\n\n\nDATA TYPES\n4.9.1.4  Numeric Overflow Exception (#O)\nThe processor reports a floating-point numeric overflow exception whenever the rounded result of an instruction \nexceeds the largest allowable finite value that will fit into the destination operand. Table 4-9 shows the threshold \nrange for numeric overflow for each of the floating-point formats; overflow occurs when a rounded result falls at or \noutside this threshold range.\n\nWhen a numeric-overflow exception occurs and the exception is masked, the processor sets the OE flag and \nreturns one of the values shown in Table 4-10, according to the current rounding mode. See Section 4.8.4, \n“Rounding.”\n\nWhen numeric overflow occurs and the numeric-overflow exception is not masked, the OE flag is set, a software \nexception handler is invoked, and the source and destination operands either remain unchanged or a biased result \nis stored in the destination operand (depending whether the overflow exception was generated during an \nSSE/SSE2/SSE3 floating-point operation or an x87 FPU operation).\n\nSee the following sections for information regarding the numeric overflow exception when detected while executing \nx87 FPU instructions or while executing SSE/SSE2/SSE3 instructions:\n• x87 FPU; Section 8.5.4, “Numeric Overflow Exception (#O)”\n• SIMD floating-point exceptions; Section 11.5.2.4, “Numeric Overflow Exception (#O)”\n\n4.9.1.5  Numeric Underflow Exception (#U)\nThe processor detects a potential floating-point numeric underflow condition whenever the result of rounding with \nunbounded exponent (taking into account precision control for x87) is non-zero and tiny; that is, non-zero and less \nthan the smallest possible normalized, finite value that will fit into the destination operand. Table 4-11 shows the \nthreshold range for numeric underflow for each of the floating-point formats (assuming normalized results); \nunderflow occurs when a rounded result falls strictly within the threshold range. The ability to detect and handle \nunderflow is provided to prevent a very small result from propagating through a computation and causing another \nexception (such as overflow during division) to be generated at a later time. Results which trigger underflow are \nalso potentially less accurate.\n\nTable 4-9.  Numeric Overflow Thresholds\n\nFloating-Point Format Overflow Thresholds\n\nSingle Precision | x | ≥ 1.0 ∗ 2128\n\nDouble Precision | x | ≥ 1.0 ∗ 21024\n\nDouble Extended Precision | x | ≥ 1.0 ∗ 216384\n\nTable 4-10.  Masked Responses to Numeric Overflow\n\nRounding Mode Sign of True Result Result\n\nTo nearest + +∞\n\n– –∞\n\nToward –∞ + Largest finite positive number\n\n– –∞\n\nToward +∞ + +∞\n\n– Largest finite negative number\n\nToward zero + Largest finite positive number\n\n– Largest finite negative number\nVol. 1 4-21\n\n\n\nDATA TYPES\nHow the processor handles an underflow condition, depends on two related conditions:\n• creation of a tiny, non-zero result\n• creation of an inexact result; that is, a result that cannot be represented exactly in the destination format\n\nWhich of these events causes an underflow exception to be reported and how the processor responds to the excep-\ntion condition depends on whether the underflow exception is masked:\n• Underflow exception masked — The underflow exception is reported (the UE flag is set) only when the result \n\nis both tiny and inexact. The processor returns a correctly signed result whose magnitude is less than or equal \nto the smallest positive normal floating-point number to the destination operand, regardless of inexactness.\n\n• Underflow exception not masked — The underflow exception is reported when the result is non-zero tiny, \nregardless of inexactness. The processor leaves the source and destination operands unaltered or stores a \nbiased result in the destination operand (depending whether the underflow exception was generated during an \nSSE/SSE2/SSE3 floating-point operation or an x87 FPU operation) and invokes a software exception handler.\n\nSee the following sections for information regarding the numeric underflow exception when detected while \nexecuting x87 FPU instructions or while executing SSE/SSE2/SSE3 instructions:\n• x87 FPU; Section 8.5.5, “Numeric Underflow Exception (#U)”\n• SIMD floating-point exceptions; Section 11.5.2.5, “Numeric Underflow Exception (#U)”\n\n4.9.1.6  Inexact-Result (Precision) Exception (#P)\nThe inexact-result exception (also called the precision exception) occurs if the result of an operation is not exactly \nrepresentable in the destination format. For example, the fraction 1/3 cannot be precisely represented in binary \nfloating-point form. This exception occurs frequently and indicates that some (normally acceptable) accuracy will \nbe lost due to rounding. The exception is supported for applications that need to perform exact arithmetic only. \nBecause the rounded result is generally satisfactory for most applications, this exception is commonly masked.\n\nIf the inexact-result exception is masked when an inexact-result condition occurs and a numeric overflow or under-\nflow condition has not occurred, the processor sets the PE flag and stores the rounded result in the destination \noperand. The current rounding mode determines the method used to round the result. See Section 4.8.4, \n“Rounding.”\n\nIf the inexact-result exception is not masked when an inexact result occurs and numeric overflow or underflow has \nnot occurred, the PE flag is set, the rounded result is stored in the destination operand, and a software exception \nhandler is invoked.\n\nIf an inexact result occurs in conjunction with numeric overflow or underflow, one of the following operations is \ncarried out:\n• If an inexact result occurs along with masked overflow or underflow, the OE flag or UE flag and the PE flag are \n\nset and the result is stored as described for the overflow or underflow exceptions; see Section 4.9.1.4, \n“Numeric Overflow Exception (#O),” or Section 4.9.1.5, “Numeric Underflow Exception (#U).” If the inexact \nresult exception is unmasked, the processor also invokes a software exception handler.\n\n• If an inexact result occurs along with unmasked overflow or underflow and the destination operand is a register, \nthe OE or UE flag and the PE flag are set, the result is stored as described for the overflow or underflow \nexceptions, and a software exception handler is invoked.\n\nIf an unmasked numeric overflow or underflow exception occurs and the destination operand is a memory location \n(which can happen only for a floating-point store), the inexact-result condition is not reported and the C1 flag is \ncleared.\n\nTable 4-11.  Numeric Underflow (Normalized) Thresholds\n\nFloating-Point Format Underflow Thresholds*\n\nSingle Precision | x | < 1.0 ∗ 2−126\n\nDouble Precision | x | < 1.0 ∗ 2−1022\n\nDouble Extended Precision | x | < 1.0 ∗ 2−16382\n\n* Where ‘x’ is the result rounded to destination precision with an unbounded exponent range.\n4-22 Vol. 1\n\n\n\nDATA TYPES\nSee the following sections for information regarding the inexact-result exception when detected while executing \nx87 FPU or SSE/SSE2/SSE3 instructions:\n• x87 FPU; Section 8.5.6, “Inexact-Result (Precision) Exception (#P)”\n• SIMD floating-point exceptions; Section 11.5.2.3, “Divide-By-Zero Exception (#Z)”\n\n4.9.2 Floating-Point Exception Priority\nThe processor handles exceptions according to a predetermined precedence. When an instruction generates two or \nmore exception conditions, the exception precedence sometimes results in the higher-priority exception being \nhandled and the lower-priority exceptions being ignored. For example, dividing an SNaN by zero can potentially \nsignal an invalid-operation exception (due to the SNaN operand) and a divide-by-zero exception. Here, if both \nexceptions are masked, the processor handles the higher-priority exception only (the invalid-operation exception), \nreturning a QNaN to the destination. Alternately, a denormal-operand or inexact-result exception can accompany \na numeric underflow or overflow exception with both exceptions being handled.\n\nThe precedence for floating-point exceptions is as follows:\n\n1. Invalid-operation exception, subdivided as follows:\n\na. stack underflow (occurs with x87 FPU only)\n\nb. stack overflow (occurs with x87 FPU only)\n\nc. operand of unsupported format (occurs with x87 FPU only when using the double extended-precision \nfloating-point format)\n\nd. SNaN operand\n\n2. QNaN operand. Though this is not an exception, the handling of a QNaN operand has precedence over lower-\npriority exceptions. For example, a QNaN divided by zero results in a QNaN, not a zero-divide exception.\n\n3. Any other invalid-operation exception not mentioned above or a divide-by-zero exception.\n\n4. Denormal-operand exception. If masked, then instruction execution continues and a lower-priority exception \ncan occur as well.\n\n5. Numeric overflow and underflow exceptions; possibly in conjunction with the inexact-result exception.\n\n6. Inexact-result exception.\n\nInvalid operation, zero divide, and denormal operand exceptions are detected before a floating-point operation \nbegins. Overflow, underflow, and precision exceptions are not detected until a true result has been computed. \nWhen an unmasked pre-operation exception is detected, the destination operand has not yet been updated, and \nappears as if the offending instruction has not been executed. When an unmasked post-operation exception is \ndetected, the destination operand may be updated with a result, depending on the nature of the exception (except \nfor SSE/SSE2/SSE3 instructions, which do not update their destination operands in such cases).\n\n4.9.3 Typical Actions of a Floating-Point Exception Handler\nAfter the floating-point exception handler is invoked, the processor handles the exception in the same manner that \nit handles non-floating-point exceptions. The floating-point exception handler is normally part of the operating \nsystem or executive software, and it usually invokes a user-registered floating-point exception handle. \n\nA typical action of the exception handler is to store state information in memory. Other typical exception handler \nactions include:\n• Examining the stored state information to determine the nature of the error\n• Taking actions to correct the condition that caused the error\n• Clearing the exception flags\n• Returning to the interrupted program and resuming normal execution\n\nIn lieu of writing recovery procedures, the exception handler can do the following:\n• Increment in software an exception counter for later display or printing\nVol. 1 4-23\n\n\n\nDATA TYPES\n• Print or display diagnostic information (such as the state information)\n• Halt further program execution\n4-24 Vol. 1\n\n\n\nCHAPTER 5\nINSTRUCTION SET SUMMARY\n\nThis chapter provides an abridged overview of Intel 64 and IA-32 instructions. Instructions are divided into the \nfollowing groups:\n• Section 5.1, “General-Purpose Instructions”.\n• Section 5.2, “x87 FPU Instructions”.\n• Section 5.3, “x87 FPU AND SIMD State Management Instructions”.\n• Section 5.4, “MMX™ Instructions”.\n• Section 5.5, “SSE Instructions”.\n• Section 5.6, “SSE2 Instructions”.\n• Section 5.7, “SSE3 Instructions”.\n• Section 5.8, “Supplemental Streaming SIMD Extensions 3 (SSSE3) Instructions”.\n• Section 5.9, “SSE4 Instructions”.\n• Section 5.10, “SSE4.1 Instructions”.\n• Section 5.11, “SSE4.2 Instruction Set”.\n• Section 5.12, “Intel® AES-NI and PCLMULQDQ”.\n• Section 5.13, “Intel® Advanced Vector Extensions (Intel® AVX)”.\n• Section 5.14, “16-bit Floating-Point Conversion”.\n• Section 5.15, “Fused-Multiply-ADD (FMA)”.\n• Section 5.16, “Intel® Advanced Vector Extensions 2 (Intel® AVX2)”.\n• Section 5.17, “Intel® Transactional Synchronization Extensions (Intel® TSX)”.\n• Section 5.18, “Intel® SHA Extensions”.\n• Section 5.19, “Intel® Advanced Vector Extensions 512 (Intel® AVX-512)”.\n• Section 5.20, “System Instructions”.\n• Section 5.21, “64-Bit Mode Instructions”.\n• Section 5.22, “Virtual-Machine Extensions”.\n• Section 5.23, “Safer Mode Extensions”.\n• Section 5.24, “Intel® Memory Protection Extensions”.\n• Section 5.25, “Intel® Software Guard Extensions”.\n• Section 5.26, “Shadow Stack Management Instructions”.\n• Section 5.27, “Control Transfer Terminating Instructions”.\n\nTable 5-1 lists the groups and IA-32 processors that support each group. More recent instruction set extensions are \nlisted in Table 5-2. Within these groups, most instructions are collected into functional subgroups.\n\nTable 5-1.  Instruction Groups in Intel 64 and IA-32 Processors\n\nInstruction Set \nArchitecture Intel 64 and IA-32 Processor Support\n\nGeneral Purpose All Intel 64 and IA-32 processors.\n\n x87 FPU Intel486, Pentium, Pentium with MMX Technology, Celeron, Pentium Pro, Pentium II, Pentium II Xeon, \nPentium III, Pentium III Xeon, Pentium 4, Intel Xeon processors, Pentium M, Intel Core Solo, Intel Core Duo, \nIntel Core 2 Duo processors, Intel Atom processors.\n\nx87 FPU and SIMD State \nManagement\n\nPentium II, Pentium II Xeon, Pentium III, Pentium III Xeon, Pentium 4, Intel Xeon processors, Pentium M, \nIntel Core Solo, Intel Core Duo, Intel Core 2 Duo processors, Intel Atom processors.\nVol. 1 5-1\n\n\n\nINSTRUCTION SET SUMMARY\nMMX Technology Pentium with MMX Technology, Celeron, Pentium II, Pentium II Xeon, Pentium III, Pentium III Xeon, Pentium \n4, Intel Xeon processors, Pentium M, Intel Core Solo, Intel Core Duo, Intel Core 2 Duo processors, Intel Atom \nprocessors.\n\nSSE Extensions Pentium III, Pentium III Xeon, Pentium 4, Intel Xeon processors, Pentium M, Intel Core Solo, Intel Core Duo, \nIntel Core 2 Duo processors, Intel Atom processors.\n\nSSE2 Extensions Pentium 4, Intel Xeon processors, Pentium M, Intel Core Solo, Intel Core Duo, Intel Core 2 Duo processors, \nIntel Atom processors.\n\nSSE3 Extensions Pentium 4 supporting HT Technology (built on 90nm process technology), Intel Core Solo, Intel Core Duo, \nIntel Core 2 Duo processors, Intel Xeon processor 3xxxx, 5xxx, 7xxx Series, Intel Atom processors.\n\nSSSE3 Extensions Intel Xeon processor 3xxx, 5100, 5200, 5300, 5400, 5500, 5600, 7300, 7400, 7500 series, Intel Core 2 \nExtreme processors QX6000 series, Intel Core 2 Duo, Intel Core 2 Quad processors, Intel Pentium Dual-Core \nprocessors, Intel Atom processors.\n\nIA-32e mode: 64-bit \nmode instructions\n\nIntel 64 processors.\n\nSystem Instructions Intel 64 and IA-32 processors.\n\nVMX Instructions Intel 64 and IA-32 processors supporting Intel Virtualization Technology.\n\nSMX Instructions Intel Core 2 Duo processor E6x50, E8xxx; Intel Core 2 Quad processor Q9xxx.\n\nTable 5-2.  Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors\n\nInstruction Set \nArchitecture Processor Generation Introduction\n\nSSE4.1 Extensions Intel® Xeon® processor 3100, 3300, 5200, 5400, 7400, 7500 series, Intel® Core™ 2 Extreme processors \nQX9000 series, Intel® Core™ 2 Quad processor Q9000 series, Intel® Core™ 2 Duo processors 8000 series \nand T9000 series, Intel Atom® processor based on Silvermont microarchitecture.\n\nSSE4.2 Extensions, \nCRC32, POPCNT\n\nIntel® Core™ i7 965 processor, Intel® Xeon® processors X3400, X3500, X5500, X6500, X7500 series, \nIntel Atom processor based on Silvermont microarchitecture.\n\nIntel® AES-NI, \nPCLMULQDQ\n\nIntel® Xeon® processor E7 series, Intel® Xeon® processors X3600 and X5600, Intel® Core™ i7 980X \nprocessor, Intel Atom processor based on Silvermont microarchitecture. Use CPUID to verify presence of \nIntel AES-NI and PCLMULQDQ across Intel® Core™ processor families.\n\nIntel® AVX Intel® Xeon® processor E3 and E5 families, 2nd Generation Intel® Core™ i7, i5, i3 processor 2xxx families.\n\nF16C 3rd Generation Intel® Core™ processors, Intel® Xeon® processor E3-1200 v2 product family, Intel® Xeon® \nprocessor E5 v2 and E7 v2 families.\n\nRDRAND 3rd Generation Intel Core processors, Intel Xeon processor E3-1200 v2 product family, Intel Xeon \nprocessor E5 v2 and E7 v2 families, Intel Atom processor based on Silvermont microarchitecture.\n\nFS/GS base access 3rd Generation Intel Core processors, Intel Xeon processor E3-1200 v2 product family, Intel Xeon \nprocessor E5 v2 and E7 v2 families, Intel Atom® processor based on Goldmont microarchitecture.\n\nFMA, AVX2, BMI1, BMI2, \nINVPCID, LZCNT, Intel® \nTSX\n\nIntel® Xeon® processor E3/E5/E7 v3 product families, 4th Generation Intel® Core™ processor family.\n\nMOVBE Intel Xeon processor E3/E5/E7 v3 product families, 4th Generation Intel Core processor family, Intel Atom \nprocessors.\n\nPREFETCHW Intel® Core™ M processor family; 5th Generation Intel® Core™ processor family, Intel Atom processor based \non Silvermont microarchitecture.\n\nTable 5-1.  Instruction Groups in Intel 64 and IA-32 Processors (Contd.)\n\nInstruction Set \nArchitecture Intel 64 and IA-32 Processor Support\n5-2 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nADX Intel Core M processor family, 5th Generation Intel Core processor family.\n\nRDSEED, CLAC, STAC Intel Core M processor family, 5th Generation Intel Core processor family, Intel Atom processor based on \nGoldmont microarchitecture.\n\nAVX512ER, AVX512PF, \nPREFETCHWT1\n\nIntel® Xeon Phi™ Processor 3200, 5200, 7200 Series.\n\nAVX512F, AVX512CD Intel Xeon Phi Processor 3200, 5200, 7200 Series, Intel® Xeon® Processor Scalable Family, Intel® Core™ i3-\n8121U processor.\n\nCLFLUSHOPT, XSAVEC, \nXSAVES, Intel® MPX\n\nIntel Xeon Processor Scalable Family, 6th Generation Intel® Core™ processor family, Intel Atom processor \nbased on Goldmont microarchitecture.\n\nSGX1 6th Generation Intel Core processor family, Intel Atom® processor based on Goldmont Plus \nmicroarchitecture.\n\nAVX512DQ, AVX512BW, \nAVX512VL\n\nIntel Xeon Processor Scalable Family, Intel Core i3-8121U processor based on Cannon Lake \nmicroarchitecture.\n\nCLWB Intel Xeon Processor Scalable Family, Intel Atom® processor based on Tremont microarchitecture, 11th \nGeneration Intel Core processor family based on Tiger Lake microarchitecture.\n\nPKU Intel Xeon Processor Scalable Family, 10th generation Intel® Core™ processors based on Comet Lake \nmicroarchitecture.\n\nAVX512_IFMA, \nAVX512_VBMI\n\nIntel Core i3-8121U processor based on Cannon Lake microarchitecture.\n\nIntel® SHA Extensions Intel Core i3-8121U processor based on Cannon Lake microarchitecture , Intel Atom processor based on \nGoldmont microarchitecture, 3rd Generation Intel® Xeon® Processor Scalable Family based on Ice Lake \nmicroarchitecture.\n\nUMIP Intel Core i3-8121U processor based on Cannon Lake microarchitecture, Intel Atom processor based on \nGoldmont Plus microarchitecture.\n\nPTWRITE Intel Atom processor based on Goldmont Plus microarchitecture.\n\nRDPID 10th Generation Intel® Core™ processor family based on Ice Lake microarchitecture, Intel Atom processor \nbased on Goldmont Plus microarchitecture.\n\nAVX512_4FMAPS, \nAVX512_4VNNIW\n\nIntel® Xeon Phi™ Processor 7215, 7285, 7295 Series.\n\nAVX512_VNNI 2nd Generation Intel® Xeon® Processor Scalable Family, 10th Generation Intel Core processor family based \non Ice Lake microarchitecture.\n\nAVX512_VPOPCNTDQ Intel Xeon Phi Processor 7215, 7285, 7295 Series, 10th Generation Intel Core processor family based on \nIce Lake microarchitecture.\n\nFast Short REP MOV 10th Generation Intel Core processor family based on Ice Lake microarchitecture.\n\nGFNI (SSE) 10th Generation Intel Core processor family based on Ice Lake microarchitecture, Intel Atom processor \nbased on Tremont microarchitecture.\n\nVAES, \nGFNI (AVX/AVX512), \nAVX512_VBMI2, \nVPCLMULQDQ, \nAVX512_BITALG\n\n10th Generation Intel Core processor family based on Ice Lake microarchitecture.\n\nENCLV Intel Atom processor based on Tremont microarchitecture, 3rd Generation Intel® Xeon® Processor Scalable \nProcessors based on Ice Lake microarchitecture.\n\nSplit Lock Detection 10th Generation Intel Core processor family based on Ice Lake microarchitecture, Intel Atom processor \nbased on Tremont microarchitecture.\n\nTable 5-2.  Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors (Contd.)\n\nInstruction Set \nArchitecture Processor Generation Introduction\nVol. 1 5-3\n\n\n\nINSTRUCTION SET SUMMARY\nThe following sections list instructions in each major group and subgroup. Given for each instruction is its \nmnemonic and descriptive names. When two or more mnemonics are given (for example, CMOVA/CMOVNBE), they \nrepresent different mnemonics for the same instruction opcode. Assemblers support redundant mnemonics for \nsome instructions to make it easier to read code listings. For instance, CMOVA (Conditional move if above) and \nCMOVNBE (Conditional move if not below or equal) represent the same condition. For detailed information about \nspecific instructions, see the Intel® 64 and IA-32 Architectures Software Developer’s Manual, Volumes 2A, 2B, 2C \n& 2D.\n\n5.1 GENERAL-PURPOSE INSTRUCTIONS\nThe general-purpose instructions perform basic data movement, arithmetic, logic, program flow, and string opera-\ntions that programmers commonly use to write application and system software to run on Intel 64 and IA-32 \nprocessors. They operate on data contained in memory, in the general-purpose registers (EAX, EBX, ECX, EDX, \nEDI, ESI, EBP, and ESP) and in the EFLAGS register. They also operate on address information contained in \nmemory, the general-purpose registers, and the segment registers (CS, DS, SS, ES, FS, and GS). \n\nThis group of instructions includes the data transfer, binary integer arithmetic, decimal arithmetic, logic operations, \nshift and rotate, bit and byte operations, program control, string, flag control, segment register operations, and \nmiscellaneous subgroups. The sections that follow introduce each subgroup. \n\nFor more detailed information on general purpose-instructions, see Chapter 7, “Programming With General-\nPurpose Instructions.”\n\n5.1.1 Data Transfer Instructions\nThe data transfer instructions move data between memory and the general-purpose and segment registers. They \nalso perform specific operations such as conditional moves, stack access, and data conversion.\n\nCLDEMOTE Intel Atom processor based on Tremont microarchitecture.\n\nDirect stores: MOVDIRI, \nMOVDIR64B \n\nIntel Atom processor based on Tremont microarchitecture, 11th Generation Intel Core processor family \nbased on Tiger Lake microarchitecture.\n\nUser wait: TPAUSE, \nUMONITOR, UMWAIT\n\nIntel Atom processor based on Tremont microarchitecture.\n\nAVX512_BF16 3rd Generation Intel® Xeon® Processor Scalable Processors based on Cooper Lake product.\n\nAVX512_VP2INTERSECT 11th Generation Intel Core processor family based on Tiger Lake microarchitecture.\n\nKey Locker1 11th Generation Intel Core processor family based on Tiger Lake microarchitecture.\n\nControl-flow Enforcement \nTechnology (CET)\n\n11th Generation Intel Core processor family based on Tiger Lake microarchitecture.\n\nMKTME2, PCONFIG 3rd Generation Intel® Xeon® Processor Scalable Family based on Ice Lake microarchitecture.\n\nWBNOINVD 3rd Generation Intel® Xeon® Processor Scalable Family based on Ice Lake microarchitecture.\n\nSupervisor Memory \nProtection Keys (PKS)\n\nFuture Intel processors\n\nNOTES:\n1. Details on Key Locker can be found in the Intel Key Locker Specification here:\n\n https://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html. \n2. Further details on MKTME usage can be found here: \n\nhttps://software.intel.com/sites/default/files/managed/a5/16/Multi-Key-Total-Memory-Encryption-Spec.pdf.\n\nTable 5-2.  Instruction Set Extensions Introduction in Intel 64 and IA-32 Processors (Contd.)\n\nInstruction Set \nArchitecture Processor Generation Introduction\n5-4 Vol. 1\n\nhttps://software.intel.com/content/www/us/en/develop/download/intel-key-locker-specification.html\nhttps://software.intel.com/sites/default/files/managed/a5/16/Multi-Key-Total-Memory-Encryption-Spec.pdf\n\n\nINSTRUCTION SET SUMMARY\nMOV Move data between general-purpose registers; move data between memory and general-\npurpose or segment registers; move immediates to general-purpose registers.\n\nCMOVE/CMOVZ Conditional move if equal/Conditional move if zero.\nCMOVNE/CMOVNZ Conditional move if not equal/Conditional move if not zero.\nCMOVA/CMOVNBE Conditional move if above/Conditional move if not below or equal.\nCMOVAE/CMOVNB Conditional move if above or equal/Conditional move if not below.\nCMOVB/CMOVNAE Conditional move if below/Conditional move if not above or equal.\nCMOVBE/CMOVNA Conditional move if below or equal/Conditional move if not above.\nCMOVG/CMOVNLE Conditional move if greater/Conditional move if not less or equal.\nCMOVGE/CMOVNL Conditional move if greater or equal/Conditional move if not less.\nCMOVL/CMOVNGE Conditional move if less/Conditional move if not greater or equal.\nCMOVLE/CMOVNG Conditional move if less or equal/Conditional move if not greater.\nCMOVC Conditional move if carry.\nCMOVNC Conditional move if not carry.\nCMOVO Conditional move if overflow.\nCMOVNO Conditional move if not overflow.\nCMOVS Conditional move if sign (negative).\nCMOVNS Conditional move if not sign (non-negative).\nCMOVP/CMOVPE Conditional move if parity/Conditional move if parity even.\nCMOVNP/CMOVPO Conditional move if not parity/Conditional move if parity odd.\nXCHG Exchange.\nBSWAP Byte swap.\nXADD Exchange and add.\nCMPXCHG Compare and exchange.\nCMPXCHG8B Compare and exchange 8 bytes.\nPUSH Push onto stack.\nPOP Pop off of stack.\nPUSHA/PUSHAD Push general-purpose registers onto stack.\nPOPA/POPAD Pop general-purpose registers from stack.\nCWD/CDQ Convert word to doubleword/Convert doubleword to quadword.\nCBW/CWDE Convert byte to word/Convert word to doubleword in EAX register.\nMOVSX Move and sign extend.\nMOVZX Move and zero extend.\n\n5.1.2 Binary Arithmetic Instructions\nThe binary arithmetic instructions perform basic binary integer computations on byte, word, and doubleword inte-\ngers located in memory and/or the general purpose registers.\nADCX Unsigned integer add with carry.\nADOX Unsigned integer add with overflow.\nADD Integer add.\nADC Add with carry.\nSUB Subtract.\nSBB Subtract with borrow.\nIMUL Signed multiply.\nMUL Unsigned multiply.\nIDIV Signed divide.\nVol. 1 5-5\n\n\n\nINSTRUCTION SET SUMMARY\nDIV Unsigned divide.\nINC Increment.\nDEC Decrement.\nNEG Negate.\nCMP Compare.\n\n5.1.3 Decimal Arithmetic Instructions\nThe decimal arithmetic instructions perform decimal arithmetic on binary coded decimal (BCD) data.\nDAA Decimal adjust after addition.\nDAS Decimal adjust after subtraction.\nAAA ASCII adjust after addition.\nAAS ASCII adjust after subtraction.\nAAM ASCII adjust after multiplication.\nAAD ASCII adjust before division.\n\n5.1.4 Logical Instructions\nThe logical instructions perform basic AND, OR, XOR, and NOT logical operations on byte, word, and doubleword \nvalues.\nAND Perform bitwise logical AND.\nOR Perform bitwise logical OR.\nXOR Perform bitwise logical exclusive OR.\nNOT Perform bitwise logical NOT.\n\n5.1.5 Shift and Rotate Instructions\nThe shift and rotate instructions shift and rotate the bits in word and doubleword operands.\nSAR Shift arithmetic right.\nSHR Shift logical right.\nSAL/SHL Shift arithmetic left/Shift logical left.\nSHRD Shift right double.\nSHLD Shift left double.\nROR Rotate right.\nROL Rotate left.\nRCR Rotate through carry right.\nRCL Rotate through carry left.\n\n5.1.6 Bit and Byte Instructions\nBit instructions test and modify individual bits in word and doubleword operands. Byte instructions set the value of \na byte operand to indicate the status of flags in the EFLAGS register.\nBT Bit test.\nBTS Bit test and set.\nBTR Bit test and reset.\nBTC Bit test and complement.\nBSF Bit scan forward.\n5-6 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nBSR Bit scan reverse.\nSETE/SETZ Set byte if equal/Set byte if zero.\nSETNE/SETNZ Set byte if not equal/Set byte if not zero.\nSETA/SETNBE Set byte if above/Set byte if not below or equal.\nSETAE/SETNB/SETNC Set byte if above or equal/Set byte if not below/Set byte if not carry.\nSETB/SETNAE/SETC Set byte if below/Set byte if not above or equal/Set byte if carry.\nSETBE/SETNA Set byte if below or equal/Set byte if not above.\nSETG/SETNLE Set byte if greater/Set byte if not less or equal.\nSETGE/SETNL Set byte if greater or equal/Set byte if not less.\nSETL/SETNGE Set byte if less/Set byte if not greater or equal.\nSETLE/SETNG Set byte if less or equal/Set byte if not greater.\nSETS Set byte if sign (negative).\nSETNS Set byte if not sign (non-negative).\nSETO Set byte if overflow.\nSETNO Set byte if not overflow.\nSETPE/SETP Set byte if parity even/Set byte if parity.\nSETPO/SETNP Set byte if parity odd/Set byte if not parity.\nTEST Logical compare.\nCRC321 Provides hardware acceleration to calculate cyclic redundancy checks for fast and efficient \n\nimplementation of data integrity protocols.\nPOPCNT2 This instruction calculates of number of bits set to 1 in the second operand (source) and \n\nreturns the count in the first operand (a destination register).\n\n5.1.7 Control Transfer Instructions\nThe control transfer instructions provide jump, conditional jump, loop, and call and return operations to control \nprogram flow.\nJMP Jump.\nJE/JZ Jump if equal/Jump if zero.\nJNE/JNZ Jump if not equal/Jump if not zero.\nJA/JNBE Jump if above/Jump if not below or equal.\nJAE/JNB Jump if above or equal/Jump if not below.\nJB/JNAE Jump if below/Jump if not above or equal.\nJBE/JNA Jump if below or equal/Jump if not above.\nJG/JNLE Jump if greater/Jump if not less or equal.\nJGE/JNL Jump if greater or equal/Jump if not less.\nJL/JNGE Jump if less/Jump if not greater or equal.\nJLE/JNG Jump if less or equal/Jump if not greater.\nJC Jump if carry.\nJNC Jump if not carry.\nJO Jump if overflow.\nJNO Jump if not overflow.\nJS Jump if sign (negative).\nJNS Jump if not sign (non-negative).\n\n1. Processor support of CRC32 is enumerated by CPUID.01:ECX[SSE4.2] = 1\n\n2. Processor support of POPCNT is enumerated by CPUID.01:ECX[POPCNT] = 1\nVol. 1 5-7\n\n\n\nINSTRUCTION SET SUMMARY\nJPO/JNP Jump if parity odd/Jump if not parity.\nJPE/JP Jump if parity even/Jump if parity.\nJCXZ/JECXZ Jump register CX zero/Jump register ECX zero.\nLOOP Loop with ECX counter.\nLOOPZ/LOOPE Loop with ECX and zero/Loop with ECX and equal.\nLOOPNZ/LOOPNE Loop with ECX and not zero/Loop with ECX and not equal.\nCALL Call procedure.\nRET Return.\nIRET Return from interrupt.\nINT Software interrupt.\nINTO Interrupt on overflow.\nBOUND Detect value out of range.\nENTER High-level procedure entry.\nLEAVE High-level procedure exit.\n\n5.1.8 String Instructions\nThe string instructions operate on strings of bytes, allowing them to be moved to and from memory.\nMOVS/MOVSB Move string/Move byte string.\nMOVS/MOVSW Move string/Move word string.\nMOVS/MOVSD Move string/Move doubleword string.\nCMPS/CMPSB Compare string/Compare byte string.\nCMPS/CMPSW Compare string/Compare word string.\nCMPS/CMPSD Compare string/Compare doubleword string.\nSCAS/SCASB Scan string/Scan byte string.\nSCAS/SCASW Scan string/Scan word string.\nSCAS/SCASD Scan string/Scan doubleword string.\nLODS/LODSB Load string/Load byte string.\nLODS/LODSW Load string/Load word string.\nLODS/LODSD Load string/Load doubleword string.\nSTOS/STOSB Store string/Store byte string.\nSTOS/STOSW Store string/Store word string.\nSTOS/STOSD Store string/Store doubleword string.\nREP Repeat while ECX not zero.\nREPE/REPZ Repeat while equal/Repeat while zero.\nREPNE/REPNZ Repeat while not equal/Repeat while not zero.\n\n5.1.9 I/O Instructions\nThese instructions move data between the processor’s I/O ports and a register or memory.\nIN Read from a port.\nOUT Write to a port.\nINS/INSB Input string from port/Input byte string from port.\nINS/INSW Input string from port/Input word string from port.\nINS/INSD Input string from port/Input doubleword string from port.\nOUTS/OUTSB Output string to port/Output byte string to port.\nOUTS/OUTSW Output string to port/Output word string to port.\n5-8 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nOUTS/OUTSD Output string to port/Output doubleword string to port.\n\n5.1.10 Enter and Leave Instructions\nThese instructions provide machine-language support for procedure calls in block-structured languages.\nENTER High-level procedure entry.\nLEAVE High-level procedure exit.\n\n5.1.11 Flag Control (EFLAG) Instructions\nThe flag control instructions operate on the flags in the EFLAGS register.\nSTC Set carry flag.\nCLC Clear the carry flag.\nCMC Complement the carry flag.\nCLD Clear the direction flag.\nSTD Set direction flag.\nLAHF Load flags into AH register.\nSAHF Store AH register into flags.\nPUSHF/PUSHFD Push EFLAGS onto stack.\nPOPF/POPFD Pop EFLAGS from stack.\nSTI Set interrupt flag.\nCLI Clear the interrupt flag.\n\n5.1.12 Segment Register Instructions\nThe segment register instructions allow far pointers (segment addresses) to be loaded into the segment registers.\nLDS Load far pointer using DS.\nLES Load far pointer using ES.\nLFS Load far pointer using FS.\nLGS Load far pointer using GS.\nLSS Load far pointer using SS.\n\n5.1.13 Miscellaneous Instructions\nThe miscellaneous instructions provide such functions as loading an effective address, executing a “no-operation,” \nand retrieving processor identification information.\nLEA Load effective address.\nNOP No operation.\nUD Undefined instruction.\nXLAT/XLATB Table lookup translation.\nCPUID Processor identification.\nMOVBE1 Move data after swapping data bytes.\nPREFETCHW Prefetch data into cache in anticipation of write.\nPREFETCHWT1 Prefetch hint T1 with intent to write.\n\n1. Processor support of MOVBE is enumerated by CPUID.01:ECX.MOVBE[bit 22] = 1.\nVol. 1 5-9\n\n\n\nINSTRUCTION SET SUMMARY\nCLFLUSH Flushes and invalidates a memory operand and its associated cache line from all levels of \nthe processor’s cache hierarchy.\n\nCLFLUSHOPT Flushes and invalidates a memory operand and its associated cache line from all levels of \nthe processor’s cache hierarchy with optimized memory system throughput.\n\n5.1.14 User Mode Extended Sate Save/Restore Instructions\nXSAVE Save processor extended states to memory.\nXSAVEC Save processor extended states with compaction to memory.\nXSAVEOPT Save processor extended states to memory, optimized.\nXRSTOR Restore processor extended states from memory.\nXGETBV Reads the state of an extended control register.\n\n5.1.15 Random Number Generator Instructions\nRDRAND Retrieves a random number generated from hardware.\nRDSEED Retrieves a random number generated from hardware.\n\n5.1.16 BMI1, BMI2\nANDN Bitwise AND of first source with inverted 2nd source operands.\nBEXTR Contiguous bitwise extract.\nBLSI Extract lowest set bit.\nBLSMSK Set all lower bits below first set bit to 1.\n\nBLSR Reset lowest set bit.\nBZHI Zero high bits starting from specified bit position.\nLZCNT Count the number leading zero bits.\nMULX Unsigned multiply without affecting arithmetic flags.\nPDEP Parallel deposit of bits using a mask.\nPEXT Parallel extraction of bits using a mask.\nRORX Rotate right without affecting arithmetic flags.\nSARX Shift arithmetic right.\nSHLX Shift logic left.\nSHRX Shift logic right.\nTZCNT Count the number trailing zero bits.\n\n5.1.16.1  Detection of VEX-encoded GPR Instructions, LZCNT and TZCNT, PREFETCHW\nVEX-encoded general-purpose instructions do not operate on any vector registers. \nThere are separate feature flags for the following subsets of instructions that operate on general purpose registers, \nand the detection requirements for hardware support are:\nCPUID.(EAX=07H, ECX=0H):EBX.BMI1[bit 3]: if 1 indicates the processor supports the first group of advanced bit \nmanipulation extensions (ANDN, BEXTR, BLSI, BLSMSK, BLSR, TZCNT);\nCPUID.(EAX=07H, ECX=0H):EBX.BMI2[bit 8]: if 1 indicates the processor supports the second group of advanced \nbit manipulation extensions (BZHI, MULX, PDEP, PEXT, RORX, SARX, SHLX, SHRX);\nCPUID.EAX=80000001H:ECX.LZCNT[bit 5]: if 1 indicates the processor supports the LZCNT instruction.\nCPUID.EAX=80000001H:ECX.PREFTEHCHW[bit 8]: if 1 indicates the processor supports the PREFTEHCHW instruc-\ntion. CPUID.(EAX=07H, ECX=0H):ECX.PREFTEHCHWT1[bit 0]: if 1 indicates the processor supports the \nPREFTEHCHWT1 instruction.\n5-10 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\n5.2 X87 FPU INSTRUCTIONS\nThe x87 FPU instructions are executed by the processor’s x87 FPU. These instructions operate on floating-point, \ninteger, and binary-coded decimal (BCD) operands. For more detail on x87 FPU instructions, see Chapter 8, \n“Programming with the x87 FPU.”\n\nThese instructions are divided into the following subgroups: data transfer, load constants, and FPU control instruc-\ntions. The sections that follow introduce each subgroup.\n\n5.2.1 x87 FPU Data Transfer Instructions\nThe data transfer instructions move floating-point, integer, and BCD values between memory and the x87 FPU \nregisters. They also perform conditional move operations on floating-point operands.\nFLD Load floating-point value.\nFST Store floating-point value.\nFSTP Store floating-point value and pop.\nFILD Load integer.\nFIST Store integer.\nFISTP1 Store integer and pop.\nFBLD Load BCD.\nFBSTP Store BCD and pop.\nFXCH Exchange registers.\nFCMOVE Floating-point conditional move if equal.\nFCMOVNE Floating-point conditional move if not equal.\nFCMOVB Floating-point conditional move if below.\nFCMOVBE Floating-point conditional move if below or equal.\nFCMOVNB Floating-point conditional move if not below.\nFCMOVNBE Floating-point conditional move if not below or equal.\nFCMOVU Floating-point conditional move if unordered.\nFCMOVNU Floating-point conditional move if not unordered.\n\n5.2.2 x87 FPU Basic Arithmetic Instructions\nThe basic arithmetic instructions perform basic arithmetic operations on floating-point and integer operands.\nFADD Add floating-point\nFADDP Add floating-point and pop\nFIADD Add integer\nFSUB Subtract floating-point\nFSUBP Subtract floating-point and pop\nFISUB Subtract integer\nFSUBR Subtract floating-point reverse\nFSUBRP Subtract floating-point reverse and pop\nFISUBR Subtract integer reverse\nFMUL Multiply floating-point\nFMULP Multiply floating-point and pop\nFIMUL Multiply integer\nFDIV Divide floating-point\n\n1. SSE3 provides an instruction FISTTP for integer conversion.\nVol. 1 5-11\n\n\n\nINSTRUCTION SET SUMMARY\nFDIVP Divide floating-point and pop\nFIDIV Divide integer\nFDIVR Divide floating-point reverse\nFDIVRP Divide floating-point reverse and pop\nFIDIVR Divide integer reverse\nFPREM Partial remainder\nFPREM1 IEEE Partial remainder\nFABS Absolute value\nFCHS Change sign\nFRNDINT Round to integer\nFSCALE Scale by power of two\nFSQRT Square root\nFXTRACT Extract exponent and significand\n\n5.2.3 x87 FPU Comparison Instructions\nThe compare instructions examine or compare floating-point or integer operands.\nFCOM Compare floating-point.\nFCOMP Compare floating-point and pop.\nFCOMPP Compare floating-point and pop twice.\nFUCOM Unordered compare floating-point.\nFUCOMP Unordered compare floating-point and pop.\nFUCOMPP Unordered compare floating-point and pop twice.\nFICOM Compare integer.\nFICOMP Compare integer and pop.\nFCOMI Compare floating-point and set EFLAGS.\nFUCOMI Unordered compare floating-point and set EFLAGS.\nFCOMIP Compare floating-point, set EFLAGS, and pop.\nFUCOMIP Unordered compare floating-point, set EFLAGS, and pop.\nFTST Test floating-point (compare with 0.0).\nFXAM Examine floating-point.\n\n5.2.4 x87 FPU Transcendental Instructions\nThe transcendental instructions perform basic trigonometric and logarithmic operations on floating-point operands.\nFSIN Sine\nFCOS Cosine\nFSINCOS Sine and cosine\nFPTAN Partial tangent\nFPATAN Partial arctangent\nF2XM1 2x − 1\nFYL2X y∗log2x\nFYL2XP1 y∗log2(x+1)\n\n5.2.5 x87 FPU Load Constants Instructions\nThe load constants instructions load common constants, such as π, into the x87 floating-point registers.\n5-12 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nFLD1 Load +1.0\nFLDZ Load +0.0\nFLDPI Load π\nFLDL2E Load log2e\nFLDLN2 Load loge2\nFLDL2T Load log210\nFLDLG2 Load log102\n\n5.2.6 x87 FPU Control Instructions\nThe x87 FPU control instructions operate on the x87 FPU register stack and save and restore the x87 FPU state.\nFINCSTP Increment FPU register stack pointer.\nFDECSTP Decrement FPU register stack pointer.\nFFREE Free floating-point register.\nFINIT Initialize FPU after checking error conditions.\nFNINIT Initialize FPU without checking error conditions.\nFCLEX Clear floating-point exception flags after checking for error conditions.\nFNCLEX Clear floating-point exception flags without checking for error conditions.\nFSTCW Store FPU control word after checking error conditions.\nFNSTCW Store FPU control word without checking error conditions.\nFLDCW Load FPU control word.\nFSTENV Store FPU environment after checking error conditions.\nFNSTENV Store FPU environment without checking error conditions.\nFLDENV Load FPU environment.\nFSAVE Save FPU state after checking error conditions.\nFNSAVE Save FPU state without checking error conditions.\nFRSTOR Restore FPU state.\nFSTSW Store FPU status word after checking error conditions.\nFNSTSW Store FPU status word without checking error conditions.\nWAIT/FWAIT Wait for FPU.\nFNOP FPU no operation.\n\n5.3 X87 FPU AND SIMD STATE MANAGEMENT INSTRUCTIONS\nTwo state management instructions were introduced into the IA-32 architecture with the Pentium II processor \nfamily:\nFXSAVE Save x87 FPU and SIMD state.\nFXRSTOR Restore x87 FPU and SIMD state.\n\nInitially, these instructions operated only on the x87 FPU (and MMX) registers to perform a fast save and restore, \nrespectively, of the x87 FPU and MMX state. With the introduction of SSE extensions in the Pentium III processor \nfamily, these instructions were expanded to also save and restore the state of the XMM and MXCSR registers. Intel \n64 architecture also supports these instructions.\n\nSee Section 10.5, “FXSAVE and FXRSTOR Instructions,” for more detail.\n\n5.4 MMX™ INSTRUCTIONS\nFour extensions have been introduced into the IA-32 architecture to permit IA-32 processors to perform single-\ninstruction multiple-data (SIMD) operations. These extensions include the MMX technology, SSE extensions, SSE2 \nVol. 1 5-13\n\n\n\nINSTRUCTION SET SUMMARY\nextensions, and SSE3 extensions. For a discussion that puts SIMD instructions in their historical context, see \nSection 2.2.7, “SIMD Instructions.”\n\nMMX instructions operate on packed byte, word, doubleword, or quadword integer operands contained in memory, \nin MMX registers, and/or in general-purpose registers. For more detail on these instructions, see Chapter 9, \n“Programming with Intel® MMX™ Technology.” \n\nMMX instructions can only be executed on Intel 64 and IA-32 processors that support the MMX technology. Support \nfor these instructions can be detected with the CPUID instruction. See the description of the CPUID instruction in \nChapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 2A.\n\nMMX instructions are divided into the following subgroups: data transfer, conversion, packed arithmetic, compar-\nison, logical, shift and rotate, and state management instructions. The sections that follow introduce each \nsubgroup.\n\n5.4.1 MMX Data Transfer Instructions\nThe data transfer instructions move doubleword and quadword operands between MMX registers and between MMX \nregisters and memory.\nMOVD Move doubleword.\nMOVQ Move quadword.\n\n5.4.2 MMX Conversion Instructions\nThe conversion instructions pack and unpack bytes, words, and doublewords\nPACKSSWB Pack words into bytes with signed saturation.\nPACKSSDW Pack doublewords into words with signed saturation.\nPACKUSWB Pack words into bytes with unsigned saturation.\nPUNPCKHBW Unpack high-order bytes.\nPUNPCKHWD Unpack high-order words.\nPUNPCKHDQ Unpack high-order doublewords.\nPUNPCKLBW Unpack low-order bytes.\nPUNPCKLWD Unpack low-order words.\nPUNPCKLDQ Unpack low-order doublewords.\n\n5.4.3 MMX Packed Arithmetic Instructions\nThe packed arithmetic instructions perform packed integer arithmetic on packed byte, word, and doubleword inte-\ngers.\nPADDB Add packed byte integers.\nPADDW Add packed word integers.\nPADDD Add packed doubleword integers.\nPADDSB Add packed signed byte integers with signed saturation.\nPADDSW Add packed signed word integers with signed saturation.\nPADDUSB Add packed unsigned byte integers with unsigned saturation.\nPADDUSW Add packed unsigned word integers with unsigned saturation.\nPSUBB Subtract packed byte integers.\nPSUBW Subtract packed word integers.\nPSUBD Subtract packed doubleword integers.\nPSUBSB Subtract packed signed byte integers with signed saturation.\nPSUBSW Subtract packed signed word integers with signed saturation.\n5-14 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nPSUBUSB Subtract packed unsigned byte integers with unsigned saturation.\nPSUBUSW Subtract packed unsigned word integers with unsigned saturation.\nPMULHW Multiply packed signed word integers and store high result.\nPMULLW Multiply packed signed word integers and store low result.\nPMADDWD Multiply and add packed word integers.\n\n5.4.4 MMX Comparison Instructions\nThe compare instructions compare packed bytes, words, or doublewords.\nPCMPEQB Compare packed bytes for equal.\nPCMPEQW Compare packed words for equal.\nPCMPEQD Compare packed doublewords for equal.\nPCMPGTB Compare packed signed byte integers for greater than.\nPCMPGTW Compare packed signed word integers for greater than.\nPCMPGTD Compare packed signed doubleword integers for greater than.\n\n5.4.5 MMX Logical Instructions\nThe logical instructions perform AND, AND NOT, OR, and XOR operations on quadword operands.\nPAND Bitwise logical AND.\nPANDN Bitwise logical AND NOT.\nPOR Bitwise logical OR.\nPXOR Bitwise logical exclusive OR.\n\n5.4.6 MMX Shift and Rotate Instructions\nThe shift and rotate instructions shift and rotate packed bytes, words, or doublewords, or quadwords in 64-bit \noperands.\nPSLLW Shift packed words left logical.\nPSLLD Shift packed doublewords left logical.\nPSLLQ Shift packed quadword left logical.\nPSRLW Shift packed words right logical.\nPSRLD Shift packed doublewords right logical.\nPSRLQ Shift packed quadword right logical.\nPSRAW Shift packed words right arithmetic.\nPSRAD Shift packed doublewords right arithmetic.\n\n5.4.7 MMX State Management Instructions\nThe EMMS instruction clears the MMX state from the MMX registers.\nEMMS Empty MMX state.\n\n5.5 SSE INSTRUCTIONS\nSSE instructions represent an extension of the SIMD execution model introduced with the MMX technology. For \nmore detail on these instructions, see Chapter 10, “Programming with Intel® Streaming SIMD Extensions (Intel® \nSSE).”\nVol. 1 5-15\n\n\n\nINSTRUCTION SET SUMMARY\nSSE instructions can only be executed on Intel 64 and IA-32 processors that support SSE extensions. Support for \nthese instructions can be detected with the CPUID instruction. See the description of the CPUID instruction in \nChapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 2A.\n\nSSE instructions are divided into four subgroups (note that the first subgroup has subordinate subgroups of its \nown):\n• SIMD single-precision floating-point instructions that operate on the XMM registers.\n• MXCSR state management instructions.\n• 64-bit SIMD integer instructions that operate on the MMX registers.\n• Cacheability control, prefetch, and instruction ordering instructions.\n\nThe following sections provide an overview of these groups.\n\n5.5.1 SSE SIMD Single-Precision Floating-Point Instructions\nThese instructions operate on packed and scalar single-precision floating-point values located in XMM registers \nand/or memory. This subgroup is further divided into the following subordinate subgroups: data transfer, packed \narithmetic, comparison, logical, shuffle and unpack, and conversion instructions.\n\n5.5.1.1  SSE Data Transfer Instructions\nSSE data transfer instructions move packed and scalar single-precision floating-point operands between XMM \nregisters and between XMM registers and memory.\nMOVAPS Move four aligned packed single-precision floating-point values between XMM registers or \n\nbetween and XMM register and memory.\nMOVUPS Move four unaligned packed single-precision floating-point values between XMM registers \n\nor between and XMM register and memory.\nMOVHPS Move two packed single-precision floating-point values to an from the high quadword of an \n\nXMM register and memory.\nMOVHLPS Move two packed single-precision floating-point values from the high quadword of an XMM \n\nregister to the low quadword of another XMM register.\nMOVLPS Move two packed single-precision floating-point values to an from the low quadword of an \n\nXMM register and memory.\nMOVLHPS Move two packed single-precision floating-point values from the low quadword of an XMM \n\nregister to the high quadword of another XMM register.\nMOVMSKPS Extract sign mask from four packed single-precision floating-point values.\nMOVSS Move scalar single-precision floating-point value between XMM registers or between an \n\nXMM register and memory.\n\n5.5.1.2  SSE Packed Arithmetic Instructions\nSSE packed arithmetic instructions perform packed and scalar arithmetic operations on packed and scalar single-\nprecision floating-point operands.\nADDPS Add packed single-precision floating-point values.\nADDSS Add scalar single-precision floating-point values.\nSUBPS Subtract packed single-precision floating-point values.\nSUBSS Subtract scalar single-precision floating-point values.\nMULPS Multiply packed single-precision floating-point values.\nMULSS Multiply scalar single-precision floating-point values.\nDIVPS Divide packed single-precision floating-point values.\nDIVSS Divide scalar single-precision floating-point values.\n5-16 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nRCPPS Compute reciprocals of packed single-precision floating-point values.\nRCPSS Compute reciprocal of scalar single-precision floating-point values.\nSQRTPS Compute square roots of packed single-precision floating-point values.\nSQRTSS Compute square root of scalar single-precision floating-point values.\nRSQRTPS Compute reciprocals of square roots of packed single-precision floating-point values.\nRSQRTSS Compute reciprocal of square root of scalar single-precision floating-point values.\nMAXPS Return maximum packed single-precision floating-point values.\nMAXSS Return maximum scalar single-precision floating-point values.\nMINPS Return minimum packed single-precision floating-point values.\nMINSS Return minimum scalar single-precision floating-point values.\n\n5.5.1.3  SSE Comparison Instructions\nSSE compare instructions compare packed and scalar single-precision floating-point operands.\nCMPPS Compare packed single-precision floating-point values.\nCMPSS Compare scalar single-precision floating-point values.\nCOMISS Perform ordered comparison of scalar single-precision floating-point values and set flags in \n\nEFLAGS register.\nUCOMISS Perform unordered comparison of scalar single-precision floating-point values and set flags \n\nin EFLAGS register.\n\n5.5.1.4  SSE Logical Instructions\nSSE logical instructions perform bitwise AND, AND NOT, OR, and XOR operations on packed single-precision \nfloating-point operands.\nANDPS Perform bitwise logical AND of packed single-precision floating-point values.\nANDNPS Perform bitwise logical AND NOT of packed single-precision floating-point values.\nORPS Perform bitwise logical OR of packed single-precision floating-point values.\nXORPS Perform bitwise logical XOR of packed single-precision floating-point values.\n\n5.5.1.5  SSE Shuffle and Unpack Instructions\nSSE shuffle and unpack instructions shuffle or interleave single-precision floating-point values in packed single-\nprecision floating-point operands.\nSHUFPS Shuffles values in packed single-precision floating-point operands.\nUNPCKHPS Unpacks and interleaves the two high-order values from two single-precision floating-point \n\noperands.\nUNPCKLPS Unpacks and interleaves the two low-order values from two single-precision floating-point \n\noperands.\n\n5.5.1.6  SSE Conversion Instructions\nSSE conversion instructions convert packed and individual doubleword integers into packed and scalar single-\nprecision floating-point values and vice versa.\nCVTPI2PS Convert packed doubleword integers to packed single-precision floating-point values.\nCVTSI2SS Convert doubleword integer to scalar single-precision floating-point value.\nCVTPS2PI Convert packed single-precision floating-point values to packed doubleword integers.\nCVTTPS2PI Convert with truncation packed single-precision floating-point values to packed double-\n\nword integers.\nCVTSS2SI Convert a scalar single-precision floating-point value to a doubleword integer.\nVol. 1 5-17\n\n\n\nINSTRUCTION SET SUMMARY\nCVTTSS2SI Convert with truncation a scalar single-precision floating-point value to a scalar double-\nword integer.\n\n5.5.2 SSE MXCSR State Management Instructions\nMXCSR state management instructions allow saving and restoring the state of the MXCSR control and status \nregister.\nLDMXCSR Load MXCSR register.\nSTMXCSR Save MXCSR register state.\n\n5.5.3 SSE 64-Bit SIMD Integer Instructions\nThese SSE 64-bit SIMD integer instructions perform additional operations on packed bytes, words, or doublewords \ncontained in MMX registers. They represent enhancements to the MMX instruction set described in Section 5.4, \n“MMX™ Instructions.”\nPAVGB Compute average of packed unsigned byte integers.\nPAVGW Compute average of packed unsigned word integers.\nPEXTRW Extract word.\nPINSRW Insert word.\nPMAXUB Maximum of packed unsigned byte integers.\nPMAXSW Maximum of packed signed word integers.\nPMINUB Minimum of packed unsigned byte integers.\nPMINSW Minimum of packed signed word integers.\nPMOVMSKB Move byte mask.\nPMULHUW Multiply packed unsigned integers and store high result.\nPSADBW Compute sum of absolute differences.\nPSHUFW Shuffle packed integer word in MMX register.\n\n5.5.4 SSE Cacheability Control, Prefetch, and Instruction Ordering Instructions\nThe cacheability control instructions provide control over the caching of non-temporal data when storing data from \nthe MMX and XMM registers to memory. The PREFETCHh allows data to be prefetched to a selected cache level. The \nSFENCE instruction controls instruction ordering on store operations.\nMASKMOVQ Non-temporal store of selected bytes from an MMX register into memory.\nMOVNTQ Non-temporal store of quadword from an MMX register into memory.\nMOVNTPS Non-temporal store of four packed single-precision floating-point values from an XMM \n\nregister into memory.\nPREFETCHh Load 32 or more of bytes from memory to a selected level of the processor’s cache hier-\n\narchy\nSFENCE Serializes store operations.\n\n5.6 SSE2 INSTRUCTIONS\nSSE2 extensions represent an extension of the SIMD execution model introduced with MMX technology and the \nSSE extensions. SSE2 instructions operate on packed double-precision floating-point operands and on packed \nbyte, word, doubleword, and quadword operands located in the XMM registers. For more detail on these instruc-\ntions, see Chapter 11, “Programming with Intel® Streaming SIMD Extensions 2 (Intel® SSE2).”\n\nSSE2 instructions can only be executed on Intel 64 and IA-32 processors that support the SSE2 extensions. \nSupport for these instructions can be detected with the CPUID instruction. See the description of the CPUID instruc-\n5-18 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\ntion in Chapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s \nManual, Volume 2A.\n\nThese instructions are divided into four subgroups (note that the first subgroup is further divided into subordinate \nsubgroups):\n• Packed and scalar double-precision floating-point instructions.\n• Packed single-precision floating-point conversion instructions.\n• 128-bit SIMD integer instructions.\n• Cacheability-control and instruction ordering instructions.\n\nThe following sections give an overview of each subgroup.\n\n5.6.1 SSE2 Packed and Scalar Double-Precision Floating-Point Instructions\nSSE2 packed and scalar double-precision floating-point instructions are divided into the following subordinate \nsubgroups: data movement, arithmetic, comparison, conversion, logical, and shuffle operations on double-preci-\nsion floating-point operands. These are introduced in the sections that follow.\n\n5.6.1.1  SSE2 Data Movement Instructions\nSSE2 data movement instructions move double-precision floating-point data between XMM registers and between \nXMM registers and memory.\nMOVAPD Move two aligned packed double-precision floating-point values between XMM registers or \n\nbetween and XMM register and memory.\nMOVUPD Move two unaligned packed double-precision floating-point values between XMM registers \n\nor between and XMM register and memory.\nMOVHPD Move high packed double-precision floating-point value to an from the high quadword of an \n\nXMM register and memory.\nMOVLPD Move low packed single-precision floating-point value to an from the low quadword of an \n\nXMM register and memory.\nMOVMSKPD Extract sign mask from two packed double-precision floating-point values.\nMOVSD Move scalar double-precision floating-point value between XMM registers or between an \n\nXMM register and memory.\n\n5.6.1.2  SSE2 Packed Arithmetic Instructions\nThe arithmetic instructions perform addition, subtraction, multiply, divide, square root, and maximum/minimum \noperations on packed and scalar double-precision floating-point operands.\nADDPD Add packed double-precision floating-point values.\nADDSD Add scalar double precision floating-point values.\nSUBPD Subtract packed double-precision floating-point values.\nSUBSD Subtract scalar double-precision floating-point values.\nMULPD Multiply packed double-precision floating-point values.\nMULSD Multiply scalar double-precision floating-point values.\nDIVPD Divide packed double-precision floating-point values.\nDIVSD Divide scalar double-precision floating-point values.\nSQRTPD Compute packed square roots of packed double-precision floating-point values.\nSQRTSD Compute scalar square root of scalar double-precision floating-point values.\nMAXPD Return maximum packed double-precision floating-point values.\nMAXSD Return maximum scalar double-precision floating-point values.\nMINPD Return minimum packed double-precision floating-point values.\nVol. 1 5-19\n\n\n\nINSTRUCTION SET SUMMARY\nMINSD Return minimum scalar double-precision floating-point values.\n\n5.6.1.3  SSE2 Logical Instructions\nSSE2 logical instructions perform AND, AND NOT, OR, and XOR operations on packed double-precision floating-\npoint values.\nANDPD Perform bitwise logical AND of packed double-precision floating-point values.\nANDNPD Perform bitwise logical AND NOT of packed double-precision floating-point values.\nORPD Perform bitwise logical OR of packed double-precision floating-point values.\nXORPD Perform bitwise logical XOR of packed double-precision floating-point values.\n\n5.6.1.4  SSE2 Compare Instructions\nSSE2 compare instructions compare packed and scalar double-precision floating-point values and return the \nresults of the comparison either to the destination operand or to the EFLAGS register.\nCMPPD Compare packed double-precision floating-point values.\nCMPSD Compare scalar double-precision floating-point values.\nCOMISD Perform ordered comparison of scalar double-precision floating-point values and set flags \n\nin EFLAGS register.\nUCOMISD Perform unordered comparison of scalar double-precision floating-point values and set \n\nflags in EFLAGS register.\n\n5.6.1.5  SSE2 Shuffle and Unpack Instructions\nSSE2 shuffle and unpack instructions shuffle or interleave double-precision floating-point values in packed double-\nprecision floating-point operands.\nSHUFPD Shuffles values in packed double-precision floating-point operands.\nUNPCKHPD Unpacks and interleaves the high values from two packed double-precision floating-point \n\noperands.\nUNPCKLPD Unpacks and interleaves the low values from two packed double-precision floating-point \n\noperands.\n\n5.6.1.6  SSE2 Conversion Instructions\nSSE2 conversion instructions convert packed and individual doubleword integers into packed and scalar double-\nprecision floating-point values and vice versa. They also convert between packed and scalar single-precision and \ndouble-precision floating-point values.\nCVTPD2PI Convert packed double-precision floating-point values to packed doubleword integers.\nCVTTPD2PI Convert with truncation packed double-precision floating-point values to packed double-\n\nword integers.\nCVTPI2PD Convert packed doubleword integers to packed double-precision floating-point values.\nCVTPD2DQ Convert packed double-precision floating-point values to packed doubleword integers.\nCVTTPD2DQ Convert with truncation packed double-precision floating-point values to packed double-\n\nword integers.\nCVTDQ2PD Convert packed doubleword integers to packed double-precision floating-point values.\nCVTPS2PD Convert packed single-precision floating-point values to packed double-precision floating-\n\npoint values.\nCVTPD2PS Convert packed double-precision floating-point values to packed single-precision floating-\n\npoint values.\nCVTSS2SD Convert scalar single-precision floating-point values to scalar double-precision floating-\n\npoint values.\n5-20 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nCVTSD2SS Convert scalar double-precision floating-point values to scalar single-precision floating-\npoint values.\n\nCVTSD2SI Convert scalar double-precision floating-point values to a doubleword integer.\nCVTTSD2SI Convert with truncation scalar double-precision floating-point values to scalar doubleword \n\nintegers.\nCVTSI2SD Convert doubleword integer to scalar double-precision floating-point value.\n\n5.6.2 SSE2 Packed Single-Precision Floating-Point Instructions\nSSE2 packed single-precision floating-point instructions perform conversion operations on single-precision \nfloating-point and integer operands. These instructions represent enhancements to the SSE single-precision \nfloating-point instructions.\nCVTDQ2PS Convert packed doubleword integers to packed single-precision floating-point values.\nCVTPS2DQ Convert packed single-precision floating-point values to packed doubleword integers.\nCVTTPS2DQ Convert with truncation packed single-precision floating-point values to packed double-\n\nword integers.\n\n5.6.3 SSE2 128-Bit SIMD Integer Instructions\nSSE2 SIMD integer instructions perform additional operations on packed words, doublewords, and quadwords \ncontained in XMM and MMX registers.\nMOVDQA Move aligned double quadword.\nMOVDQU Move unaligned double quadword.\nMOVQ2DQ Move quadword integer from MMX to XMM registers.\nMOVDQ2Q Move quadword integer from XMM to MMX registers.\nPMULUDQ Multiply packed unsigned doubleword integers.\nPADDQ Add packed quadword integers.\nPSUBQ Subtract packed quadword integers.\nPSHUFLW Shuffle packed low words.\nPSHUFHW Shuffle packed high words.\nPSHUFD Shuffle packed doublewords.\nPSLLDQ Shift double quadword left logical.\nPSRLDQ Shift double quadword right logical.\nPUNPCKHQDQ Unpack high quadwords.\nPUNPCKLQDQ Unpack low quadwords.\n\n5.6.4 SSE2 Cacheability Control and Ordering Instructions\nSSE2 cacheability control instructions provide additional operations for caching of non-temporal data when storing \ndata from XMM registers to memory. LFENCE and MFENCE provide additional control of instruction ordering on \nstore operations.\nCLFLUSH See Section 5.1.13.\nLFENCE Serializes load operations.\nMFENCE Serializes load and store operations.\nPAUSE Improves the performance of “spin-wait loops”.\nMASKMOVDQU Non-temporal store of selected bytes from an XMM register into memory.\nMOVNTPD Non-temporal store of two packed double-precision floating-point values from an XMM \n\nregister into memory.\nMOVNTDQ Non-temporal store of double quadword from an XMM register into memory.\nVol. 1 5-21\n\n\n\nINSTRUCTION SET SUMMARY\nMOVNTI Non-temporal store of a doubleword from a general-purpose register into memory.\n\n5.7 SSE3 INSTRUCTIONS\nThe SSE3 extensions offers 13 instructions that accelerate performance of Streaming SIMD Extensions technology, \nStreaming SIMD Extensions 2 technology, and x87-FP math capabilities. These instructions can be grouped into the \nfollowing categories:\n• One x87FPU instruction used in integer conversion.\n• One SIMD integer instruction that addresses unaligned data loads.\n• Two SIMD floating-point packed ADD/SUB instructions.\n• Four SIMD floating-point horizontal ADD/SUB instructions.\n• Three SIMD floating-point LOAD/MOVE/DUPLICATE instructions.\n• Two thread synchronization instructions.\n\nSSE3 instructions can only be executed on Intel 64 and IA-32 processors that support SSE3 extensions. Support \nfor these instructions can be detected with the CPUID instruction. See the description of the CPUID instruction in \nChapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s Manual, \nVolume 2A.\n\nThe sections that follow describe each subgroup.\n\n5.7.1 SSE3 x87-FP Integer Conversion Instruction\nFISTTP Behaves like the FISTP instruction but uses truncation, irrespective of the rounding mode \n\nspecified in the floating-point control word (FCW).\n\n5.7.2 SSE3 Specialized 128-bit Unaligned Data Load Instruction\nLDDQU Special 128-bit unaligned load designed to avoid cache line splits.\n\n5.7.3 SSE3 SIMD Floating-Point Packed ADD/SUB Instructions\nADDSUBPS Performs single-precision addition on the second and fourth pairs of 32-bit data elements \n\nwithin the operands; single-precision subtraction on the first and third pairs.\nADDSUBPD Performs double-precision addition on the second pair of quadwords, and double-precision \n\nsubtraction on the first pair.\n\n5.7.4 SSE3 SIMD Floating-Point Horizontal ADD/SUB Instructions\nHADDPS Performs a single-precision addition on contiguous data elements. The first data element of \n\nthe result is obtained by adding the first and second elements of the first operand; the \nsecond element by adding the third and fourth elements of the first operand; the third by \nadding the first and second elements of the second operand; and the fourth by adding the \nthird and fourth elements of the second operand.\n\nHSUBPS Performs a single-precision subtraction on contiguous data elements. The first data \nelement of the result is obtained by subtracting the second element of the first operand \nfrom the first element of the first operand; the second element by subtracting the fourth \nelement of the first operand from the third element of the first operand; the third by \nsubtracting the second element of the second operand from the first element of the second \noperand; and the fourth by subtracting the fourth element of the second operand from the \nthird element of the second operand.\n5-22 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\nHADDPD Performs a double-precision addition on contiguous data elements. The first data element \nof the result is obtained by adding the first and second elements of the first operand; the \nsecond element by adding the first and second elements of the second operand.\n\nHSUBPD Performs a double-precision subtraction on contiguous data elements. The first data \nelement of the result is obtained by subtracting the second element of the first operand \nfrom the first element of the first operand; the second element by subtracting the second \nelement of the second operand from the first element of the second operand.\n\n5.7.5 SSE3 SIMD Floating-Point LOAD/MOVE/DUPLICATE Instructions\nMOVSHDUP Loads/moves 128 bits; duplicating the second and fourth 32-bit data elements.\nMOVSLDUP Loads/moves 128 bits; duplicating the first and third 32-bit data elements.\nMOVDDUP Loads/moves 64 bits (bits[63:0] if the source is a register) and returns the same 64 bits in \n\nboth the lower and upper halves of the 128-bit result register; duplicates the 64 bits from \nthe source.\n\n5.7.6 SSE3 Agent Synchronization Instructions\nMONITOR Sets up an address range used to monitor write-back stores.\nMWAIT Enables a logical processor to enter into an optimized state while waiting for a write-back \n\nstore to the address range set up by the MONITOR instruction.\n\n5.8 SUPPLEMENTAL STREAMING SIMD EXTENSIONS 3 (SSSE3) INSTRUCTIONS\nSSSE3 provide 32 instructions (represented by 14 mnemonics) to accelerate computations on packed integers. \nThese include:\n• Twelve instructions that perform horizontal addition or subtraction operations.\n• Six instructions that evaluate absolute values.\n• Two instructions that perform multiply and add operations and speed up the evaluation of dot products.\n• Two instructions that accelerate packed-integer multiply operations and produce integer values with scaling.\n• Two instructions that perform a byte-wise, in-place shuffle according to the second shuffle control operand.\n• Six instructions that negate packed integers in the destination operand if the signs of the corresponding \n\nelement in the source operand is less than zero.\n• Two instructions that align data from the composite of two operands.\n\nSSSE3 instructions can only be executed on Intel 64 and IA-32 processors that support SSSE3 extensions. Support \nfor these instructions can be detected with the CPUID instruction. See the description of the CPUID instruction in \nChapter 3, “Instruction Set Reference, A-L,” of the Intel® 64 and IA-32 Architectures Software Developer’s \nManual, Volume 2A.\n\nThe sections that follow describe each subgroup.\n\n5.8.1 Horizontal Addition/Subtraction\nPHADDW Adds two adjacent, signed 16-bit integers horizontally from the source and destination \n\noperands and packs the signed 16-bit results to the destination operand.\nPHADDSW Adds two adjacent, signed 16-bit integers horizontally from the source and destination \n\noperands and packs the signed, saturated 16-bit results to the destination operand.\nPHADDD Adds two adjacent, signed 32-bit integers horizontally from the source and destination \n\noperands and packs the signed 32-bit results to the destination operand.\nPHSUBW Performs horizontal subtraction on each adjacent pair of 16-bit signed integers by \n\nsubtracting the most significant word from the least significant word of each pair in the \nVol. 1 5-23\n\n\n\nINSTRUCTION SET SUMMARY\nsource and destination operands. The signed 16-bit results are packed and written to the \ndestination operand.\n\nPHSUBSW Performs horizontal subtraction on each adjacent pair of 16-bit signed integers by \nsubtracting the most significant word from the least significant word of each pair in the \nsource and destination operands. The signed, saturated 16-bit results are packed and \nwritten to the destination operand.\n\nPHSUBD Performs horizontal subtraction on each adjacent pair of 32-bit signed integers by \nsubtracting the most significant doubleword from the least significant double word of each \npair in the source and destination operands. The signed 32-bit results are packed and \nwritten to the destination operand.\n\n5.8.2 Packed Absolute Values\nPABSB Computes the absolute value of each signed byte data element.\nPABSW Computes the absolute value of each signed 16-bit data element.\nPABSD Computes the absolute value of each signed 32-bit data element. \n\n5.8.3 Multiply and Add Packed Signed and Unsigned Bytes\nPMADDUBSW Multiplies each unsigned byte value with the corresponding signed byte value to produce \n\nan intermediate, 16-bit signed integer. Each adjacent pair of 16-bit signed values are \nadded horizontally. The signed, saturated 16-bit results are packed to the destination \noperand.\n\n5.8.4 Packed Multiply High with Round and Scale\nPMULHRSW Multiplies vertically each signed 16-bit integer from the destination operand with the corre-\n\nsponding signed 16-bit integer of the source operand, producing intermediate, signed 32-\nbit integers. Each intermediate 32-bit integer is truncated to the 18 most significant bits. \nRounding is always performed by adding 1 to the least significant bit of the 18-bit interme-\ndiate result. The final result is obtained by selecting the 16 bits immediately to the right of \nthe most significant bit of each 18-bit intermediate result and packed to the destination \noperand.\n\n5.8.5 Packed Shuffle Bytes\nPSHUFB Permutes each byte in place, according to a shuffle control mask. The least significant \n\nthree or four bits of each shuffle control byte of the control mask form the shuffle index. \nThe shuffle mask is unaffected. If the most significant bit (bit 7) of a shuffle control byte is \nset, the constant zero is written in the result byte.\n\n5.8.6 Packed Sign\nPSIGNB/W/D Negates each signed integer element of the destination operand if the sign of the corre-\n\nsponding data element in the source operand is less than zero.\n\n5.8.7 Packed Align Right\nPALIGNR Source operand is appended after the destination operand forming an intermediate value \n\nof twice the width of an operand. The result is extracted from the intermediate value into \nthe destination operand by selecting the 128 bit or 64 bit value that are right-aligned to the \nbyte offset specified by the immediate value.\n5-24 Vol. 1\n\n\n\nINSTRUCTION SET SUMMARY\n5.9 SSE4 INSTRUCTIONS\nIntel® Streaming SIMD Extensions 4 (SSE4) introduces 54 new instructions. 47 of the SSE4 instructions are \nreferred to as SSE4.1 in this document, 7 new SSE4 instructions are referred to as SSE4.2. \n\nSSE4.1 is targeted to improve the performance of media, imaging, and 3D workloads. SSE4.1 adds instructions \nthat improve compiler vectorization and significantly increase support for packed dword computation. The tech-\nnology also provides a hint that can improve memory throughput when reading from uncacheable WC memory \ntype.\n\nThe 47 SSE4.1 instructions include:\n• Two instructions perform packed dword multiplies.\n• Two instructions perform floating-point dot products with input/output selects.\n• One instruction performs a load with a streaming hint.\n• Six instructions simplify packed blending.\n• Eight instructions expand support for packed integer MIN/MAX.\n• Four instructions support floating-point round with selectable rounding mode and precision exception override.\n• Seven instructions improve data insertion and extractions from XMM registers\n• Twelve instructions improve packed integer format conversions (sign and zero extensions).\n• One instruction improves SAD (sum absolute difference) generation for small block sizes.\n• One instruction aids horizontal searching operations.\n• One instruction improves masked comparisons.\n• One instruction adds qword packed equality comparisons.\n• One instruction adds dword packing with unsigned saturation.\n\nThe SSE4.2 instructions operating on XMM registers include:\n• String and text processing that can take advantage of single-instruction multiple-data programming \n\ntechniques.\n• A SIMD integer instruction that enhances the capability of the 128-bit integer SIMD capability in SSE4.1.\n\n5.10 SSE4.1 INSTRUCTIONS\nSSE4.1 instructions can use an XMM register as a source or destination. Programming SSE4.1 is similar to \nprogramming 128-bit Integer SIMD and floating-point SIMD instructions in SSE/SSE2/SSE3/SSSE3. SSE4.1 does \nnot provide any 64-bit integer SIMD instructions operating on MMX registers. The sections that follow describe \neach subgroup.\n\n5.10.1 Dword Multiply Instructions \nPMULLD Returns four lower 32-bits of the 64-bit results of signed 32-bit integer multiplies.\nPMULDQ Returns two 64-bit signed result of signed 32-bit integer multiplies.\n\n5.10.2 Floating-Point Dot Product Instructions\nDPPD Perform double-precision dot product for up to 2 elements and broadcast.\nDPPS Perform single-precision dot products for up to 4 elements and broadcast.\n\n5.10.3 Streaming Load Hint Instruction\nMOVNTDQA Provides a non-temporal hint that can cause adjacent 16-byte items within an aligned 64-\n\nbyte region (a streaming line) to be fetched and held in a small set of temporary buffers \nVol. 1 5-25\n\n\n\nINSTRUCTION SET SUMMARY\n(“streaming load buffers”). Subsequent streaming loads to other aligned 16-byte items in \nthe same streaming line may be supplied from the streaming load buffer and can improve \nthroughput.\n\n5.10.4 Packed Blending Instructions\nBLENDPD Conditionally copies specified double-precision floating-point data elements in the source \n\noperand to the corresponding data elements in the destination, using an immediate byte \ncontrol. \n\nBLENDPS Conditionally copies specified single-precision floating-point data elements in the source \noperand to the corresponding data elements in the destination, using an immediate byte \ncontrol.\n\nBLENDVPD Conditionally copies specified double-precision floating-point data elements in the source \noperand to the corresponding data elements in the destination, using an implied mask. \n\nBLENDVPS Conditionally copies specified single-precision floating-point data elements ","extracted_metadata":{"access_permission:fill_in_form":["true"],"pdf:docinfo:title":["Intel(R) 64 and IA-32 Architectures Software Developer's Manual, Combined Volumes: 1, 2ABCD, 3ABCD, and 4"],"Content-Type":["application/pdf"],"dcterms:created":["2021-06-28T12:21:04Z"],"xmpTPg:NPages":["4778"],"pdf:docinfo:producer":["Acrobat Distiller 21.0 (Windows)"],"pdf:docinfo:creator_tool":["FrameMaker 10.0.2"],"pdf:hasMarkedContent":["false"],"pdf:PDFVersion":["1.6"],"pdf:hasXFA":["false"],"X-TIKA:EXCEPTION:write_limit_reached":["true"],"pdf:docinfo:creator":["Intel Corporation"],"pdf:encrypted":["true"],"pdf:unmappedUnicodeCharsPerPage":["0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0","0"],"access_permission:extract_for_accessibility":["true"],"X-TIKA:Parsed-By":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"access_permission:assemble_document":["true"],"pdf:hasXMP":["true"],"xmpMM:DocumentID":["uuid:f01d258b-da68-460f-9726-fe37142e8506"],"access_permission:can_modify":["true"],"X-TIKA:Parsed-By-Full-Set":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"dc:creator":["Intel Corporation"],"access_permission:modify_annotations":["true"],"pdf:docinfo:modified":["2021-06-28T21:13:42Z"],"xmp:CreateDate":["2021-06-28T12:21:04Z"],"xmp:MetadataDate":["2021-06-28T21:13:42Z"],"xmp:ModifyDate":["2021-06-28T21:13:42Z"],"pdf:producer":["Acrobat Distiller 21.0 (Windows)"],"access_permission:can_print":["true"],"pdf:hasCollection":["false"],"dc:title":["Intel(R) 64 and IA-32 Architectures Software Developer's Manual, Combined Volumes: 1, 2ABCD, 3ABCD, and 4"],"dcterms:modified":["2021-06-28T21:13:42Z"],"access_permission:can_print_degraded":["true"],"pdf:charsPerPage":["510","1733","463","1733","9242","10567","11233","11450","10983","11312","11084","10649","10927","10604","10692","10169","10690","8265","462","11000","10871","400","10551","10613","2871","22","2568","2086","4320","4108","4071","2397","2164","1328","2431","27","2904","3939","3523","2946","3163","2884","1996","3298","1608","3739","1888","2755","2537","3961","2333","1947","2884","2623","1122","2939","2511","1839","1659","1475","1543","1598","1464","1579","3697","4232","894","3924","2178","1567","3048","2091","4238","4063","1662","2404","4010","2111","3177","2618","3951","4067","2324","2695","2238","3044","3507","1847","1345","2434","1404","2274","1872","2517","994","2047","718","2211","2716","779","2163","3080","3046","3759","4081","3223","3769","3645","2693","4067","3550","123","2355","3483","3120","3424","2191","1387","2159","1864","1566","2461","1939","1494","2203","2452","1844","3039","2906","2598","2876","2865","2474","2853","3336","2820","2747"],"access_permission:extract_content":["true"],"dc:format":["application/pdf; version=1.6"],"Content-Length":["52916900"],"pdf:docinfo:created":["2021-06-28T12:21:04Z"],"xmp:CreatorTool":["FrameMaker 10.0.2"],"resourceName":["Intel 64 and IA-32 Architectures Software Developer's Manual - Combined Volumes 1-4 - June 2021 (325462-sdm-vol-1-2abcd-3abcd).pdf"]},"metadata_field_count":40,"attempts":1,"timestamp":1754064940.5539432,"platform":"Linux","python_version":"3.13.5"},{"file_path":"test_documents/pdfs/Fundamentals_of_Deep_Learning_2014.pdf","file_size":56715281,"file_type":"pdf","category":"huge","framework":"extractous","iteration":2,"extraction_time":0.45744895935058594,"startup_time":null,"peak_memory_mb":425.59375,"avg_memory_mb":484.5078125,"peak_cpu_percent":91.6,"avg_cpu_percent":18.32,"total_io_mb":null,"status":"success","character_count":38842,"word_count":4872,"error_type":null,"error_message":null,"quality_metrics":{"char_count":38842,"word_count":4872,"sentence_count":285,"paragraph_count":535,"avg_word_length":5.3273809523809526,"avg_sentence_length":17.428070175438595,"extraction_completeness":1.0,"text_coherence":0.6666666666666666,"noise_ratio":0.40676175274187737,"gibberish_ratio":0.006369426751592357,"flesch_reading_ease":30.866139586346748,"gunning_fog_index":17.539937445140875,"has_proper_formatting":true,"maintains_line_breaks":true,"preserves_whitespace":true,"table_structure_preserved":true,"format_specific_score":0.49999999999999994,"expected_content_preserved":false,"has_encoding_issues":true,"has_ocr_artifacts":true,"preserves_pdf_formatting":true},"overall_quality_score":0.5373445602423348,"extracted_text":"\nFundamentals\t\r  of\t\r  Deep\t\r  Learning\t\r  \nof\t\r  Representa5ons\t\r  \n\n\t\r  \t\r  \nTel-­‐Aviv\t\r  University\t\r  \n\nDeep\t\r  Learning\t\r  Master\t\r  Class\t\r  \t\r  \n\t\r  \n\nYoshua\t\r  Bengio\t\r  \t\r  \nNovember\t\r  7,\t\r  2014,\t\r  Tel-­‐Aviv\t\r  \n\n\t\r  \n\n\n\nUltimate Goal \n• Understand\t\r  the\t\r  principles\t\r  \ngiving\t\r  rise\t\r  to\t\r  intelligence\t\r  \n\n\t\r  \n\n2\t\r  \n\n\n\nFocus \n• \t\r  Learning:\t\r  mathema5cal\t\r  \nand\t\r  computa5onal\t\r  \nprinciples\t\r  allowing\t\r  one\t\r  to\t\r  \nlearn\t\r  from\t\r  examples\t\r  in\t\r  \norder\t\r  to\t\r  acquire\t\r  knowledge\t\r  \t\r  \n\n\t\r  \n3\t\r  \n\n\n\nBreakthrough \n• \t\r  Deep\t\r  Learning:\t\r  machine\t\r  \nlearning\t\r  algorithms\t\r  inspired\t\r  \nby\t\r  brains,\t\r  based\t\r  on\t\r  learning\t\r  \nmul5ple\t\r  levels\t\r  of\t\r  \nrepresenta5on\t\r  /\t\r  abstrac5on.\t\r  \n\n\t\r  \n4\t\r  \n\n\n\nImpact \nDeep\t\r  learning\t\r  has\t\r  revolu5onized\t\r  \t\r  \n• Speech\t\r  recogni5on\t\r  \n• Object\t\r  recogni5on\t\r  \nMore\t\r  coming,\t\r  including\t\r  other\t\r  \nareas\t\r  of\t\r  computer\t\r  vision,\t\r  NLP,\t\r  \nmachine\t\r  transla5on,\t\r  dialogue,\t\r  \nreinforcement\t\r  learning…\t\r  \n\t\r  \n5\t\r  \n\n\n\nTechnical Goals Hierarchy \n\nTo\t\r  reach\t\r  AI:\t\r  \n•  Needs\t\r  knowledge\t\r  \n•  Needs\t\r  learning\t\r   \t\r   \t\r   \t\r   \t\r   \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \n\n(involves\t\r  priors\t\r  +\t\r  op#miza#on/search\t\r  +\t\r  efficient\t\r  computa#on)\t\r  \n\n•  Needs\t\r  generaliza5on\t\r   \t\r   \t\r   \t\r   \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \n(guessing\t\r  where\t\r  probability\t\r  mass\t\r  concentrates)\t\r  \n\n•  Needs\t\r  ways\t\r  to\t\r  fight\t\r  the\t\r  curse\t\r  of\t\r  dimensionality\t\r  \n(exponenHally\t\r  many\t\r  configuraHons\t\r  of\t\r  the\t\r  variables\t\r  to\t\r  consider)\t\r  \n\n•  Needs\t\r  disentangling\t\r  the\t\r  underlying\t\r  explanatory\t\r  factors\t\r  \n(making\t\r  sense\t\r  of\t\r  the\t\r  data)\t\r  \n\n6\t\r  \n\n\n\nEasy Learning \n\nlearned function: prediction = f(x)\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n\n*\n*\n\ntrue unknown function\n\n= example (x,y)*\n\nx\n\ny\n\n\n\nML 101. What We Are Fighting Against:  \nThe Curse of Dimensionality \n\n\t\r  \t\r  \t\r  To\t\r  generalize\t\r  locally,\t\r  \nneed\t\r  representaHve\t\r  \nexamples\t\r  for\t\r  all\t\r  \nrelevant\t\r  variaHons!\t\r  \n\n\t\r  \n\n\n\nNot Dimensionality so much as \nNumber of Variations \n\n•  Theorem:\t\r  Gaussian\t\r  kernel\t\r  machines\t\r  need\t\r  at\t\r  least\t\r  k\t\r  examples\t\r  \nto\t\r  learn\t\r  a\t\r  funcHon\t\r  that\t\r  has\t\r  2k\t\r  zero-­‐crossings\t\r  along\t\r  some\t\r  line\t\r  \n\n\t\r  \n\t\r  \n\t\r  \n\t\r  \n\t\r  \n•  Theorem:\t\r  For\t\r  a\t\r  Gaussian\t\r  kernel\t\r  machine\t\r  to\t\r  learn\t\r  some\t\r  \n\nmaximally\t\r  varying\t\r  funcHons\t\r  \t\r  over\t\r  d\t\r  inputs\t\r  requires\t\r  O(2d)\t\r  \nexamples\t\r  \n\n\t\r  \n\n(Bengio, Dellalleau & Le Roux 2007) \n\n\n\n10\t\r  \n\nFor AI Tasks: Manifold structure \n\n•  examples\t\r  concentrate\t\r  near\t\r  a\t\r  lower\t\r  dimensional\t\r  “manifold\t\r  \n•  Evidence:\t\r  most\t\r  input\t\r  configura5ons\t\r  are\t\r  unlikely\t\r  \n\n\n\n•  Good\t\r  features\t\r  essenHal\t\r  for\t\r  successful\t\r  ML:\t\r  90%\t\r  of\t\r  effort\t\r  \n\n•  HandcraYing\t\r  features\t\r  vs\t\r  learning\t\r  them\t\r  \n\n•  Good\t\r  representaHon?\t\r  \n•  guesses\t\r  \n\t\r  \t\r  \t\r  \t\r  \t\r  the\t\r  features\t\r  /\t\r  factors\t\r  /\t\r  causes\t\r  \n\nRepresentation Learning \n\n11\t\r  \n\nraw\t\r  \ninput\t\r  \ndata\t\r  \n\nrepresented\t\r  \nby\t\r  chosen\t\r  \nfeatures\t\r  \n\nMACHINE\t\r  \nLEARNING\t\r  \t\r  \n\nrepresented\t\r  \nby\t\r  learned\t\r  \nfeatures\t\r  \n\n\n\nInput\n\nHand-\ndesigned \nprogram\n\nOutput\n\nInput\n\nHand-\ndesigned \nfeatures\n\nMapping \nfrom \n\nfeatures\n\nOutput\n\nInput\n\nFeatures\n\nMapping \nfrom \n\nfeatures\n\nOutput\n\nInput\n\nSimplest \nfeatures\n\nMapping \nfrom \n\nfeatures\n\nOutput\n\nMost \ncomplex \nfeatures\n\nRule-based\nsystems\n\nClassic\nmachine\nlearning\n\nRepresentation\nlearning\n\nDeep\nlearning\n\nAutomating \nFeature Discovery \n\n12\t\r  \n\n\n\nLearning multiple levels of \nrepresentation \nThere\t\r  is\t\r  theoreHcal\t\r  and\t\r  empirical\t\r  evidence\t\r  in\t\r  favor\t\r  of\t\r  \nmulHple\t\r  levels\t\r  of\t\r  representaHon\t\r  \n\n\t\r  Exponen5al\t\r  gain\t\r  for\t\r  some\t\r  families\t\r  of\t\r  func5ons\t\r  \n\nBiologically\t\r  inspired\t\r  learning\t\r  \n\nBrain\t\r  has\t\r  a\t\r  deep\t\r  architecture\t\r  \n\nCortex\t\r  seems\t\r  to\t\r  have\t\r  a\t\r  \t\r  \ngeneric\t\r  learning\t\r  algorithm\t\r  \t\r  \n\nHumans\t\r  first\t\r  learn\t\r  simpler\t\r  \t\r  \nconcepts\t\r  and\t\r  compose\t\r  them\t\r  \n\nIt\t\r  works!\t\r  Speech\t\r  +\t\r  vision\t\r  breakthroughs\t\r  \n13\t\r  \n\n\n\nVisualizing and Understanding Convolutional Networks\n\n(a) (b)\n\n(c) (d) (e)\n\nFigure 6. (a): 1st layer features without feature scale clipping. Note that one feature dominates. (b): 1st layer features\nfrom (Krizhevsky et al., 2012). (c): Our 1st layer features. The smaller stride (2 vs 4) and filter size (7x7 vs 11x11)\nresults in more distinctive features and fewer “dead” features. (d): Visualizations of 2nd layer features from (Krizhevsky\net al., 2012). (e): Visualizations of our 2nd layer features. These are cleaner, with no aliasing artifacts that are visible in\n(d).\n\nCar wheel\nRacer\nCab\nPolice van\n\n \n\nPomeranian\nTennis ball\nKeeshond\nPekinese\n\nAfghan hound\nGordon setter\nIrish setter\nMortarboard\nFur coat\nAcademic gown\nAustralian terrier\nIce lolly\nVizsla\nNeck brace\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n0.8\n\n0.9\n\n \n\n \n\n0.05\n\n0.1\n\n0.15\n\n0.2\n\n0.25\n\nTrue Label: Pomeranian\n\n(a) Input Image (b) Layer 5, strongest feature map\n(c) Layer 5, strongest\nfeature map projections\n\n(d) Classifier, probability \nof correct class \n\n(e) Classifier, most \nprobable class \n\nTrue Label: Car Wheel\n\nTrue Label: Afghan Hound\n\nFigure 7. Three test examples where we systematically cover up di↵erent portions of the scene with a gray square (1st\ncolumn) and see how the top (layer 5) feature maps ((b) & (c)) and classifier output ((d) & (e)) changes. (b): for each\nposition of the gray scale, we record the total activation in one layer 5 feature map (the one with the strongest response\nin the unoccluded image). (c): a visualization of this feature map projected down into the input image (black square),\nalong with visualizations of this map from other images. The first row example shows the strongest feature to be the\ndog’s face. When this is covered-up the activity in the feature map decreases (blue area in (b)). (d): a map of correct\nclass probability, as a function of the position of the gray square. E.g. when the dog’s face is obscured, the probability\nfor “pomeranian” drops significantly. (e): the most probable label as a function of occluder position. E.g. in the 1st row,\nfor most locations it is “pomeranian”, but if the dog’s face is obscured but not the ball, then it predicts “tennis ball”. In\nthe 2nd example, text on the car is the strongest feature in layer 5, but the classifier is most sensitive to the wheel. The\n3rd example contains multiple objects. The strongest feature in layer 5 picks out the faces, but the classifier is sensitive\nto the dog (blue region in (d)), since it uses multiple feature maps.\n\nVisualizing and Understanding Convolutional Networks\n\n(a) (b)\n\n(c) (d) (e)\n\nFigure 6. (a): 1st layer features without feature scale clipping. Note that one feature dominates. (b): 1st layer features\nfrom (Krizhevsky et al., 2012). (c): Our 1st layer features. The smaller stride (2 vs 4) and filter size (7x7 vs 11x11)\nresults in more distinctive features and fewer “dead” features. (d): Visualizations of 2nd layer features from (Krizhevsky\net al., 2012). (e): Visualizations of our 2nd layer features. These are cleaner, with no aliasing artifacts that are visible in\n(d).\n\nCar wheel\nRacer\nCab\nPolice van\n\n \n\nPomeranian\nTennis ball\nKeeshond\nPekinese\n\nAfghan hound\nGordon setter\nIrish setter\nMortarboard\nFur coat\nAcademic gown\nAustralian terrier\nIce lolly\nVizsla\nNeck brace\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n0.8\n\n0.9\n\n \n\n \n\n0.05\n\n0.1\n\n0.15\n\n0.2\n\n0.25\n\nTrue Label: Pomeranian\n\n(a) Input Image (b) Layer 5, strongest feature map\n(c) Layer 5, strongest\nfeature map projections\n\n(d) Classifier, probability \nof correct class \n\n(e) Classifier, most \nprobable class \n\nTrue Label: Car Wheel\n\nTrue Label: Afghan Hound\n\nFigure 7. Three test examples where we systematically cover up di↵erent portions of the scene with a gray square (1st\ncolumn) and see how the top (layer 5) feature maps ((b) & (c)) and classifier output ((d) & (e)) changes. (b): for each\nposition of the gray scale, we record the total activation in one layer 5 feature map (the one with the strongest response\nin the unoccluded image). (c): a visualization of this feature map projected down into the input image (black square),\nalong with visualizations of this map from other images. The first row example shows the strongest feature to be the\ndog’s face. When this is covered-up the activity in the feature map decreases (blue area in (b)). (d): a map of correct\nclass probability, as a function of the position of the gray square. E.g. when the dog’s face is obscured, the probability\nfor “pomeranian” drops significantly. (e): the most probable label as a function of occluder position. E.g. in the 1st row,\nfor most locations it is “pomeranian”, but if the dog’s face is obscured but not the ball, then it predicts “tennis ball”. In\nthe 2nd example, text on the car is the strongest feature in layer 5, but the classifier is most sensitive to the wheel. The\n3rd example contains multiple objects. The strongest feature in layer 5 picks out the faces, but the classifier is sensitive\nto the dog (blue region in (d)), since it uses multiple feature maps.\n\nVisualizing and Understanding Convolutional Networks\n\n(a) (b)\n\n(c) (d) (e)\n\nFigure 6. (a): 1st layer features without feature scale clipping. Note that one feature dominates. (b): 1st layer features\nfrom (Krizhevsky et al., 2012). (c): Our 1st layer features. The smaller stride (2 vs 4) and filter size (7x7 vs 11x11)\nresults in more distinctive features and fewer “dead” features. (d): Visualizations of 2nd layer features from (Krizhevsky\net al., 2012). (e): Visualizations of our 2nd layer features. These are cleaner, with no aliasing artifacts that are visible in\n(d).\n\nCar wheel\nRacer\nCab\nPolice van\n\n \n\nPomeranian\nTennis ball\nKeeshond\nPekinese\n\nAfghan hound\nGordon setter\nIrish setter\nMortarboard\nFur coat\nAcademic gown\nAustralian terrier\nIce lolly\nVizsla\nNeck brace\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n \n\n0.1\n\n0.2\n\n0.3\n\n0.4\n\n0.5\n\n0.6\n\n0.7\n\n0.8\n\n0.9\n\n \n\n \n\n0.05\n\n0.1\n\n0.15\n\n0.2\n\n0.25\n\nTrue Label: Pomeranian\n\n(a) Input Image (b) Layer 5, strongest feature map\n(c) Layer 5, strongest\nfeature map projections\n\n(d) Classifier, probability \nof correct class \n\n(e) Classifier, most \nprobable class \n\nTrue Label: Car Wheel\n\nTrue Label: Afghan Hound\n\nFigure 7. Three test examples where we systematically cover up di↵erent portions of the scene with a gray square (1st\ncolumn) and see how the top (layer 5) feature maps ((b) & (c)) and classifier output ((d) & (e)) changes. (b): for each\nposition of the gray scale, we record the total activation in one layer 5 feature map (the one with the strongest response\nin the unoccluded image). (c): a visualization of this feature map projected down into the input image (black square),\nalong with visualizations of this map from other images. The first row example shows the strongest feature to be the\ndog’s face. When this is covered-up the activity in the feature map decreases (blue area in (b)). (d): a map of correct\nclass probability, as a function of the position of the gray square. E.g. when the dog’s face is obscured, the probability\nfor “pomeranian” drops significantly. (e): the most probable label as a function of occluder position. E.g. in the 1st row,\nfor most locations it is “pomeranian”, but if the dog’s face is obscured but not the ball, then it predicts “tennis ball”. In\nthe 2nd example, text on the car is the strongest feature in layer 5, but the classifier is most sensitive to the wheel. The\n3rd example contains multiple objects. The strongest feature in layer 5 picks out the faces, but the classifier is sensitive\nto the dog (blue region in (d)), since it uses multiple feature maps.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisible layer\n(input pixels)\n\n1st hidden layer\n(edges)\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\nVisualizing and Understanding Convolutional Networks\n\nFigure 2. Visualization of features in a fully trained model. For layers 2-5 we show the top 9 activations in a random subset\nof feature maps across the validation data, projected down to pixel space using our deconvolutional network approach.\nOur reconstructions are not samples from the model: they are reconstructed patterns from the validation set that cause\nhigh activations in a given feature map. For each feature map we also show the corresponding image patches. Note:\n(i) the the strong grouping within each feature map, (ii) greater invariance at higher layers and (iii) exaggeration of\ndiscriminative parts of the image, e.g. eyes and noses of dogs (layer 4, row 1, cols 1). Best viewed in electronic form.\n\n2nd hidden layer\n(corners and\n\ncontours)\n\n3rd hidden layer\n(object parts)\n\nCAR PERSON ANIMAL Output\n(object identity)\n\nComposing Features on Features \n\n14\t\r  \n\nHigher-­‐level\t\r  features\t\r  \n\nare\t\r  defined\t\r  in\t\r  terms\t\r  of\t\r  \n\nlower-­‐level\t\r  \n\nfeatures\t\r  \n\n\n\nGoogle Image Search: \nDifferent object types represented in the \nsame space \n\nGoogle:\t\r  \nS.\t\r  Bengio,\t\r  J.\t\r  \nWeston\t\r  &\t\r  N.\t\r  \nUsunier\t\r  \n\n(IJCAI\t\r  2011,\t\r  \nNIPS’2010,\t\r  \nJMLR\t\r  2010,\t\r  \nMLJ\t\r  2010)\t\r  \n\n\n\nFollowing up on (Bengio et al NIPS’2000) \nNeural word embeddings - visualization \n\n16\t\r  \n\n\n\nNeural Language Models \n•  Meanings\t\r  and\t\r  their\t\r  combinaHon\t\r  all\t\r  ‘learned’\t\r  together.\t\r  \n\nMinimal\t\r  structure\t\r  imposed.\t\r  \t\r  \n\t\r  \n\t\r  \n\t\r  \n\t\r  \nPouHne\t\r   \t\r  is\t\r   \t\r  a\t\r   \t\r  curious\t\r  \t\r  \t\r  \t\r  \t\r  \t\r  \t\r  _____________\t\r  .\t\r  \n\n\t\r  \n\na1\t\r  \na2\t\r  \na3\t\r  \na4\t\r  \n….\t\r  \n\t\r  \n\nb1\t\r  \nb2\t\r  \nb3\t\r  \nb4\t\r  \n….\t\r  \n\t\r  \n\nc1\t\r  \nc2\t\r  \nc3\t\r  \nc4\t\r  \n….\t\r  \n\t\r  \n\nd1\t\r  \nd2\t\r  \nd3\t\r  \nd4\t\r  \n….\t\r  \n\t\r  \n\n\t\r  representaHon\t\r  \nx1\t\r  x2\t\r  x3\t\r  x4\t\r  x5\t\r  …\t\r  \n\nA\t\r  guess\t\r  \n\nPARAMETERS\t\r  \n\nMORE\t\r  \nPARAMETERS\t\r  \n\n\n\nAnalogical Representations for Free \n(Mikolov et al, ICLR 2013) \n\n•  SemanHc\t\r  relaHons\t\r  appear\t\r  as\t\r  linear\t\r  relaHonships\t\r  in\t\r  the\t\r  space\t\r  of\t\r  \nlearned\t\r  representaHons\t\r  \n\n•  King\t\r  –\t\r  Queen\t\r  ≈\t\r  \t\r  Man\t\r  –\t\r  Woman\t\r  \n•  Paris\t\r  –\t\r  France\t\r  +\t\r  Italy\t\r  ≈\t\r  Rome\t\r  \n\n18\t\r  \n\nParis\t\r  \n\nFrance\t\r  \nItaly\t\r  \n\nRome\t\r  \n\n\n\nThe Next Challenge: Rich Semantic \nRepresentations for Word Sequences \n\n•  Impressive\t\r  progress\t\r  in\t\r  \ncapturing\t\r  word\t\r  semanHcs\t\r  \nEasier\t\r  learning:\t\r  non-­‐parametric\t\r  \n(table\t\r  look-­‐up)\t\r  \n\n•  OpHmizaHon\t\r  challenge\t\r  for\t\r  \nmapping\t\r  sequences\t\r  to\t\r  rich\t\r  &\t\r  \ncomplete\t\r  representaHons\t\r  \n\n•  Good\t\r  test\t\r  case:\t\r  machine\t\r  \ntranslaHon\t\r  \n\n19\t\r  \n\n\n\nBreakthroughs in Machine Translation \n\n•  (Cho\t\r  et\t\r  al,\t\r  EMNLP\t\r  2014)\t\r  Learning\t\r  Phrase\t\r  RepresentaHons\t\r  using\t\r  \nRNN\t\r  Encoder–Decoder\t\r  for\t\r  StaHsHcal\t\r  Machine\t\r  TranslaHon\t\r  \t\r  \n\n•  (Sutskever\t\r  et\t\r  al,\t\r  NIPS\t\r  2014)\t\r  Sequence\t\r  to\t\r  sequence\t\r  learning\t\r  with\t\r  \nneural\t\r  networks,\t\r  3\t\r  BLEU\t\r  points\t\r  improvement\t\r  for\t\r  English-­‐French\t\r  \n\n•  (Devlin\t\r  et\t\r  al,\t\r  ACL\t\r  2014)\t\r  Fast\t\r  and\t\r  Robust\t\r  Neural\t\r  Network\t\r  Joint\t\r  \nModels\t\r  for\t\r  StaHsHcal\t\r  Machine\t\r  TranslaHon\t\r  \t\r  \n\nBest\t\r  paper\t\r  award,\t\r  6\t\r  BLEU\t\r  points\t\r  improvement\t\r  for\t\r  Arabic-­‐English\t\r  \n\n20\t\r  \n\n�� �� ��\n\n��� �� ��\n\n�\n\n�\t�\n�\t�\n\n\r��\n�\t�\n\nFrench\t\r  \nencoder\t\r  \n\nEnglish\t\r  \ndecoder\t\r  \n\nFrench\t\r  sentence\t\r  \n\nEnglish\t\r  sentence\t\r  \n\nEnglish\t\r  \nencoder\t\r  \n\nEnglish\t\r  \ndecoder\t\r  \n\nEnglish\t\r  sentence\t\r  \n\nEnglish\t\r  sentence\t\r  \n\nFo\nr\t\r  b\n\nite\nxt\n\t\r  d\nat\na\t\r  \n\nFo\nr\t\r  u\n\nni\nlin\ngu\nal\n\t\r  d\nat\na\t\r  \n\n\n\nmain \n\nsubroutine1 includes \nsubsub1 code and \nsubsub2 code and \nsubsubsub1 code \n\n“Shallow” computer program \n\nsubroutine2 includes \nsubsub2 code and \nsubsub3 code and \nsubsubsub3 code and … \n\n\n\nmain \n\nsub1 sub2 sub3 \n\nsubsub1 subsub2 subsub3 \n\nsubsubsub1 subsubsub2 \nsubsubsub3 \n\n“Deep” computer program \n\n\n\nSharing Components in a Deep \nArchitecture \n\nSum-­‐product\t\r  \nnetwork\t\r  \n\nPolynomial\t\r  expressed\t\r  with\t\r  shared\t\r  components:\t\r  advantage\t\r  of\t\r  \ndepth\t\r  may\t\r  grow\t\r  exponenHally\t\r  \t\r  \n\t\r  \n\nTheorems\t\r  in\t\r  \t\r  \n(Bengio\t\r  &\t\r  Delalleau,\t\r  ALT\t\r  2011;\t\r  \nDelalleau\t\r  &\t\r  Bengio\t\r  NIPS\t\r  2011)\t\r  \n\n\n\nDeep Architectures are More \nExpressive \nTheoreHcal\t\r  arguments:\t\r  \n\n…\t\r  \n1\t\r   2\t\r   3\t\r   2n \n\n1\t\r   2\t\r   3\t\r  \n…\t\r  \n\nn\t\r  \n\n= universal approximator 2 layers of \nLogic gates \nFormal neurons \nRBF units \n\nTheorems on advantage of depth: \n(Hastad et al 86 & 91, Bengio et al 2007, \nBengio & Delalleau 2011, Braverman 2011, \nPascanu et al 2014) \n\nSome functions compactly \nrepresented with k layers may \nrequire exponential size with 2 \nlayers \n\nRBMs & auto-encoders = universal approximator \n\n\n\nNew theoretical result: \nExpressiveness of deep nets with \npiecewise-linear activation fns \n\n25\t\r  \n\n(Pascanu,\t\r  Montufar,\t\r  Cho\t\r  &\t\r  Bengio;\t\r  ICLR\t\r  2014)\t\r  \n\nDeeper\t\r  nets\t\r  with\t\r  recHfier/maxout\t\r  units\t\r  are\t\r  exponenHally\t\r  more\t\r  \nexpressive\t\r  than\t\r  shallow\t\r  ones\t\r  (1\t\r  hidden\t\r  layer)\t\r  because\t\r  they\t\r  can\t\r  split\t\r  \nthe\t\r  input\t\r  space\t\r  in\t\r  many\t\r  more\t\r  (not-­‐independent)\t\r  linear\t\r  regions,\t\r  with\t\r  \nconstraints,\t\r  e.g.,\t\r  with\t\r  abs\t\r  units,\t\r  each\t\r  unit\t\r  creates\t\r  mirror\t\r  responses,\t\r  \nfolding\t\r  the\t\r  input\t\r  space:\t\r  \t\r  \n\n\t\r  \n\n\t\r  \n\n\n\n•  Clustering,\t\r  Nearest-­‐\nNeighbors,\t\r  RBF\t\r  SVMs,\t\r  local\t\r  \nnon-­‐parametric\t\r  density\t\r  \nesHmaHon\t\r  &\t\r  predicHon,\t\r  \ndecision\t\r  trees,\t\r  etc.\t\r  \n\n•  Parameters\t\r  for\t\r  each\t\r  \ndisHnguishable\t\r  region\t\r  \n\n•  #\t\r  of\t\r  dis5nguishable\t\r  regions\t\r  \nis\t\r  linear\t\r  in\t\r  #\t\r  of\t\r  parameters\t\r  \n\nNon-distributed representations \n\nClustering\t\r  \n\n26\t\r  \n\nà\t\r  No\t\r  non-­‐trivial\t\r  generalizaHon\t\r  to\t\r  regions\t\r  without\t\r  examples\t\r  \n\n\n\n•  Factor\t\r  models,\t\r  PCA,\t\r  RBMs,\t\r  \nNeural\t\r  Nets,\t\r  Sparse\t\r  Coding,\t\r  \nDeep\t\r  Learning,\t\r  etc.\t\r  \n\n•  Each\t\r  parameter\t\r  influences\t\r  \nmany\t\r  regions,\t\r  not\t\r  just\t\r  local\t\r  \nneighbors\t\r  \n\n•  #\t\r  of\t\r  dis5nguishable\t\r  regions\t\r  \ngrows\t\r  almost\t\r  exponen5ally\t\r  \nwith\t\r  #\t\r  of\t\r  parameters\t\r  \n\n•  GENERALIZE\t\r  NON-­‐LOCALLY\t\r  \nTO\t\r  NEVER-­‐SEEN\t\r  REGIONS\t\r  \n\nThe need for distributed \nrepresentations \n\nMulH-­‐\t\r  \nClustering\t\r  \n\n27\t\r  \n\nC1\t\r   C2\t\r   C3\t\r  \n\ninput\t\r  \n\nNon-­‐mutually\t\r  \nexclusive\t\r  features/\navributes\t\r  create\t\r  a\t\r  \ncombinatorially\t\r  large\t\r  \nset\t\r  of\t\r  disHnguiable\t\r  \nconfiguraHons\t\r  \n\n\n\nThe need for distributed \nrepresentations \n\nMulH-­‐\t\r  \nClustering\t\r  Clustering\t\r  \n\n28\t\r  \n\nLearning\t\r  a\t\r  set\t\r  of\t\r  features\t\r  that\t\r  are\t\r  not\t\r  mutually\t\r  exclusive\t\r  \ncan\t\r  be\t\r  exponenHally\t\r  more\t\r  staHsHcally\t\r  efficient\t\r  than\t\r  \nhaving\t\r  nearest-­‐neighbor-­‐like\t\r  or\t\r  clustering-­‐like\t\r  models\t\r  \n\n\n\nMontréal \nToronto \n\nBengio \n\nHinton \nLe Cun \n\nMajor Breakthrough in 2006 \n\n•  Ability\t\r  to\t\r  train\t\r  deep\t\r  architectures\t\r  by\t\r  \nusing\t\r  layer-­‐wise\t\r  unsupervised\t\r  \nlearning,\t\r  whereas\t\r  previous\t\r  purely\t\r  \nsupervised\t\r  avempts\t\r  had\t\r  failed\t\r  \n\n•  Unsupervised\t\r  feature\t\r  learners:\t\r  \n•  RBMs\t\r  \n•  Auto-­‐encoder\t\r  variants\t\r  \n•  Sparse\t\r  coding\t\r  variants\t\r  \n\nNew York \n29\t\r   (Bengio\t\r  &\t\r  LeCun\t\r  2007),\t\r  Scaling\t\r  Learning\t\r  Algorithms\t\r  towards\t\r  AI\t\r  \t\r  \n\n\n\nIssues with Back-Prop \n•  In\t\r  very\t\r  deep\t\r  nets\t\r  or\t\r  recurrent\t\r  nets\t\r  with\t\r  many\t\r  steps,\t\r  \nnon-­‐lineariHes\t\r  compose\t\r  and\t\r  yield\t\r  sharp\t\r  non-­‐linearity\t\r  \nà\t\r  gradients\t\r  vanish\t\r  or\t\r  explode\t\r  \n\n•  Training\t\r  deeper\t\r  nets:\t\r  harder\t\r  opHmizaHon\t\r  \n•  In\t\r  the\t\r  extreme\t\r  of\t\r  non-­‐linearity:\t\r  discrete\t\r  funcHons,\t\r  \ncan’t\t\r  use\t\r  back-­‐prop\t\r  \n\n•  Not\t\r  biologically\t\r  plausible?\t\r  \n\n¢\t\r   =\t\r  ¢\t\r   …\t\r  \n\n\n\n31\t\r  \n\nEffect of Initial Conditions \nin Deep Nets \n\n•  (Erhan\t\r  et\t\r  al\t\r  2009,\t\r  JMLR)\t\r  \n•  Supervised\t\r  deep\t\r  net\t\r  with\t\r  vs\t\r  w/o\t\r  \t\r  \n\t\r  \t\r  unsupervised\t\r  pre-­‐training\t\r  èvery\t\r  different\t\r  minima\t\r  \n\nNeural\t\r  net\t\r  trajectories\t\r  in\t\r  \t\r  \nfuncHon\t\r  space,\t\r  visualized\t\r  by\t\r  \nt-­‐SNE\t\r  \n\nNo\t\r  two\t\r  training\t\r  trajectories\t\r  \nend\t\r  up\t\r  in\t\r  the\t\r  same\t\r  place\t\r  à\t\r  \nhuge\t\r  number\t\r  of\t\r  effecHve\t\r  \nlocal\t\r  minima\t\r  \n\nw/o\t\r  unsupervised\t\r  pre-­‐training\t\r  \n\nwith\t\r  unsupervised\t\r  pre-­‐training\t\r  \n\n\n\nOrder & Selection of Examples Matters \n(Bengio,\t\r  Louradour,\t\r  Collobert\t\r  &\t\r  Weston,\t\r  ICML’2009)\t\r  \t\r  \t\r  \t\r  A\t\r  \n\n• Curriculum\t\r  learning\t\r  \t\r  \n•  (Bengio\t\r  et\t\r  al\t\r  2009,\t\r  Krueger\t\r  &\t\r  Dayan\t\r  2009)\t\r  \t\r  \t\r  \n\n•  Start\t\r  with\t\r  easier\t\r  examples\t\r  \n\n•  Faster\t\r  convergence\t\r  to\t\r  a\t\r  bever\t\r  local\t\r  \nminimum\t\r  in\t\r  deep\t\r  architectures\t\r  \n\n!\"#$%\n\n&%\n\n&\"!$%\n\n&\"$%\n\n'% $''% ('''% ($''%\n\n!\"\n#\n$%\n&\n'\n(\n)'\n*\n+\n,)\n-\n\"\n%.\n/)\n\n01!!1\"'))\n\n23.&,*4)\n\n)*++,)*-*.%\n\n/01)*++,)*-*.%\n\n!\"#$%\n\n&%\n\n&\"!$%\n\n&\"$%\n\n'% $''% ('''% ($''%\n\n!\"\n#\n$%\n&\n'\n(\n)'\n*\n+\n,)\n-\n\"\n%.\n/)\n\n01!!1\"'))\n\n23.&,*4)\n\n)*++,)*-*.%\n\n/01)*++,)*-*.%\n\n32\t\r  \n\n\n\nCurriculum Learning \n\nGuided learning helps training humans and animals  \n\n Shaping \n\n \n\nStart from simpler examples / easier tasks   (Piaget 1952, Skinner 1958) \n\nEducation \n\n \n\n\n\nContinuation Methods \n\nTrack local minima \n\n \n\nFinal solution \n\n \n\nEasy to find minimum \n\n \n\n\n\nGuided Training, Intermediate \nConcepts \n\n•  In\t\r  (Gulcehre\t\r  &\t\r  Bengio\t\r  ICLR’2013)\t\r  we\t\r  set\t\r  up\t\r  a\t\r  task\t\r  that\t\r  seems\t\r  \nalmost\t\r  impossible\t\r  to\t\r  learn\t\r  by\t\r  shallow\t\r  nets,\t\r  deep\t\r  nets,\t\r  SVMs,\t\r  \ntrees,\t\r  boosHng\t\r  etc\t\r  \n\n•  Breaking\t\r  the\t\r  problem\t\r  in\t\r  two\t\r  sub-­‐problems\t\r  and\t\r  pre-­‐training\t\r  \neach\t\r  module\t\r  separately,\t\r  then\t\r  fine-­‐tuning,\t\r  nails\t\r  it\t\r  \n\n•  Need\t\r  prior\t\r  knowledge\t\r  to\t\r  decompose\t\r  the\t\r  task\t\r  \n•  Guided\t\r  pre-­‐training\t\r  allows\t\r  to\t\r  find\t\r  much\t\r  bever\t\r  soluHons,\t\r  escape\t\r  \n\neffecHve\t\r  local\t\r  minima\t\r  \n\n35\t\r  \n\nHINTS\t\r  \n\n\n\n•  TradiHonal\t\r  thinking\t\r  is\t\r  that\t\r  major\t\r  obstacle\t\r  for\t\r  training\t\r  deep\t\r  nets\t\r  is\t\r  \nlocal\t\r  minima\t\r  \n\n•  TheoreHcal\t\r  and\t\r  empirical\t\r  evidence\t\r  suggest\t\r  instead\t\r  that\t\r  saddle\t\r  \npoints\t\r  are\t\r  exponenHally\t\r  more\t\r  prevalent\t\r  criHcal\t\r  points,\t\r  and\t\r  local\t\r  \nminima\t\r  tend\t\r  to\t\r  be\t\r  of\t\r  cost\t\r  near\t\r  that\t\r  of\t\r  global\t\r  minimum\t\r  \n\n•  (Pascanu,\t\r  Dauphin,\t\r  Ganguli,\t\r  Bengio\t\r  2014):\t\r  On\t\r  the\t\r  saddle\t\r  point\t\r  \nproblem\t\r  for\t\r  non-­‐convex\t\r  opNmizaNon.\t\r  \t\r  \t\r  \n\nSaddle Points, not Local Minima \n\n36\t\r  \n\n\n\nCIFAR\t\r  MNIST\t\r  \n\nSaddle Points \n\n•  Local\t\r  minima\t\r  dominate\t\r  in\t\r  low-­‐D,\t\r  but\t\r  \nsaddle\t\r  points\t\r  dominate\t\r  in\t\r  high-­‐D\t\r  \n\n•  Most\t\r  local\t\r  minima\t\r  are\t\r  close\t\r  to\t\r  the\t\r  \nbovom\t\r  (global\t\r  minimum\t\r  error)\t\r  \n\n37\t\r  \n\n\n\nIt is possible to escape saddle points! \n\n•  NIPS’2014\t\r  paper,\t\r  Dauphin\t\r  et\t\r  al.\t\r  \n•  More\t\r  work\t\r  is\t\r  ongoing\t\r  to\t\r  make\t\r  it\t\r  online\t\r  \n•  Challenge:\t\r  track\t\r  the\t\r  most\t\r  negaHve\t\r  eigenvector,\t\r  which\t\r  is\t\r  easy\t\r  in\t\r  \n\nbatch\t\r  mode\t\r  with\t\r  power\t\r  method,\t\r  if\t\r  we\t\r  also\t\r  track\t\r  most\t\r  posiHve,\t\r  \nvia\t\r  \t\r  \t\r  \n\n38\t\r  \n\nv  (H � �I)v\n\n\n\nSaddle-Free Optimization  \n(Dauphin et al NIPS’2014) \n\n•  Replace\t\r  eigenvalues\t\r  λ\t\r  of\t\r  Hessian\t\r  by\t\r  |λ|\t\r  \n\n39\t\r  \n\n\n\nDeep Supervised Neural Nets \n\n•  Now\t\r  can\t\r  train\t\r  them\t\r  even\t\r  without\t\r  \nunsupervised\t\r  pre-­‐training:\t\r  \t\r  \nbe]er\t\r  ini5aliza5on\t\r  and\t\r  non-­‐\nlineari5es\t\r  (recHfiers,\t\r  maxout),\t\r  \ngeneralize\t\r  well\t\r  with\t\r  large\t\r  labeled\t\r  \nsets\t\r  and\t\r  regularizers\t\r  (dropout)\t\r  \n\n•  Unsupervised\t\r  pre-­‐training:\t\r  \t\r  \nrare\t\r  classes,\t\r  transfer,\t\r  smaller\t\r  \nlabeled\t\r  sets,\t\r  or\t\r  as\t\r  extra\t\r  \nregularizer.\t\r  \n\n40\t\r  \n\n\n\nWhy Unsupervised Learning? \n\n•  Recent\t\r  progress\t\r  mostly\t\r  in\t\r  supervised\t\r  DL\t\r  \n•  \t\r  \t\r  \t\r  \t\r  real\t\r  challenges\t\r  for\t\r  unsupervised\t\r  DL\t\r  \n•  PotenHal\t\r  benefits:\t\r  \n\n•  Exploit\t\r  tons\t\r  of\t\r  unlabeled\t\r  data\t\r  \n•  Answer\t\r  new\t\r  quesHons\t\r  about\t\r  the\t\r  variables\t\r  observed\t\r  \n•  Regularizer\t\r  –\t\r  transfer\t\r  learning\t\r  –\t\r  domain\t\r  adaptaHon\t\r  \n•  Easier\t\r  opHmizaHon\t\r  (local\t\r  training\t\r  signal)\t\r  \n•  Structured\t\r  outputs\t\r  \n\n41\t\r  \n\nE\t\r  \n\n\n\nInvariance and Disentangling \n\n•  Invariant\t\r  features\t\r  \n\n•  Which\t\r  invariances?\t\r  \n\n•  AlternaHve:\t\r  learning\t\r  to\t\r  disentangle\t\r  factors\t\r  \n\n•  Good\t\r  disentangling\t\r  à\t\r  \t\r  \n\t\r  avoid\t\r  the\t\r  curse\t\r  of\t\r  dimensionality\t\r  \n\n42\t\r  \n\n\n\nEmergence of Disentangling \n•  (Goodfellow\t\r  et\t\r  al.\t\r  2009):\t\r  sparse\t\r  auto-­‐encoders\t\r  trained\t\r  \n\non\t\r  images\t\r  \t\r  \n•  some\t\r  higher-­‐level\t\r  features\t\r  more\t\r  invariant\t\r  to\t\r  \ngeometric\t\r  factors\t\r  of\t\r  variaHon\t\r  \t\r  \n\n•  (Glorot\t\r  et\t\r  al.\t\r  2011):\t\r  sparse\t\r  recHfied\t\r  denoising\t\r  auto-­‐\nencoders\t\r  trained\t\r  on\t\r  bags\t\r  of\t\r  words\t\r  for\t\r  senHment\t\r  \nanalysis\t\r  \n•  different\t\r  features\t\r  specialize\t\r  on\t\r  different\t\r  aspects\t\r  \n(domain,\t\r  senHment)\t\r  \n\n43\t\r  \n\nWHY?\t\r  \n\n\n\nHow do humans generalize \nfrom very few examples? \n\n44\t\r  \n\n•  They\t\r  transfer\t\r  knowledge\t\r  from\t\r  previous\t\r  learning:\t\r  \n•  RepresentaHons\t\r  \n\n•  Explanatory\t\r  factors\t\r  \n\n•  Previous\t\r  learning\t\r  from:\t\r  unlabeled\t\r  data\t\r  \t\r  \n\n\t\r   \t\r   \t\r  \t\r  \t\r  \t\r  \t\r   \t\r  +\t\r  labels\t\r  for\t\r  other\t\r  tasks\t\r  \n\n•  Prior:\t\r  shared\t\r  underlying\t\r  explanatory\t\r  factors,\t\r  in\t\r  \npar5cular\t\r  between\t\r  P(x)\t\r  and\t\r  P(Y|x)\t\r  \t\r  \n\n\t\r  \n\n\n\nRaw\t\r  data\t\r  \n1\t\r  layer\t\r   2\t\r  layers\t\r  \n\n4\t\r  layers\t\r  \n3\t\r  layers\t\r  \n\nICML’2011\t\r  \nworkshop\t\r  on\t\r  \nUnsup.\t\r  &\t\r  \nTransfer\t\r  Learning\t\r  \n\nNIPS’2011\t\r  \nTransfer\t\r  \nLearning\t\r  \nChallenge\t\r  \t\r  \nPaper:\t\r  \nICML’2012\t\r  \n\nUnsupervised and Transfer Learning \nChallenge + Transfer Learning \nChallenge: Deep Learning 1st Place \n\n\n\n46\t\r  \n\nAuto-Encoders Learn Salient \nVariations, like a non-linear PCA \n\n•  Minimizing\t\r  reconstrucHon\t\r  error\t\r  forces\t\r  to\t\r  \nkeep\t\r  variaHons\t\r  along\t\r  manifold.\t\r  \n\n•  Regularizer\t\r  wants\t\r  to\t\r  throw\t\r  away\t\r  all\t\r  \nvariaHons.\t\r  \n\n•  With\t\r  both:\t\r  keep\t\r  ONLY\t\r  sensiHvity\t\r  to\t\r  \nvariaHons\t\r  ON\t\r  the\t\r  manifold.\t\r  \n\n\n\nSpace-Filling in Representation-Space \n•  Deeper\t\r  representa5ons\t\r  !\t\r  abstrac5ons\t\r  !\t\r  disentangling\t\r  \n•  Manifolds\t\r  are\t\r  expanded\t\r  and\t\r  fla]ened\t\r  \n\nLinear\t\r  interpolaHon\t\r  at\t\r  layer\t\r  2\t\r  \n\nLinear\t\r  interpolaHon\t\r  at\t\r  layer\t\r  1\t\r  \n\n3’s\t\r  manifold\t\r  \n\n9’s\t\r  manifold\t\r  \n\nLinear\t\r  interpolaHon\t\r  in\t\r  pixel\t\r  space\t\r  \n\nPixel\t\r  space\t\r  \n\n9’s\t\r  manifold\t\r   3’s\t\r  manifold\t\r  \n\nRepresentaHon\t\r  space\t\r  \n\n9’s\t\r  manifold\t\r   3’s\t\r  manifold\t\r  \n\nX-­‐space\t\r  \n\nH-­‐space\t\r  \n\n\n\nWhy Unsupervised Representation \nLearning? Because of Causality. \n\n•  If\t\r  Ys\t\r  of\t\r  interest\t\r  are\t\r  among\t\r  the\t\r  causal\t\r  factors\t\r  of\t\r  X,\t\r  then\t\r  \n\nis\t\r  Hed\t\r  to\t\r  P(X)\t\r  and\t\r  P(X|Y),\t\r  and\t\r  P(X)\t\r  is\t\r  defined\t\r  in\t\r  terms\t\r  of\t\r  P(X|Y),\t\r  i.e.\t\r  \n•  The\t\r  best\t\r  possible\t\r  model\t\r  of\t\r  X\t\r  (unsupervised\t\r  learning)\t\r  MUST\t\r  \n\ninvolve\t\r  Y\t\r  as\t\r  a\t\r  latent\t\r  factor,\t\r  implicitly\t\r  or\t\r  explicitly.\t\r  \n•  RepresentaHon\t\r  learning\t\r  SEEKS\t\r  the\t\r  latent\t\r  variables\t\r  H\t\r  that\t\r  \n\nexplain\t\r  the\t\r  variaHons\t\r  of\t\r  X,\t\r  making\t\r  it\t\r  likely\t\r  to\t\r  also\t\r  uncover\t\r  Y.\t\r  \n•  We\t\r  need\t\r  3\t\r  pieces:\t\r  \t\r  \n\n•  latent\t\r  variable\t\r  model\t\r  P(H),\t\r  \t\r  \n•  generaHve\t\r  decoder\t\r  P(X|H),\t\r  and\t\r  \t\r  \n•  approximate\t\r  inference\t\r  encoder\t\r  Q(H|X).\t\r  \n\n\t\r  \t\r  \n48\t\r  \n\nP (Y |X) =\nP (X|Y )P (Y )\n\nP (X)\n\n\n\nChallenges with Graphical Models with \nLatent Variables \n\n•  Latent\t\r  variables\t\r  help\t\r  to\t\r  avoid\t\r  the\t\r  curse\t\r  of\t\r  dimensionality\t\r  \n\n•  But\t\r  they\t\r  come\t\r  with\t\r  intractabiliHes\t\r  due\t\r  to\t\r  sums\t\r  over\t\r  an\t\r  \nexponenHally\t\r  large\t\r  number\t\r  of\t\r  terms\t\r  (marginalizaHon):\t\r  \n\n•  Exact\t\r  inference\t\r  (P(h|x))\t\r  is\t\r  typically\t\r  intractable\t\r  \n\n• With\t\r  undirected\t\r  models,\t\r  the\t\r  normalizaHon\t\r  constant\t\r  and\t\r  its\t\r  \ngradient\t\r  are\t\r  intractable\t\r  \n\n\t\r  \n\n49\t\r  \n\n\n\nIssues with Boltzmann Machines \n•  Sampling\t\r  from\t\r  the\t\r  MCMC\t\r  of\t\r  the\t\r  model\t\r  is\t\r  required\t\r  in\t\r  the\t\r  inner\t\r  \n\nloop\t\r  of\t\r  training\t\r  \n•  As\t\r  the\t\r  model\t\r  gets\t\r  sharper,\t\r  mixing\t\r  between\t\r  well-­‐separated\t\r  \n\nmodes\t\r  stalls\t\r  \n\n50\t\r  \n\nTraining\t\r  updates\t\r  \n\nMixing\t\r  \nvicious\t\r  circle\t\r  \n\n\n\nparameters\t\r  \n\ngenerated\t\r  \nsamples\t\r  \n\nBypassing Normalization Constants \nwith Generative Black Boxes \n•  Instead\t\r  of\t\r  parametrizing\t\r  p(x),\t\r  \n\nparametrize\t\r  a\t\r  machine\t\r  which\t\r  \ngenerates\t\r  samples\t\r  \n\n•  \t\r  (Goodfellow\t\r  et\t\r  al,\t\r  NIPS\t\r  2014,\t\r  \nGeneraHve\t\r  adversarial\t\r  nets)\t\r  for\t\r  the\t\r  \ncase\t\r  of\t\r  ancestral\t\r  sampling\t\r  in\t\r  a\t\r  deep\t\r  \ngeneraHve\t\r  net.\t\r  VariaHonal\t\r  auto-­‐\nencoders\t\r  are\t\r  closely\t\r  related.\t\r  \n\n•  (Bengio\t\r  et\t\r  al,\t\r  ICML\t\r  2014,\t\r  GeneraHve\t\r  \nStochasHc\t\r  Networks),\t\r  learning\t\r  the\t\r  \ntransiHon\t\r  operator\t\r  of\t\r  a\t\r  Markov\t\r  chain\t\r  \nthat\t\r  generates\t\r  the\t\r  data.\t\r  \n\n51\t\r  \n\nrandom\t\r  \nnumbers\t\r  \n\ngenerated\t\r  \nsamples\t\r  \n\nrandom\t\r  \nnumbers\t\r  \n\nprevious\t\r  state\t\r  \n\n\t\r  next\t\r  state\t\r  \n\ngenerated\t\r  \nsamples\t\r  \n\ngenerated\t\r  \nsamples\t\r  \n\nparameters\t\r  \n\n\n\nAdversarial Nets \nmovies \n\nEach\t\r  movie\t\r  =\t\r  linear\t\r  interpolaHon\t\r  \nbetween\t\r  2\t\r  random\t\r  samples\t\r  in\t\r  \nrepresentaHon-­‐space\t\r  \n\n52\t\r  \n\n\n\nAncestral Sampling with Learned \nApproximate Inference \n\n•  Helmholtz\t\r  machine\t\r  &\t\r  Wake-­‐Sleep\t\r  algorithm\t\r  \n•  (Dayan,\t\r  Hinton,\t\r  Neal,\t\r  Zemel\t\r  1995)\t\r  \n\n•  VariaHonal\t\r  Auto-­‐Encoders\t\r  \n•  (Kingma\t\r  &\t\r  Welling\t\r  2013,\t\r  ICLR\t\r  2014)\t\r  \n•  (Gregor\t\r  et\t\r  al\t\r  ICML\t\r  2014)\t\r  \n•  (Rezende\t\r  et\t\r  al\t\r  ICML\t\r  2014)\t\r  \n•  (Mnih\t\r  &\t\r  Gregor\t\r  ICML\t\r  2014)\t\r  \n\n•  Reweighted\t\r  Wake-­‐Sleep\t\r  (Bornschein\t\r  &\t\r  Bengio\t\r  2014)\t\r  \n•  Target\t\r  PropagaHon\t\r  (Bengio\t\r  2014)\t\r  \n•  Deep\t\r  Directed\t\r  GeneraHve\t\r  Auto-­‐Encoders\t\r  (Ozair\t\r  &\t\r  Bengio\t\r  2014)\t\r  \n•  NICE\t\r  (Dinh\t\r  et\t\r  al\t\r  2014)\t\r  \n53\t\r  \n\nTrained\t\r  approximate\t\r  \ninference\t\r  \n\nvisible\t\r  \n\nlatent\t\r  \n\nP\t\r  Q\t\r  \n\n\n\nExtracting Structure By Gradual \nDisentangling and Manifold Unfolding \n(Bengio 2014, arXiv 1407.7906)  \nEach\t\r  level\t\r  transforms\t\r  the\t\r  \ndata\t\r  into\t\r  a\t\r  representaHon\t\r  in\t\r  \nwhich\t\r  it\t\r  is\t\r  easier\t\r  to\t\r  model,\t\r  \nunfolding\t\r  it\t\r  more,\t\r  \ncontracHng\t\r  the\t\r  noise\t\r  \ndimensions\t\r  and\t\r  mapping\t\r  the\t\r  \nsignal\t\r  dimensions\t\r  to\t\r  a\t\r  \nfactorized\t\r  (uniform-­‐like)\t\r  \ndistribuHon.\t\r  \n\t\r  \n\t\r  \nfor\t\r  each\t\r  intermediate\t\r  level\t\r  h\t\r  \n\n54\t\r  \n\nQ(x)\t\r  \n\nf1\t\r  \ng1\t\r  \n\nQ(h1)\t\r  \nP(h1)\t\r  \n\nfL\t\r   gL\t\r  \n\nQ(hL)\t\r  \nP(hL)\t\r  no\n\nise\n\t\r  \n\nsignal\t\r  \n\n…\t\r  \n\nP(x|h1)\t\r  \nQ(h1|x)\t\r  \n\nQ(h2|h1)\t\r   f2\t\r   P(h2|h1)\t\r  g2\t\r  \n\nminKL(Q(x, h)||P (x, h))\n\n\n\nNICE: \nNonlinear Independent Component Estimation \n\n•  Perfect\t\r  auto-­‐encoder\t\r  g=f-­‐1\t\r  \n•  No\t\r  need\t\r  for\t\r  reconstrucHon\t\r  error\t\r  \n•  DeterminisHc\t\r  encoder,\t\r  no\t\r  need\t\r  for\t\r  entropy\t\r  term\t\r  \n•  But\t\r  need\t\r  to\t\r  correct\t\r  for\t\r  density\t\r  scaling\t\r  \n\n•  Exact\t\r  tractable\t\r  likelihood\t\r  \n\n55\t\r  \n\n(Dinh,\t\r  Krueger\t\r  &\t\r  Bengio\t\r  2014,\t\r  arxiv\t\r  1410.8516)\t\r  \n\nlog pX(x) = log pH(f(x)) + log\n\n����det\n@f(x)\n\n@x\n\n����\n\t\r  \nfactorized\t\r  prior\t\r  \n\nPH(h) =\nY\n\ni\n\nPHi(hi)\n\nf\t\r   g=f-­‐1\t\r  \n\nQ(h)\t\r  \n\nP(h)\t\r  \n\n\n\nNICE \nInpaiting \nMovies \n(not \nconv.) \n\n56\t\r  \n\n\n\nUnfolding AND Disentangling \n\n•  The\t\r  previous\t\r  criteria\t\r  may\t\r  allow\t\r  us\t\r  to\t\r  unfold\t\r  and\t\r  flaven\t\r  the\t\r  data\t\r  \nmanifold\t\r  \n\n•  What\t\r  about\t\r  disentangling\t\r  the\t\r  underflying\t\r  factors\t\r  of\t\r  variaHon?\t\r  \n•  Is\t\r  it\t\r  enough\t\r  to\t\r  assume\t\r  they\t\r  are\t\r  marginally\t\r  independent?\t\r  \n•  They\t\r  are\t\r  not\t\r  condiHonally\t\r  independent…\t\r  \n•  There\t\r  may\t\r  be\t\r  intrinsinc\t\r  ambiguiHes\t\r  what\t\r  makes\t\r  the\t\r  \n\ndisentangling\t\r  job\t\r  impossible\t\r  à\t\r  need\t\r  more\t\r  prior\t\r  knowledge.\t\r  \n\n57\t\r  \n\n\n\nBroad Priors as Hints to Disentangle \nthe Factors of Variation \n\n•  MulNple\t\r  factors:\t\r  distributed\t\r  representaHons\t\r  \n•  MulHple\t\r  levels\t\r  of\t\r  abstracHon:\t\r  depth\t\r  \n•  Semi-­‐supervised\t\r  learning:\t\r  Y\t\r  is\t\r  one\t\r  of\t\r  the\t\r  factors\t\r  explaining\t\r  X\t\r  \n•  MulN-­‐task\t\r  learning:\t\r  different\t\r  tasks\t\r  share\t\r  some\t\r  factors\t\r  \n•  Manifold\t\r  hypothesis:\t\r  probability\t\r  mass\t\r  concentraHon\t\r  \n•  Natural\t\r  clustering:\t\r  class\t\r  =\t\r  manifold,\t\r  well-­‐separated\t\r  manifolds\t\r  \n•  Temporal\t\r  and\t\r  spaHal\t\r  coherence\t\r  \n•  Sparsity:\t\r  most\t\r  factors\t\r  irrelevant\t\r  for\t\r  parHcular\t\r  X\t\r  \n•  Simplicity\t\r  of\t\r  factor\t\r  dependencies\t\r  (in\t\r  the\t\r  right\t\r  representaHon)\t\r  \n\n58\t\r  \n\n\n\nLearning Multiple Levels of \nAbstraction \n\n•  The\t\r  big\t\r  payoff\t\r  of\t\r  deep\t\r  learning\t\r  is\t\r  to\t\r  allow\t\r  learning\t\r  \nhigher\t\r  levels\t\r  of\t\r  abstracHon\t\r  \n\n•  Higher-­‐level\t\r  abstracHons\t\r  disentangle\t\r  the\t\r  factors\t\r  of\t\r  \nvariaHon,\t\r  which\t\r  allows\t\r  much\t\r  easier\t\r  generalizaHon\t\r  and\t\r  \ntransfer\t\r  \n\n59\t\r  \n\n\n\nConclusions \n•  Deep\t\r  Learning\t\r  has\t\r  become\t\r  a\t\r  crucial\t\r  machine\t\r  learning\t\r  tool:\t\r  \t\r  \n\n•  Int.\t\r  Conf.\t\r  on\t\r  Learning\t\r  RepresentaHon\t\r  2013\t\r  &\t\r  2014\t\r  a\t\r  huge\t\r  success!\t\r  \nConference\t\r  &\t\r  workshop\t\r  tracks,\t\r  open\t\r  to\t\r  new\t\r  ideas\t\r  J\t\r  \n\n•  Industrial\t\r  applicaHons\t\r  (Google,\t\r  IBM,\t\r  MicrosoY,\t\r  Baidu,\t\r  Facebook,\t\r  \nSamsung,\t\r  Yahoo,\t\r  Intel,\t\r  Apple,\t\r  Nuance,\t\r  BBN,\t\r  …)\t\r  \n\n•  PotenHal\t\r  for\t\r  more\t\r  breakthroughs\t\r  and\t\r  approaching\t\r  the\t\r  \n“understanding”\t\r  part\t\r  of\t\r  AI\t\r  by\t\r  \n•  Scaling\t\r  computaHon\t\r  \t\r  \n•  Numerical\t\r  opHmizaHon\t\r  (bever\t\r  training\t\r  much\t\r  deeper\t\r  nets,\t\r  RNNs)\t\r  \n•  Bypass\t\r  intractable\t\r  marginalizaHons\t\r  and\t\r  exploit\t\r  broad\t\r  priors\t\r  and\t\r  \nlayer-­‐wise\t\r  training\t\r  signals\t\r  to\t\r  learn\t\r  more\t\r  disentangled\t\r  \nabstracHons\t\r  for\t\r  unsupervised\t\r  &\t\r  structured\t\r  output\t\r  learning\t\r  \n\n60\t\r  \n\n\n\nMerci! Questions? LISA team: \n\n\n","extracted_metadata":{"pdf:docinfo:title":["Tel-Aviv-6nov2014.pptx"],"pdf:docinfo:creator_tool":["PowerPoint"],"access_permission:modify_annotations":["true"],"dcterms:modified":["2014-11-06T21:19:27Z"],"pdf:containsNonEmbeddedFont":["false"],"pdf:docinfo:modified":["2014-11-06T21:19:27Z"],"pdf:docinfo:creator":["Yoshua Bengio"],"xmpTPg:NPages":["61"],"access_permission:assemble_document":["true"],"resourceName":["Fundamentals_of_Deep_Learning_2014.pdf"],"pdf:charsPerPage":["142","73","129","146","197","429","101","150","337","143","289","301","386","11169","161","83","288","240","285","647","180","101","224","431","433","323","448","236","364","314","373","451","165","79","431","403","166","260","97","319","338","179","361","303","249","252","352","585","367","225","596","108","504","466","375","37","378","537","241","653","29"],"access_permission:extract_content":["true"],"access_permission:can_modify":["true"],"pdf:totalUnmappedUnicodeChars":["169"],"pdf:hasXFA":["false"],"Content-Type":["application/pdf"],"pdf:hasCollection":["false"],"xmp:CreatorTool":["PowerPoint"],"X-TIKA:Parsed-By-Full-Set":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"pdf:num3DAnnotations":["0"],"Content-Length":["56715281"],"pdf:hasMarkedContent":["false"],"X-TIKA:Parsed-By":["org.apache.tika.parser.DefaultParser","org.apache.tika.parser.pdf.PDFParser"],"access_permission:can_print":["true"],"pdf:hasXMP":["false"],"pdf:encrypted":["false"],"dc:title":["Tel-Aviv-6nov2014.pptx"],"pdf:overallPercentageUnmappedUnicodeChars":["0.00590310525149107"],"pdf:producer":["Mac OS X 10.9.5 Quartz PDFContext"],"pdf:containsDamagedFont":["false"],"dc:creator":["Yoshua Bengio"],"access_permission:fill_in_form":["true"],"access_permission:can_print_degraded":["true"],"pdf:PDFVersion":["1.3"],"dc:format":["application/pdf; version=1.3"],"access_permission:extract_for_accessibility":["true"],"pdf:docinfo:producer":["Mac OS X 10.9.5 Quartz PDFContext"],"dcterms:created":["2014-11-06T21:19:27Z"],"pdf:unmappedUnicodeCharsPerPage":["1","0","2","3","4","6","0","2","2","1","3","0","5","0","0","0","3","4","5","7","0","0","1","1","2","6","6","4","1","4","2","1","0","0","4","6","1","2","0","5","5","1","4","2","0","5","7","4","4","0","6","2","3","3","2","0","4","9","4","10","0"],"pdf:docinfo:created":["2014-11-06T21:19:27Z"]},"metadata_field_count":40,"attempts":1,"timestamp":1754064941.0978725,"platform":"Linux","python_version":"3.13.5"}]